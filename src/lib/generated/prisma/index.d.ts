
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ChainState
 * 
 */
export type ChainState = $Result.DefaultSelection<Prisma.$ChainStatePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Collection
 * 
 */
export type Collection = $Result.DefaultSelection<Prisma.$CollectionPayload>
/**
 * Model NFT
 * 
 */
export type NFT = $Result.DefaultSelection<Prisma.$NFTPayload>
/**
 * Model TraitStat
 * 
 */
export type TraitStat = $Result.DefaultSelection<Prisma.$TraitStatPayload>
/**
 * Model NFTActivity
 * 
 */
export type NFTActivity = $Result.DefaultSelection<Prisma.$NFTActivityPayload>
/**
 * Model Single721
 * 
 */
export type Single721 = $Result.DefaultSelection<Prisma.$Single721Payload>
/**
 * Model Single1155
 * 
 */
export type Single1155 = $Result.DefaultSelection<Prisma.$Single1155Payload>
/**
 * Model Erc1155Balance
 * 
 */
export type Erc1155Balance = $Result.DefaultSelection<Prisma.$Erc1155BalancePayload>
/**
 * Model Erc1155Holding
 * 
 */
export type Erc1155Holding = $Result.DefaultSelection<Prisma.$Erc1155HoldingPayload>
/**
 * Model MarketplaceListing
 * 
 */
export type MarketplaceListing = $Result.DefaultSelection<Prisma.$MarketplaceListingPayload>
/**
 * Model Auction
 * 
 */
export type Auction = $Result.DefaultSelection<Prisma.$AuctionPayload>
/**
 * Model AuctionBid
 * 
 */
export type AuctionBid = $Result.DefaultSelection<Prisma.$AuctionBidPayload>
/**
 * Model DeployedContract
 * 
 */
export type DeployedContract = $Result.DefaultSelection<Prisma.$DeployedContractPayload>
/**
 * Model FeeConfig
 * 
 */
export type FeeConfig = $Result.DefaultSelection<Prisma.$FeeConfigPayload>
/**
 * Model FeeConfigLog
 * 
 */
export type FeeConfigLog = $Result.DefaultSelection<Prisma.$FeeConfigLogPayload>
/**
 * Model PublicSale
 * 
 */
export type PublicSale = $Result.DefaultSelection<Prisma.$PublicSalePayload>
/**
 * Model Presale
 * 
 */
export type Presale = $Result.DefaultSelection<Prisma.$PresalePayload>
/**
 * Model PresaleWhitelistAddress
 * 
 */
export type PresaleWhitelistAddress = $Result.DefaultSelection<Prisma.$PresaleWhitelistAddressPayload>
/**
 * Model PresaleDraft
 * 
 */
export type PresaleDraft = $Result.DefaultSelection<Prisma.$PresaleDraftPayload>
/**
 * Model AssetUpload
 * 
 */
export type AssetUpload = $Result.DefaultSelection<Prisma.$AssetUploadPayload>
/**
 * Model CollectionSubmission
 * 
 */
export type CollectionSubmission = $Result.DefaultSelection<Prisma.$CollectionSubmissionPayload>
/**
 * Model NFTRarity
 * 
 */
export type NFTRarity = $Result.DefaultSelection<Prisma.$NFTRarityPayload>
/**
 * Model HolderReward
 * 
 */
export type HolderReward = $Result.DefaultSelection<Prisma.$HolderRewardPayload>
/**
 * Model RewardAccumulator
 * 
 */
export type RewardAccumulator = $Result.DefaultSelection<Prisma.$RewardAccumulatorPayload>
/**
 * Model FeaturedCycle
 * 
 */
export type FeaturedCycle = $Result.DefaultSelection<Prisma.$FeaturedCyclePayload>
/**
 * Model FeaturedBid
 * 
 */
export type FeaturedBid = $Result.DefaultSelection<Prisma.$FeaturedBidPayload>
/**
 * Model Currency
 * 
 */
export type Currency = $Result.DefaultSelection<Prisma.$CurrencyPayload>
/**
 * Model MarketplaceSale
 * 
 */
export type MarketplaceSale = $Result.DefaultSelection<Prisma.$MarketplaceSalePayload>
/**
 * Model RewardAccumulatorMulti
 * 
 */
export type RewardAccumulatorMulti = $Result.DefaultSelection<Prisma.$RewardAccumulatorMultiPayload>
/**
 * Model HolderRewardMulti
 * 
 */
export type HolderRewardMulti = $Result.DefaultSelection<Prisma.$HolderRewardMultiPayload>
/**
 * Model RewardDistributionLog
 * 
 */
export type RewardDistributionLog = $Result.DefaultSelection<Prisma.$RewardDistributionLogPayload>
/**
 * Model RewardClaimLog
 * 
 */
export type RewardClaimLog = $Result.DefaultSelection<Prisma.$RewardClaimLogPayload>
/**
 * Model StolenItem
 * 
 */
export type StolenItem = $Result.DefaultSelection<Prisma.$StolenItemPayload>
/**
 * Model StolenEvent
 * 
 */
export type StolenEvent = $Result.DefaultSelection<Prisma.$StolenEventPayload>
/**
 * Model MultisigSafe
 * 
 */
export type MultisigSafe = $Result.DefaultSelection<Prisma.$MultisigSafePayload>
/**
 * Model MultisigOwner
 * 
 */
export type MultisigOwner = $Result.DefaultSelection<Prisma.$MultisigOwnerPayload>
/**
 * Model MultisigTx
 * 
 */
export type MultisigTx = $Result.DefaultSelection<Prisma.$MultisigTxPayload>
/**
 * Model MultisigApproval
 * 
 */
export type MultisigApproval = $Result.DefaultSelection<Prisma.$MultisigApprovalPayload>
/**
 * Model PendingChainAction
 * 
 */
export type PendingChainAction = $Result.DefaultSelection<Prisma.$PendingChainActionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ContractType: {
  ERC721_DROP: 'ERC721_DROP',
  ERC721_SINGLE: 'ERC721_SINGLE',
  ERC1155_SINGLE: 'ERC1155_SINGLE'
};

export type ContractType = (typeof ContractType)[keyof typeof ContractType]


export const MetadataOption: {
  UPLOAD: 'UPLOAD',
  EXTERNAL: 'EXTERNAL'
};

export type MetadataOption = (typeof MetadataOption)[keyof typeof MetadataOption]


export const ListingStatus: {
  ACTIVE: 'ACTIVE',
  SOLD: 'SOLD',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type ListingStatus = (typeof ListingStatus)[keyof typeof ListingStatus]


export const AuctionStatus: {
  ACTIVE: 'ACTIVE',
  ENDED: 'ENDED',
  CANCELLED: 'CANCELLED'
};

export type AuctionStatus = (typeof AuctionStatus)[keyof typeof AuctionStatus]


export const DraftStatus: {
  DRAFT: 'DRAFT',
  FINALIZED: 'FINALIZED',
  CONSUMED: 'CONSUMED'
};

export type DraftStatus = (typeof DraftStatus)[keyof typeof DraftStatus]


export const IndexStatus: {
  PENDING: 'PENDING',
  QUEUED: 'QUEUED',
  INDEXING: 'INDEXING',
  COMPLETED: 'COMPLETED',
  ERROR: 'ERROR'
};

export type IndexStatus = (typeof IndexStatus)[keyof typeof IndexStatus]


export const NftStatus: {
  PENDING: 'PENDING',
  SUCCESS: 'SUCCESS',
  ERROR: 'ERROR'
};

export type NftStatus = (typeof NftStatus)[keyof typeof NftStatus]


export const SubmissionStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type SubmissionStatus = (typeof SubmissionStatus)[keyof typeof SubmissionStatus]


export const GatewayPref: {
  PUBLIC: 'PUBLIC',
  PINATA: 'PINATA'
};

export type GatewayPref = (typeof GatewayPref)[keyof typeof GatewayPref]


export const FeaturedCycleStatus: {
  UPCOMING: 'UPCOMING',
  ACTIVE: 'ACTIVE',
  FINALIZED: 'FINALIZED'
};

export type FeaturedCycleStatus = (typeof FeaturedCycleStatus)[keyof typeof FeaturedCycleStatus]


export const MultisigTxStatus: {
  SUBMITTED: 'SUBMITTED',
  APPROVED: 'APPROVED',
  EXECUTED: 'EXECUTED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type MultisigTxStatus = (typeof MultisigTxStatus)[keyof typeof MultisigTxStatus]


export const StolenStatus: {
  FLAGGED: 'FLAGGED',
  CLEARED: 'CLEARED'
};

export type StolenStatus = (typeof StolenStatus)[keyof typeof StolenStatus]


export const StolenSource: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  PARTNER: 'PARTNER',
  LAW_ENFORCEMENT: 'LAW_ENFORCEMENT',
  MARKETPLACE: 'MARKETPLACE'
};

export type StolenSource = (typeof StolenSource)[keyof typeof StolenSource]


export const CurrencyKind: {
  NATIVE: 'NATIVE',
  ERC20: 'ERC20'
};

export type CurrencyKind = (typeof CurrencyKind)[keyof typeof CurrencyKind]


export const PendingChainActionType: {
  NFT_AUCTION_CREATE: 'NFT_AUCTION_CREATE',
  NFT_AUCTION_BID: 'NFT_AUCTION_BID',
  NFT_AUCTION_CANCEL: 'NFT_AUCTION_CANCEL',
  NFT_AUCTION_FINALIZE: 'NFT_AUCTION_FINALIZE'
};

export type PendingChainActionType = (typeof PendingChainActionType)[keyof typeof PendingChainActionType]


export const PendingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  FAILED: 'FAILED',
  EXPIRED: 'EXPIRED'
};

export type PendingStatus = (typeof PendingStatus)[keyof typeof PendingStatus]

}

export type ContractType = $Enums.ContractType

export const ContractType: typeof $Enums.ContractType

export type MetadataOption = $Enums.MetadataOption

export const MetadataOption: typeof $Enums.MetadataOption

export type ListingStatus = $Enums.ListingStatus

export const ListingStatus: typeof $Enums.ListingStatus

export type AuctionStatus = $Enums.AuctionStatus

export const AuctionStatus: typeof $Enums.AuctionStatus

export type DraftStatus = $Enums.DraftStatus

export const DraftStatus: typeof $Enums.DraftStatus

export type IndexStatus = $Enums.IndexStatus

export const IndexStatus: typeof $Enums.IndexStatus

export type NftStatus = $Enums.NftStatus

export const NftStatus: typeof $Enums.NftStatus

export type SubmissionStatus = $Enums.SubmissionStatus

export const SubmissionStatus: typeof $Enums.SubmissionStatus

export type GatewayPref = $Enums.GatewayPref

export const GatewayPref: typeof $Enums.GatewayPref

export type FeaturedCycleStatus = $Enums.FeaturedCycleStatus

export const FeaturedCycleStatus: typeof $Enums.FeaturedCycleStatus

export type MultisigTxStatus = $Enums.MultisigTxStatus

export const MultisigTxStatus: typeof $Enums.MultisigTxStatus

export type StolenStatus = $Enums.StolenStatus

export const StolenStatus: typeof $Enums.StolenStatus

export type StolenSource = $Enums.StolenSource

export const StolenSource: typeof $Enums.StolenSource

export type CurrencyKind = $Enums.CurrencyKind

export const CurrencyKind: typeof $Enums.CurrencyKind

export type PendingChainActionType = $Enums.PendingChainActionType

export const PendingChainActionType: typeof $Enums.PendingChainActionType

export type PendingStatus = $Enums.PendingStatus

export const PendingStatus: typeof $Enums.PendingStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ChainStates
 * const chainStates = await prisma.chainState.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ChainStates
   * const chainStates = await prisma.chainState.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.chainState`: Exposes CRUD operations for the **ChainState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChainStates
    * const chainStates = await prisma.chainState.findMany()
    * ```
    */
  get chainState(): Prisma.ChainStateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collection`: Exposes CRUD operations for the **Collection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collections
    * const collections = await prisma.collection.findMany()
    * ```
    */
  get collection(): Prisma.CollectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nFT`: Exposes CRUD operations for the **NFT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NFTS
    * const nFTS = await prisma.nFT.findMany()
    * ```
    */
  get nFT(): Prisma.NFTDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.traitStat`: Exposes CRUD operations for the **TraitStat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TraitStats
    * const traitStats = await prisma.traitStat.findMany()
    * ```
    */
  get traitStat(): Prisma.TraitStatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nFTActivity`: Exposes CRUD operations for the **NFTActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NFTActivities
    * const nFTActivities = await prisma.nFTActivity.findMany()
    * ```
    */
  get nFTActivity(): Prisma.NFTActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.single721`: Exposes CRUD operations for the **Single721** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Single721s
    * const single721s = await prisma.single721.findMany()
    * ```
    */
  get single721(): Prisma.Single721Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.single1155`: Exposes CRUD operations for the **Single1155** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Single1155s
    * const single1155s = await prisma.single1155.findMany()
    * ```
    */
  get single1155(): Prisma.Single1155Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.erc1155Balance`: Exposes CRUD operations for the **Erc1155Balance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Erc1155Balances
    * const erc1155Balances = await prisma.erc1155Balance.findMany()
    * ```
    */
  get erc1155Balance(): Prisma.Erc1155BalanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.erc1155Holding`: Exposes CRUD operations for the **Erc1155Holding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Erc1155Holdings
    * const erc1155Holdings = await prisma.erc1155Holding.findMany()
    * ```
    */
  get erc1155Holding(): Prisma.Erc1155HoldingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketplaceListing`: Exposes CRUD operations for the **MarketplaceListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketplaceListings
    * const marketplaceListings = await prisma.marketplaceListing.findMany()
    * ```
    */
  get marketplaceListing(): Prisma.MarketplaceListingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auction`: Exposes CRUD operations for the **Auction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auctions
    * const auctions = await prisma.auction.findMany()
    * ```
    */
  get auction(): Prisma.AuctionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auctionBid`: Exposes CRUD operations for the **AuctionBid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuctionBids
    * const auctionBids = await prisma.auctionBid.findMany()
    * ```
    */
  get auctionBid(): Prisma.AuctionBidDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deployedContract`: Exposes CRUD operations for the **DeployedContract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeployedContracts
    * const deployedContracts = await prisma.deployedContract.findMany()
    * ```
    */
  get deployedContract(): Prisma.DeployedContractDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feeConfig`: Exposes CRUD operations for the **FeeConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeConfigs
    * const feeConfigs = await prisma.feeConfig.findMany()
    * ```
    */
  get feeConfig(): Prisma.FeeConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feeConfigLog`: Exposes CRUD operations for the **FeeConfigLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeConfigLogs
    * const feeConfigLogs = await prisma.feeConfigLog.findMany()
    * ```
    */
  get feeConfigLog(): Prisma.FeeConfigLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publicSale`: Exposes CRUD operations for the **PublicSale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PublicSales
    * const publicSales = await prisma.publicSale.findMany()
    * ```
    */
  get publicSale(): Prisma.PublicSaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.presale`: Exposes CRUD operations for the **Presale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Presales
    * const presales = await prisma.presale.findMany()
    * ```
    */
  get presale(): Prisma.PresaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.presaleWhitelistAddress`: Exposes CRUD operations for the **PresaleWhitelistAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PresaleWhitelistAddresses
    * const presaleWhitelistAddresses = await prisma.presaleWhitelistAddress.findMany()
    * ```
    */
  get presaleWhitelistAddress(): Prisma.PresaleWhitelistAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.presaleDraft`: Exposes CRUD operations for the **PresaleDraft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PresaleDrafts
    * const presaleDrafts = await prisma.presaleDraft.findMany()
    * ```
    */
  get presaleDraft(): Prisma.PresaleDraftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assetUpload`: Exposes CRUD operations for the **AssetUpload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssetUploads
    * const assetUploads = await prisma.assetUpload.findMany()
    * ```
    */
  get assetUpload(): Prisma.AssetUploadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectionSubmission`: Exposes CRUD operations for the **CollectionSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CollectionSubmissions
    * const collectionSubmissions = await prisma.collectionSubmission.findMany()
    * ```
    */
  get collectionSubmission(): Prisma.CollectionSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nFTRarity`: Exposes CRUD operations for the **NFTRarity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NFTRarities
    * const nFTRarities = await prisma.nFTRarity.findMany()
    * ```
    */
  get nFTRarity(): Prisma.NFTRarityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.holderReward`: Exposes CRUD operations for the **HolderReward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HolderRewards
    * const holderRewards = await prisma.holderReward.findMany()
    * ```
    */
  get holderReward(): Prisma.HolderRewardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rewardAccumulator`: Exposes CRUD operations for the **RewardAccumulator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardAccumulators
    * const rewardAccumulators = await prisma.rewardAccumulator.findMany()
    * ```
    */
  get rewardAccumulator(): Prisma.RewardAccumulatorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featuredCycle`: Exposes CRUD operations for the **FeaturedCycle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeaturedCycles
    * const featuredCycles = await prisma.featuredCycle.findMany()
    * ```
    */
  get featuredCycle(): Prisma.FeaturedCycleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.featuredBid`: Exposes CRUD operations for the **FeaturedBid** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeaturedBids
    * const featuredBids = await prisma.featuredBid.findMany()
    * ```
    */
  get featuredBid(): Prisma.FeaturedBidDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **Currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.CurrencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketplaceSale`: Exposes CRUD operations for the **MarketplaceSale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketplaceSales
    * const marketplaceSales = await prisma.marketplaceSale.findMany()
    * ```
    */
  get marketplaceSale(): Prisma.MarketplaceSaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rewardAccumulatorMulti`: Exposes CRUD operations for the **RewardAccumulatorMulti** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardAccumulatorMultis
    * const rewardAccumulatorMultis = await prisma.rewardAccumulatorMulti.findMany()
    * ```
    */
  get rewardAccumulatorMulti(): Prisma.RewardAccumulatorMultiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.holderRewardMulti`: Exposes CRUD operations for the **HolderRewardMulti** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HolderRewardMultis
    * const holderRewardMultis = await prisma.holderRewardMulti.findMany()
    * ```
    */
  get holderRewardMulti(): Prisma.HolderRewardMultiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rewardDistributionLog`: Exposes CRUD operations for the **RewardDistributionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardDistributionLogs
    * const rewardDistributionLogs = await prisma.rewardDistributionLog.findMany()
    * ```
    */
  get rewardDistributionLog(): Prisma.RewardDistributionLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rewardClaimLog`: Exposes CRUD operations for the **RewardClaimLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RewardClaimLogs
    * const rewardClaimLogs = await prisma.rewardClaimLog.findMany()
    * ```
    */
  get rewardClaimLog(): Prisma.RewardClaimLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stolenItem`: Exposes CRUD operations for the **StolenItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StolenItems
    * const stolenItems = await prisma.stolenItem.findMany()
    * ```
    */
  get stolenItem(): Prisma.StolenItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stolenEvent`: Exposes CRUD operations for the **StolenEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StolenEvents
    * const stolenEvents = await prisma.stolenEvent.findMany()
    * ```
    */
  get stolenEvent(): Prisma.StolenEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.multisigSafe`: Exposes CRUD operations for the **MultisigSafe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MultisigSafes
    * const multisigSafes = await prisma.multisigSafe.findMany()
    * ```
    */
  get multisigSafe(): Prisma.MultisigSafeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.multisigOwner`: Exposes CRUD operations for the **MultisigOwner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MultisigOwners
    * const multisigOwners = await prisma.multisigOwner.findMany()
    * ```
    */
  get multisigOwner(): Prisma.MultisigOwnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.multisigTx`: Exposes CRUD operations for the **MultisigTx** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MultisigTxes
    * const multisigTxes = await prisma.multisigTx.findMany()
    * ```
    */
  get multisigTx(): Prisma.MultisigTxDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.multisigApproval`: Exposes CRUD operations for the **MultisigApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MultisigApprovals
    * const multisigApprovals = await prisma.multisigApproval.findMany()
    * ```
    */
  get multisigApproval(): Prisma.MultisigApprovalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendingChainAction`: Exposes CRUD operations for the **PendingChainAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingChainActions
    * const pendingChainActions = await prisma.pendingChainAction.findMany()
    * ```
    */
  get pendingChainAction(): Prisma.PendingChainActionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ChainState: 'ChainState',
    User: 'User',
    Collection: 'Collection',
    NFT: 'NFT',
    TraitStat: 'TraitStat',
    NFTActivity: 'NFTActivity',
    Single721: 'Single721',
    Single1155: 'Single1155',
    Erc1155Balance: 'Erc1155Balance',
    Erc1155Holding: 'Erc1155Holding',
    MarketplaceListing: 'MarketplaceListing',
    Auction: 'Auction',
    AuctionBid: 'AuctionBid',
    DeployedContract: 'DeployedContract',
    FeeConfig: 'FeeConfig',
    FeeConfigLog: 'FeeConfigLog',
    PublicSale: 'PublicSale',
    Presale: 'Presale',
    PresaleWhitelistAddress: 'PresaleWhitelistAddress',
    PresaleDraft: 'PresaleDraft',
    AssetUpload: 'AssetUpload',
    CollectionSubmission: 'CollectionSubmission',
    NFTRarity: 'NFTRarity',
    HolderReward: 'HolderReward',
    RewardAccumulator: 'RewardAccumulator',
    FeaturedCycle: 'FeaturedCycle',
    FeaturedBid: 'FeaturedBid',
    Currency: 'Currency',
    MarketplaceSale: 'MarketplaceSale',
    RewardAccumulatorMulti: 'RewardAccumulatorMulti',
    HolderRewardMulti: 'HolderRewardMulti',
    RewardDistributionLog: 'RewardDistributionLog',
    RewardClaimLog: 'RewardClaimLog',
    StolenItem: 'StolenItem',
    StolenEvent: 'StolenEvent',
    MultisigSafe: 'MultisigSafe',
    MultisigOwner: 'MultisigOwner',
    MultisigTx: 'MultisigTx',
    MultisigApproval: 'MultisigApproval',
    PendingChainAction: 'PendingChainAction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "chainState" | "user" | "collection" | "nFT" | "traitStat" | "nFTActivity" | "single721" | "single1155" | "erc1155Balance" | "erc1155Holding" | "marketplaceListing" | "auction" | "auctionBid" | "deployedContract" | "feeConfig" | "feeConfigLog" | "publicSale" | "presale" | "presaleWhitelistAddress" | "presaleDraft" | "assetUpload" | "collectionSubmission" | "nFTRarity" | "holderReward" | "rewardAccumulator" | "featuredCycle" | "featuredBid" | "currency" | "marketplaceSale" | "rewardAccumulatorMulti" | "holderRewardMulti" | "rewardDistributionLog" | "rewardClaimLog" | "stolenItem" | "stolenEvent" | "multisigSafe" | "multisigOwner" | "multisigTx" | "multisigApproval" | "pendingChainAction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ChainState: {
        payload: Prisma.$ChainStatePayload<ExtArgs>
        fields: Prisma.ChainStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChainStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChainStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainStatePayload>
          }
          findFirst: {
            args: Prisma.ChainStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChainStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainStatePayload>
          }
          findMany: {
            args: Prisma.ChainStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainStatePayload>[]
          }
          create: {
            args: Prisma.ChainStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainStatePayload>
          }
          createMany: {
            args: Prisma.ChainStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChainStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainStatePayload>[]
          }
          delete: {
            args: Prisma.ChainStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainStatePayload>
          }
          update: {
            args: Prisma.ChainStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainStatePayload>
          }
          deleteMany: {
            args: Prisma.ChainStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChainStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChainStateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainStatePayload>[]
          }
          upsert: {
            args: Prisma.ChainStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChainStatePayload>
          }
          aggregate: {
            args: Prisma.ChainStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChainState>
          }
          groupBy: {
            args: Prisma.ChainStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChainStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChainStateCountArgs<ExtArgs>
            result: $Utils.Optional<ChainStateCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Collection: {
        payload: Prisma.$CollectionPayload<ExtArgs>
        fields: Prisma.CollectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          findFirst: {
            args: Prisma.CollectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          findMany: {
            args: Prisma.CollectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>[]
          }
          create: {
            args: Prisma.CollectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          createMany: {
            args: Prisma.CollectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>[]
          }
          delete: {
            args: Prisma.CollectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          update: {
            args: Prisma.CollectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          deleteMany: {
            args: Prisma.CollectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>[]
          }
          upsert: {
            args: Prisma.CollectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          aggregate: {
            args: Prisma.CollectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollection>
          }
          groupBy: {
            args: Prisma.CollectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionCountAggregateOutputType> | number
          }
        }
      }
      NFT: {
        payload: Prisma.$NFTPayload<ExtArgs>
        fields: Prisma.NFTFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NFTFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NFTFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          findFirst: {
            args: Prisma.NFTFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NFTFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          findMany: {
            args: Prisma.NFTFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>[]
          }
          create: {
            args: Prisma.NFTCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          createMany: {
            args: Prisma.NFTCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NFTCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>[]
          }
          delete: {
            args: Prisma.NFTDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          update: {
            args: Prisma.NFTUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          deleteMany: {
            args: Prisma.NFTDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NFTUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NFTUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>[]
          }
          upsert: {
            args: Prisma.NFTUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTPayload>
          }
          aggregate: {
            args: Prisma.NFTAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNFT>
          }
          groupBy: {
            args: Prisma.NFTGroupByArgs<ExtArgs>
            result: $Utils.Optional<NFTGroupByOutputType>[]
          }
          count: {
            args: Prisma.NFTCountArgs<ExtArgs>
            result: $Utils.Optional<NFTCountAggregateOutputType> | number
          }
        }
      }
      TraitStat: {
        payload: Prisma.$TraitStatPayload<ExtArgs>
        fields: Prisma.TraitStatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TraitStatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitStatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TraitStatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitStatPayload>
          }
          findFirst: {
            args: Prisma.TraitStatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitStatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TraitStatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitStatPayload>
          }
          findMany: {
            args: Prisma.TraitStatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitStatPayload>[]
          }
          create: {
            args: Prisma.TraitStatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitStatPayload>
          }
          createMany: {
            args: Prisma.TraitStatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TraitStatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitStatPayload>[]
          }
          delete: {
            args: Prisma.TraitStatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitStatPayload>
          }
          update: {
            args: Prisma.TraitStatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitStatPayload>
          }
          deleteMany: {
            args: Prisma.TraitStatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TraitStatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TraitStatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitStatPayload>[]
          }
          upsert: {
            args: Prisma.TraitStatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraitStatPayload>
          }
          aggregate: {
            args: Prisma.TraitStatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTraitStat>
          }
          groupBy: {
            args: Prisma.TraitStatGroupByArgs<ExtArgs>
            result: $Utils.Optional<TraitStatGroupByOutputType>[]
          }
          count: {
            args: Prisma.TraitStatCountArgs<ExtArgs>
            result: $Utils.Optional<TraitStatCountAggregateOutputType> | number
          }
        }
      }
      NFTActivity: {
        payload: Prisma.$NFTActivityPayload<ExtArgs>
        fields: Prisma.NFTActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NFTActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NFTActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTActivityPayload>
          }
          findFirst: {
            args: Prisma.NFTActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NFTActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTActivityPayload>
          }
          findMany: {
            args: Prisma.NFTActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTActivityPayload>[]
          }
          create: {
            args: Prisma.NFTActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTActivityPayload>
          }
          createMany: {
            args: Prisma.NFTActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NFTActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTActivityPayload>[]
          }
          delete: {
            args: Prisma.NFTActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTActivityPayload>
          }
          update: {
            args: Prisma.NFTActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTActivityPayload>
          }
          deleteMany: {
            args: Prisma.NFTActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NFTActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NFTActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTActivityPayload>[]
          }
          upsert: {
            args: Prisma.NFTActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTActivityPayload>
          }
          aggregate: {
            args: Prisma.NFTActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNFTActivity>
          }
          groupBy: {
            args: Prisma.NFTActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<NFTActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.NFTActivityCountArgs<ExtArgs>
            result: $Utils.Optional<NFTActivityCountAggregateOutputType> | number
          }
        }
      }
      Single721: {
        payload: Prisma.$Single721Payload<ExtArgs>
        fields: Prisma.Single721FieldRefs
        operations: {
          findUnique: {
            args: Prisma.Single721FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single721Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Single721FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single721Payload>
          }
          findFirst: {
            args: Prisma.Single721FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single721Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Single721FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single721Payload>
          }
          findMany: {
            args: Prisma.Single721FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single721Payload>[]
          }
          create: {
            args: Prisma.Single721CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single721Payload>
          }
          createMany: {
            args: Prisma.Single721CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Single721CreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single721Payload>[]
          }
          delete: {
            args: Prisma.Single721DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single721Payload>
          }
          update: {
            args: Prisma.Single721UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single721Payload>
          }
          deleteMany: {
            args: Prisma.Single721DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Single721UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Single721UpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single721Payload>[]
          }
          upsert: {
            args: Prisma.Single721UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single721Payload>
          }
          aggregate: {
            args: Prisma.Single721AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSingle721>
          }
          groupBy: {
            args: Prisma.Single721GroupByArgs<ExtArgs>
            result: $Utils.Optional<Single721GroupByOutputType>[]
          }
          count: {
            args: Prisma.Single721CountArgs<ExtArgs>
            result: $Utils.Optional<Single721CountAggregateOutputType> | number
          }
        }
      }
      Single1155: {
        payload: Prisma.$Single1155Payload<ExtArgs>
        fields: Prisma.Single1155FieldRefs
        operations: {
          findUnique: {
            args: Prisma.Single1155FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single1155Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Single1155FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single1155Payload>
          }
          findFirst: {
            args: Prisma.Single1155FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single1155Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Single1155FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single1155Payload>
          }
          findMany: {
            args: Prisma.Single1155FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single1155Payload>[]
          }
          create: {
            args: Prisma.Single1155CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single1155Payload>
          }
          createMany: {
            args: Prisma.Single1155CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Single1155CreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single1155Payload>[]
          }
          delete: {
            args: Prisma.Single1155DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single1155Payload>
          }
          update: {
            args: Prisma.Single1155UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single1155Payload>
          }
          deleteMany: {
            args: Prisma.Single1155DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Single1155UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Single1155UpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single1155Payload>[]
          }
          upsert: {
            args: Prisma.Single1155UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Single1155Payload>
          }
          aggregate: {
            args: Prisma.Single1155AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSingle1155>
          }
          groupBy: {
            args: Prisma.Single1155GroupByArgs<ExtArgs>
            result: $Utils.Optional<Single1155GroupByOutputType>[]
          }
          count: {
            args: Prisma.Single1155CountArgs<ExtArgs>
            result: $Utils.Optional<Single1155CountAggregateOutputType> | number
          }
        }
      }
      Erc1155Balance: {
        payload: Prisma.$Erc1155BalancePayload<ExtArgs>
        fields: Prisma.Erc1155BalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Erc1155BalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155BalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Erc1155BalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155BalancePayload>
          }
          findFirst: {
            args: Prisma.Erc1155BalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155BalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Erc1155BalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155BalancePayload>
          }
          findMany: {
            args: Prisma.Erc1155BalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155BalancePayload>[]
          }
          create: {
            args: Prisma.Erc1155BalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155BalancePayload>
          }
          createMany: {
            args: Prisma.Erc1155BalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Erc1155BalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155BalancePayload>[]
          }
          delete: {
            args: Prisma.Erc1155BalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155BalancePayload>
          }
          update: {
            args: Prisma.Erc1155BalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155BalancePayload>
          }
          deleteMany: {
            args: Prisma.Erc1155BalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Erc1155BalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Erc1155BalanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155BalancePayload>[]
          }
          upsert: {
            args: Prisma.Erc1155BalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155BalancePayload>
          }
          aggregate: {
            args: Prisma.Erc1155BalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateErc1155Balance>
          }
          groupBy: {
            args: Prisma.Erc1155BalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Erc1155BalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.Erc1155BalanceCountArgs<ExtArgs>
            result: $Utils.Optional<Erc1155BalanceCountAggregateOutputType> | number
          }
        }
      }
      Erc1155Holding: {
        payload: Prisma.$Erc1155HoldingPayload<ExtArgs>
        fields: Prisma.Erc1155HoldingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Erc1155HoldingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155HoldingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Erc1155HoldingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155HoldingPayload>
          }
          findFirst: {
            args: Prisma.Erc1155HoldingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155HoldingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Erc1155HoldingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155HoldingPayload>
          }
          findMany: {
            args: Prisma.Erc1155HoldingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155HoldingPayload>[]
          }
          create: {
            args: Prisma.Erc1155HoldingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155HoldingPayload>
          }
          createMany: {
            args: Prisma.Erc1155HoldingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.Erc1155HoldingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155HoldingPayload>[]
          }
          delete: {
            args: Prisma.Erc1155HoldingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155HoldingPayload>
          }
          update: {
            args: Prisma.Erc1155HoldingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155HoldingPayload>
          }
          deleteMany: {
            args: Prisma.Erc1155HoldingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Erc1155HoldingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.Erc1155HoldingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155HoldingPayload>[]
          }
          upsert: {
            args: Prisma.Erc1155HoldingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Erc1155HoldingPayload>
          }
          aggregate: {
            args: Prisma.Erc1155HoldingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateErc1155Holding>
          }
          groupBy: {
            args: Prisma.Erc1155HoldingGroupByArgs<ExtArgs>
            result: $Utils.Optional<Erc1155HoldingGroupByOutputType>[]
          }
          count: {
            args: Prisma.Erc1155HoldingCountArgs<ExtArgs>
            result: $Utils.Optional<Erc1155HoldingCountAggregateOutputType> | number
          }
        }
      }
      MarketplaceListing: {
        payload: Prisma.$MarketplaceListingPayload<ExtArgs>
        fields: Prisma.MarketplaceListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketplaceListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketplaceListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          findFirst: {
            args: Prisma.MarketplaceListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketplaceListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          findMany: {
            args: Prisma.MarketplaceListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>[]
          }
          create: {
            args: Prisma.MarketplaceListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          createMany: {
            args: Prisma.MarketplaceListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketplaceListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>[]
          }
          delete: {
            args: Prisma.MarketplaceListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          update: {
            args: Prisma.MarketplaceListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          deleteMany: {
            args: Prisma.MarketplaceListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketplaceListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketplaceListingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>[]
          }
          upsert: {
            args: Prisma.MarketplaceListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceListingPayload>
          }
          aggregate: {
            args: Prisma.MarketplaceListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketplaceListing>
          }
          groupBy: {
            args: Prisma.MarketplaceListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketplaceListingCountArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceListingCountAggregateOutputType> | number
          }
        }
      }
      Auction: {
        payload: Prisma.$AuctionPayload<ExtArgs>
        fields: Prisma.AuctionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuctionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuctionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          findFirst: {
            args: Prisma.AuctionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuctionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          findMany: {
            args: Prisma.AuctionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>[]
          }
          create: {
            args: Prisma.AuctionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          createMany: {
            args: Prisma.AuctionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuctionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>[]
          }
          delete: {
            args: Prisma.AuctionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          update: {
            args: Prisma.AuctionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          deleteMany: {
            args: Prisma.AuctionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuctionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuctionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>[]
          }
          upsert: {
            args: Prisma.AuctionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionPayload>
          }
          aggregate: {
            args: Prisma.AuctionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuction>
          }
          groupBy: {
            args: Prisma.AuctionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuctionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuctionCountArgs<ExtArgs>
            result: $Utils.Optional<AuctionCountAggregateOutputType> | number
          }
        }
      }
      AuctionBid: {
        payload: Prisma.$AuctionBidPayload<ExtArgs>
        fields: Prisma.AuctionBidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuctionBidFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuctionBidFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>
          }
          findFirst: {
            args: Prisma.AuctionBidFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuctionBidFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>
          }
          findMany: {
            args: Prisma.AuctionBidFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>[]
          }
          create: {
            args: Prisma.AuctionBidCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>
          }
          createMany: {
            args: Prisma.AuctionBidCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuctionBidCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>[]
          }
          delete: {
            args: Prisma.AuctionBidDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>
          }
          update: {
            args: Prisma.AuctionBidUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>
          }
          deleteMany: {
            args: Prisma.AuctionBidDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuctionBidUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuctionBidUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>[]
          }
          upsert: {
            args: Prisma.AuctionBidUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuctionBidPayload>
          }
          aggregate: {
            args: Prisma.AuctionBidAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuctionBid>
          }
          groupBy: {
            args: Prisma.AuctionBidGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuctionBidGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuctionBidCountArgs<ExtArgs>
            result: $Utils.Optional<AuctionBidCountAggregateOutputType> | number
          }
        }
      }
      DeployedContract: {
        payload: Prisma.$DeployedContractPayload<ExtArgs>
        fields: Prisma.DeployedContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeployedContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeployedContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeployedContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeployedContractPayload>
          }
          findFirst: {
            args: Prisma.DeployedContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeployedContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeployedContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeployedContractPayload>
          }
          findMany: {
            args: Prisma.DeployedContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeployedContractPayload>[]
          }
          create: {
            args: Prisma.DeployedContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeployedContractPayload>
          }
          createMany: {
            args: Prisma.DeployedContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeployedContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeployedContractPayload>[]
          }
          delete: {
            args: Prisma.DeployedContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeployedContractPayload>
          }
          update: {
            args: Prisma.DeployedContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeployedContractPayload>
          }
          deleteMany: {
            args: Prisma.DeployedContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeployedContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeployedContractUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeployedContractPayload>[]
          }
          upsert: {
            args: Prisma.DeployedContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeployedContractPayload>
          }
          aggregate: {
            args: Prisma.DeployedContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeployedContract>
          }
          groupBy: {
            args: Prisma.DeployedContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeployedContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeployedContractCountArgs<ExtArgs>
            result: $Utils.Optional<DeployedContractCountAggregateOutputType> | number
          }
        }
      }
      FeeConfig: {
        payload: Prisma.$FeeConfigPayload<ExtArgs>
        fields: Prisma.FeeConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigPayload>
          }
          findFirst: {
            args: Prisma.FeeConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigPayload>
          }
          findMany: {
            args: Prisma.FeeConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigPayload>[]
          }
          create: {
            args: Prisma.FeeConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigPayload>
          }
          createMany: {
            args: Prisma.FeeConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeeConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigPayload>[]
          }
          delete: {
            args: Prisma.FeeConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigPayload>
          }
          update: {
            args: Prisma.FeeConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigPayload>
          }
          deleteMany: {
            args: Prisma.FeeConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeeConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigPayload>[]
          }
          upsert: {
            args: Prisma.FeeConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigPayload>
          }
          aggregate: {
            args: Prisma.FeeConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeConfig>
          }
          groupBy: {
            args: Prisma.FeeConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeConfigCountArgs<ExtArgs>
            result: $Utils.Optional<FeeConfigCountAggregateOutputType> | number
          }
        }
      }
      FeeConfigLog: {
        payload: Prisma.$FeeConfigLogPayload<ExtArgs>
        fields: Prisma.FeeConfigLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeConfigLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeConfigLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigLogPayload>
          }
          findFirst: {
            args: Prisma.FeeConfigLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeConfigLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigLogPayload>
          }
          findMany: {
            args: Prisma.FeeConfigLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigLogPayload>[]
          }
          create: {
            args: Prisma.FeeConfigLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigLogPayload>
          }
          createMany: {
            args: Prisma.FeeConfigLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeeConfigLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigLogPayload>[]
          }
          delete: {
            args: Prisma.FeeConfigLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigLogPayload>
          }
          update: {
            args: Prisma.FeeConfigLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigLogPayload>
          }
          deleteMany: {
            args: Prisma.FeeConfigLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeConfigLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeeConfigLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigLogPayload>[]
          }
          upsert: {
            args: Prisma.FeeConfigLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeConfigLogPayload>
          }
          aggregate: {
            args: Prisma.FeeConfigLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeConfigLog>
          }
          groupBy: {
            args: Prisma.FeeConfigLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeConfigLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeConfigLogCountArgs<ExtArgs>
            result: $Utils.Optional<FeeConfigLogCountAggregateOutputType> | number
          }
        }
      }
      PublicSale: {
        payload: Prisma.$PublicSalePayload<ExtArgs>
        fields: Prisma.PublicSaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublicSaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicSalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublicSaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicSalePayload>
          }
          findFirst: {
            args: Prisma.PublicSaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicSalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublicSaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicSalePayload>
          }
          findMany: {
            args: Prisma.PublicSaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicSalePayload>[]
          }
          create: {
            args: Prisma.PublicSaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicSalePayload>
          }
          createMany: {
            args: Prisma.PublicSaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PublicSaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicSalePayload>[]
          }
          delete: {
            args: Prisma.PublicSaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicSalePayload>
          }
          update: {
            args: Prisma.PublicSaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicSalePayload>
          }
          deleteMany: {
            args: Prisma.PublicSaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PublicSaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PublicSaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicSalePayload>[]
          }
          upsert: {
            args: Prisma.PublicSaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublicSalePayload>
          }
          aggregate: {
            args: Prisma.PublicSaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublicSale>
          }
          groupBy: {
            args: Prisma.PublicSaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublicSaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PublicSaleCountArgs<ExtArgs>
            result: $Utils.Optional<PublicSaleCountAggregateOutputType> | number
          }
        }
      }
      Presale: {
        payload: Prisma.$PresalePayload<ExtArgs>
        fields: Prisma.PresaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PresaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PresaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresalePayload>
          }
          findFirst: {
            args: Prisma.PresaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PresaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresalePayload>
          }
          findMany: {
            args: Prisma.PresaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresalePayload>[]
          }
          create: {
            args: Prisma.PresaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresalePayload>
          }
          createMany: {
            args: Prisma.PresaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PresaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresalePayload>[]
          }
          delete: {
            args: Prisma.PresaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresalePayload>
          }
          update: {
            args: Prisma.PresaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresalePayload>
          }
          deleteMany: {
            args: Prisma.PresaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PresaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PresaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresalePayload>[]
          }
          upsert: {
            args: Prisma.PresaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresalePayload>
          }
          aggregate: {
            args: Prisma.PresaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePresale>
          }
          groupBy: {
            args: Prisma.PresaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PresaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PresaleCountArgs<ExtArgs>
            result: $Utils.Optional<PresaleCountAggregateOutputType> | number
          }
        }
      }
      PresaleWhitelistAddress: {
        payload: Prisma.$PresaleWhitelistAddressPayload<ExtArgs>
        fields: Prisma.PresaleWhitelistAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PresaleWhitelistAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleWhitelistAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PresaleWhitelistAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleWhitelistAddressPayload>
          }
          findFirst: {
            args: Prisma.PresaleWhitelistAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleWhitelistAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PresaleWhitelistAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleWhitelistAddressPayload>
          }
          findMany: {
            args: Prisma.PresaleWhitelistAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleWhitelistAddressPayload>[]
          }
          create: {
            args: Prisma.PresaleWhitelistAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleWhitelistAddressPayload>
          }
          createMany: {
            args: Prisma.PresaleWhitelistAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PresaleWhitelistAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleWhitelistAddressPayload>[]
          }
          delete: {
            args: Prisma.PresaleWhitelistAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleWhitelistAddressPayload>
          }
          update: {
            args: Prisma.PresaleWhitelistAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleWhitelistAddressPayload>
          }
          deleteMany: {
            args: Prisma.PresaleWhitelistAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PresaleWhitelistAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PresaleWhitelistAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleWhitelistAddressPayload>[]
          }
          upsert: {
            args: Prisma.PresaleWhitelistAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleWhitelistAddressPayload>
          }
          aggregate: {
            args: Prisma.PresaleWhitelistAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePresaleWhitelistAddress>
          }
          groupBy: {
            args: Prisma.PresaleWhitelistAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<PresaleWhitelistAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.PresaleWhitelistAddressCountArgs<ExtArgs>
            result: $Utils.Optional<PresaleWhitelistAddressCountAggregateOutputType> | number
          }
        }
      }
      PresaleDraft: {
        payload: Prisma.$PresaleDraftPayload<ExtArgs>
        fields: Prisma.PresaleDraftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PresaleDraftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleDraftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PresaleDraftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleDraftPayload>
          }
          findFirst: {
            args: Prisma.PresaleDraftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleDraftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PresaleDraftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleDraftPayload>
          }
          findMany: {
            args: Prisma.PresaleDraftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleDraftPayload>[]
          }
          create: {
            args: Prisma.PresaleDraftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleDraftPayload>
          }
          createMany: {
            args: Prisma.PresaleDraftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PresaleDraftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleDraftPayload>[]
          }
          delete: {
            args: Prisma.PresaleDraftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleDraftPayload>
          }
          update: {
            args: Prisma.PresaleDraftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleDraftPayload>
          }
          deleteMany: {
            args: Prisma.PresaleDraftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PresaleDraftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PresaleDraftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleDraftPayload>[]
          }
          upsert: {
            args: Prisma.PresaleDraftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PresaleDraftPayload>
          }
          aggregate: {
            args: Prisma.PresaleDraftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePresaleDraft>
          }
          groupBy: {
            args: Prisma.PresaleDraftGroupByArgs<ExtArgs>
            result: $Utils.Optional<PresaleDraftGroupByOutputType>[]
          }
          count: {
            args: Prisma.PresaleDraftCountArgs<ExtArgs>
            result: $Utils.Optional<PresaleDraftCountAggregateOutputType> | number
          }
        }
      }
      AssetUpload: {
        payload: Prisma.$AssetUploadPayload<ExtArgs>
        fields: Prisma.AssetUploadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssetUploadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetUploadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssetUploadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetUploadPayload>
          }
          findFirst: {
            args: Prisma.AssetUploadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetUploadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssetUploadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetUploadPayload>
          }
          findMany: {
            args: Prisma.AssetUploadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetUploadPayload>[]
          }
          create: {
            args: Prisma.AssetUploadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetUploadPayload>
          }
          createMany: {
            args: Prisma.AssetUploadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssetUploadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetUploadPayload>[]
          }
          delete: {
            args: Prisma.AssetUploadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetUploadPayload>
          }
          update: {
            args: Prisma.AssetUploadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetUploadPayload>
          }
          deleteMany: {
            args: Prisma.AssetUploadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssetUploadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssetUploadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetUploadPayload>[]
          }
          upsert: {
            args: Prisma.AssetUploadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssetUploadPayload>
          }
          aggregate: {
            args: Prisma.AssetUploadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssetUpload>
          }
          groupBy: {
            args: Prisma.AssetUploadGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssetUploadGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssetUploadCountArgs<ExtArgs>
            result: $Utils.Optional<AssetUploadCountAggregateOutputType> | number
          }
        }
      }
      CollectionSubmission: {
        payload: Prisma.$CollectionSubmissionPayload<ExtArgs>
        fields: Prisma.CollectionSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionSubmissionPayload>
          }
          findFirst: {
            args: Prisma.CollectionSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionSubmissionPayload>
          }
          findMany: {
            args: Prisma.CollectionSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionSubmissionPayload>[]
          }
          create: {
            args: Prisma.CollectionSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionSubmissionPayload>
          }
          createMany: {
            args: Prisma.CollectionSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionSubmissionPayload>[]
          }
          delete: {
            args: Prisma.CollectionSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionSubmissionPayload>
          }
          update: {
            args: Prisma.CollectionSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.CollectionSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.CollectionSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionSubmissionPayload>
          }
          aggregate: {
            args: Prisma.CollectionSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectionSubmission>
          }
          groupBy: {
            args: Prisma.CollectionSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionSubmissionCountAggregateOutputType> | number
          }
        }
      }
      NFTRarity: {
        payload: Prisma.$NFTRarityPayload<ExtArgs>
        fields: Prisma.NFTRarityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NFTRarityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTRarityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NFTRarityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTRarityPayload>
          }
          findFirst: {
            args: Prisma.NFTRarityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTRarityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NFTRarityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTRarityPayload>
          }
          findMany: {
            args: Prisma.NFTRarityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTRarityPayload>[]
          }
          create: {
            args: Prisma.NFTRarityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTRarityPayload>
          }
          createMany: {
            args: Prisma.NFTRarityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NFTRarityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTRarityPayload>[]
          }
          delete: {
            args: Prisma.NFTRarityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTRarityPayload>
          }
          update: {
            args: Prisma.NFTRarityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTRarityPayload>
          }
          deleteMany: {
            args: Prisma.NFTRarityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NFTRarityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NFTRarityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTRarityPayload>[]
          }
          upsert: {
            args: Prisma.NFTRarityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NFTRarityPayload>
          }
          aggregate: {
            args: Prisma.NFTRarityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNFTRarity>
          }
          groupBy: {
            args: Prisma.NFTRarityGroupByArgs<ExtArgs>
            result: $Utils.Optional<NFTRarityGroupByOutputType>[]
          }
          count: {
            args: Prisma.NFTRarityCountArgs<ExtArgs>
            result: $Utils.Optional<NFTRarityCountAggregateOutputType> | number
          }
        }
      }
      HolderReward: {
        payload: Prisma.$HolderRewardPayload<ExtArgs>
        fields: Prisma.HolderRewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HolderRewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HolderRewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardPayload>
          }
          findFirst: {
            args: Prisma.HolderRewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HolderRewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardPayload>
          }
          findMany: {
            args: Prisma.HolderRewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardPayload>[]
          }
          create: {
            args: Prisma.HolderRewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardPayload>
          }
          createMany: {
            args: Prisma.HolderRewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HolderRewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardPayload>[]
          }
          delete: {
            args: Prisma.HolderRewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardPayload>
          }
          update: {
            args: Prisma.HolderRewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardPayload>
          }
          deleteMany: {
            args: Prisma.HolderRewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HolderRewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HolderRewardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardPayload>[]
          }
          upsert: {
            args: Prisma.HolderRewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardPayload>
          }
          aggregate: {
            args: Prisma.HolderRewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHolderReward>
          }
          groupBy: {
            args: Prisma.HolderRewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<HolderRewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.HolderRewardCountArgs<ExtArgs>
            result: $Utils.Optional<HolderRewardCountAggregateOutputType> | number
          }
        }
      }
      RewardAccumulator: {
        payload: Prisma.$RewardAccumulatorPayload<ExtArgs>
        fields: Prisma.RewardAccumulatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardAccumulatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardAccumulatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorPayload>
          }
          findFirst: {
            args: Prisma.RewardAccumulatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardAccumulatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorPayload>
          }
          findMany: {
            args: Prisma.RewardAccumulatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorPayload>[]
          }
          create: {
            args: Prisma.RewardAccumulatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorPayload>
          }
          createMany: {
            args: Prisma.RewardAccumulatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardAccumulatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorPayload>[]
          }
          delete: {
            args: Prisma.RewardAccumulatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorPayload>
          }
          update: {
            args: Prisma.RewardAccumulatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorPayload>
          }
          deleteMany: {
            args: Prisma.RewardAccumulatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardAccumulatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RewardAccumulatorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorPayload>[]
          }
          upsert: {
            args: Prisma.RewardAccumulatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorPayload>
          }
          aggregate: {
            args: Prisma.RewardAccumulatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardAccumulator>
          }
          groupBy: {
            args: Prisma.RewardAccumulatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardAccumulatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardAccumulatorCountArgs<ExtArgs>
            result: $Utils.Optional<RewardAccumulatorCountAggregateOutputType> | number
          }
        }
      }
      FeaturedCycle: {
        payload: Prisma.$FeaturedCyclePayload<ExtArgs>
        fields: Prisma.FeaturedCycleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeaturedCycleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedCyclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeaturedCycleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedCyclePayload>
          }
          findFirst: {
            args: Prisma.FeaturedCycleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedCyclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeaturedCycleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedCyclePayload>
          }
          findMany: {
            args: Prisma.FeaturedCycleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedCyclePayload>[]
          }
          create: {
            args: Prisma.FeaturedCycleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedCyclePayload>
          }
          createMany: {
            args: Prisma.FeaturedCycleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeaturedCycleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedCyclePayload>[]
          }
          delete: {
            args: Prisma.FeaturedCycleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedCyclePayload>
          }
          update: {
            args: Prisma.FeaturedCycleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedCyclePayload>
          }
          deleteMany: {
            args: Prisma.FeaturedCycleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeaturedCycleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeaturedCycleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedCyclePayload>[]
          }
          upsert: {
            args: Prisma.FeaturedCycleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedCyclePayload>
          }
          aggregate: {
            args: Prisma.FeaturedCycleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeaturedCycle>
          }
          groupBy: {
            args: Prisma.FeaturedCycleGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeaturedCycleGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeaturedCycleCountArgs<ExtArgs>
            result: $Utils.Optional<FeaturedCycleCountAggregateOutputType> | number
          }
        }
      }
      FeaturedBid: {
        payload: Prisma.$FeaturedBidPayload<ExtArgs>
        fields: Prisma.FeaturedBidFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeaturedBidFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBidPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeaturedBidFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBidPayload>
          }
          findFirst: {
            args: Prisma.FeaturedBidFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBidPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeaturedBidFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBidPayload>
          }
          findMany: {
            args: Prisma.FeaturedBidFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBidPayload>[]
          }
          create: {
            args: Prisma.FeaturedBidCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBidPayload>
          }
          createMany: {
            args: Prisma.FeaturedBidCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeaturedBidCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBidPayload>[]
          }
          delete: {
            args: Prisma.FeaturedBidDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBidPayload>
          }
          update: {
            args: Prisma.FeaturedBidUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBidPayload>
          }
          deleteMany: {
            args: Prisma.FeaturedBidDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeaturedBidUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeaturedBidUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBidPayload>[]
          }
          upsert: {
            args: Prisma.FeaturedBidUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturedBidPayload>
          }
          aggregate: {
            args: Prisma.FeaturedBidAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeaturedBid>
          }
          groupBy: {
            args: Prisma.FeaturedBidGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeaturedBidGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeaturedBidCountArgs<ExtArgs>
            result: $Utils.Optional<FeaturedBidCountAggregateOutputType> | number
          }
        }
      }
      Currency: {
        payload: Prisma.$CurrencyPayload<ExtArgs>
        fields: Prisma.CurrencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CurrencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findFirst: {
            args: Prisma.CurrencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          findMany: {
            args: Prisma.CurrencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          create: {
            args: Prisma.CurrencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          createMany: {
            args: Prisma.CurrencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CurrencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          delete: {
            args: Prisma.CurrencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          update: {
            args: Prisma.CurrencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          deleteMany: {
            args: Prisma.CurrencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CurrencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CurrencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
          }
          upsert: {
            args: Prisma.CurrencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CurrencyPayload>
          }
          aggregate: {
            args: Prisma.CurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrency>
          }
          groupBy: {
            args: Prisma.CurrencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CurrencyCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyCountAggregateOutputType> | number
          }
        }
      }
      MarketplaceSale: {
        payload: Prisma.$MarketplaceSalePayload<ExtArgs>
        fields: Prisma.MarketplaceSaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketplaceSaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceSalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketplaceSaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceSalePayload>
          }
          findFirst: {
            args: Prisma.MarketplaceSaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceSalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketplaceSaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceSalePayload>
          }
          findMany: {
            args: Prisma.MarketplaceSaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceSalePayload>[]
          }
          create: {
            args: Prisma.MarketplaceSaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceSalePayload>
          }
          createMany: {
            args: Prisma.MarketplaceSaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketplaceSaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceSalePayload>[]
          }
          delete: {
            args: Prisma.MarketplaceSaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceSalePayload>
          }
          update: {
            args: Prisma.MarketplaceSaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceSalePayload>
          }
          deleteMany: {
            args: Prisma.MarketplaceSaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketplaceSaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketplaceSaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceSalePayload>[]
          }
          upsert: {
            args: Prisma.MarketplaceSaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceSalePayload>
          }
          aggregate: {
            args: Prisma.MarketplaceSaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketplaceSale>
          }
          groupBy: {
            args: Prisma.MarketplaceSaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceSaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketplaceSaleCountArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceSaleCountAggregateOutputType> | number
          }
        }
      }
      RewardAccumulatorMulti: {
        payload: Prisma.$RewardAccumulatorMultiPayload<ExtArgs>
        fields: Prisma.RewardAccumulatorMultiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardAccumulatorMultiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorMultiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardAccumulatorMultiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorMultiPayload>
          }
          findFirst: {
            args: Prisma.RewardAccumulatorMultiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorMultiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardAccumulatorMultiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorMultiPayload>
          }
          findMany: {
            args: Prisma.RewardAccumulatorMultiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorMultiPayload>[]
          }
          create: {
            args: Prisma.RewardAccumulatorMultiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorMultiPayload>
          }
          createMany: {
            args: Prisma.RewardAccumulatorMultiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardAccumulatorMultiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorMultiPayload>[]
          }
          delete: {
            args: Prisma.RewardAccumulatorMultiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorMultiPayload>
          }
          update: {
            args: Prisma.RewardAccumulatorMultiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorMultiPayload>
          }
          deleteMany: {
            args: Prisma.RewardAccumulatorMultiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardAccumulatorMultiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RewardAccumulatorMultiUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorMultiPayload>[]
          }
          upsert: {
            args: Prisma.RewardAccumulatorMultiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardAccumulatorMultiPayload>
          }
          aggregate: {
            args: Prisma.RewardAccumulatorMultiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardAccumulatorMulti>
          }
          groupBy: {
            args: Prisma.RewardAccumulatorMultiGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardAccumulatorMultiGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardAccumulatorMultiCountArgs<ExtArgs>
            result: $Utils.Optional<RewardAccumulatorMultiCountAggregateOutputType> | number
          }
        }
      }
      HolderRewardMulti: {
        payload: Prisma.$HolderRewardMultiPayload<ExtArgs>
        fields: Prisma.HolderRewardMultiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HolderRewardMultiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardMultiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HolderRewardMultiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardMultiPayload>
          }
          findFirst: {
            args: Prisma.HolderRewardMultiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardMultiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HolderRewardMultiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardMultiPayload>
          }
          findMany: {
            args: Prisma.HolderRewardMultiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardMultiPayload>[]
          }
          create: {
            args: Prisma.HolderRewardMultiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardMultiPayload>
          }
          createMany: {
            args: Prisma.HolderRewardMultiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HolderRewardMultiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardMultiPayload>[]
          }
          delete: {
            args: Prisma.HolderRewardMultiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardMultiPayload>
          }
          update: {
            args: Prisma.HolderRewardMultiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardMultiPayload>
          }
          deleteMany: {
            args: Prisma.HolderRewardMultiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HolderRewardMultiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HolderRewardMultiUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardMultiPayload>[]
          }
          upsert: {
            args: Prisma.HolderRewardMultiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolderRewardMultiPayload>
          }
          aggregate: {
            args: Prisma.HolderRewardMultiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHolderRewardMulti>
          }
          groupBy: {
            args: Prisma.HolderRewardMultiGroupByArgs<ExtArgs>
            result: $Utils.Optional<HolderRewardMultiGroupByOutputType>[]
          }
          count: {
            args: Prisma.HolderRewardMultiCountArgs<ExtArgs>
            result: $Utils.Optional<HolderRewardMultiCountAggregateOutputType> | number
          }
        }
      }
      RewardDistributionLog: {
        payload: Prisma.$RewardDistributionLogPayload<ExtArgs>
        fields: Prisma.RewardDistributionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardDistributionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDistributionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardDistributionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDistributionLogPayload>
          }
          findFirst: {
            args: Prisma.RewardDistributionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDistributionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardDistributionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDistributionLogPayload>
          }
          findMany: {
            args: Prisma.RewardDistributionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDistributionLogPayload>[]
          }
          create: {
            args: Prisma.RewardDistributionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDistributionLogPayload>
          }
          createMany: {
            args: Prisma.RewardDistributionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardDistributionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDistributionLogPayload>[]
          }
          delete: {
            args: Prisma.RewardDistributionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDistributionLogPayload>
          }
          update: {
            args: Prisma.RewardDistributionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDistributionLogPayload>
          }
          deleteMany: {
            args: Prisma.RewardDistributionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardDistributionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RewardDistributionLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDistributionLogPayload>[]
          }
          upsert: {
            args: Prisma.RewardDistributionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardDistributionLogPayload>
          }
          aggregate: {
            args: Prisma.RewardDistributionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardDistributionLog>
          }
          groupBy: {
            args: Prisma.RewardDistributionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardDistributionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardDistributionLogCountArgs<ExtArgs>
            result: $Utils.Optional<RewardDistributionLogCountAggregateOutputType> | number
          }
        }
      }
      RewardClaimLog: {
        payload: Prisma.$RewardClaimLogPayload<ExtArgs>
        fields: Prisma.RewardClaimLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RewardClaimLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RewardClaimLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimLogPayload>
          }
          findFirst: {
            args: Prisma.RewardClaimLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RewardClaimLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimLogPayload>
          }
          findMany: {
            args: Prisma.RewardClaimLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimLogPayload>[]
          }
          create: {
            args: Prisma.RewardClaimLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimLogPayload>
          }
          createMany: {
            args: Prisma.RewardClaimLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RewardClaimLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimLogPayload>[]
          }
          delete: {
            args: Prisma.RewardClaimLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimLogPayload>
          }
          update: {
            args: Prisma.RewardClaimLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimLogPayload>
          }
          deleteMany: {
            args: Prisma.RewardClaimLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RewardClaimLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RewardClaimLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimLogPayload>[]
          }
          upsert: {
            args: Prisma.RewardClaimLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RewardClaimLogPayload>
          }
          aggregate: {
            args: Prisma.RewardClaimLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRewardClaimLog>
          }
          groupBy: {
            args: Prisma.RewardClaimLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardClaimLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.RewardClaimLogCountArgs<ExtArgs>
            result: $Utils.Optional<RewardClaimLogCountAggregateOutputType> | number
          }
        }
      }
      StolenItem: {
        payload: Prisma.$StolenItemPayload<ExtArgs>
        fields: Prisma.StolenItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StolenItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StolenItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenItemPayload>
          }
          findFirst: {
            args: Prisma.StolenItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StolenItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenItemPayload>
          }
          findMany: {
            args: Prisma.StolenItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenItemPayload>[]
          }
          create: {
            args: Prisma.StolenItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenItemPayload>
          }
          createMany: {
            args: Prisma.StolenItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StolenItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenItemPayload>[]
          }
          delete: {
            args: Prisma.StolenItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenItemPayload>
          }
          update: {
            args: Prisma.StolenItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenItemPayload>
          }
          deleteMany: {
            args: Prisma.StolenItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StolenItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StolenItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenItemPayload>[]
          }
          upsert: {
            args: Prisma.StolenItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenItemPayload>
          }
          aggregate: {
            args: Prisma.StolenItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStolenItem>
          }
          groupBy: {
            args: Prisma.StolenItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<StolenItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.StolenItemCountArgs<ExtArgs>
            result: $Utils.Optional<StolenItemCountAggregateOutputType> | number
          }
        }
      }
      StolenEvent: {
        payload: Prisma.$StolenEventPayload<ExtArgs>
        fields: Prisma.StolenEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StolenEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StolenEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenEventPayload>
          }
          findFirst: {
            args: Prisma.StolenEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StolenEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenEventPayload>
          }
          findMany: {
            args: Prisma.StolenEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenEventPayload>[]
          }
          create: {
            args: Prisma.StolenEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenEventPayload>
          }
          createMany: {
            args: Prisma.StolenEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StolenEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenEventPayload>[]
          }
          delete: {
            args: Prisma.StolenEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenEventPayload>
          }
          update: {
            args: Prisma.StolenEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenEventPayload>
          }
          deleteMany: {
            args: Prisma.StolenEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StolenEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StolenEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenEventPayload>[]
          }
          upsert: {
            args: Prisma.StolenEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StolenEventPayload>
          }
          aggregate: {
            args: Prisma.StolenEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStolenEvent>
          }
          groupBy: {
            args: Prisma.StolenEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<StolenEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.StolenEventCountArgs<ExtArgs>
            result: $Utils.Optional<StolenEventCountAggregateOutputType> | number
          }
        }
      }
      MultisigSafe: {
        payload: Prisma.$MultisigSafePayload<ExtArgs>
        fields: Prisma.MultisigSafeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MultisigSafeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigSafePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MultisigSafeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigSafePayload>
          }
          findFirst: {
            args: Prisma.MultisigSafeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigSafePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MultisigSafeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigSafePayload>
          }
          findMany: {
            args: Prisma.MultisigSafeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigSafePayload>[]
          }
          create: {
            args: Prisma.MultisigSafeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigSafePayload>
          }
          createMany: {
            args: Prisma.MultisigSafeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MultisigSafeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigSafePayload>[]
          }
          delete: {
            args: Prisma.MultisigSafeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigSafePayload>
          }
          update: {
            args: Prisma.MultisigSafeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigSafePayload>
          }
          deleteMany: {
            args: Prisma.MultisigSafeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MultisigSafeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MultisigSafeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigSafePayload>[]
          }
          upsert: {
            args: Prisma.MultisigSafeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigSafePayload>
          }
          aggregate: {
            args: Prisma.MultisigSafeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMultisigSafe>
          }
          groupBy: {
            args: Prisma.MultisigSafeGroupByArgs<ExtArgs>
            result: $Utils.Optional<MultisigSafeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MultisigSafeCountArgs<ExtArgs>
            result: $Utils.Optional<MultisigSafeCountAggregateOutputType> | number
          }
        }
      }
      MultisigOwner: {
        payload: Prisma.$MultisigOwnerPayload<ExtArgs>
        fields: Prisma.MultisigOwnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MultisigOwnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigOwnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MultisigOwnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigOwnerPayload>
          }
          findFirst: {
            args: Prisma.MultisigOwnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigOwnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MultisigOwnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigOwnerPayload>
          }
          findMany: {
            args: Prisma.MultisigOwnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigOwnerPayload>[]
          }
          create: {
            args: Prisma.MultisigOwnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigOwnerPayload>
          }
          createMany: {
            args: Prisma.MultisigOwnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MultisigOwnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigOwnerPayload>[]
          }
          delete: {
            args: Prisma.MultisigOwnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigOwnerPayload>
          }
          update: {
            args: Prisma.MultisigOwnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigOwnerPayload>
          }
          deleteMany: {
            args: Prisma.MultisigOwnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MultisigOwnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MultisigOwnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigOwnerPayload>[]
          }
          upsert: {
            args: Prisma.MultisigOwnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigOwnerPayload>
          }
          aggregate: {
            args: Prisma.MultisigOwnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMultisigOwner>
          }
          groupBy: {
            args: Prisma.MultisigOwnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<MultisigOwnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.MultisigOwnerCountArgs<ExtArgs>
            result: $Utils.Optional<MultisigOwnerCountAggregateOutputType> | number
          }
        }
      }
      MultisigTx: {
        payload: Prisma.$MultisigTxPayload<ExtArgs>
        fields: Prisma.MultisigTxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MultisigTxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigTxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MultisigTxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigTxPayload>
          }
          findFirst: {
            args: Prisma.MultisigTxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigTxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MultisigTxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigTxPayload>
          }
          findMany: {
            args: Prisma.MultisigTxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigTxPayload>[]
          }
          create: {
            args: Prisma.MultisigTxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigTxPayload>
          }
          createMany: {
            args: Prisma.MultisigTxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MultisigTxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigTxPayload>[]
          }
          delete: {
            args: Prisma.MultisigTxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigTxPayload>
          }
          update: {
            args: Prisma.MultisigTxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigTxPayload>
          }
          deleteMany: {
            args: Prisma.MultisigTxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MultisigTxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MultisigTxUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigTxPayload>[]
          }
          upsert: {
            args: Prisma.MultisigTxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigTxPayload>
          }
          aggregate: {
            args: Prisma.MultisigTxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMultisigTx>
          }
          groupBy: {
            args: Prisma.MultisigTxGroupByArgs<ExtArgs>
            result: $Utils.Optional<MultisigTxGroupByOutputType>[]
          }
          count: {
            args: Prisma.MultisigTxCountArgs<ExtArgs>
            result: $Utils.Optional<MultisigTxCountAggregateOutputType> | number
          }
        }
      }
      MultisigApproval: {
        payload: Prisma.$MultisigApprovalPayload<ExtArgs>
        fields: Prisma.MultisigApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MultisigApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MultisigApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigApprovalPayload>
          }
          findFirst: {
            args: Prisma.MultisigApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MultisigApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigApprovalPayload>
          }
          findMany: {
            args: Prisma.MultisigApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigApprovalPayload>[]
          }
          create: {
            args: Prisma.MultisigApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigApprovalPayload>
          }
          createMany: {
            args: Prisma.MultisigApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MultisigApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigApprovalPayload>[]
          }
          delete: {
            args: Prisma.MultisigApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigApprovalPayload>
          }
          update: {
            args: Prisma.MultisigApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigApprovalPayload>
          }
          deleteMany: {
            args: Prisma.MultisigApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MultisigApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MultisigApprovalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigApprovalPayload>[]
          }
          upsert: {
            args: Prisma.MultisigApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MultisigApprovalPayload>
          }
          aggregate: {
            args: Prisma.MultisigApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMultisigApproval>
          }
          groupBy: {
            args: Prisma.MultisigApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<MultisigApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.MultisigApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<MultisigApprovalCountAggregateOutputType> | number
          }
        }
      }
      PendingChainAction: {
        payload: Prisma.$PendingChainActionPayload<ExtArgs>
        fields: Prisma.PendingChainActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingChainActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingChainActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingChainActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingChainActionPayload>
          }
          findFirst: {
            args: Prisma.PendingChainActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingChainActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingChainActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingChainActionPayload>
          }
          findMany: {
            args: Prisma.PendingChainActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingChainActionPayload>[]
          }
          create: {
            args: Prisma.PendingChainActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingChainActionPayload>
          }
          createMany: {
            args: Prisma.PendingChainActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendingChainActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingChainActionPayload>[]
          }
          delete: {
            args: Prisma.PendingChainActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingChainActionPayload>
          }
          update: {
            args: Prisma.PendingChainActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingChainActionPayload>
          }
          deleteMany: {
            args: Prisma.PendingChainActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendingChainActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PendingChainActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingChainActionPayload>[]
          }
          upsert: {
            args: Prisma.PendingChainActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingChainActionPayload>
          }
          aggregate: {
            args: Prisma.PendingChainActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendingChainAction>
          }
          groupBy: {
            args: Prisma.PendingChainActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendingChainActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingChainActionCountArgs<ExtArgs>
            result: $Utils.Optional<PendingChainActionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    chainState?: ChainStateOmit
    user?: UserOmit
    collection?: CollectionOmit
    nFT?: NFTOmit
    traitStat?: TraitStatOmit
    nFTActivity?: NFTActivityOmit
    single721?: Single721Omit
    single1155?: Single1155Omit
    erc1155Balance?: Erc1155BalanceOmit
    erc1155Holding?: Erc1155HoldingOmit
    marketplaceListing?: MarketplaceListingOmit
    auction?: AuctionOmit
    auctionBid?: AuctionBidOmit
    deployedContract?: DeployedContractOmit
    feeConfig?: FeeConfigOmit
    feeConfigLog?: FeeConfigLogOmit
    publicSale?: PublicSaleOmit
    presale?: PresaleOmit
    presaleWhitelistAddress?: PresaleWhitelistAddressOmit
    presaleDraft?: PresaleDraftOmit
    assetUpload?: AssetUploadOmit
    collectionSubmission?: CollectionSubmissionOmit
    nFTRarity?: NFTRarityOmit
    holderReward?: HolderRewardOmit
    rewardAccumulator?: RewardAccumulatorOmit
    featuredCycle?: FeaturedCycleOmit
    featuredBid?: FeaturedBidOmit
    currency?: CurrencyOmit
    marketplaceSale?: MarketplaceSaleOmit
    rewardAccumulatorMulti?: RewardAccumulatorMultiOmit
    holderRewardMulti?: HolderRewardMultiOmit
    rewardDistributionLog?: RewardDistributionLogOmit
    rewardClaimLog?: RewardClaimLogOmit
    stolenItem?: StolenItemOmit
    stolenEvent?: StolenEventOmit
    multisigSafe?: MultisigSafeOmit
    multisigOwner?: MultisigOwnerOmit
    multisigTx?: MultisigTxOmit
    multisigApproval?: MultisigApprovalOmit
    pendingChainAction?: PendingChainActionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    collections: number
    submissions: number
    featuredBids: number
    holderRewardsMulti: number
    ownedNFTs: number
    rewardClaimLogs: number
    stolenReports: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collections?: boolean | UserCountOutputTypeCountCollectionsArgs
    submissions?: boolean | UserCountOutputTypeCountSubmissionsArgs
    featuredBids?: boolean | UserCountOutputTypeCountFeaturedBidsArgs
    holderRewardsMulti?: boolean | UserCountOutputTypeCountHolderRewardsMultiArgs
    ownedNFTs?: boolean | UserCountOutputTypeCountOwnedNFTsArgs
    rewardClaimLogs?: boolean | UserCountOutputTypeCountRewardClaimLogsArgs
    stolenReports?: boolean | UserCountOutputTypeCountStolenReportsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionSubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeaturedBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedBidWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHolderRewardsMultiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HolderRewardMultiWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedNFTsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NFTWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRewardClaimLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardClaimLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStolenReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StolenItemWhereInput
  }


  /**
   * Count Type CollectionCountOutputType
   */

  export type CollectionCountOutputType = {
    assetUploads: number
    featuredBidEntries: number
    featuredAsWinner: number
    nfts: number
  }

  export type CollectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assetUploads?: boolean | CollectionCountOutputTypeCountAssetUploadsArgs
    featuredBidEntries?: boolean | CollectionCountOutputTypeCountFeaturedBidEntriesArgs
    featuredAsWinner?: boolean | CollectionCountOutputTypeCountFeaturedAsWinnerArgs
    nfts?: boolean | CollectionCountOutputTypeCountNftsArgs
  }

  // Custom InputTypes
  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCountOutputType
     */
    select?: CollectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountAssetUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetUploadWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountFeaturedBidEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedBidWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountFeaturedAsWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedCycleWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountNftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NFTWhereInput
  }


  /**
   * Count Type NFTCountOutputType
   */

  export type NFTCountOutputType = {
    auctionEntries: number
    listingEntries: number
    sales: number
    activities: number
  }

  export type NFTCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auctionEntries?: boolean | NFTCountOutputTypeCountAuctionEntriesArgs
    listingEntries?: boolean | NFTCountOutputTypeCountListingEntriesArgs
    sales?: boolean | NFTCountOutputTypeCountSalesArgs
    activities?: boolean | NFTCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * NFTCountOutputType without action
   */
  export type NFTCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTCountOutputType
     */
    select?: NFTCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NFTCountOutputType without action
   */
  export type NFTCountOutputTypeCountAuctionEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionWhereInput
  }

  /**
   * NFTCountOutputType without action
   */
  export type NFTCountOutputTypeCountListingEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceListingWhereInput
  }

  /**
   * NFTCountOutputType without action
   */
  export type NFTCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceSaleWhereInput
  }

  /**
   * NFTCountOutputType without action
   */
  export type NFTCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NFTActivityWhereInput
  }


  /**
   * Count Type Single721CountOutputType
   */

  export type Single721CountOutputType = {
    assetUploads: number
    nfts: number
  }

  export type Single721CountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assetUploads?: boolean | Single721CountOutputTypeCountAssetUploadsArgs
    nfts?: boolean | Single721CountOutputTypeCountNftsArgs
  }

  // Custom InputTypes
  /**
   * Single721CountOutputType without action
   */
  export type Single721CountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721CountOutputType
     */
    select?: Single721CountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Single721CountOutputType without action
   */
  export type Single721CountOutputTypeCountAssetUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetUploadWhereInput
  }

  /**
   * Single721CountOutputType without action
   */
  export type Single721CountOutputTypeCountNftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NFTWhereInput
  }


  /**
   * Count Type Single1155CountOutputType
   */

  export type Single1155CountOutputType = {
    assetUploads: number
    balances: number
    nfts: number
  }

  export type Single1155CountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assetUploads?: boolean | Single1155CountOutputTypeCountAssetUploadsArgs
    balances?: boolean | Single1155CountOutputTypeCountBalancesArgs
    nfts?: boolean | Single1155CountOutputTypeCountNftsArgs
  }

  // Custom InputTypes
  /**
   * Single1155CountOutputType without action
   */
  export type Single1155CountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155CountOutputType
     */
    select?: Single1155CountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Single1155CountOutputType without action
   */
  export type Single1155CountOutputTypeCountAssetUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetUploadWhereInput
  }

  /**
   * Single1155CountOutputType without action
   */
  export type Single1155CountOutputTypeCountBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Erc1155BalanceWhereInput
  }

  /**
   * Single1155CountOutputType without action
   */
  export type Single1155CountOutputTypeCountNftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NFTWhereInput
  }


  /**
   * Count Type AuctionCountOutputType
   */

  export type AuctionCountOutputType = {
    bids: number
  }

  export type AuctionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bids?: boolean | AuctionCountOutputTypeCountBidsArgs
  }

  // Custom InputTypes
  /**
   * AuctionCountOutputType without action
   */
  export type AuctionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionCountOutputType
     */
    select?: AuctionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuctionCountOutputType without action
   */
  export type AuctionCountOutputTypeCountBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionBidWhereInput
  }


  /**
   * Count Type FeeConfigCountOutputType
   */

  export type FeeConfigCountOutputType = {
    logs: number
  }

  export type FeeConfigCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | FeeConfigCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * FeeConfigCountOutputType without action
   */
  export type FeeConfigCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfigCountOutputType
     */
    select?: FeeConfigCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeeConfigCountOutputType without action
   */
  export type FeeConfigCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeConfigLogWhereInput
  }


  /**
   * Count Type PresaleCountOutputType
   */

  export type PresaleCountOutputType = {
    whitelist: number
  }

  export type PresaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whitelist?: boolean | PresaleCountOutputTypeCountWhitelistArgs
  }

  // Custom InputTypes
  /**
   * PresaleCountOutputType without action
   */
  export type PresaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleCountOutputType
     */
    select?: PresaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PresaleCountOutputType without action
   */
  export type PresaleCountOutputTypeCountWhitelistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresaleWhitelistAddressWhereInput
  }


  /**
   * Count Type FeaturedCycleCountOutputType
   */

  export type FeaturedCycleCountOutputType = {
    bids: number
  }

  export type FeaturedCycleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bids?: boolean | FeaturedCycleCountOutputTypeCountBidsArgs
  }

  // Custom InputTypes
  /**
   * FeaturedCycleCountOutputType without action
   */
  export type FeaturedCycleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycleCountOutputType
     */
    select?: FeaturedCycleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeaturedCycleCountOutputType without action
   */
  export type FeaturedCycleCountOutputTypeCountBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedBidWhereInput
  }


  /**
   * Count Type CurrencyCountOutputType
   */

  export type CurrencyCountOutputType = {
    auctions: number
    bids: number
    holderRewards: number
    listings: number
    sales: number
    claimLogs: number
    distributionLogs: number
  }

  export type CurrencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auctions?: boolean | CurrencyCountOutputTypeCountAuctionsArgs
    bids?: boolean | CurrencyCountOutputTypeCountBidsArgs
    holderRewards?: boolean | CurrencyCountOutputTypeCountHolderRewardsArgs
    listings?: boolean | CurrencyCountOutputTypeCountListingsArgs
    sales?: boolean | CurrencyCountOutputTypeCountSalesArgs
    claimLogs?: boolean | CurrencyCountOutputTypeCountClaimLogsArgs
    distributionLogs?: boolean | CurrencyCountOutputTypeCountDistributionLogsArgs
  }

  // Custom InputTypes
  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyCountOutputType
     */
    select?: CurrencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountAuctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionBidWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountHolderRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HolderRewardMultiWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceListingWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceSaleWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountClaimLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardClaimLogWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountDistributionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardDistributionLogWhereInput
  }


  /**
   * Count Type MultisigSafeCountOutputType
   */

  export type MultisigSafeCountOutputType = {
    owners: number
    txs: number
  }

  export type MultisigSafeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owners?: boolean | MultisigSafeCountOutputTypeCountOwnersArgs
    txs?: boolean | MultisigSafeCountOutputTypeCountTxsArgs
  }

  // Custom InputTypes
  /**
   * MultisigSafeCountOutputType without action
   */
  export type MultisigSafeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigSafeCountOutputType
     */
    select?: MultisigSafeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MultisigSafeCountOutputType without action
   */
  export type MultisigSafeCountOutputTypeCountOwnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultisigOwnerWhereInput
  }

  /**
   * MultisigSafeCountOutputType without action
   */
  export type MultisigSafeCountOutputTypeCountTxsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultisigTxWhereInput
  }


  /**
   * Count Type MultisigTxCountOutputType
   */

  export type MultisigTxCountOutputType = {
    approvals: number
  }

  export type MultisigTxCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvals?: boolean | MultisigTxCountOutputTypeCountApprovalsArgs
  }

  // Custom InputTypes
  /**
   * MultisigTxCountOutputType without action
   */
  export type MultisigTxCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigTxCountOutputType
     */
    select?: MultisigTxCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MultisigTxCountOutputType without action
   */
  export type MultisigTxCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultisigApprovalWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ChainState
   */

  export type AggregateChainState = {
    _count: ChainStateCountAggregateOutputType | null
    _avg: ChainStateAvgAggregateOutputType | null
    _sum: ChainStateSumAggregateOutputType | null
    _min: ChainStateMinAggregateOutputType | null
    _max: ChainStateMaxAggregateOutputType | null
  }

  export type ChainStateAvgAggregateOutputType = {
    lastBlockNumber: number | null
  }

  export type ChainStateSumAggregateOutputType = {
    lastBlockNumber: number | null
  }

  export type ChainStateMinAggregateOutputType = {
    id: string | null
    userAddress: string | null
    contract: string | null
    lastBlockNumber: number | null
  }

  export type ChainStateMaxAggregateOutputType = {
    id: string | null
    userAddress: string | null
    contract: string | null
    lastBlockNumber: number | null
  }

  export type ChainStateCountAggregateOutputType = {
    id: number
    userAddress: number
    contract: number
    lastBlockNumber: number
    _all: number
  }


  export type ChainStateAvgAggregateInputType = {
    lastBlockNumber?: true
  }

  export type ChainStateSumAggregateInputType = {
    lastBlockNumber?: true
  }

  export type ChainStateMinAggregateInputType = {
    id?: true
    userAddress?: true
    contract?: true
    lastBlockNumber?: true
  }

  export type ChainStateMaxAggregateInputType = {
    id?: true
    userAddress?: true
    contract?: true
    lastBlockNumber?: true
  }

  export type ChainStateCountAggregateInputType = {
    id?: true
    userAddress?: true
    contract?: true
    lastBlockNumber?: true
    _all?: true
  }

  export type ChainStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChainState to aggregate.
     */
    where?: ChainStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChainStates to fetch.
     */
    orderBy?: ChainStateOrderByWithRelationInput | ChainStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChainStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChainStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChainStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChainStates
    **/
    _count?: true | ChainStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChainStateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChainStateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChainStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChainStateMaxAggregateInputType
  }

  export type GetChainStateAggregateType<T extends ChainStateAggregateArgs> = {
        [P in keyof T & keyof AggregateChainState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChainState[P]>
      : GetScalarType<T[P], AggregateChainState[P]>
  }




  export type ChainStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChainStateWhereInput
    orderBy?: ChainStateOrderByWithAggregationInput | ChainStateOrderByWithAggregationInput[]
    by: ChainStateScalarFieldEnum[] | ChainStateScalarFieldEnum
    having?: ChainStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChainStateCountAggregateInputType | true
    _avg?: ChainStateAvgAggregateInputType
    _sum?: ChainStateSumAggregateInputType
    _min?: ChainStateMinAggregateInputType
    _max?: ChainStateMaxAggregateInputType
  }

  export type ChainStateGroupByOutputType = {
    id: string
    userAddress: string
    contract: string
    lastBlockNumber: number
    _count: ChainStateCountAggregateOutputType | null
    _avg: ChainStateAvgAggregateOutputType | null
    _sum: ChainStateSumAggregateOutputType | null
    _min: ChainStateMinAggregateOutputType | null
    _max: ChainStateMaxAggregateOutputType | null
  }

  type GetChainStateGroupByPayload<T extends ChainStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChainStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChainStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChainStateGroupByOutputType[P]>
            : GetScalarType<T[P], ChainStateGroupByOutputType[P]>
        }
      >
    >


  export type ChainStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userAddress?: boolean
    contract?: boolean
    lastBlockNumber?: boolean
  }, ExtArgs["result"]["chainState"]>

  export type ChainStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userAddress?: boolean
    contract?: boolean
    lastBlockNumber?: boolean
  }, ExtArgs["result"]["chainState"]>

  export type ChainStateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userAddress?: boolean
    contract?: boolean
    lastBlockNumber?: boolean
  }, ExtArgs["result"]["chainState"]>

  export type ChainStateSelectScalar = {
    id?: boolean
    userAddress?: boolean
    contract?: boolean
    lastBlockNumber?: boolean
  }

  export type ChainStateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userAddress" | "contract" | "lastBlockNumber", ExtArgs["result"]["chainState"]>

  export type $ChainStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChainState"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userAddress: string
      contract: string
      lastBlockNumber: number
    }, ExtArgs["result"]["chainState"]>
    composites: {}
  }

  type ChainStateGetPayload<S extends boolean | null | undefined | ChainStateDefaultArgs> = $Result.GetResult<Prisma.$ChainStatePayload, S>

  type ChainStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChainStateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChainStateCountAggregateInputType | true
    }

  export interface ChainStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChainState'], meta: { name: 'ChainState' } }
    /**
     * Find zero or one ChainState that matches the filter.
     * @param {ChainStateFindUniqueArgs} args - Arguments to find a ChainState
     * @example
     * // Get one ChainState
     * const chainState = await prisma.chainState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChainStateFindUniqueArgs>(args: SelectSubset<T, ChainStateFindUniqueArgs<ExtArgs>>): Prisma__ChainStateClient<$Result.GetResult<Prisma.$ChainStatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChainState that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChainStateFindUniqueOrThrowArgs} args - Arguments to find a ChainState
     * @example
     * // Get one ChainState
     * const chainState = await prisma.chainState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChainStateFindUniqueOrThrowArgs>(args: SelectSubset<T, ChainStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChainStateClient<$Result.GetResult<Prisma.$ChainStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChainState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainStateFindFirstArgs} args - Arguments to find a ChainState
     * @example
     * // Get one ChainState
     * const chainState = await prisma.chainState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChainStateFindFirstArgs>(args?: SelectSubset<T, ChainStateFindFirstArgs<ExtArgs>>): Prisma__ChainStateClient<$Result.GetResult<Prisma.$ChainStatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChainState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainStateFindFirstOrThrowArgs} args - Arguments to find a ChainState
     * @example
     * // Get one ChainState
     * const chainState = await prisma.chainState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChainStateFindFirstOrThrowArgs>(args?: SelectSubset<T, ChainStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChainStateClient<$Result.GetResult<Prisma.$ChainStatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChainStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChainStates
     * const chainStates = await prisma.chainState.findMany()
     * 
     * // Get first 10 ChainStates
     * const chainStates = await prisma.chainState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chainStateWithIdOnly = await prisma.chainState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChainStateFindManyArgs>(args?: SelectSubset<T, ChainStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChainStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChainState.
     * @param {ChainStateCreateArgs} args - Arguments to create a ChainState.
     * @example
     * // Create one ChainState
     * const ChainState = await prisma.chainState.create({
     *   data: {
     *     // ... data to create a ChainState
     *   }
     * })
     * 
     */
    create<T extends ChainStateCreateArgs>(args: SelectSubset<T, ChainStateCreateArgs<ExtArgs>>): Prisma__ChainStateClient<$Result.GetResult<Prisma.$ChainStatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChainStates.
     * @param {ChainStateCreateManyArgs} args - Arguments to create many ChainStates.
     * @example
     * // Create many ChainStates
     * const chainState = await prisma.chainState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChainStateCreateManyArgs>(args?: SelectSubset<T, ChainStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChainStates and returns the data saved in the database.
     * @param {ChainStateCreateManyAndReturnArgs} args - Arguments to create many ChainStates.
     * @example
     * // Create many ChainStates
     * const chainState = await prisma.chainState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChainStates and only return the `id`
     * const chainStateWithIdOnly = await prisma.chainState.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChainStateCreateManyAndReturnArgs>(args?: SelectSubset<T, ChainStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChainStatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChainState.
     * @param {ChainStateDeleteArgs} args - Arguments to delete one ChainState.
     * @example
     * // Delete one ChainState
     * const ChainState = await prisma.chainState.delete({
     *   where: {
     *     // ... filter to delete one ChainState
     *   }
     * })
     * 
     */
    delete<T extends ChainStateDeleteArgs>(args: SelectSubset<T, ChainStateDeleteArgs<ExtArgs>>): Prisma__ChainStateClient<$Result.GetResult<Prisma.$ChainStatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChainState.
     * @param {ChainStateUpdateArgs} args - Arguments to update one ChainState.
     * @example
     * // Update one ChainState
     * const chainState = await prisma.chainState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChainStateUpdateArgs>(args: SelectSubset<T, ChainStateUpdateArgs<ExtArgs>>): Prisma__ChainStateClient<$Result.GetResult<Prisma.$ChainStatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChainStates.
     * @param {ChainStateDeleteManyArgs} args - Arguments to filter ChainStates to delete.
     * @example
     * // Delete a few ChainStates
     * const { count } = await prisma.chainState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChainStateDeleteManyArgs>(args?: SelectSubset<T, ChainStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChainStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChainStates
     * const chainState = await prisma.chainState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChainStateUpdateManyArgs>(args: SelectSubset<T, ChainStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChainStates and returns the data updated in the database.
     * @param {ChainStateUpdateManyAndReturnArgs} args - Arguments to update many ChainStates.
     * @example
     * // Update many ChainStates
     * const chainState = await prisma.chainState.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChainStates and only return the `id`
     * const chainStateWithIdOnly = await prisma.chainState.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChainStateUpdateManyAndReturnArgs>(args: SelectSubset<T, ChainStateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChainStatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChainState.
     * @param {ChainStateUpsertArgs} args - Arguments to update or create a ChainState.
     * @example
     * // Update or create a ChainState
     * const chainState = await prisma.chainState.upsert({
     *   create: {
     *     // ... data to create a ChainState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChainState we want to update
     *   }
     * })
     */
    upsert<T extends ChainStateUpsertArgs>(args: SelectSubset<T, ChainStateUpsertArgs<ExtArgs>>): Prisma__ChainStateClient<$Result.GetResult<Prisma.$ChainStatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChainStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainStateCountArgs} args - Arguments to filter ChainStates to count.
     * @example
     * // Count the number of ChainStates
     * const count = await prisma.chainState.count({
     *   where: {
     *     // ... the filter for the ChainStates we want to count
     *   }
     * })
    **/
    count<T extends ChainStateCountArgs>(
      args?: Subset<T, ChainStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChainStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChainState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChainStateAggregateArgs>(args: Subset<T, ChainStateAggregateArgs>): Prisma.PrismaPromise<GetChainStateAggregateType<T>>

    /**
     * Group by ChainState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChainStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChainStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChainStateGroupByArgs['orderBy'] }
        : { orderBy?: ChainStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChainStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChainStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChainState model
   */
  readonly fields: ChainStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChainState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChainStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChainState model
   */
  interface ChainStateFieldRefs {
    readonly id: FieldRef<"ChainState", 'String'>
    readonly userAddress: FieldRef<"ChainState", 'String'>
    readonly contract: FieldRef<"ChainState", 'String'>
    readonly lastBlockNumber: FieldRef<"ChainState", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ChainState findUnique
   */
  export type ChainStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainState
     */
    select?: ChainStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChainState
     */
    omit?: ChainStateOmit<ExtArgs> | null
    /**
     * Filter, which ChainState to fetch.
     */
    where: ChainStateWhereUniqueInput
  }

  /**
   * ChainState findUniqueOrThrow
   */
  export type ChainStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainState
     */
    select?: ChainStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChainState
     */
    omit?: ChainStateOmit<ExtArgs> | null
    /**
     * Filter, which ChainState to fetch.
     */
    where: ChainStateWhereUniqueInput
  }

  /**
   * ChainState findFirst
   */
  export type ChainStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainState
     */
    select?: ChainStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChainState
     */
    omit?: ChainStateOmit<ExtArgs> | null
    /**
     * Filter, which ChainState to fetch.
     */
    where?: ChainStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChainStates to fetch.
     */
    orderBy?: ChainStateOrderByWithRelationInput | ChainStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChainStates.
     */
    cursor?: ChainStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChainStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChainStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChainStates.
     */
    distinct?: ChainStateScalarFieldEnum | ChainStateScalarFieldEnum[]
  }

  /**
   * ChainState findFirstOrThrow
   */
  export type ChainStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainState
     */
    select?: ChainStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChainState
     */
    omit?: ChainStateOmit<ExtArgs> | null
    /**
     * Filter, which ChainState to fetch.
     */
    where?: ChainStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChainStates to fetch.
     */
    orderBy?: ChainStateOrderByWithRelationInput | ChainStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChainStates.
     */
    cursor?: ChainStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChainStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChainStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChainStates.
     */
    distinct?: ChainStateScalarFieldEnum | ChainStateScalarFieldEnum[]
  }

  /**
   * ChainState findMany
   */
  export type ChainStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainState
     */
    select?: ChainStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChainState
     */
    omit?: ChainStateOmit<ExtArgs> | null
    /**
     * Filter, which ChainStates to fetch.
     */
    where?: ChainStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChainStates to fetch.
     */
    orderBy?: ChainStateOrderByWithRelationInput | ChainStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChainStates.
     */
    cursor?: ChainStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChainStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChainStates.
     */
    skip?: number
    distinct?: ChainStateScalarFieldEnum | ChainStateScalarFieldEnum[]
  }

  /**
   * ChainState create
   */
  export type ChainStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainState
     */
    select?: ChainStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChainState
     */
    omit?: ChainStateOmit<ExtArgs> | null
    /**
     * The data needed to create a ChainState.
     */
    data: XOR<ChainStateCreateInput, ChainStateUncheckedCreateInput>
  }

  /**
   * ChainState createMany
   */
  export type ChainStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChainStates.
     */
    data: ChainStateCreateManyInput | ChainStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChainState createManyAndReturn
   */
  export type ChainStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainState
     */
    select?: ChainStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChainState
     */
    omit?: ChainStateOmit<ExtArgs> | null
    /**
     * The data used to create many ChainStates.
     */
    data: ChainStateCreateManyInput | ChainStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChainState update
   */
  export type ChainStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainState
     */
    select?: ChainStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChainState
     */
    omit?: ChainStateOmit<ExtArgs> | null
    /**
     * The data needed to update a ChainState.
     */
    data: XOR<ChainStateUpdateInput, ChainStateUncheckedUpdateInput>
    /**
     * Choose, which ChainState to update.
     */
    where: ChainStateWhereUniqueInput
  }

  /**
   * ChainState updateMany
   */
  export type ChainStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChainStates.
     */
    data: XOR<ChainStateUpdateManyMutationInput, ChainStateUncheckedUpdateManyInput>
    /**
     * Filter which ChainStates to update
     */
    where?: ChainStateWhereInput
    /**
     * Limit how many ChainStates to update.
     */
    limit?: number
  }

  /**
   * ChainState updateManyAndReturn
   */
  export type ChainStateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainState
     */
    select?: ChainStateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChainState
     */
    omit?: ChainStateOmit<ExtArgs> | null
    /**
     * The data used to update ChainStates.
     */
    data: XOR<ChainStateUpdateManyMutationInput, ChainStateUncheckedUpdateManyInput>
    /**
     * Filter which ChainStates to update
     */
    where?: ChainStateWhereInput
    /**
     * Limit how many ChainStates to update.
     */
    limit?: number
  }

  /**
   * ChainState upsert
   */
  export type ChainStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainState
     */
    select?: ChainStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChainState
     */
    omit?: ChainStateOmit<ExtArgs> | null
    /**
     * The filter to search for the ChainState to update in case it exists.
     */
    where: ChainStateWhereUniqueInput
    /**
     * In case the ChainState found by the `where` argument doesn't exist, create a new ChainState with this data.
     */
    create: XOR<ChainStateCreateInput, ChainStateUncheckedCreateInput>
    /**
     * In case the ChainState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChainStateUpdateInput, ChainStateUncheckedUpdateInput>
  }

  /**
   * ChainState delete
   */
  export type ChainStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainState
     */
    select?: ChainStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChainState
     */
    omit?: ChainStateOmit<ExtArgs> | null
    /**
     * Filter which ChainState to delete.
     */
    where: ChainStateWhereUniqueInput
  }

  /**
   * ChainState deleteMany
   */
  export type ChainStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChainStates to delete
     */
    where?: ChainStateWhereInput
    /**
     * Limit how many ChainStates to delete.
     */
    limit?: number
  }

  /**
   * ChainState without action
   */
  export type ChainStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChainState
     */
    select?: ChainStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChainState
     */
    omit?: ChainStateOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    walletAddress: string | null
    username: string | null
    bio: string | null
    profileBanner: string | null
    profileAvatar: string | null
    x: string | null
    instagram: string | null
    website: string | null
    telegram: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    walletAddress: string | null
    username: string | null
    bio: string | null
    profileBanner: string | null
    profileAvatar: string | null
    x: string | null
    instagram: string | null
    website: string | null
    telegram: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    walletAddress: number
    username: number
    bio: number
    profileBanner: number
    profileAvatar: number
    x: number
    instagram: number
    website: number
    telegram: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    walletAddress?: true
    username?: true
    bio?: true
    profileBanner?: true
    profileAvatar?: true
    x?: true
    instagram?: true
    website?: true
    telegram?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    walletAddress?: true
    username?: true
    bio?: true
    profileBanner?: true
    profileAvatar?: true
    x?: true
    instagram?: true
    website?: true
    telegram?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    walletAddress?: true
    username?: true
    bio?: true
    profileBanner?: true
    profileAvatar?: true
    x?: true
    instagram?: true
    website?: true
    telegram?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    walletAddress: string
    username: string
    bio: string | null
    profileBanner: string | null
    profileAvatar: string
    x: string | null
    instagram: string | null
    website: string | null
    telegram: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletAddress?: boolean
    username?: boolean
    bio?: boolean
    profileBanner?: boolean
    profileAvatar?: boolean
    x?: boolean
    instagram?: boolean
    website?: boolean
    telegram?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collections?: boolean | User$collectionsArgs<ExtArgs>
    submissions?: boolean | User$submissionsArgs<ExtArgs>
    featuredBids?: boolean | User$featuredBidsArgs<ExtArgs>
    holderRewardsMulti?: boolean | User$holderRewardsMultiArgs<ExtArgs>
    ownedNFTs?: boolean | User$ownedNFTsArgs<ExtArgs>
    rewardClaimLogs?: boolean | User$rewardClaimLogsArgs<ExtArgs>
    stolenReports?: boolean | User$stolenReportsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletAddress?: boolean
    username?: boolean
    bio?: boolean
    profileBanner?: boolean
    profileAvatar?: boolean
    x?: boolean
    instagram?: boolean
    website?: boolean
    telegram?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletAddress?: boolean
    username?: boolean
    bio?: boolean
    profileBanner?: boolean
    profileAvatar?: boolean
    x?: boolean
    instagram?: boolean
    website?: boolean
    telegram?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    walletAddress?: boolean
    username?: boolean
    bio?: boolean
    profileBanner?: boolean
    profileAvatar?: boolean
    x?: boolean
    instagram?: boolean
    website?: boolean
    telegram?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletAddress" | "username" | "bio" | "profileBanner" | "profileAvatar" | "x" | "instagram" | "website" | "telegram" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collections?: boolean | User$collectionsArgs<ExtArgs>
    submissions?: boolean | User$submissionsArgs<ExtArgs>
    featuredBids?: boolean | User$featuredBidsArgs<ExtArgs>
    holderRewardsMulti?: boolean | User$holderRewardsMultiArgs<ExtArgs>
    ownedNFTs?: boolean | User$ownedNFTsArgs<ExtArgs>
    rewardClaimLogs?: boolean | User$rewardClaimLogsArgs<ExtArgs>
    stolenReports?: boolean | User$stolenReportsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      collections: Prisma.$CollectionPayload<ExtArgs>[]
      submissions: Prisma.$CollectionSubmissionPayload<ExtArgs>[]
      featuredBids: Prisma.$FeaturedBidPayload<ExtArgs>[]
      holderRewardsMulti: Prisma.$HolderRewardMultiPayload<ExtArgs>[]
      ownedNFTs: Prisma.$NFTPayload<ExtArgs>[]
      rewardClaimLogs: Prisma.$RewardClaimLogPayload<ExtArgs>[]
      stolenReports: Prisma.$StolenItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletAddress: string
      username: string
      bio: string | null
      profileBanner: string | null
      profileAvatar: string
      x: string | null
      instagram: string | null
      website: string | null
      telegram: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collections<T extends User$collectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$collectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    submissions<T extends User$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    featuredBids<T extends User$featuredBidsArgs<ExtArgs> = {}>(args?: Subset<T, User$featuredBidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    holderRewardsMulti<T extends User$holderRewardsMultiArgs<ExtArgs> = {}>(args?: Subset<T, User$holderRewardsMultiArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolderRewardMultiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedNFTs<T extends User$ownedNFTsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedNFTsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rewardClaimLogs<T extends User$rewardClaimLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$rewardClaimLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardClaimLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stolenReports<T extends User$stolenReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$stolenReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StolenItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly walletAddress: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly profileBanner: FieldRef<"User", 'String'>
    readonly profileAvatar: FieldRef<"User", 'String'>
    readonly x: FieldRef<"User", 'String'>
    readonly instagram: FieldRef<"User", 'String'>
    readonly website: FieldRef<"User", 'String'>
    readonly telegram: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.collections
   */
  export type User$collectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    where?: CollectionWhereInput
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    cursor?: CollectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * User.submissions
   */
  export type User$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionSubmission
     */
    select?: CollectionSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionSubmission
     */
    omit?: CollectionSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionSubmissionInclude<ExtArgs> | null
    where?: CollectionSubmissionWhereInput
    orderBy?: CollectionSubmissionOrderByWithRelationInput | CollectionSubmissionOrderByWithRelationInput[]
    cursor?: CollectionSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionSubmissionScalarFieldEnum | CollectionSubmissionScalarFieldEnum[]
  }

  /**
   * User.featuredBids
   */
  export type User$featuredBidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidInclude<ExtArgs> | null
    where?: FeaturedBidWhereInput
    orderBy?: FeaturedBidOrderByWithRelationInput | FeaturedBidOrderByWithRelationInput[]
    cursor?: FeaturedBidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeaturedBidScalarFieldEnum | FeaturedBidScalarFieldEnum[]
  }

  /**
   * User.holderRewardsMulti
   */
  export type User$holderRewardsMultiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderRewardMulti
     */
    select?: HolderRewardMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderRewardMulti
     */
    omit?: HolderRewardMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolderRewardMultiInclude<ExtArgs> | null
    where?: HolderRewardMultiWhereInput
    orderBy?: HolderRewardMultiOrderByWithRelationInput | HolderRewardMultiOrderByWithRelationInput[]
    cursor?: HolderRewardMultiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HolderRewardMultiScalarFieldEnum | HolderRewardMultiScalarFieldEnum[]
  }

  /**
   * User.ownedNFTs
   */
  export type User$ownedNFTsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    where?: NFTWhereInput
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    cursor?: NFTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NFTScalarFieldEnum | NFTScalarFieldEnum[]
  }

  /**
   * User.rewardClaimLogs
   */
  export type User$rewardClaimLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaimLog
     */
    select?: RewardClaimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaimLog
     */
    omit?: RewardClaimLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimLogInclude<ExtArgs> | null
    where?: RewardClaimLogWhereInput
    orderBy?: RewardClaimLogOrderByWithRelationInput | RewardClaimLogOrderByWithRelationInput[]
    cursor?: RewardClaimLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardClaimLogScalarFieldEnum | RewardClaimLogScalarFieldEnum[]
  }

  /**
   * User.stolenReports
   */
  export type User$stolenReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenItem
     */
    select?: StolenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenItem
     */
    omit?: StolenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StolenItemInclude<ExtArgs> | null
    where?: StolenItemWhereInput
    orderBy?: StolenItemOrderByWithRelationInput | StolenItemOrderByWithRelationInput[]
    cursor?: StolenItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StolenItemScalarFieldEnum | StolenItemScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Collection
   */

  export type AggregateCollection = {
    _count: CollectionCountAggregateOutputType | null
    _avg: CollectionAvgAggregateOutputType | null
    _sum: CollectionSumAggregateOutputType | null
    _min: CollectionMinAggregateOutputType | null
    _max: CollectionMaxAggregateOutputType | null
  }

  export type CollectionAvgAggregateOutputType = {
    supply: number | null
    floorPrice: number | null
    volume: number | null
    itemsCount: number | null
    ownersCount: number | null
    change24h: number | null
  }

  export type CollectionSumAggregateOutputType = {
    supply: number | null
    floorPrice: number | null
    volume: number | null
    itemsCount: number | null
    ownersCount: number | null
    change24h: number | null
  }

  export type CollectionMinAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    contract: string | null
    description: string | null
    logoUrl: string | null
    coverUrl: string | null
    standard: string | null
    supply: number | null
    baseUri: string | null
    gatewayPref: $Enums.GatewayPref | null
    indexStatus: $Enums.IndexStatus | null
    x: string | null
    instagram: string | null
    website: string | null
    discord: string | null
    telegram: string | null
    floorPrice: number | null
    volume: number | null
    itemsCount: number | null
    ownersCount: number | null
    change24h: number | null
    creatorId: string | null
    ownerAddress: string | null
    isOrphan: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    contract: string | null
    description: string | null
    logoUrl: string | null
    coverUrl: string | null
    standard: string | null
    supply: number | null
    baseUri: string | null
    gatewayPref: $Enums.GatewayPref | null
    indexStatus: $Enums.IndexStatus | null
    x: string | null
    instagram: string | null
    website: string | null
    discord: string | null
    telegram: string | null
    floorPrice: number | null
    volume: number | null
    itemsCount: number | null
    ownersCount: number | null
    change24h: number | null
    creatorId: string | null
    ownerAddress: string | null
    isOrphan: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionCountAggregateOutputType = {
    id: number
    name: number
    symbol: number
    contract: number
    description: number
    logoUrl: number
    coverUrl: number
    standard: number
    supply: number
    baseUri: number
    gatewayPref: number
    indexStatus: number
    x: number
    instagram: number
    website: number
    discord: number
    telegram: number
    floorPrice: number
    volume: number
    itemsCount: number
    ownersCount: number
    change24h: number
    creatorId: number
    ownerAddress: number
    isOrphan: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CollectionAvgAggregateInputType = {
    supply?: true
    floorPrice?: true
    volume?: true
    itemsCount?: true
    ownersCount?: true
    change24h?: true
  }

  export type CollectionSumAggregateInputType = {
    supply?: true
    floorPrice?: true
    volume?: true
    itemsCount?: true
    ownersCount?: true
    change24h?: true
  }

  export type CollectionMinAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    contract?: true
    description?: true
    logoUrl?: true
    coverUrl?: true
    standard?: true
    supply?: true
    baseUri?: true
    gatewayPref?: true
    indexStatus?: true
    x?: true
    instagram?: true
    website?: true
    discord?: true
    telegram?: true
    floorPrice?: true
    volume?: true
    itemsCount?: true
    ownersCount?: true
    change24h?: true
    creatorId?: true
    ownerAddress?: true
    isOrphan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionMaxAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    contract?: true
    description?: true
    logoUrl?: true
    coverUrl?: true
    standard?: true
    supply?: true
    baseUri?: true
    gatewayPref?: true
    indexStatus?: true
    x?: true
    instagram?: true
    website?: true
    discord?: true
    telegram?: true
    floorPrice?: true
    volume?: true
    itemsCount?: true
    ownersCount?: true
    change24h?: true
    creatorId?: true
    ownerAddress?: true
    isOrphan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionCountAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    contract?: true
    description?: true
    logoUrl?: true
    coverUrl?: true
    standard?: true
    supply?: true
    baseUri?: true
    gatewayPref?: true
    indexStatus?: true
    x?: true
    instagram?: true
    website?: true
    discord?: true
    telegram?: true
    floorPrice?: true
    volume?: true
    itemsCount?: true
    ownersCount?: true
    change24h?: true
    creatorId?: true
    ownerAddress?: true
    isOrphan?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CollectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collection to aggregate.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Collections
    **/
    _count?: true | CollectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionMaxAggregateInputType
  }

  export type GetCollectionAggregateType<T extends CollectionAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection[P]>
      : GetScalarType<T[P], AggregateCollection[P]>
  }




  export type CollectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionWhereInput
    orderBy?: CollectionOrderByWithAggregationInput | CollectionOrderByWithAggregationInput[]
    by: CollectionScalarFieldEnum[] | CollectionScalarFieldEnum
    having?: CollectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCountAggregateInputType | true
    _avg?: CollectionAvgAggregateInputType
    _sum?: CollectionSumAggregateInputType
    _min?: CollectionMinAggregateInputType
    _max?: CollectionMaxAggregateInputType
  }

  export type CollectionGroupByOutputType = {
    id: string
    name: string
    symbol: string
    contract: string
    description: string | null
    logoUrl: string | null
    coverUrl: string | null
    standard: string
    supply: number | null
    baseUri: string | null
    gatewayPref: $Enums.GatewayPref
    indexStatus: $Enums.IndexStatus
    x: string | null
    instagram: string | null
    website: string | null
    discord: string | null
    telegram: string | null
    floorPrice: number
    volume: number
    itemsCount: number
    ownersCount: number
    change24h: number
    creatorId: string
    ownerAddress: string
    isOrphan: boolean
    createdAt: Date
    updatedAt: Date
    _count: CollectionCountAggregateOutputType | null
    _avg: CollectionAvgAggregateOutputType | null
    _sum: CollectionSumAggregateOutputType | null
    _min: CollectionMinAggregateOutputType | null
    _max: CollectionMaxAggregateOutputType | null
  }

  type GetCollectionGroupByPayload<T extends CollectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionGroupByOutputType[P]>
        }
      >
    >


  export type CollectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    contract?: boolean
    description?: boolean
    logoUrl?: boolean
    coverUrl?: boolean
    standard?: boolean
    supply?: boolean
    baseUri?: boolean
    gatewayPref?: boolean
    indexStatus?: boolean
    x?: boolean
    instagram?: boolean
    website?: boolean
    discord?: boolean
    telegram?: boolean
    floorPrice?: boolean
    volume?: boolean
    itemsCount?: boolean
    ownersCount?: boolean
    change24h?: boolean
    creatorId?: boolean
    ownerAddress?: boolean
    isOrphan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assetUploads?: boolean | Collection$assetUploadsArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    deployment?: boolean | Collection$deploymentArgs<ExtArgs>
    featuredBidEntries?: boolean | Collection$featuredBidEntriesArgs<ExtArgs>
    featuredAsWinner?: boolean | Collection$featuredAsWinnerArgs<ExtArgs>
    nfts?: boolean | Collection$nftsArgs<ExtArgs>
    presale?: boolean | Collection$presaleArgs<ExtArgs>
    publicSale?: boolean | Collection$publicSaleArgs<ExtArgs>
    _count?: boolean | CollectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type CollectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    contract?: boolean
    description?: boolean
    logoUrl?: boolean
    coverUrl?: boolean
    standard?: boolean
    supply?: boolean
    baseUri?: boolean
    gatewayPref?: boolean
    indexStatus?: boolean
    x?: boolean
    instagram?: boolean
    website?: boolean
    discord?: boolean
    telegram?: boolean
    floorPrice?: boolean
    volume?: boolean
    itemsCount?: boolean
    ownersCount?: boolean
    change24h?: boolean
    creatorId?: boolean
    ownerAddress?: boolean
    isOrphan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type CollectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    contract?: boolean
    description?: boolean
    logoUrl?: boolean
    coverUrl?: boolean
    standard?: boolean
    supply?: boolean
    baseUri?: boolean
    gatewayPref?: boolean
    indexStatus?: boolean
    x?: boolean
    instagram?: boolean
    website?: boolean
    discord?: boolean
    telegram?: boolean
    floorPrice?: boolean
    volume?: boolean
    itemsCount?: boolean
    ownersCount?: boolean
    change24h?: boolean
    creatorId?: boolean
    ownerAddress?: boolean
    isOrphan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type CollectionSelectScalar = {
    id?: boolean
    name?: boolean
    symbol?: boolean
    contract?: boolean
    description?: boolean
    logoUrl?: boolean
    coverUrl?: boolean
    standard?: boolean
    supply?: boolean
    baseUri?: boolean
    gatewayPref?: boolean
    indexStatus?: boolean
    x?: boolean
    instagram?: boolean
    website?: boolean
    discord?: boolean
    telegram?: boolean
    floorPrice?: boolean
    volume?: boolean
    itemsCount?: boolean
    ownersCount?: boolean
    change24h?: boolean
    creatorId?: boolean
    ownerAddress?: boolean
    isOrphan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CollectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "symbol" | "contract" | "description" | "logoUrl" | "coverUrl" | "standard" | "supply" | "baseUri" | "gatewayPref" | "indexStatus" | "x" | "instagram" | "website" | "discord" | "telegram" | "floorPrice" | "volume" | "itemsCount" | "ownersCount" | "change24h" | "creatorId" | "ownerAddress" | "isOrphan" | "createdAt" | "updatedAt", ExtArgs["result"]["collection"]>
  export type CollectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assetUploads?: boolean | Collection$assetUploadsArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    deployment?: boolean | Collection$deploymentArgs<ExtArgs>
    featuredBidEntries?: boolean | Collection$featuredBidEntriesArgs<ExtArgs>
    featuredAsWinner?: boolean | Collection$featuredAsWinnerArgs<ExtArgs>
    nfts?: boolean | Collection$nftsArgs<ExtArgs>
    presale?: boolean | Collection$presaleArgs<ExtArgs>
    publicSale?: boolean | Collection$publicSaleArgs<ExtArgs>
    _count?: boolean | CollectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CollectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CollectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CollectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Collection"
    objects: {
      assetUploads: Prisma.$AssetUploadPayload<ExtArgs>[]
      creator: Prisma.$UserPayload<ExtArgs>
      deployment: Prisma.$DeployedContractPayload<ExtArgs> | null
      featuredBidEntries: Prisma.$FeaturedBidPayload<ExtArgs>[]
      featuredAsWinner: Prisma.$FeaturedCyclePayload<ExtArgs>[]
      nfts: Prisma.$NFTPayload<ExtArgs>[]
      presale: Prisma.$PresalePayload<ExtArgs> | null
      publicSale: Prisma.$PublicSalePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      symbol: string
      contract: string
      description: string | null
      logoUrl: string | null
      coverUrl: string | null
      standard: string
      supply: number | null
      baseUri: string | null
      gatewayPref: $Enums.GatewayPref
      indexStatus: $Enums.IndexStatus
      x: string | null
      instagram: string | null
      website: string | null
      discord: string | null
      telegram: string | null
      floorPrice: number
      volume: number
      itemsCount: number
      ownersCount: number
      change24h: number
      creatorId: string
      ownerAddress: string
      isOrphan: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["collection"]>
    composites: {}
  }

  type CollectionGetPayload<S extends boolean | null | undefined | CollectionDefaultArgs> = $Result.GetResult<Prisma.$CollectionPayload, S>

  type CollectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionCountAggregateInputType | true
    }

  export interface CollectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Collection'], meta: { name: 'Collection' } }
    /**
     * Find zero or one Collection that matches the filter.
     * @param {CollectionFindUniqueArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionFindUniqueArgs>(args: SelectSubset<T, CollectionFindUniqueArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Collection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionFindUniqueOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Collection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindFirstArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionFindFirstArgs>(args?: SelectSubset<T, CollectionFindFirstArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Collection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindFirstOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collections
     * const collections = await prisma.collection.findMany()
     * 
     * // Get first 10 Collections
     * const collections = await prisma.collection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionWithIdOnly = await prisma.collection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionFindManyArgs>(args?: SelectSubset<T, CollectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Collection.
     * @param {CollectionCreateArgs} args - Arguments to create a Collection.
     * @example
     * // Create one Collection
     * const Collection = await prisma.collection.create({
     *   data: {
     *     // ... data to create a Collection
     *   }
     * })
     * 
     */
    create<T extends CollectionCreateArgs>(args: SelectSubset<T, CollectionCreateArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Collections.
     * @param {CollectionCreateManyArgs} args - Arguments to create many Collections.
     * @example
     * // Create many Collections
     * const collection = await prisma.collection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionCreateManyArgs>(args?: SelectSubset<T, CollectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collections and returns the data saved in the database.
     * @param {CollectionCreateManyAndReturnArgs} args - Arguments to create many Collections.
     * @example
     * // Create many Collections
     * const collection = await prisma.collection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collections and only return the `id`
     * const collectionWithIdOnly = await prisma.collection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Collection.
     * @param {CollectionDeleteArgs} args - Arguments to delete one Collection.
     * @example
     * // Delete one Collection
     * const Collection = await prisma.collection.delete({
     *   where: {
     *     // ... filter to delete one Collection
     *   }
     * })
     * 
     */
    delete<T extends CollectionDeleteArgs>(args: SelectSubset<T, CollectionDeleteArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Collection.
     * @param {CollectionUpdateArgs} args - Arguments to update one Collection.
     * @example
     * // Update one Collection
     * const collection = await prisma.collection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionUpdateArgs>(args: SelectSubset<T, CollectionUpdateArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Collections.
     * @param {CollectionDeleteManyArgs} args - Arguments to filter Collections to delete.
     * @example
     * // Delete a few Collections
     * const { count } = await prisma.collection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionDeleteManyArgs>(args?: SelectSubset<T, CollectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collections
     * const collection = await prisma.collection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionUpdateManyArgs>(args: SelectSubset<T, CollectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collections and returns the data updated in the database.
     * @param {CollectionUpdateManyAndReturnArgs} args - Arguments to update many Collections.
     * @example
     * // Update many Collections
     * const collection = await prisma.collection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Collections and only return the `id`
     * const collectionWithIdOnly = await prisma.collection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Collection.
     * @param {CollectionUpsertArgs} args - Arguments to update or create a Collection.
     * @example
     * // Update or create a Collection
     * const collection = await prisma.collection.upsert({
     *   create: {
     *     // ... data to create a Collection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection we want to update
     *   }
     * })
     */
    upsert<T extends CollectionUpsertArgs>(args: SelectSubset<T, CollectionUpsertArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCountArgs} args - Arguments to filter Collections to count.
     * @example
     * // Count the number of Collections
     * const count = await prisma.collection.count({
     *   where: {
     *     // ... the filter for the Collections we want to count
     *   }
     * })
    **/
    count<T extends CollectionCountArgs>(
      args?: Subset<T, CollectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionAggregateArgs>(args: Subset<T, CollectionAggregateArgs>): Prisma.PrismaPromise<GetCollectionAggregateType<T>>

    /**
     * Group by Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionGroupByArgs['orderBy'] }
        : { orderBy?: CollectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Collection model
   */
  readonly fields: CollectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Collection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assetUploads<T extends Collection$assetUploadsArgs<ExtArgs> = {}>(args?: Subset<T, Collection$assetUploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetUploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deployment<T extends Collection$deploymentArgs<ExtArgs> = {}>(args?: Subset<T, Collection$deploymentArgs<ExtArgs>>): Prisma__DeployedContractClient<$Result.GetResult<Prisma.$DeployedContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    featuredBidEntries<T extends Collection$featuredBidEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Collection$featuredBidEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    featuredAsWinner<T extends Collection$featuredAsWinnerArgs<ExtArgs> = {}>(args?: Subset<T, Collection$featuredAsWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedCyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nfts<T extends Collection$nftsArgs<ExtArgs> = {}>(args?: Subset<T, Collection$nftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    presale<T extends Collection$presaleArgs<ExtArgs> = {}>(args?: Subset<T, Collection$presaleArgs<ExtArgs>>): Prisma__PresaleClient<$Result.GetResult<Prisma.$PresalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    publicSale<T extends Collection$publicSaleArgs<ExtArgs> = {}>(args?: Subset<T, Collection$publicSaleArgs<ExtArgs>>): Prisma__PublicSaleClient<$Result.GetResult<Prisma.$PublicSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Collection model
   */
  interface CollectionFieldRefs {
    readonly id: FieldRef<"Collection", 'String'>
    readonly name: FieldRef<"Collection", 'String'>
    readonly symbol: FieldRef<"Collection", 'String'>
    readonly contract: FieldRef<"Collection", 'String'>
    readonly description: FieldRef<"Collection", 'String'>
    readonly logoUrl: FieldRef<"Collection", 'String'>
    readonly coverUrl: FieldRef<"Collection", 'String'>
    readonly standard: FieldRef<"Collection", 'String'>
    readonly supply: FieldRef<"Collection", 'Int'>
    readonly baseUri: FieldRef<"Collection", 'String'>
    readonly gatewayPref: FieldRef<"Collection", 'GatewayPref'>
    readonly indexStatus: FieldRef<"Collection", 'IndexStatus'>
    readonly x: FieldRef<"Collection", 'String'>
    readonly instagram: FieldRef<"Collection", 'String'>
    readonly website: FieldRef<"Collection", 'String'>
    readonly discord: FieldRef<"Collection", 'String'>
    readonly telegram: FieldRef<"Collection", 'String'>
    readonly floorPrice: FieldRef<"Collection", 'Float'>
    readonly volume: FieldRef<"Collection", 'Float'>
    readonly itemsCount: FieldRef<"Collection", 'Int'>
    readonly ownersCount: FieldRef<"Collection", 'Int'>
    readonly change24h: FieldRef<"Collection", 'Float'>
    readonly creatorId: FieldRef<"Collection", 'String'>
    readonly ownerAddress: FieldRef<"Collection", 'String'>
    readonly isOrphan: FieldRef<"Collection", 'Boolean'>
    readonly createdAt: FieldRef<"Collection", 'DateTime'>
    readonly updatedAt: FieldRef<"Collection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Collection findUnique
   */
  export type CollectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection findUniqueOrThrow
   */
  export type CollectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection findFirst
   */
  export type CollectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collections.
     */
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection findFirstOrThrow
   */
  export type CollectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collections.
     */
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection findMany
   */
  export type CollectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collections to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection create
   */
  export type CollectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Collection.
     */
    data: XOR<CollectionCreateInput, CollectionUncheckedCreateInput>
  }

  /**
   * Collection createMany
   */
  export type CollectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Collections.
     */
    data: CollectionCreateManyInput | CollectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Collection createManyAndReturn
   */
  export type CollectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * The data used to create many Collections.
     */
    data: CollectionCreateManyInput | CollectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Collection update
   */
  export type CollectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Collection.
     */
    data: XOR<CollectionUpdateInput, CollectionUncheckedUpdateInput>
    /**
     * Choose, which Collection to update.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection updateMany
   */
  export type CollectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Collections.
     */
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyInput>
    /**
     * Filter which Collections to update
     */
    where?: CollectionWhereInput
    /**
     * Limit how many Collections to update.
     */
    limit?: number
  }

  /**
   * Collection updateManyAndReturn
   */
  export type CollectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * The data used to update Collections.
     */
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyInput>
    /**
     * Filter which Collections to update
     */
    where?: CollectionWhereInput
    /**
     * Limit how many Collections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Collection upsert
   */
  export type CollectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Collection to update in case it exists.
     */
    where: CollectionWhereUniqueInput
    /**
     * In case the Collection found by the `where` argument doesn't exist, create a new Collection with this data.
     */
    create: XOR<CollectionCreateInput, CollectionUncheckedCreateInput>
    /**
     * In case the Collection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionUpdateInput, CollectionUncheckedUpdateInput>
  }

  /**
   * Collection delete
   */
  export type CollectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter which Collection to delete.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection deleteMany
   */
  export type CollectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collections to delete
     */
    where?: CollectionWhereInput
    /**
     * Limit how many Collections to delete.
     */
    limit?: number
  }

  /**
   * Collection.assetUploads
   */
  export type Collection$assetUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadInclude<ExtArgs> | null
    where?: AssetUploadWhereInput
    orderBy?: AssetUploadOrderByWithRelationInput | AssetUploadOrderByWithRelationInput[]
    cursor?: AssetUploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetUploadScalarFieldEnum | AssetUploadScalarFieldEnum[]
  }

  /**
   * Collection.deployment
   */
  export type Collection$deploymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractInclude<ExtArgs> | null
    where?: DeployedContractWhereInput
  }

  /**
   * Collection.featuredBidEntries
   */
  export type Collection$featuredBidEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidInclude<ExtArgs> | null
    where?: FeaturedBidWhereInput
    orderBy?: FeaturedBidOrderByWithRelationInput | FeaturedBidOrderByWithRelationInput[]
    cursor?: FeaturedBidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeaturedBidScalarFieldEnum | FeaturedBidScalarFieldEnum[]
  }

  /**
   * Collection.featuredAsWinner
   */
  export type Collection$featuredAsWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycle
     */
    select?: FeaturedCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedCycle
     */
    omit?: FeaturedCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedCycleInclude<ExtArgs> | null
    where?: FeaturedCycleWhereInput
    orderBy?: FeaturedCycleOrderByWithRelationInput | FeaturedCycleOrderByWithRelationInput[]
    cursor?: FeaturedCycleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeaturedCycleScalarFieldEnum | FeaturedCycleScalarFieldEnum[]
  }

  /**
   * Collection.nfts
   */
  export type Collection$nftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    where?: NFTWhereInput
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    cursor?: NFTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NFTScalarFieldEnum | NFTScalarFieldEnum[]
  }

  /**
   * Collection.presale
   */
  export type Collection$presaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presale
     */
    select?: PresaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presale
     */
    omit?: PresaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleInclude<ExtArgs> | null
    where?: PresaleWhereInput
  }

  /**
   * Collection.publicSale
   */
  export type Collection$publicSaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicSale
     */
    select?: PublicSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicSale
     */
    omit?: PublicSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicSaleInclude<ExtArgs> | null
    where?: PublicSaleWhereInput
  }

  /**
   * Collection without action
   */
  export type CollectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
  }


  /**
   * Model NFT
   */

  export type AggregateNFT = {
    _count: NFTCountAggregateOutputType | null
    _avg: NFTAvgAggregateOutputType | null
    _sum: NFTSumAggregateOutputType | null
    _min: NFTMinAggregateOutputType | null
    _max: NFTMaxAggregateOutputType | null
  }

  export type NFTAvgAggregateOutputType = {
    royaltyBps: number | null
    retryCount: number | null
    rarityScore: Decimal | null
  }

  export type NFTSumAggregateOutputType = {
    royaltyBps: number | null
    retryCount: number | null
    rarityScore: Decimal | null
  }

  export type NFTMinAggregateOutputType = {
    id: string | null
    tokenId: string | null
    name: string | null
    imageUrl: string | null
    description: string | null
    tokenUri: string | null
    contract: string | null
    standard: string | null
    royaltyBps: number | null
    royaltyRecipient: string | null
    ownerId: string | null
    collectionId: string | null
    single721Id: string | null
    single1155Id: string | null
    status: $Enums.NftStatus | null
    retryCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    rarityScore: Decimal | null
  }

  export type NFTMaxAggregateOutputType = {
    id: string | null
    tokenId: string | null
    name: string | null
    imageUrl: string | null
    description: string | null
    tokenUri: string | null
    contract: string | null
    standard: string | null
    royaltyBps: number | null
    royaltyRecipient: string | null
    ownerId: string | null
    collectionId: string | null
    single721Id: string | null
    single1155Id: string | null
    status: $Enums.NftStatus | null
    retryCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    rarityScore: Decimal | null
  }

  export type NFTCountAggregateOutputType = {
    id: number
    tokenId: number
    name: number
    imageUrl: number
    description: number
    traits: number
    attributes: number
    tokenUri: number
    contract: number
    standard: number
    rawMetadata: number
    royaltyBps: number
    royaltyRecipient: number
    ownerId: number
    collectionId: number
    single721Id: number
    single1155Id: number
    status: number
    retryCount: number
    createdAt: number
    updatedAt: number
    rarityScore: number
    _all: number
  }


  export type NFTAvgAggregateInputType = {
    royaltyBps?: true
    retryCount?: true
    rarityScore?: true
  }

  export type NFTSumAggregateInputType = {
    royaltyBps?: true
    retryCount?: true
    rarityScore?: true
  }

  export type NFTMinAggregateInputType = {
    id?: true
    tokenId?: true
    name?: true
    imageUrl?: true
    description?: true
    tokenUri?: true
    contract?: true
    standard?: true
    royaltyBps?: true
    royaltyRecipient?: true
    ownerId?: true
    collectionId?: true
    single721Id?: true
    single1155Id?: true
    status?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
    rarityScore?: true
  }

  export type NFTMaxAggregateInputType = {
    id?: true
    tokenId?: true
    name?: true
    imageUrl?: true
    description?: true
    tokenUri?: true
    contract?: true
    standard?: true
    royaltyBps?: true
    royaltyRecipient?: true
    ownerId?: true
    collectionId?: true
    single721Id?: true
    single1155Id?: true
    status?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
    rarityScore?: true
  }

  export type NFTCountAggregateInputType = {
    id?: true
    tokenId?: true
    name?: true
    imageUrl?: true
    description?: true
    traits?: true
    attributes?: true
    tokenUri?: true
    contract?: true
    standard?: true
    rawMetadata?: true
    royaltyBps?: true
    royaltyRecipient?: true
    ownerId?: true
    collectionId?: true
    single721Id?: true
    single1155Id?: true
    status?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
    rarityScore?: true
    _all?: true
  }

  export type NFTAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NFT to aggregate.
     */
    where?: NFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTS to fetch.
     */
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NFTS
    **/
    _count?: true | NFTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NFTAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NFTSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NFTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NFTMaxAggregateInputType
  }

  export type GetNFTAggregateType<T extends NFTAggregateArgs> = {
        [P in keyof T & keyof AggregateNFT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNFT[P]>
      : GetScalarType<T[P], AggregateNFT[P]>
  }




  export type NFTGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NFTWhereInput
    orderBy?: NFTOrderByWithAggregationInput | NFTOrderByWithAggregationInput[]
    by: NFTScalarFieldEnum[] | NFTScalarFieldEnum
    having?: NFTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NFTCountAggregateInputType | true
    _avg?: NFTAvgAggregateInputType
    _sum?: NFTSumAggregateInputType
    _min?: NFTMinAggregateInputType
    _max?: NFTMaxAggregateInputType
  }

  export type NFTGroupByOutputType = {
    id: string
    tokenId: string
    name: string | null
    imageUrl: string | null
    description: string | null
    traits: JsonValue | null
    attributes: JsonValue | null
    tokenUri: string | null
    contract: string
    standard: string | null
    rawMetadata: JsonValue | null
    royaltyBps: number | null
    royaltyRecipient: string | null
    ownerId: string | null
    collectionId: string | null
    single721Id: string | null
    single1155Id: string | null
    status: $Enums.NftStatus
    retryCount: number
    createdAt: Date
    updatedAt: Date
    rarityScore: Decimal | null
    _count: NFTCountAggregateOutputType | null
    _avg: NFTAvgAggregateOutputType | null
    _sum: NFTSumAggregateOutputType | null
    _min: NFTMinAggregateOutputType | null
    _max: NFTMaxAggregateOutputType | null
  }

  type GetNFTGroupByPayload<T extends NFTGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NFTGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NFTGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NFTGroupByOutputType[P]>
            : GetScalarType<T[P], NFTGroupByOutputType[P]>
        }
      >
    >


  export type NFTSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    name?: boolean
    imageUrl?: boolean
    description?: boolean
    traits?: boolean
    attributes?: boolean
    tokenUri?: boolean
    contract?: boolean
    standard?: boolean
    rawMetadata?: boolean
    royaltyBps?: boolean
    royaltyRecipient?: boolean
    ownerId?: boolean
    collectionId?: boolean
    single721Id?: boolean
    single1155Id?: boolean
    status?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rarityScore?: boolean
    auctionEntries?: boolean | NFT$auctionEntriesArgs<ExtArgs>
    listingEntries?: boolean | NFT$listingEntriesArgs<ExtArgs>
    sales?: boolean | NFT$salesArgs<ExtArgs>
    collection?: boolean | NFT$collectionArgs<ExtArgs>
    owner?: boolean | NFT$ownerArgs<ExtArgs>
    single1155?: boolean | NFT$single1155Args<ExtArgs>
    single721?: boolean | NFT$single721Args<ExtArgs>
    activities?: boolean | NFT$activitiesArgs<ExtArgs>
    _count?: boolean | NFTCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nFT"]>

  export type NFTSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    name?: boolean
    imageUrl?: boolean
    description?: boolean
    traits?: boolean
    attributes?: boolean
    tokenUri?: boolean
    contract?: boolean
    standard?: boolean
    rawMetadata?: boolean
    royaltyBps?: boolean
    royaltyRecipient?: boolean
    ownerId?: boolean
    collectionId?: boolean
    single721Id?: boolean
    single1155Id?: boolean
    status?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rarityScore?: boolean
    collection?: boolean | NFT$collectionArgs<ExtArgs>
    owner?: boolean | NFT$ownerArgs<ExtArgs>
    single1155?: boolean | NFT$single1155Args<ExtArgs>
    single721?: boolean | NFT$single721Args<ExtArgs>
  }, ExtArgs["result"]["nFT"]>

  export type NFTSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenId?: boolean
    name?: boolean
    imageUrl?: boolean
    description?: boolean
    traits?: boolean
    attributes?: boolean
    tokenUri?: boolean
    contract?: boolean
    standard?: boolean
    rawMetadata?: boolean
    royaltyBps?: boolean
    royaltyRecipient?: boolean
    ownerId?: boolean
    collectionId?: boolean
    single721Id?: boolean
    single1155Id?: boolean
    status?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rarityScore?: boolean
    collection?: boolean | NFT$collectionArgs<ExtArgs>
    owner?: boolean | NFT$ownerArgs<ExtArgs>
    single1155?: boolean | NFT$single1155Args<ExtArgs>
    single721?: boolean | NFT$single721Args<ExtArgs>
  }, ExtArgs["result"]["nFT"]>

  export type NFTSelectScalar = {
    id?: boolean
    tokenId?: boolean
    name?: boolean
    imageUrl?: boolean
    description?: boolean
    traits?: boolean
    attributes?: boolean
    tokenUri?: boolean
    contract?: boolean
    standard?: boolean
    rawMetadata?: boolean
    royaltyBps?: boolean
    royaltyRecipient?: boolean
    ownerId?: boolean
    collectionId?: boolean
    single721Id?: boolean
    single1155Id?: boolean
    status?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rarityScore?: boolean
  }

  export type NFTOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tokenId" | "name" | "imageUrl" | "description" | "traits" | "attributes" | "tokenUri" | "contract" | "standard" | "rawMetadata" | "royaltyBps" | "royaltyRecipient" | "ownerId" | "collectionId" | "single721Id" | "single1155Id" | "status" | "retryCount" | "createdAt" | "updatedAt" | "rarityScore", ExtArgs["result"]["nFT"]>
  export type NFTInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auctionEntries?: boolean | NFT$auctionEntriesArgs<ExtArgs>
    listingEntries?: boolean | NFT$listingEntriesArgs<ExtArgs>
    sales?: boolean | NFT$salesArgs<ExtArgs>
    collection?: boolean | NFT$collectionArgs<ExtArgs>
    owner?: boolean | NFT$ownerArgs<ExtArgs>
    single1155?: boolean | NFT$single1155Args<ExtArgs>
    single721?: boolean | NFT$single721Args<ExtArgs>
    activities?: boolean | NFT$activitiesArgs<ExtArgs>
    _count?: boolean | NFTCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NFTIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | NFT$collectionArgs<ExtArgs>
    owner?: boolean | NFT$ownerArgs<ExtArgs>
    single1155?: boolean | NFT$single1155Args<ExtArgs>
    single721?: boolean | NFT$single721Args<ExtArgs>
  }
  export type NFTIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | NFT$collectionArgs<ExtArgs>
    owner?: boolean | NFT$ownerArgs<ExtArgs>
    single1155?: boolean | NFT$single1155Args<ExtArgs>
    single721?: boolean | NFT$single721Args<ExtArgs>
  }

  export type $NFTPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NFT"
    objects: {
      auctionEntries: Prisma.$AuctionPayload<ExtArgs>[]
      listingEntries: Prisma.$MarketplaceListingPayload<ExtArgs>[]
      sales: Prisma.$MarketplaceSalePayload<ExtArgs>[]
      collection: Prisma.$CollectionPayload<ExtArgs> | null
      owner: Prisma.$UserPayload<ExtArgs> | null
      single1155: Prisma.$Single1155Payload<ExtArgs> | null
      single721: Prisma.$Single721Payload<ExtArgs> | null
      activities: Prisma.$NFTActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tokenId: string
      name: string | null
      imageUrl: string | null
      description: string | null
      traits: Prisma.JsonValue | null
      attributes: Prisma.JsonValue | null
      tokenUri: string | null
      contract: string
      standard: string | null
      rawMetadata: Prisma.JsonValue | null
      royaltyBps: number | null
      royaltyRecipient: string | null
      ownerId: string | null
      collectionId: string | null
      single721Id: string | null
      single1155Id: string | null
      status: $Enums.NftStatus
      retryCount: number
      createdAt: Date
      updatedAt: Date
      rarityScore: Prisma.Decimal | null
    }, ExtArgs["result"]["nFT"]>
    composites: {}
  }

  type NFTGetPayload<S extends boolean | null | undefined | NFTDefaultArgs> = $Result.GetResult<Prisma.$NFTPayload, S>

  type NFTCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NFTFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NFTCountAggregateInputType | true
    }

  export interface NFTDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NFT'], meta: { name: 'NFT' } }
    /**
     * Find zero or one NFT that matches the filter.
     * @param {NFTFindUniqueArgs} args - Arguments to find a NFT
     * @example
     * // Get one NFT
     * const nFT = await prisma.nFT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NFTFindUniqueArgs>(args: SelectSubset<T, NFTFindUniqueArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NFT that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NFTFindUniqueOrThrowArgs} args - Arguments to find a NFT
     * @example
     * // Get one NFT
     * const nFT = await prisma.nFT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NFTFindUniqueOrThrowArgs>(args: SelectSubset<T, NFTFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NFT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTFindFirstArgs} args - Arguments to find a NFT
     * @example
     * // Get one NFT
     * const nFT = await prisma.nFT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NFTFindFirstArgs>(args?: SelectSubset<T, NFTFindFirstArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NFT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTFindFirstOrThrowArgs} args - Arguments to find a NFT
     * @example
     * // Get one NFT
     * const nFT = await prisma.nFT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NFTFindFirstOrThrowArgs>(args?: SelectSubset<T, NFTFindFirstOrThrowArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NFTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NFTS
     * const nFTS = await prisma.nFT.findMany()
     * 
     * // Get first 10 NFTS
     * const nFTS = await prisma.nFT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nFTWithIdOnly = await prisma.nFT.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NFTFindManyArgs>(args?: SelectSubset<T, NFTFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NFT.
     * @param {NFTCreateArgs} args - Arguments to create a NFT.
     * @example
     * // Create one NFT
     * const NFT = await prisma.nFT.create({
     *   data: {
     *     // ... data to create a NFT
     *   }
     * })
     * 
     */
    create<T extends NFTCreateArgs>(args: SelectSubset<T, NFTCreateArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NFTS.
     * @param {NFTCreateManyArgs} args - Arguments to create many NFTS.
     * @example
     * // Create many NFTS
     * const nFT = await prisma.nFT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NFTCreateManyArgs>(args?: SelectSubset<T, NFTCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NFTS and returns the data saved in the database.
     * @param {NFTCreateManyAndReturnArgs} args - Arguments to create many NFTS.
     * @example
     * // Create many NFTS
     * const nFT = await prisma.nFT.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NFTS and only return the `id`
     * const nFTWithIdOnly = await prisma.nFT.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NFTCreateManyAndReturnArgs>(args?: SelectSubset<T, NFTCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NFT.
     * @param {NFTDeleteArgs} args - Arguments to delete one NFT.
     * @example
     * // Delete one NFT
     * const NFT = await prisma.nFT.delete({
     *   where: {
     *     // ... filter to delete one NFT
     *   }
     * })
     * 
     */
    delete<T extends NFTDeleteArgs>(args: SelectSubset<T, NFTDeleteArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NFT.
     * @param {NFTUpdateArgs} args - Arguments to update one NFT.
     * @example
     * // Update one NFT
     * const nFT = await prisma.nFT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NFTUpdateArgs>(args: SelectSubset<T, NFTUpdateArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NFTS.
     * @param {NFTDeleteManyArgs} args - Arguments to filter NFTS to delete.
     * @example
     * // Delete a few NFTS
     * const { count } = await prisma.nFT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NFTDeleteManyArgs>(args?: SelectSubset<T, NFTDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NFTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NFTS
     * const nFT = await prisma.nFT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NFTUpdateManyArgs>(args: SelectSubset<T, NFTUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NFTS and returns the data updated in the database.
     * @param {NFTUpdateManyAndReturnArgs} args - Arguments to update many NFTS.
     * @example
     * // Update many NFTS
     * const nFT = await prisma.nFT.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NFTS and only return the `id`
     * const nFTWithIdOnly = await prisma.nFT.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NFTUpdateManyAndReturnArgs>(args: SelectSubset<T, NFTUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NFT.
     * @param {NFTUpsertArgs} args - Arguments to update or create a NFT.
     * @example
     * // Update or create a NFT
     * const nFT = await prisma.nFT.upsert({
     *   create: {
     *     // ... data to create a NFT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NFT we want to update
     *   }
     * })
     */
    upsert<T extends NFTUpsertArgs>(args: SelectSubset<T, NFTUpsertArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NFTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTCountArgs} args - Arguments to filter NFTS to count.
     * @example
     * // Count the number of NFTS
     * const count = await prisma.nFT.count({
     *   where: {
     *     // ... the filter for the NFTS we want to count
     *   }
     * })
    **/
    count<T extends NFTCountArgs>(
      args?: Subset<T, NFTCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NFTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NFT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NFTAggregateArgs>(args: Subset<T, NFTAggregateArgs>): Prisma.PrismaPromise<GetNFTAggregateType<T>>

    /**
     * Group by NFT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NFTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NFTGroupByArgs['orderBy'] }
        : { orderBy?: NFTGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NFTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNFTGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NFT model
   */
  readonly fields: NFTFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NFT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NFTClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auctionEntries<T extends NFT$auctionEntriesArgs<ExtArgs> = {}>(args?: Subset<T, NFT$auctionEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listingEntries<T extends NFT$listingEntriesArgs<ExtArgs> = {}>(args?: Subset<T, NFT$listingEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends NFT$salesArgs<ExtArgs> = {}>(args?: Subset<T, NFT$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collection<T extends NFT$collectionArgs<ExtArgs> = {}>(args?: Subset<T, NFT$collectionArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    owner<T extends NFT$ownerArgs<ExtArgs> = {}>(args?: Subset<T, NFT$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    single1155<T extends NFT$single1155Args<ExtArgs> = {}>(args?: Subset<T, NFT$single1155Args<ExtArgs>>): Prisma__Single1155Client<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    single721<T extends NFT$single721Args<ExtArgs> = {}>(args?: Subset<T, NFT$single721Args<ExtArgs>>): Prisma__Single721Client<$Result.GetResult<Prisma.$Single721Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    activities<T extends NFT$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, NFT$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NFT model
   */
  interface NFTFieldRefs {
    readonly id: FieldRef<"NFT", 'String'>
    readonly tokenId: FieldRef<"NFT", 'String'>
    readonly name: FieldRef<"NFT", 'String'>
    readonly imageUrl: FieldRef<"NFT", 'String'>
    readonly description: FieldRef<"NFT", 'String'>
    readonly traits: FieldRef<"NFT", 'Json'>
    readonly attributes: FieldRef<"NFT", 'Json'>
    readonly tokenUri: FieldRef<"NFT", 'String'>
    readonly contract: FieldRef<"NFT", 'String'>
    readonly standard: FieldRef<"NFT", 'String'>
    readonly rawMetadata: FieldRef<"NFT", 'Json'>
    readonly royaltyBps: FieldRef<"NFT", 'Int'>
    readonly royaltyRecipient: FieldRef<"NFT", 'String'>
    readonly ownerId: FieldRef<"NFT", 'String'>
    readonly collectionId: FieldRef<"NFT", 'String'>
    readonly single721Id: FieldRef<"NFT", 'String'>
    readonly single1155Id: FieldRef<"NFT", 'String'>
    readonly status: FieldRef<"NFT", 'NftStatus'>
    readonly retryCount: FieldRef<"NFT", 'Int'>
    readonly createdAt: FieldRef<"NFT", 'DateTime'>
    readonly updatedAt: FieldRef<"NFT", 'DateTime'>
    readonly rarityScore: FieldRef<"NFT", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * NFT findUnique
   */
  export type NFTFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * Filter, which NFT to fetch.
     */
    where: NFTWhereUniqueInput
  }

  /**
   * NFT findUniqueOrThrow
   */
  export type NFTFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * Filter, which NFT to fetch.
     */
    where: NFTWhereUniqueInput
  }

  /**
   * NFT findFirst
   */
  export type NFTFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * Filter, which NFT to fetch.
     */
    where?: NFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTS to fetch.
     */
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NFTS.
     */
    cursor?: NFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NFTS.
     */
    distinct?: NFTScalarFieldEnum | NFTScalarFieldEnum[]
  }

  /**
   * NFT findFirstOrThrow
   */
  export type NFTFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * Filter, which NFT to fetch.
     */
    where?: NFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTS to fetch.
     */
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NFTS.
     */
    cursor?: NFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NFTS.
     */
    distinct?: NFTScalarFieldEnum | NFTScalarFieldEnum[]
  }

  /**
   * NFT findMany
   */
  export type NFTFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * Filter, which NFTS to fetch.
     */
    where?: NFTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTS to fetch.
     */
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NFTS.
     */
    cursor?: NFTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTS.
     */
    skip?: number
    distinct?: NFTScalarFieldEnum | NFTScalarFieldEnum[]
  }

  /**
   * NFT create
   */
  export type NFTCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * The data needed to create a NFT.
     */
    data: XOR<NFTCreateInput, NFTUncheckedCreateInput>
  }

  /**
   * NFT createMany
   */
  export type NFTCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NFTS.
     */
    data: NFTCreateManyInput | NFTCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NFT createManyAndReturn
   */
  export type NFTCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * The data used to create many NFTS.
     */
    data: NFTCreateManyInput | NFTCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NFT update
   */
  export type NFTUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * The data needed to update a NFT.
     */
    data: XOR<NFTUpdateInput, NFTUncheckedUpdateInput>
    /**
     * Choose, which NFT to update.
     */
    where: NFTWhereUniqueInput
  }

  /**
   * NFT updateMany
   */
  export type NFTUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NFTS.
     */
    data: XOR<NFTUpdateManyMutationInput, NFTUncheckedUpdateManyInput>
    /**
     * Filter which NFTS to update
     */
    where?: NFTWhereInput
    /**
     * Limit how many NFTS to update.
     */
    limit?: number
  }

  /**
   * NFT updateManyAndReturn
   */
  export type NFTUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * The data used to update NFTS.
     */
    data: XOR<NFTUpdateManyMutationInput, NFTUncheckedUpdateManyInput>
    /**
     * Filter which NFTS to update
     */
    where?: NFTWhereInput
    /**
     * Limit how many NFTS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NFT upsert
   */
  export type NFTUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * The filter to search for the NFT to update in case it exists.
     */
    where: NFTWhereUniqueInput
    /**
     * In case the NFT found by the `where` argument doesn't exist, create a new NFT with this data.
     */
    create: XOR<NFTCreateInput, NFTUncheckedCreateInput>
    /**
     * In case the NFT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NFTUpdateInput, NFTUncheckedUpdateInput>
  }

  /**
   * NFT delete
   */
  export type NFTDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    /**
     * Filter which NFT to delete.
     */
    where: NFTWhereUniqueInput
  }

  /**
   * NFT deleteMany
   */
  export type NFTDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NFTS to delete
     */
    where?: NFTWhereInput
    /**
     * Limit how many NFTS to delete.
     */
    limit?: number
  }

  /**
   * NFT.auctionEntries
   */
  export type NFT$auctionEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    where?: AuctionWhereInput
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    cursor?: AuctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }

  /**
   * NFT.listingEntries
   */
  export type NFT$listingEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    where?: MarketplaceListingWhereInput
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    cursor?: MarketplaceListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketplaceListingScalarFieldEnum | MarketplaceListingScalarFieldEnum[]
  }

  /**
   * NFT.sales
   */
  export type NFT$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceSale
     */
    select?: MarketplaceSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceSale
     */
    omit?: MarketplaceSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceSaleInclude<ExtArgs> | null
    where?: MarketplaceSaleWhereInput
    orderBy?: MarketplaceSaleOrderByWithRelationInput | MarketplaceSaleOrderByWithRelationInput[]
    cursor?: MarketplaceSaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketplaceSaleScalarFieldEnum | MarketplaceSaleScalarFieldEnum[]
  }

  /**
   * NFT.collection
   */
  export type NFT$collectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    where?: CollectionWhereInput
  }

  /**
   * NFT.owner
   */
  export type NFT$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * NFT.single1155
   */
  export type NFT$single1155Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single1155Include<ExtArgs> | null
    where?: Single1155WhereInput
  }

  /**
   * NFT.single721
   */
  export type NFT$single721Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single721Include<ExtArgs> | null
    where?: Single721WhereInput
  }

  /**
   * NFT.activities
   */
  export type NFT$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTActivity
     */
    select?: NFTActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTActivity
     */
    omit?: NFTActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTActivityInclude<ExtArgs> | null
    where?: NFTActivityWhereInput
    orderBy?: NFTActivityOrderByWithRelationInput | NFTActivityOrderByWithRelationInput[]
    cursor?: NFTActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NFTActivityScalarFieldEnum | NFTActivityScalarFieldEnum[]
  }

  /**
   * NFT without action
   */
  export type NFTDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
  }


  /**
   * Model TraitStat
   */

  export type AggregateTraitStat = {
    _count: TraitStatCountAggregateOutputType | null
    _avg: TraitStatAvgAggregateOutputType | null
    _sum: TraitStatSumAggregateOutputType | null
    _min: TraitStatMinAggregateOutputType | null
    _max: TraitStatMaxAggregateOutputType | null
  }

  export type TraitStatAvgAggregateOutputType = {
    count: number | null
    frequency: number | null
  }

  export type TraitStatSumAggregateOutputType = {
    count: number | null
    frequency: number | null
  }

  export type TraitStatMinAggregateOutputType = {
    id: string | null
    contract: string | null
    trait_type: string | null
    count: number | null
    frequency: number | null
    createdAt: Date | null
  }

  export type TraitStatMaxAggregateOutputType = {
    id: string | null
    contract: string | null
    trait_type: string | null
    count: number | null
    frequency: number | null
    createdAt: Date | null
  }

  export type TraitStatCountAggregateOutputType = {
    id: number
    contract: number
    trait_type: number
    value: number
    count: number
    frequency: number
    createdAt: number
    _all: number
  }


  export type TraitStatAvgAggregateInputType = {
    count?: true
    frequency?: true
  }

  export type TraitStatSumAggregateInputType = {
    count?: true
    frequency?: true
  }

  export type TraitStatMinAggregateInputType = {
    id?: true
    contract?: true
    trait_type?: true
    count?: true
    frequency?: true
    createdAt?: true
  }

  export type TraitStatMaxAggregateInputType = {
    id?: true
    contract?: true
    trait_type?: true
    count?: true
    frequency?: true
    createdAt?: true
  }

  export type TraitStatCountAggregateInputType = {
    id?: true
    contract?: true
    trait_type?: true
    value?: true
    count?: true
    frequency?: true
    createdAt?: true
    _all?: true
  }

  export type TraitStatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TraitStat to aggregate.
     */
    where?: TraitStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraitStats to fetch.
     */
    orderBy?: TraitStatOrderByWithRelationInput | TraitStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TraitStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraitStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraitStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TraitStats
    **/
    _count?: true | TraitStatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TraitStatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TraitStatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TraitStatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TraitStatMaxAggregateInputType
  }

  export type GetTraitStatAggregateType<T extends TraitStatAggregateArgs> = {
        [P in keyof T & keyof AggregateTraitStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraitStat[P]>
      : GetScalarType<T[P], AggregateTraitStat[P]>
  }




  export type TraitStatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraitStatWhereInput
    orderBy?: TraitStatOrderByWithAggregationInput | TraitStatOrderByWithAggregationInput[]
    by: TraitStatScalarFieldEnum[] | TraitStatScalarFieldEnum
    having?: TraitStatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TraitStatCountAggregateInputType | true
    _avg?: TraitStatAvgAggregateInputType
    _sum?: TraitStatSumAggregateInputType
    _min?: TraitStatMinAggregateInputType
    _max?: TraitStatMaxAggregateInputType
  }

  export type TraitStatGroupByOutputType = {
    id: string
    contract: string
    trait_type: string
    value: JsonValue
    count: number
    frequency: number
    createdAt: Date
    _count: TraitStatCountAggregateOutputType | null
    _avg: TraitStatAvgAggregateOutputType | null
    _sum: TraitStatSumAggregateOutputType | null
    _min: TraitStatMinAggregateOutputType | null
    _max: TraitStatMaxAggregateOutputType | null
  }

  type GetTraitStatGroupByPayload<T extends TraitStatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TraitStatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TraitStatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TraitStatGroupByOutputType[P]>
            : GetScalarType<T[P], TraitStatGroupByOutputType[P]>
        }
      >
    >


  export type TraitStatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    trait_type?: boolean
    value?: boolean
    count?: boolean
    frequency?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["traitStat"]>

  export type TraitStatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    trait_type?: boolean
    value?: boolean
    count?: boolean
    frequency?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["traitStat"]>

  export type TraitStatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    trait_type?: boolean
    value?: boolean
    count?: boolean
    frequency?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["traitStat"]>

  export type TraitStatSelectScalar = {
    id?: boolean
    contract?: boolean
    trait_type?: boolean
    value?: boolean
    count?: boolean
    frequency?: boolean
    createdAt?: boolean
  }

  export type TraitStatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contract" | "trait_type" | "value" | "count" | "frequency" | "createdAt", ExtArgs["result"]["traitStat"]>

  export type $TraitStatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TraitStat"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contract: string
      trait_type: string
      value: Prisma.JsonValue
      count: number
      frequency: number
      createdAt: Date
    }, ExtArgs["result"]["traitStat"]>
    composites: {}
  }

  type TraitStatGetPayload<S extends boolean | null | undefined | TraitStatDefaultArgs> = $Result.GetResult<Prisma.$TraitStatPayload, S>

  type TraitStatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TraitStatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TraitStatCountAggregateInputType | true
    }

  export interface TraitStatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TraitStat'], meta: { name: 'TraitStat' } }
    /**
     * Find zero or one TraitStat that matches the filter.
     * @param {TraitStatFindUniqueArgs} args - Arguments to find a TraitStat
     * @example
     * // Get one TraitStat
     * const traitStat = await prisma.traitStat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TraitStatFindUniqueArgs>(args: SelectSubset<T, TraitStatFindUniqueArgs<ExtArgs>>): Prisma__TraitStatClient<$Result.GetResult<Prisma.$TraitStatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TraitStat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TraitStatFindUniqueOrThrowArgs} args - Arguments to find a TraitStat
     * @example
     * // Get one TraitStat
     * const traitStat = await prisma.traitStat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TraitStatFindUniqueOrThrowArgs>(args: SelectSubset<T, TraitStatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TraitStatClient<$Result.GetResult<Prisma.$TraitStatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TraitStat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitStatFindFirstArgs} args - Arguments to find a TraitStat
     * @example
     * // Get one TraitStat
     * const traitStat = await prisma.traitStat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TraitStatFindFirstArgs>(args?: SelectSubset<T, TraitStatFindFirstArgs<ExtArgs>>): Prisma__TraitStatClient<$Result.GetResult<Prisma.$TraitStatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TraitStat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitStatFindFirstOrThrowArgs} args - Arguments to find a TraitStat
     * @example
     * // Get one TraitStat
     * const traitStat = await prisma.traitStat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TraitStatFindFirstOrThrowArgs>(args?: SelectSubset<T, TraitStatFindFirstOrThrowArgs<ExtArgs>>): Prisma__TraitStatClient<$Result.GetResult<Prisma.$TraitStatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TraitStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitStatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TraitStats
     * const traitStats = await prisma.traitStat.findMany()
     * 
     * // Get first 10 TraitStats
     * const traitStats = await prisma.traitStat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const traitStatWithIdOnly = await prisma.traitStat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TraitStatFindManyArgs>(args?: SelectSubset<T, TraitStatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitStatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TraitStat.
     * @param {TraitStatCreateArgs} args - Arguments to create a TraitStat.
     * @example
     * // Create one TraitStat
     * const TraitStat = await prisma.traitStat.create({
     *   data: {
     *     // ... data to create a TraitStat
     *   }
     * })
     * 
     */
    create<T extends TraitStatCreateArgs>(args: SelectSubset<T, TraitStatCreateArgs<ExtArgs>>): Prisma__TraitStatClient<$Result.GetResult<Prisma.$TraitStatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TraitStats.
     * @param {TraitStatCreateManyArgs} args - Arguments to create many TraitStats.
     * @example
     * // Create many TraitStats
     * const traitStat = await prisma.traitStat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TraitStatCreateManyArgs>(args?: SelectSubset<T, TraitStatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TraitStats and returns the data saved in the database.
     * @param {TraitStatCreateManyAndReturnArgs} args - Arguments to create many TraitStats.
     * @example
     * // Create many TraitStats
     * const traitStat = await prisma.traitStat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TraitStats and only return the `id`
     * const traitStatWithIdOnly = await prisma.traitStat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TraitStatCreateManyAndReturnArgs>(args?: SelectSubset<T, TraitStatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitStatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TraitStat.
     * @param {TraitStatDeleteArgs} args - Arguments to delete one TraitStat.
     * @example
     * // Delete one TraitStat
     * const TraitStat = await prisma.traitStat.delete({
     *   where: {
     *     // ... filter to delete one TraitStat
     *   }
     * })
     * 
     */
    delete<T extends TraitStatDeleteArgs>(args: SelectSubset<T, TraitStatDeleteArgs<ExtArgs>>): Prisma__TraitStatClient<$Result.GetResult<Prisma.$TraitStatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TraitStat.
     * @param {TraitStatUpdateArgs} args - Arguments to update one TraitStat.
     * @example
     * // Update one TraitStat
     * const traitStat = await prisma.traitStat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TraitStatUpdateArgs>(args: SelectSubset<T, TraitStatUpdateArgs<ExtArgs>>): Prisma__TraitStatClient<$Result.GetResult<Prisma.$TraitStatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TraitStats.
     * @param {TraitStatDeleteManyArgs} args - Arguments to filter TraitStats to delete.
     * @example
     * // Delete a few TraitStats
     * const { count } = await prisma.traitStat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TraitStatDeleteManyArgs>(args?: SelectSubset<T, TraitStatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TraitStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitStatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TraitStats
     * const traitStat = await prisma.traitStat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TraitStatUpdateManyArgs>(args: SelectSubset<T, TraitStatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TraitStats and returns the data updated in the database.
     * @param {TraitStatUpdateManyAndReturnArgs} args - Arguments to update many TraitStats.
     * @example
     * // Update many TraitStats
     * const traitStat = await prisma.traitStat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TraitStats and only return the `id`
     * const traitStatWithIdOnly = await prisma.traitStat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TraitStatUpdateManyAndReturnArgs>(args: SelectSubset<T, TraitStatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraitStatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TraitStat.
     * @param {TraitStatUpsertArgs} args - Arguments to update or create a TraitStat.
     * @example
     * // Update or create a TraitStat
     * const traitStat = await prisma.traitStat.upsert({
     *   create: {
     *     // ... data to create a TraitStat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TraitStat we want to update
     *   }
     * })
     */
    upsert<T extends TraitStatUpsertArgs>(args: SelectSubset<T, TraitStatUpsertArgs<ExtArgs>>): Prisma__TraitStatClient<$Result.GetResult<Prisma.$TraitStatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TraitStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitStatCountArgs} args - Arguments to filter TraitStats to count.
     * @example
     * // Count the number of TraitStats
     * const count = await prisma.traitStat.count({
     *   where: {
     *     // ... the filter for the TraitStats we want to count
     *   }
     * })
    **/
    count<T extends TraitStatCountArgs>(
      args?: Subset<T, TraitStatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TraitStatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TraitStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitStatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TraitStatAggregateArgs>(args: Subset<T, TraitStatAggregateArgs>): Prisma.PrismaPromise<GetTraitStatAggregateType<T>>

    /**
     * Group by TraitStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraitStatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TraitStatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TraitStatGroupByArgs['orderBy'] }
        : { orderBy?: TraitStatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TraitStatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraitStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TraitStat model
   */
  readonly fields: TraitStatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TraitStat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TraitStatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TraitStat model
   */
  interface TraitStatFieldRefs {
    readonly id: FieldRef<"TraitStat", 'String'>
    readonly contract: FieldRef<"TraitStat", 'String'>
    readonly trait_type: FieldRef<"TraitStat", 'String'>
    readonly value: FieldRef<"TraitStat", 'Json'>
    readonly count: FieldRef<"TraitStat", 'Int'>
    readonly frequency: FieldRef<"TraitStat", 'Float'>
    readonly createdAt: FieldRef<"TraitStat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TraitStat findUnique
   */
  export type TraitStatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitStat
     */
    select?: TraitStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitStat
     */
    omit?: TraitStatOmit<ExtArgs> | null
    /**
     * Filter, which TraitStat to fetch.
     */
    where: TraitStatWhereUniqueInput
  }

  /**
   * TraitStat findUniqueOrThrow
   */
  export type TraitStatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitStat
     */
    select?: TraitStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitStat
     */
    omit?: TraitStatOmit<ExtArgs> | null
    /**
     * Filter, which TraitStat to fetch.
     */
    where: TraitStatWhereUniqueInput
  }

  /**
   * TraitStat findFirst
   */
  export type TraitStatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitStat
     */
    select?: TraitStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitStat
     */
    omit?: TraitStatOmit<ExtArgs> | null
    /**
     * Filter, which TraitStat to fetch.
     */
    where?: TraitStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraitStats to fetch.
     */
    orderBy?: TraitStatOrderByWithRelationInput | TraitStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraitStats.
     */
    cursor?: TraitStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraitStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraitStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraitStats.
     */
    distinct?: TraitStatScalarFieldEnum | TraitStatScalarFieldEnum[]
  }

  /**
   * TraitStat findFirstOrThrow
   */
  export type TraitStatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitStat
     */
    select?: TraitStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitStat
     */
    omit?: TraitStatOmit<ExtArgs> | null
    /**
     * Filter, which TraitStat to fetch.
     */
    where?: TraitStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraitStats to fetch.
     */
    orderBy?: TraitStatOrderByWithRelationInput | TraitStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraitStats.
     */
    cursor?: TraitStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraitStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraitStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraitStats.
     */
    distinct?: TraitStatScalarFieldEnum | TraitStatScalarFieldEnum[]
  }

  /**
   * TraitStat findMany
   */
  export type TraitStatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitStat
     */
    select?: TraitStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitStat
     */
    omit?: TraitStatOmit<ExtArgs> | null
    /**
     * Filter, which TraitStats to fetch.
     */
    where?: TraitStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraitStats to fetch.
     */
    orderBy?: TraitStatOrderByWithRelationInput | TraitStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TraitStats.
     */
    cursor?: TraitStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraitStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraitStats.
     */
    skip?: number
    distinct?: TraitStatScalarFieldEnum | TraitStatScalarFieldEnum[]
  }

  /**
   * TraitStat create
   */
  export type TraitStatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitStat
     */
    select?: TraitStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitStat
     */
    omit?: TraitStatOmit<ExtArgs> | null
    /**
     * The data needed to create a TraitStat.
     */
    data: XOR<TraitStatCreateInput, TraitStatUncheckedCreateInput>
  }

  /**
   * TraitStat createMany
   */
  export type TraitStatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TraitStats.
     */
    data: TraitStatCreateManyInput | TraitStatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TraitStat createManyAndReturn
   */
  export type TraitStatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitStat
     */
    select?: TraitStatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TraitStat
     */
    omit?: TraitStatOmit<ExtArgs> | null
    /**
     * The data used to create many TraitStats.
     */
    data: TraitStatCreateManyInput | TraitStatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TraitStat update
   */
  export type TraitStatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitStat
     */
    select?: TraitStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitStat
     */
    omit?: TraitStatOmit<ExtArgs> | null
    /**
     * The data needed to update a TraitStat.
     */
    data: XOR<TraitStatUpdateInput, TraitStatUncheckedUpdateInput>
    /**
     * Choose, which TraitStat to update.
     */
    where: TraitStatWhereUniqueInput
  }

  /**
   * TraitStat updateMany
   */
  export type TraitStatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TraitStats.
     */
    data: XOR<TraitStatUpdateManyMutationInput, TraitStatUncheckedUpdateManyInput>
    /**
     * Filter which TraitStats to update
     */
    where?: TraitStatWhereInput
    /**
     * Limit how many TraitStats to update.
     */
    limit?: number
  }

  /**
   * TraitStat updateManyAndReturn
   */
  export type TraitStatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitStat
     */
    select?: TraitStatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TraitStat
     */
    omit?: TraitStatOmit<ExtArgs> | null
    /**
     * The data used to update TraitStats.
     */
    data: XOR<TraitStatUpdateManyMutationInput, TraitStatUncheckedUpdateManyInput>
    /**
     * Filter which TraitStats to update
     */
    where?: TraitStatWhereInput
    /**
     * Limit how many TraitStats to update.
     */
    limit?: number
  }

  /**
   * TraitStat upsert
   */
  export type TraitStatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitStat
     */
    select?: TraitStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitStat
     */
    omit?: TraitStatOmit<ExtArgs> | null
    /**
     * The filter to search for the TraitStat to update in case it exists.
     */
    where: TraitStatWhereUniqueInput
    /**
     * In case the TraitStat found by the `where` argument doesn't exist, create a new TraitStat with this data.
     */
    create: XOR<TraitStatCreateInput, TraitStatUncheckedCreateInput>
    /**
     * In case the TraitStat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TraitStatUpdateInput, TraitStatUncheckedUpdateInput>
  }

  /**
   * TraitStat delete
   */
  export type TraitStatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitStat
     */
    select?: TraitStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitStat
     */
    omit?: TraitStatOmit<ExtArgs> | null
    /**
     * Filter which TraitStat to delete.
     */
    where: TraitStatWhereUniqueInput
  }

  /**
   * TraitStat deleteMany
   */
  export type TraitStatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TraitStats to delete
     */
    where?: TraitStatWhereInput
    /**
     * Limit how many TraitStats to delete.
     */
    limit?: number
  }

  /**
   * TraitStat without action
   */
  export type TraitStatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraitStat
     */
    select?: TraitStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraitStat
     */
    omit?: TraitStatOmit<ExtArgs> | null
  }


  /**
   * Model NFTActivity
   */

  export type AggregateNFTActivity = {
    _count: NFTActivityCountAggregateOutputType | null
    _avg: NFTActivityAvgAggregateOutputType | null
    _sum: NFTActivitySumAggregateOutputType | null
    _min: NFTActivityMinAggregateOutputType | null
    _max: NFTActivityMaxAggregateOutputType | null
  }

  export type NFTActivityAvgAggregateOutputType = {
    priceEtnWei: Decimal | null
    logIndex: number | null
    blockNumber: number | null
  }

  export type NFTActivitySumAggregateOutputType = {
    priceEtnWei: Decimal | null
    logIndex: number | null
    blockNumber: number | null
  }

  export type NFTActivityMinAggregateOutputType = {
    id: string | null
    nftId: string | null
    contract: string | null
    tokenId: string | null
    type: string | null
    fromAddress: string | null
    toAddress: string | null
    priceEtnWei: Decimal | null
    txHash: string | null
    logIndex: number | null
    blockNumber: number | null
    timestamp: Date | null
    marketplace: string | null
    createdAt: Date | null
  }

  export type NFTActivityMaxAggregateOutputType = {
    id: string | null
    nftId: string | null
    contract: string | null
    tokenId: string | null
    type: string | null
    fromAddress: string | null
    toAddress: string | null
    priceEtnWei: Decimal | null
    txHash: string | null
    logIndex: number | null
    blockNumber: number | null
    timestamp: Date | null
    marketplace: string | null
    createdAt: Date | null
  }

  export type NFTActivityCountAggregateOutputType = {
    id: number
    nftId: number
    contract: number
    tokenId: number
    type: number
    fromAddress: number
    toAddress: number
    priceEtnWei: number
    txHash: number
    logIndex: number
    blockNumber: number
    timestamp: number
    marketplace: number
    rawData: number
    createdAt: number
    _all: number
  }


  export type NFTActivityAvgAggregateInputType = {
    priceEtnWei?: true
    logIndex?: true
    blockNumber?: true
  }

  export type NFTActivitySumAggregateInputType = {
    priceEtnWei?: true
    logIndex?: true
    blockNumber?: true
  }

  export type NFTActivityMinAggregateInputType = {
    id?: true
    nftId?: true
    contract?: true
    tokenId?: true
    type?: true
    fromAddress?: true
    toAddress?: true
    priceEtnWei?: true
    txHash?: true
    logIndex?: true
    blockNumber?: true
    timestamp?: true
    marketplace?: true
    createdAt?: true
  }

  export type NFTActivityMaxAggregateInputType = {
    id?: true
    nftId?: true
    contract?: true
    tokenId?: true
    type?: true
    fromAddress?: true
    toAddress?: true
    priceEtnWei?: true
    txHash?: true
    logIndex?: true
    blockNumber?: true
    timestamp?: true
    marketplace?: true
    createdAt?: true
  }

  export type NFTActivityCountAggregateInputType = {
    id?: true
    nftId?: true
    contract?: true
    tokenId?: true
    type?: true
    fromAddress?: true
    toAddress?: true
    priceEtnWei?: true
    txHash?: true
    logIndex?: true
    blockNumber?: true
    timestamp?: true
    marketplace?: true
    rawData?: true
    createdAt?: true
    _all?: true
  }

  export type NFTActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NFTActivity to aggregate.
     */
    where?: NFTActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTActivities to fetch.
     */
    orderBy?: NFTActivityOrderByWithRelationInput | NFTActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NFTActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NFTActivities
    **/
    _count?: true | NFTActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NFTActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NFTActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NFTActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NFTActivityMaxAggregateInputType
  }

  export type GetNFTActivityAggregateType<T extends NFTActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateNFTActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNFTActivity[P]>
      : GetScalarType<T[P], AggregateNFTActivity[P]>
  }




  export type NFTActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NFTActivityWhereInput
    orderBy?: NFTActivityOrderByWithAggregationInput | NFTActivityOrderByWithAggregationInput[]
    by: NFTActivityScalarFieldEnum[] | NFTActivityScalarFieldEnum
    having?: NFTActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NFTActivityCountAggregateInputType | true
    _avg?: NFTActivityAvgAggregateInputType
    _sum?: NFTActivitySumAggregateInputType
    _min?: NFTActivityMinAggregateInputType
    _max?: NFTActivityMaxAggregateInputType
  }

  export type NFTActivityGroupByOutputType = {
    id: string
    nftId: string
    contract: string
    tokenId: string
    type: string
    fromAddress: string
    toAddress: string
    priceEtnWei: Decimal | null
    txHash: string
    logIndex: number
    blockNumber: number
    timestamp: Date
    marketplace: string | null
    rawData: JsonValue | null
    createdAt: Date
    _count: NFTActivityCountAggregateOutputType | null
    _avg: NFTActivityAvgAggregateOutputType | null
    _sum: NFTActivitySumAggregateOutputType | null
    _min: NFTActivityMinAggregateOutputType | null
    _max: NFTActivityMaxAggregateOutputType | null
  }

  type GetNFTActivityGroupByPayload<T extends NFTActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NFTActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NFTActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NFTActivityGroupByOutputType[P]>
            : GetScalarType<T[P], NFTActivityGroupByOutputType[P]>
        }
      >
    >


  export type NFTActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nftId?: boolean
    contract?: boolean
    tokenId?: boolean
    type?: boolean
    fromAddress?: boolean
    toAddress?: boolean
    priceEtnWei?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    marketplace?: boolean
    rawData?: boolean
    createdAt?: boolean
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nFTActivity"]>

  export type NFTActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nftId?: boolean
    contract?: boolean
    tokenId?: boolean
    type?: boolean
    fromAddress?: boolean
    toAddress?: boolean
    priceEtnWei?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    marketplace?: boolean
    rawData?: boolean
    createdAt?: boolean
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nFTActivity"]>

  export type NFTActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nftId?: boolean
    contract?: boolean
    tokenId?: boolean
    type?: boolean
    fromAddress?: boolean
    toAddress?: boolean
    priceEtnWei?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    marketplace?: boolean
    rawData?: boolean
    createdAt?: boolean
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nFTActivity"]>

  export type NFTActivitySelectScalar = {
    id?: boolean
    nftId?: boolean
    contract?: boolean
    tokenId?: boolean
    type?: boolean
    fromAddress?: boolean
    toAddress?: boolean
    priceEtnWei?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    marketplace?: boolean
    rawData?: boolean
    createdAt?: boolean
  }

  export type NFTActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nftId" | "contract" | "tokenId" | "type" | "fromAddress" | "toAddress" | "priceEtnWei" | "txHash" | "logIndex" | "blockNumber" | "timestamp" | "marketplace" | "rawData" | "createdAt", ExtArgs["result"]["nFTActivity"]>
  export type NFTActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }
  export type NFTActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }
  export type NFTActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }

  export type $NFTActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NFTActivity"
    objects: {
      nft: Prisma.$NFTPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nftId: string
      contract: string
      tokenId: string
      type: string
      fromAddress: string
      toAddress: string
      priceEtnWei: Prisma.Decimal | null
      txHash: string
      logIndex: number
      blockNumber: number
      timestamp: Date
      marketplace: string | null
      rawData: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["nFTActivity"]>
    composites: {}
  }

  type NFTActivityGetPayload<S extends boolean | null | undefined | NFTActivityDefaultArgs> = $Result.GetResult<Prisma.$NFTActivityPayload, S>

  type NFTActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NFTActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NFTActivityCountAggregateInputType | true
    }

  export interface NFTActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NFTActivity'], meta: { name: 'NFTActivity' } }
    /**
     * Find zero or one NFTActivity that matches the filter.
     * @param {NFTActivityFindUniqueArgs} args - Arguments to find a NFTActivity
     * @example
     * // Get one NFTActivity
     * const nFTActivity = await prisma.nFTActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NFTActivityFindUniqueArgs>(args: SelectSubset<T, NFTActivityFindUniqueArgs<ExtArgs>>): Prisma__NFTActivityClient<$Result.GetResult<Prisma.$NFTActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NFTActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NFTActivityFindUniqueOrThrowArgs} args - Arguments to find a NFTActivity
     * @example
     * // Get one NFTActivity
     * const nFTActivity = await prisma.nFTActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NFTActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, NFTActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NFTActivityClient<$Result.GetResult<Prisma.$NFTActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NFTActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTActivityFindFirstArgs} args - Arguments to find a NFTActivity
     * @example
     * // Get one NFTActivity
     * const nFTActivity = await prisma.nFTActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NFTActivityFindFirstArgs>(args?: SelectSubset<T, NFTActivityFindFirstArgs<ExtArgs>>): Prisma__NFTActivityClient<$Result.GetResult<Prisma.$NFTActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NFTActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTActivityFindFirstOrThrowArgs} args - Arguments to find a NFTActivity
     * @example
     * // Get one NFTActivity
     * const nFTActivity = await prisma.nFTActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NFTActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, NFTActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__NFTActivityClient<$Result.GetResult<Prisma.$NFTActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NFTActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NFTActivities
     * const nFTActivities = await prisma.nFTActivity.findMany()
     * 
     * // Get first 10 NFTActivities
     * const nFTActivities = await prisma.nFTActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nFTActivityWithIdOnly = await prisma.nFTActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NFTActivityFindManyArgs>(args?: SelectSubset<T, NFTActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NFTActivity.
     * @param {NFTActivityCreateArgs} args - Arguments to create a NFTActivity.
     * @example
     * // Create one NFTActivity
     * const NFTActivity = await prisma.nFTActivity.create({
     *   data: {
     *     // ... data to create a NFTActivity
     *   }
     * })
     * 
     */
    create<T extends NFTActivityCreateArgs>(args: SelectSubset<T, NFTActivityCreateArgs<ExtArgs>>): Prisma__NFTActivityClient<$Result.GetResult<Prisma.$NFTActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NFTActivities.
     * @param {NFTActivityCreateManyArgs} args - Arguments to create many NFTActivities.
     * @example
     * // Create many NFTActivities
     * const nFTActivity = await prisma.nFTActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NFTActivityCreateManyArgs>(args?: SelectSubset<T, NFTActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NFTActivities and returns the data saved in the database.
     * @param {NFTActivityCreateManyAndReturnArgs} args - Arguments to create many NFTActivities.
     * @example
     * // Create many NFTActivities
     * const nFTActivity = await prisma.nFTActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NFTActivities and only return the `id`
     * const nFTActivityWithIdOnly = await prisma.nFTActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NFTActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, NFTActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NFTActivity.
     * @param {NFTActivityDeleteArgs} args - Arguments to delete one NFTActivity.
     * @example
     * // Delete one NFTActivity
     * const NFTActivity = await prisma.nFTActivity.delete({
     *   where: {
     *     // ... filter to delete one NFTActivity
     *   }
     * })
     * 
     */
    delete<T extends NFTActivityDeleteArgs>(args: SelectSubset<T, NFTActivityDeleteArgs<ExtArgs>>): Prisma__NFTActivityClient<$Result.GetResult<Prisma.$NFTActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NFTActivity.
     * @param {NFTActivityUpdateArgs} args - Arguments to update one NFTActivity.
     * @example
     * // Update one NFTActivity
     * const nFTActivity = await prisma.nFTActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NFTActivityUpdateArgs>(args: SelectSubset<T, NFTActivityUpdateArgs<ExtArgs>>): Prisma__NFTActivityClient<$Result.GetResult<Prisma.$NFTActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NFTActivities.
     * @param {NFTActivityDeleteManyArgs} args - Arguments to filter NFTActivities to delete.
     * @example
     * // Delete a few NFTActivities
     * const { count } = await prisma.nFTActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NFTActivityDeleteManyArgs>(args?: SelectSubset<T, NFTActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NFTActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NFTActivities
     * const nFTActivity = await prisma.nFTActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NFTActivityUpdateManyArgs>(args: SelectSubset<T, NFTActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NFTActivities and returns the data updated in the database.
     * @param {NFTActivityUpdateManyAndReturnArgs} args - Arguments to update many NFTActivities.
     * @example
     * // Update many NFTActivities
     * const nFTActivity = await prisma.nFTActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NFTActivities and only return the `id`
     * const nFTActivityWithIdOnly = await prisma.nFTActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NFTActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, NFTActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NFTActivity.
     * @param {NFTActivityUpsertArgs} args - Arguments to update or create a NFTActivity.
     * @example
     * // Update or create a NFTActivity
     * const nFTActivity = await prisma.nFTActivity.upsert({
     *   create: {
     *     // ... data to create a NFTActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NFTActivity we want to update
     *   }
     * })
     */
    upsert<T extends NFTActivityUpsertArgs>(args: SelectSubset<T, NFTActivityUpsertArgs<ExtArgs>>): Prisma__NFTActivityClient<$Result.GetResult<Prisma.$NFTActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NFTActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTActivityCountArgs} args - Arguments to filter NFTActivities to count.
     * @example
     * // Count the number of NFTActivities
     * const count = await prisma.nFTActivity.count({
     *   where: {
     *     // ... the filter for the NFTActivities we want to count
     *   }
     * })
    **/
    count<T extends NFTActivityCountArgs>(
      args?: Subset<T, NFTActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NFTActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NFTActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NFTActivityAggregateArgs>(args: Subset<T, NFTActivityAggregateArgs>): Prisma.PrismaPromise<GetNFTActivityAggregateType<T>>

    /**
     * Group by NFTActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NFTActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NFTActivityGroupByArgs['orderBy'] }
        : { orderBy?: NFTActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NFTActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNFTActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NFTActivity model
   */
  readonly fields: NFTActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NFTActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NFTActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nft<T extends NFTDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NFTDefaultArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NFTActivity model
   */
  interface NFTActivityFieldRefs {
    readonly id: FieldRef<"NFTActivity", 'String'>
    readonly nftId: FieldRef<"NFTActivity", 'String'>
    readonly contract: FieldRef<"NFTActivity", 'String'>
    readonly tokenId: FieldRef<"NFTActivity", 'String'>
    readonly type: FieldRef<"NFTActivity", 'String'>
    readonly fromAddress: FieldRef<"NFTActivity", 'String'>
    readonly toAddress: FieldRef<"NFTActivity", 'String'>
    readonly priceEtnWei: FieldRef<"NFTActivity", 'Decimal'>
    readonly txHash: FieldRef<"NFTActivity", 'String'>
    readonly logIndex: FieldRef<"NFTActivity", 'Int'>
    readonly blockNumber: FieldRef<"NFTActivity", 'Int'>
    readonly timestamp: FieldRef<"NFTActivity", 'DateTime'>
    readonly marketplace: FieldRef<"NFTActivity", 'String'>
    readonly rawData: FieldRef<"NFTActivity", 'Json'>
    readonly createdAt: FieldRef<"NFTActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NFTActivity findUnique
   */
  export type NFTActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTActivity
     */
    select?: NFTActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTActivity
     */
    omit?: NFTActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTActivityInclude<ExtArgs> | null
    /**
     * Filter, which NFTActivity to fetch.
     */
    where: NFTActivityWhereUniqueInput
  }

  /**
   * NFTActivity findUniqueOrThrow
   */
  export type NFTActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTActivity
     */
    select?: NFTActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTActivity
     */
    omit?: NFTActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTActivityInclude<ExtArgs> | null
    /**
     * Filter, which NFTActivity to fetch.
     */
    where: NFTActivityWhereUniqueInput
  }

  /**
   * NFTActivity findFirst
   */
  export type NFTActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTActivity
     */
    select?: NFTActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTActivity
     */
    omit?: NFTActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTActivityInclude<ExtArgs> | null
    /**
     * Filter, which NFTActivity to fetch.
     */
    where?: NFTActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTActivities to fetch.
     */
    orderBy?: NFTActivityOrderByWithRelationInput | NFTActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NFTActivities.
     */
    cursor?: NFTActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NFTActivities.
     */
    distinct?: NFTActivityScalarFieldEnum | NFTActivityScalarFieldEnum[]
  }

  /**
   * NFTActivity findFirstOrThrow
   */
  export type NFTActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTActivity
     */
    select?: NFTActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTActivity
     */
    omit?: NFTActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTActivityInclude<ExtArgs> | null
    /**
     * Filter, which NFTActivity to fetch.
     */
    where?: NFTActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTActivities to fetch.
     */
    orderBy?: NFTActivityOrderByWithRelationInput | NFTActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NFTActivities.
     */
    cursor?: NFTActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NFTActivities.
     */
    distinct?: NFTActivityScalarFieldEnum | NFTActivityScalarFieldEnum[]
  }

  /**
   * NFTActivity findMany
   */
  export type NFTActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTActivity
     */
    select?: NFTActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTActivity
     */
    omit?: NFTActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTActivityInclude<ExtArgs> | null
    /**
     * Filter, which NFTActivities to fetch.
     */
    where?: NFTActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTActivities to fetch.
     */
    orderBy?: NFTActivityOrderByWithRelationInput | NFTActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NFTActivities.
     */
    cursor?: NFTActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTActivities.
     */
    skip?: number
    distinct?: NFTActivityScalarFieldEnum | NFTActivityScalarFieldEnum[]
  }

  /**
   * NFTActivity create
   */
  export type NFTActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTActivity
     */
    select?: NFTActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTActivity
     */
    omit?: NFTActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a NFTActivity.
     */
    data: XOR<NFTActivityCreateInput, NFTActivityUncheckedCreateInput>
  }

  /**
   * NFTActivity createMany
   */
  export type NFTActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NFTActivities.
     */
    data: NFTActivityCreateManyInput | NFTActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NFTActivity createManyAndReturn
   */
  export type NFTActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTActivity
     */
    select?: NFTActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NFTActivity
     */
    omit?: NFTActivityOmit<ExtArgs> | null
    /**
     * The data used to create many NFTActivities.
     */
    data: NFTActivityCreateManyInput | NFTActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NFTActivity update
   */
  export type NFTActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTActivity
     */
    select?: NFTActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTActivity
     */
    omit?: NFTActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a NFTActivity.
     */
    data: XOR<NFTActivityUpdateInput, NFTActivityUncheckedUpdateInput>
    /**
     * Choose, which NFTActivity to update.
     */
    where: NFTActivityWhereUniqueInput
  }

  /**
   * NFTActivity updateMany
   */
  export type NFTActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NFTActivities.
     */
    data: XOR<NFTActivityUpdateManyMutationInput, NFTActivityUncheckedUpdateManyInput>
    /**
     * Filter which NFTActivities to update
     */
    where?: NFTActivityWhereInput
    /**
     * Limit how many NFTActivities to update.
     */
    limit?: number
  }

  /**
   * NFTActivity updateManyAndReturn
   */
  export type NFTActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTActivity
     */
    select?: NFTActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NFTActivity
     */
    omit?: NFTActivityOmit<ExtArgs> | null
    /**
     * The data used to update NFTActivities.
     */
    data: XOR<NFTActivityUpdateManyMutationInput, NFTActivityUncheckedUpdateManyInput>
    /**
     * Filter which NFTActivities to update
     */
    where?: NFTActivityWhereInput
    /**
     * Limit how many NFTActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NFTActivity upsert
   */
  export type NFTActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTActivity
     */
    select?: NFTActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTActivity
     */
    omit?: NFTActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the NFTActivity to update in case it exists.
     */
    where: NFTActivityWhereUniqueInput
    /**
     * In case the NFTActivity found by the `where` argument doesn't exist, create a new NFTActivity with this data.
     */
    create: XOR<NFTActivityCreateInput, NFTActivityUncheckedCreateInput>
    /**
     * In case the NFTActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NFTActivityUpdateInput, NFTActivityUncheckedUpdateInput>
  }

  /**
   * NFTActivity delete
   */
  export type NFTActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTActivity
     */
    select?: NFTActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTActivity
     */
    omit?: NFTActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTActivityInclude<ExtArgs> | null
    /**
     * Filter which NFTActivity to delete.
     */
    where: NFTActivityWhereUniqueInput
  }

  /**
   * NFTActivity deleteMany
   */
  export type NFTActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NFTActivities to delete
     */
    where?: NFTActivityWhereInput
    /**
     * Limit how many NFTActivities to delete.
     */
    limit?: number
  }

  /**
   * NFTActivity without action
   */
  export type NFTActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTActivity
     */
    select?: NFTActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTActivity
     */
    omit?: NFTActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTActivityInclude<ExtArgs> | null
  }


  /**
   * Model Single721
   */

  export type AggregateSingle721 = {
    _count: Single721CountAggregateOutputType | null
    _avg: Single721AvgAggregateOutputType | null
    _sum: Single721SumAggregateOutputType | null
    _min: Single721MinAggregateOutputType | null
    _max: Single721MaxAggregateOutputType | null
  }

  export type Single721AvgAggregateOutputType = {
    royaltyBps: number | null
  }

  export type Single721SumAggregateOutputType = {
    royaltyBps: number | null
  }

  export type Single721MinAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    contract: string | null
    tokenUri: string | null
    royaltyRecipient: string | null
    royaltyBps: number | null
    creatorId: string | null
    ownerAddress: string | null
    description: string | null
    imageUrl: string | null
    indexStatus: $Enums.IndexStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Single721MaxAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    contract: string | null
    tokenUri: string | null
    royaltyRecipient: string | null
    royaltyBps: number | null
    creatorId: string | null
    ownerAddress: string | null
    description: string | null
    imageUrl: string | null
    indexStatus: $Enums.IndexStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Single721CountAggregateOutputType = {
    id: number
    name: number
    symbol: number
    contract: number
    tokenUri: number
    royaltyRecipient: number
    royaltyBps: number
    creatorId: number
    ownerAddress: number
    description: number
    imageUrl: number
    indexStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Single721AvgAggregateInputType = {
    royaltyBps?: true
  }

  export type Single721SumAggregateInputType = {
    royaltyBps?: true
  }

  export type Single721MinAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    contract?: true
    tokenUri?: true
    royaltyRecipient?: true
    royaltyBps?: true
    creatorId?: true
    ownerAddress?: true
    description?: true
    imageUrl?: true
    indexStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Single721MaxAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    contract?: true
    tokenUri?: true
    royaltyRecipient?: true
    royaltyBps?: true
    creatorId?: true
    ownerAddress?: true
    description?: true
    imageUrl?: true
    indexStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Single721CountAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    contract?: true
    tokenUri?: true
    royaltyRecipient?: true
    royaltyBps?: true
    creatorId?: true
    ownerAddress?: true
    description?: true
    imageUrl?: true
    indexStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Single721AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Single721 to aggregate.
     */
    where?: Single721WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Single721s to fetch.
     */
    orderBy?: Single721OrderByWithRelationInput | Single721OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Single721WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Single721s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Single721s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Single721s
    **/
    _count?: true | Single721CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Single721AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Single721SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Single721MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Single721MaxAggregateInputType
  }

  export type GetSingle721AggregateType<T extends Single721AggregateArgs> = {
        [P in keyof T & keyof AggregateSingle721]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSingle721[P]>
      : GetScalarType<T[P], AggregateSingle721[P]>
  }




  export type Single721GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Single721WhereInput
    orderBy?: Single721OrderByWithAggregationInput | Single721OrderByWithAggregationInput[]
    by: Single721ScalarFieldEnum[] | Single721ScalarFieldEnum
    having?: Single721ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Single721CountAggregateInputType | true
    _avg?: Single721AvgAggregateInputType
    _sum?: Single721SumAggregateInputType
    _min?: Single721MinAggregateInputType
    _max?: Single721MaxAggregateInputType
  }

  export type Single721GroupByOutputType = {
    id: string
    name: string
    symbol: string
    contract: string
    tokenUri: string
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description: string | null
    imageUrl: string | null
    indexStatus: $Enums.IndexStatus
    createdAt: Date
    updatedAt: Date
    _count: Single721CountAggregateOutputType | null
    _avg: Single721AvgAggregateOutputType | null
    _sum: Single721SumAggregateOutputType | null
    _min: Single721MinAggregateOutputType | null
    _max: Single721MaxAggregateOutputType | null
  }

  type GetSingle721GroupByPayload<T extends Single721GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Single721GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Single721GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Single721GroupByOutputType[P]>
            : GetScalarType<T[P], Single721GroupByOutputType[P]>
        }
      >
    >


  export type Single721Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    contract?: boolean
    tokenUri?: boolean
    royaltyRecipient?: boolean
    royaltyBps?: boolean
    creatorId?: boolean
    ownerAddress?: boolean
    description?: boolean
    imageUrl?: boolean
    indexStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assetUploads?: boolean | Single721$assetUploadsArgs<ExtArgs>
    deployment?: boolean | Single721$deploymentArgs<ExtArgs>
    nfts?: boolean | Single721$nftsArgs<ExtArgs>
    _count?: boolean | Single721CountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["single721"]>

  export type Single721SelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    contract?: boolean
    tokenUri?: boolean
    royaltyRecipient?: boolean
    royaltyBps?: boolean
    creatorId?: boolean
    ownerAddress?: boolean
    description?: boolean
    imageUrl?: boolean
    indexStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["single721"]>

  export type Single721SelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    contract?: boolean
    tokenUri?: boolean
    royaltyRecipient?: boolean
    royaltyBps?: boolean
    creatorId?: boolean
    ownerAddress?: boolean
    description?: boolean
    imageUrl?: boolean
    indexStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["single721"]>

  export type Single721SelectScalar = {
    id?: boolean
    name?: boolean
    symbol?: boolean
    contract?: boolean
    tokenUri?: boolean
    royaltyRecipient?: boolean
    royaltyBps?: boolean
    creatorId?: boolean
    ownerAddress?: boolean
    description?: boolean
    imageUrl?: boolean
    indexStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type Single721Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "symbol" | "contract" | "tokenUri" | "royaltyRecipient" | "royaltyBps" | "creatorId" | "ownerAddress" | "description" | "imageUrl" | "indexStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["single721"]>
  export type Single721Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assetUploads?: boolean | Single721$assetUploadsArgs<ExtArgs>
    deployment?: boolean | Single721$deploymentArgs<ExtArgs>
    nfts?: boolean | Single721$nftsArgs<ExtArgs>
    _count?: boolean | Single721CountOutputTypeDefaultArgs<ExtArgs>
  }
  export type Single721IncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type Single721IncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $Single721Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Single721"
    objects: {
      assetUploads: Prisma.$AssetUploadPayload<ExtArgs>[]
      deployment: Prisma.$DeployedContractPayload<ExtArgs> | null
      nfts: Prisma.$NFTPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      symbol: string
      contract: string
      tokenUri: string
      royaltyRecipient: string
      royaltyBps: number
      creatorId: string
      ownerAddress: string
      description: string | null
      imageUrl: string | null
      indexStatus: $Enums.IndexStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["single721"]>
    composites: {}
  }

  type Single721GetPayload<S extends boolean | null | undefined | Single721DefaultArgs> = $Result.GetResult<Prisma.$Single721Payload, S>

  type Single721CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Single721FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Single721CountAggregateInputType | true
    }

  export interface Single721Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Single721'], meta: { name: 'Single721' } }
    /**
     * Find zero or one Single721 that matches the filter.
     * @param {Single721FindUniqueArgs} args - Arguments to find a Single721
     * @example
     * // Get one Single721
     * const single721 = await prisma.single721.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Single721FindUniqueArgs>(args: SelectSubset<T, Single721FindUniqueArgs<ExtArgs>>): Prisma__Single721Client<$Result.GetResult<Prisma.$Single721Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Single721 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Single721FindUniqueOrThrowArgs} args - Arguments to find a Single721
     * @example
     * // Get one Single721
     * const single721 = await prisma.single721.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Single721FindUniqueOrThrowArgs>(args: SelectSubset<T, Single721FindUniqueOrThrowArgs<ExtArgs>>): Prisma__Single721Client<$Result.GetResult<Prisma.$Single721Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Single721 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Single721FindFirstArgs} args - Arguments to find a Single721
     * @example
     * // Get one Single721
     * const single721 = await prisma.single721.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Single721FindFirstArgs>(args?: SelectSubset<T, Single721FindFirstArgs<ExtArgs>>): Prisma__Single721Client<$Result.GetResult<Prisma.$Single721Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Single721 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Single721FindFirstOrThrowArgs} args - Arguments to find a Single721
     * @example
     * // Get one Single721
     * const single721 = await prisma.single721.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Single721FindFirstOrThrowArgs>(args?: SelectSubset<T, Single721FindFirstOrThrowArgs<ExtArgs>>): Prisma__Single721Client<$Result.GetResult<Prisma.$Single721Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Single721s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Single721FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Single721s
     * const single721s = await prisma.single721.findMany()
     * 
     * // Get first 10 Single721s
     * const single721s = await prisma.single721.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const single721WithIdOnly = await prisma.single721.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Single721FindManyArgs>(args?: SelectSubset<T, Single721FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Single721Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Single721.
     * @param {Single721CreateArgs} args - Arguments to create a Single721.
     * @example
     * // Create one Single721
     * const Single721 = await prisma.single721.create({
     *   data: {
     *     // ... data to create a Single721
     *   }
     * })
     * 
     */
    create<T extends Single721CreateArgs>(args: SelectSubset<T, Single721CreateArgs<ExtArgs>>): Prisma__Single721Client<$Result.GetResult<Prisma.$Single721Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Single721s.
     * @param {Single721CreateManyArgs} args - Arguments to create many Single721s.
     * @example
     * // Create many Single721s
     * const single721 = await prisma.single721.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Single721CreateManyArgs>(args?: SelectSubset<T, Single721CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Single721s and returns the data saved in the database.
     * @param {Single721CreateManyAndReturnArgs} args - Arguments to create many Single721s.
     * @example
     * // Create many Single721s
     * const single721 = await prisma.single721.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Single721s and only return the `id`
     * const single721WithIdOnly = await prisma.single721.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Single721CreateManyAndReturnArgs>(args?: SelectSubset<T, Single721CreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Single721Payload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Single721.
     * @param {Single721DeleteArgs} args - Arguments to delete one Single721.
     * @example
     * // Delete one Single721
     * const Single721 = await prisma.single721.delete({
     *   where: {
     *     // ... filter to delete one Single721
     *   }
     * })
     * 
     */
    delete<T extends Single721DeleteArgs>(args: SelectSubset<T, Single721DeleteArgs<ExtArgs>>): Prisma__Single721Client<$Result.GetResult<Prisma.$Single721Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Single721.
     * @param {Single721UpdateArgs} args - Arguments to update one Single721.
     * @example
     * // Update one Single721
     * const single721 = await prisma.single721.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Single721UpdateArgs>(args: SelectSubset<T, Single721UpdateArgs<ExtArgs>>): Prisma__Single721Client<$Result.GetResult<Prisma.$Single721Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Single721s.
     * @param {Single721DeleteManyArgs} args - Arguments to filter Single721s to delete.
     * @example
     * // Delete a few Single721s
     * const { count } = await prisma.single721.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Single721DeleteManyArgs>(args?: SelectSubset<T, Single721DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Single721s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Single721UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Single721s
     * const single721 = await prisma.single721.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Single721UpdateManyArgs>(args: SelectSubset<T, Single721UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Single721s and returns the data updated in the database.
     * @param {Single721UpdateManyAndReturnArgs} args - Arguments to update many Single721s.
     * @example
     * // Update many Single721s
     * const single721 = await prisma.single721.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Single721s and only return the `id`
     * const single721WithIdOnly = await prisma.single721.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Single721UpdateManyAndReturnArgs>(args: SelectSubset<T, Single721UpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Single721Payload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Single721.
     * @param {Single721UpsertArgs} args - Arguments to update or create a Single721.
     * @example
     * // Update or create a Single721
     * const single721 = await prisma.single721.upsert({
     *   create: {
     *     // ... data to create a Single721
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Single721 we want to update
     *   }
     * })
     */
    upsert<T extends Single721UpsertArgs>(args: SelectSubset<T, Single721UpsertArgs<ExtArgs>>): Prisma__Single721Client<$Result.GetResult<Prisma.$Single721Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Single721s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Single721CountArgs} args - Arguments to filter Single721s to count.
     * @example
     * // Count the number of Single721s
     * const count = await prisma.single721.count({
     *   where: {
     *     // ... the filter for the Single721s we want to count
     *   }
     * })
    **/
    count<T extends Single721CountArgs>(
      args?: Subset<T, Single721CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Single721CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Single721.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Single721AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Single721AggregateArgs>(args: Subset<T, Single721AggregateArgs>): Prisma.PrismaPromise<GetSingle721AggregateType<T>>

    /**
     * Group by Single721.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Single721GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Single721GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Single721GroupByArgs['orderBy'] }
        : { orderBy?: Single721GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Single721GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSingle721GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Single721 model
   */
  readonly fields: Single721FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Single721.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Single721Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assetUploads<T extends Single721$assetUploadsArgs<ExtArgs> = {}>(args?: Subset<T, Single721$assetUploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetUploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deployment<T extends Single721$deploymentArgs<ExtArgs> = {}>(args?: Subset<T, Single721$deploymentArgs<ExtArgs>>): Prisma__DeployedContractClient<$Result.GetResult<Prisma.$DeployedContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    nfts<T extends Single721$nftsArgs<ExtArgs> = {}>(args?: Subset<T, Single721$nftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Single721 model
   */
  interface Single721FieldRefs {
    readonly id: FieldRef<"Single721", 'String'>
    readonly name: FieldRef<"Single721", 'String'>
    readonly symbol: FieldRef<"Single721", 'String'>
    readonly contract: FieldRef<"Single721", 'String'>
    readonly tokenUri: FieldRef<"Single721", 'String'>
    readonly royaltyRecipient: FieldRef<"Single721", 'String'>
    readonly royaltyBps: FieldRef<"Single721", 'Int'>
    readonly creatorId: FieldRef<"Single721", 'String'>
    readonly ownerAddress: FieldRef<"Single721", 'String'>
    readonly description: FieldRef<"Single721", 'String'>
    readonly imageUrl: FieldRef<"Single721", 'String'>
    readonly indexStatus: FieldRef<"Single721", 'IndexStatus'>
    readonly createdAt: FieldRef<"Single721", 'DateTime'>
    readonly updatedAt: FieldRef<"Single721", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Single721 findUnique
   */
  export type Single721FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single721Include<ExtArgs> | null
    /**
     * Filter, which Single721 to fetch.
     */
    where: Single721WhereUniqueInput
  }

  /**
   * Single721 findUniqueOrThrow
   */
  export type Single721FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single721Include<ExtArgs> | null
    /**
     * Filter, which Single721 to fetch.
     */
    where: Single721WhereUniqueInput
  }

  /**
   * Single721 findFirst
   */
  export type Single721FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single721Include<ExtArgs> | null
    /**
     * Filter, which Single721 to fetch.
     */
    where?: Single721WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Single721s to fetch.
     */
    orderBy?: Single721OrderByWithRelationInput | Single721OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Single721s.
     */
    cursor?: Single721WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Single721s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Single721s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Single721s.
     */
    distinct?: Single721ScalarFieldEnum | Single721ScalarFieldEnum[]
  }

  /**
   * Single721 findFirstOrThrow
   */
  export type Single721FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single721Include<ExtArgs> | null
    /**
     * Filter, which Single721 to fetch.
     */
    where?: Single721WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Single721s to fetch.
     */
    orderBy?: Single721OrderByWithRelationInput | Single721OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Single721s.
     */
    cursor?: Single721WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Single721s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Single721s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Single721s.
     */
    distinct?: Single721ScalarFieldEnum | Single721ScalarFieldEnum[]
  }

  /**
   * Single721 findMany
   */
  export type Single721FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single721Include<ExtArgs> | null
    /**
     * Filter, which Single721s to fetch.
     */
    where?: Single721WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Single721s to fetch.
     */
    orderBy?: Single721OrderByWithRelationInput | Single721OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Single721s.
     */
    cursor?: Single721WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Single721s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Single721s.
     */
    skip?: number
    distinct?: Single721ScalarFieldEnum | Single721ScalarFieldEnum[]
  }

  /**
   * Single721 create
   */
  export type Single721CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single721Include<ExtArgs> | null
    /**
     * The data needed to create a Single721.
     */
    data: XOR<Single721CreateInput, Single721UncheckedCreateInput>
  }

  /**
   * Single721 createMany
   */
  export type Single721CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Single721s.
     */
    data: Single721CreateManyInput | Single721CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Single721 createManyAndReturn
   */
  export type Single721CreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721SelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * The data used to create many Single721s.
     */
    data: Single721CreateManyInput | Single721CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Single721 update
   */
  export type Single721UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single721Include<ExtArgs> | null
    /**
     * The data needed to update a Single721.
     */
    data: XOR<Single721UpdateInput, Single721UncheckedUpdateInput>
    /**
     * Choose, which Single721 to update.
     */
    where: Single721WhereUniqueInput
  }

  /**
   * Single721 updateMany
   */
  export type Single721UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Single721s.
     */
    data: XOR<Single721UpdateManyMutationInput, Single721UncheckedUpdateManyInput>
    /**
     * Filter which Single721s to update
     */
    where?: Single721WhereInput
    /**
     * Limit how many Single721s to update.
     */
    limit?: number
  }

  /**
   * Single721 updateManyAndReturn
   */
  export type Single721UpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721SelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * The data used to update Single721s.
     */
    data: XOR<Single721UpdateManyMutationInput, Single721UncheckedUpdateManyInput>
    /**
     * Filter which Single721s to update
     */
    where?: Single721WhereInput
    /**
     * Limit how many Single721s to update.
     */
    limit?: number
  }

  /**
   * Single721 upsert
   */
  export type Single721UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single721Include<ExtArgs> | null
    /**
     * The filter to search for the Single721 to update in case it exists.
     */
    where: Single721WhereUniqueInput
    /**
     * In case the Single721 found by the `where` argument doesn't exist, create a new Single721 with this data.
     */
    create: XOR<Single721CreateInput, Single721UncheckedCreateInput>
    /**
     * In case the Single721 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Single721UpdateInput, Single721UncheckedUpdateInput>
  }

  /**
   * Single721 delete
   */
  export type Single721DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single721Include<ExtArgs> | null
    /**
     * Filter which Single721 to delete.
     */
    where: Single721WhereUniqueInput
  }

  /**
   * Single721 deleteMany
   */
  export type Single721DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Single721s to delete
     */
    where?: Single721WhereInput
    /**
     * Limit how many Single721s to delete.
     */
    limit?: number
  }

  /**
   * Single721.assetUploads
   */
  export type Single721$assetUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadInclude<ExtArgs> | null
    where?: AssetUploadWhereInput
    orderBy?: AssetUploadOrderByWithRelationInput | AssetUploadOrderByWithRelationInput[]
    cursor?: AssetUploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetUploadScalarFieldEnum | AssetUploadScalarFieldEnum[]
  }

  /**
   * Single721.deployment
   */
  export type Single721$deploymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractInclude<ExtArgs> | null
    where?: DeployedContractWhereInput
  }

  /**
   * Single721.nfts
   */
  export type Single721$nftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    where?: NFTWhereInput
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    cursor?: NFTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NFTScalarFieldEnum | NFTScalarFieldEnum[]
  }

  /**
   * Single721 without action
   */
  export type Single721DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single721Include<ExtArgs> | null
  }


  /**
   * Model Single1155
   */

  export type AggregateSingle1155 = {
    _count: Single1155CountAggregateOutputType | null
    _avg: Single1155AvgAggregateOutputType | null
    _sum: Single1155SumAggregateOutputType | null
    _min: Single1155MinAggregateOutputType | null
    _max: Single1155MaxAggregateOutputType | null
  }

  export type Single1155AvgAggregateOutputType = {
    maxSupply: number | null
    mintPriceEtnWei: Decimal | null
    maxPerWallet: number | null
    royaltyBps: number | null
  }

  export type Single1155SumAggregateOutputType = {
    maxSupply: number | null
    mintPriceEtnWei: Decimal | null
    maxPerWallet: number | null
    royaltyBps: number | null
  }

  export type Single1155MinAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    contract: string | null
    baseUri: string | null
    maxSupply: number | null
    mintPriceEtnWei: Decimal | null
    maxPerWallet: number | null
    royaltyRecipient: string | null
    royaltyBps: number | null
    creatorId: string | null
    ownerAddress: string | null
    description: string | null
    imageUrl: string | null
    indexStatus: $Enums.IndexStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Single1155MaxAggregateOutputType = {
    id: string | null
    name: string | null
    symbol: string | null
    contract: string | null
    baseUri: string | null
    maxSupply: number | null
    mintPriceEtnWei: Decimal | null
    maxPerWallet: number | null
    royaltyRecipient: string | null
    royaltyBps: number | null
    creatorId: string | null
    ownerAddress: string | null
    description: string | null
    imageUrl: string | null
    indexStatus: $Enums.IndexStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Single1155CountAggregateOutputType = {
    id: number
    name: number
    symbol: number
    contract: number
    baseUri: number
    maxSupply: number
    mintPriceEtnWei: number
    maxPerWallet: number
    royaltyRecipient: number
    royaltyBps: number
    creatorId: number
    ownerAddress: number
    description: number
    imageUrl: number
    indexStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Single1155AvgAggregateInputType = {
    maxSupply?: true
    mintPriceEtnWei?: true
    maxPerWallet?: true
    royaltyBps?: true
  }

  export type Single1155SumAggregateInputType = {
    maxSupply?: true
    mintPriceEtnWei?: true
    maxPerWallet?: true
    royaltyBps?: true
  }

  export type Single1155MinAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    contract?: true
    baseUri?: true
    maxSupply?: true
    mintPriceEtnWei?: true
    maxPerWallet?: true
    royaltyRecipient?: true
    royaltyBps?: true
    creatorId?: true
    ownerAddress?: true
    description?: true
    imageUrl?: true
    indexStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Single1155MaxAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    contract?: true
    baseUri?: true
    maxSupply?: true
    mintPriceEtnWei?: true
    maxPerWallet?: true
    royaltyRecipient?: true
    royaltyBps?: true
    creatorId?: true
    ownerAddress?: true
    description?: true
    imageUrl?: true
    indexStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Single1155CountAggregateInputType = {
    id?: true
    name?: true
    symbol?: true
    contract?: true
    baseUri?: true
    maxSupply?: true
    mintPriceEtnWei?: true
    maxPerWallet?: true
    royaltyRecipient?: true
    royaltyBps?: true
    creatorId?: true
    ownerAddress?: true
    description?: true
    imageUrl?: true
    indexStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Single1155AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Single1155 to aggregate.
     */
    where?: Single1155WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Single1155s to fetch.
     */
    orderBy?: Single1155OrderByWithRelationInput | Single1155OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Single1155WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Single1155s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Single1155s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Single1155s
    **/
    _count?: true | Single1155CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Single1155AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Single1155SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Single1155MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Single1155MaxAggregateInputType
  }

  export type GetSingle1155AggregateType<T extends Single1155AggregateArgs> = {
        [P in keyof T & keyof AggregateSingle1155]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSingle1155[P]>
      : GetScalarType<T[P], AggregateSingle1155[P]>
  }




  export type Single1155GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Single1155WhereInput
    orderBy?: Single1155OrderByWithAggregationInput | Single1155OrderByWithAggregationInput[]
    by: Single1155ScalarFieldEnum[] | Single1155ScalarFieldEnum
    having?: Single1155ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Single1155CountAggregateInputType | true
    _avg?: Single1155AvgAggregateInputType
    _sum?: Single1155SumAggregateInputType
    _min?: Single1155MinAggregateInputType
    _max?: Single1155MaxAggregateInputType
  }

  export type Single1155GroupByOutputType = {
    id: string
    name: string
    symbol: string
    contract: string
    baseUri: string
    maxSupply: number
    mintPriceEtnWei: Decimal
    maxPerWallet: number
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description: string | null
    imageUrl: string | null
    indexStatus: $Enums.IndexStatus
    createdAt: Date
    updatedAt: Date
    _count: Single1155CountAggregateOutputType | null
    _avg: Single1155AvgAggregateOutputType | null
    _sum: Single1155SumAggregateOutputType | null
    _min: Single1155MinAggregateOutputType | null
    _max: Single1155MaxAggregateOutputType | null
  }

  type GetSingle1155GroupByPayload<T extends Single1155GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Single1155GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Single1155GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Single1155GroupByOutputType[P]>
            : GetScalarType<T[P], Single1155GroupByOutputType[P]>
        }
      >
    >


  export type Single1155Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    contract?: boolean
    baseUri?: boolean
    maxSupply?: boolean
    mintPriceEtnWei?: boolean
    maxPerWallet?: boolean
    royaltyRecipient?: boolean
    royaltyBps?: boolean
    creatorId?: boolean
    ownerAddress?: boolean
    description?: boolean
    imageUrl?: boolean
    indexStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assetUploads?: boolean | Single1155$assetUploadsArgs<ExtArgs>
    deployment?: boolean | Single1155$deploymentArgs<ExtArgs>
    balances?: boolean | Single1155$balancesArgs<ExtArgs>
    nfts?: boolean | Single1155$nftsArgs<ExtArgs>
    _count?: boolean | Single1155CountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["single1155"]>

  export type Single1155SelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    contract?: boolean
    baseUri?: boolean
    maxSupply?: boolean
    mintPriceEtnWei?: boolean
    maxPerWallet?: boolean
    royaltyRecipient?: boolean
    royaltyBps?: boolean
    creatorId?: boolean
    ownerAddress?: boolean
    description?: boolean
    imageUrl?: boolean
    indexStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["single1155"]>

  export type Single1155SelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    symbol?: boolean
    contract?: boolean
    baseUri?: boolean
    maxSupply?: boolean
    mintPriceEtnWei?: boolean
    maxPerWallet?: boolean
    royaltyRecipient?: boolean
    royaltyBps?: boolean
    creatorId?: boolean
    ownerAddress?: boolean
    description?: boolean
    imageUrl?: boolean
    indexStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["single1155"]>

  export type Single1155SelectScalar = {
    id?: boolean
    name?: boolean
    symbol?: boolean
    contract?: boolean
    baseUri?: boolean
    maxSupply?: boolean
    mintPriceEtnWei?: boolean
    maxPerWallet?: boolean
    royaltyRecipient?: boolean
    royaltyBps?: boolean
    creatorId?: boolean
    ownerAddress?: boolean
    description?: boolean
    imageUrl?: boolean
    indexStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type Single1155Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "symbol" | "contract" | "baseUri" | "maxSupply" | "mintPriceEtnWei" | "maxPerWallet" | "royaltyRecipient" | "royaltyBps" | "creatorId" | "ownerAddress" | "description" | "imageUrl" | "indexStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["single1155"]>
  export type Single1155Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assetUploads?: boolean | Single1155$assetUploadsArgs<ExtArgs>
    deployment?: boolean | Single1155$deploymentArgs<ExtArgs>
    balances?: boolean | Single1155$balancesArgs<ExtArgs>
    nfts?: boolean | Single1155$nftsArgs<ExtArgs>
    _count?: boolean | Single1155CountOutputTypeDefaultArgs<ExtArgs>
  }
  export type Single1155IncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type Single1155IncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $Single1155Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Single1155"
    objects: {
      assetUploads: Prisma.$AssetUploadPayload<ExtArgs>[]
      deployment: Prisma.$DeployedContractPayload<ExtArgs> | null
      balances: Prisma.$Erc1155BalancePayload<ExtArgs>[]
      nfts: Prisma.$NFTPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      symbol: string
      contract: string
      baseUri: string
      maxSupply: number
      mintPriceEtnWei: Prisma.Decimal
      maxPerWallet: number
      royaltyRecipient: string
      royaltyBps: number
      creatorId: string
      ownerAddress: string
      description: string | null
      imageUrl: string | null
      indexStatus: $Enums.IndexStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["single1155"]>
    composites: {}
  }

  type Single1155GetPayload<S extends boolean | null | undefined | Single1155DefaultArgs> = $Result.GetResult<Prisma.$Single1155Payload, S>

  type Single1155CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Single1155FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Single1155CountAggregateInputType | true
    }

  export interface Single1155Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Single1155'], meta: { name: 'Single1155' } }
    /**
     * Find zero or one Single1155 that matches the filter.
     * @param {Single1155FindUniqueArgs} args - Arguments to find a Single1155
     * @example
     * // Get one Single1155
     * const single1155 = await prisma.single1155.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Single1155FindUniqueArgs>(args: SelectSubset<T, Single1155FindUniqueArgs<ExtArgs>>): Prisma__Single1155Client<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Single1155 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Single1155FindUniqueOrThrowArgs} args - Arguments to find a Single1155
     * @example
     * // Get one Single1155
     * const single1155 = await prisma.single1155.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Single1155FindUniqueOrThrowArgs>(args: SelectSubset<T, Single1155FindUniqueOrThrowArgs<ExtArgs>>): Prisma__Single1155Client<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Single1155 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Single1155FindFirstArgs} args - Arguments to find a Single1155
     * @example
     * // Get one Single1155
     * const single1155 = await prisma.single1155.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Single1155FindFirstArgs>(args?: SelectSubset<T, Single1155FindFirstArgs<ExtArgs>>): Prisma__Single1155Client<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Single1155 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Single1155FindFirstOrThrowArgs} args - Arguments to find a Single1155
     * @example
     * // Get one Single1155
     * const single1155 = await prisma.single1155.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Single1155FindFirstOrThrowArgs>(args?: SelectSubset<T, Single1155FindFirstOrThrowArgs<ExtArgs>>): Prisma__Single1155Client<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Single1155s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Single1155FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Single1155s
     * const single1155s = await prisma.single1155.findMany()
     * 
     * // Get first 10 Single1155s
     * const single1155s = await prisma.single1155.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const single1155WithIdOnly = await prisma.single1155.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Single1155FindManyArgs>(args?: SelectSubset<T, Single1155FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Single1155.
     * @param {Single1155CreateArgs} args - Arguments to create a Single1155.
     * @example
     * // Create one Single1155
     * const Single1155 = await prisma.single1155.create({
     *   data: {
     *     // ... data to create a Single1155
     *   }
     * })
     * 
     */
    create<T extends Single1155CreateArgs>(args: SelectSubset<T, Single1155CreateArgs<ExtArgs>>): Prisma__Single1155Client<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Single1155s.
     * @param {Single1155CreateManyArgs} args - Arguments to create many Single1155s.
     * @example
     * // Create many Single1155s
     * const single1155 = await prisma.single1155.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Single1155CreateManyArgs>(args?: SelectSubset<T, Single1155CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Single1155s and returns the data saved in the database.
     * @param {Single1155CreateManyAndReturnArgs} args - Arguments to create many Single1155s.
     * @example
     * // Create many Single1155s
     * const single1155 = await prisma.single1155.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Single1155s and only return the `id`
     * const single1155WithIdOnly = await prisma.single1155.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Single1155CreateManyAndReturnArgs>(args?: SelectSubset<T, Single1155CreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Single1155.
     * @param {Single1155DeleteArgs} args - Arguments to delete one Single1155.
     * @example
     * // Delete one Single1155
     * const Single1155 = await prisma.single1155.delete({
     *   where: {
     *     // ... filter to delete one Single1155
     *   }
     * })
     * 
     */
    delete<T extends Single1155DeleteArgs>(args: SelectSubset<T, Single1155DeleteArgs<ExtArgs>>): Prisma__Single1155Client<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Single1155.
     * @param {Single1155UpdateArgs} args - Arguments to update one Single1155.
     * @example
     * // Update one Single1155
     * const single1155 = await prisma.single1155.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Single1155UpdateArgs>(args: SelectSubset<T, Single1155UpdateArgs<ExtArgs>>): Prisma__Single1155Client<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Single1155s.
     * @param {Single1155DeleteManyArgs} args - Arguments to filter Single1155s to delete.
     * @example
     * // Delete a few Single1155s
     * const { count } = await prisma.single1155.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Single1155DeleteManyArgs>(args?: SelectSubset<T, Single1155DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Single1155s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Single1155UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Single1155s
     * const single1155 = await prisma.single1155.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Single1155UpdateManyArgs>(args: SelectSubset<T, Single1155UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Single1155s and returns the data updated in the database.
     * @param {Single1155UpdateManyAndReturnArgs} args - Arguments to update many Single1155s.
     * @example
     * // Update many Single1155s
     * const single1155 = await prisma.single1155.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Single1155s and only return the `id`
     * const single1155WithIdOnly = await prisma.single1155.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Single1155UpdateManyAndReturnArgs>(args: SelectSubset<T, Single1155UpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Single1155.
     * @param {Single1155UpsertArgs} args - Arguments to update or create a Single1155.
     * @example
     * // Update or create a Single1155
     * const single1155 = await prisma.single1155.upsert({
     *   create: {
     *     // ... data to create a Single1155
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Single1155 we want to update
     *   }
     * })
     */
    upsert<T extends Single1155UpsertArgs>(args: SelectSubset<T, Single1155UpsertArgs<ExtArgs>>): Prisma__Single1155Client<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Single1155s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Single1155CountArgs} args - Arguments to filter Single1155s to count.
     * @example
     * // Count the number of Single1155s
     * const count = await prisma.single1155.count({
     *   where: {
     *     // ... the filter for the Single1155s we want to count
     *   }
     * })
    **/
    count<T extends Single1155CountArgs>(
      args?: Subset<T, Single1155CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Single1155CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Single1155.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Single1155AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Single1155AggregateArgs>(args: Subset<T, Single1155AggregateArgs>): Prisma.PrismaPromise<GetSingle1155AggregateType<T>>

    /**
     * Group by Single1155.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Single1155GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Single1155GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Single1155GroupByArgs['orderBy'] }
        : { orderBy?: Single1155GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Single1155GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSingle1155GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Single1155 model
   */
  readonly fields: Single1155FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Single1155.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Single1155Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assetUploads<T extends Single1155$assetUploadsArgs<ExtArgs> = {}>(args?: Subset<T, Single1155$assetUploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetUploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deployment<T extends Single1155$deploymentArgs<ExtArgs> = {}>(args?: Subset<T, Single1155$deploymentArgs<ExtArgs>>): Prisma__DeployedContractClient<$Result.GetResult<Prisma.$DeployedContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    balances<T extends Single1155$balancesArgs<ExtArgs> = {}>(args?: Subset<T, Single1155$balancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Erc1155BalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nfts<T extends Single1155$nftsArgs<ExtArgs> = {}>(args?: Subset<T, Single1155$nftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Single1155 model
   */
  interface Single1155FieldRefs {
    readonly id: FieldRef<"Single1155", 'String'>
    readonly name: FieldRef<"Single1155", 'String'>
    readonly symbol: FieldRef<"Single1155", 'String'>
    readonly contract: FieldRef<"Single1155", 'String'>
    readonly baseUri: FieldRef<"Single1155", 'String'>
    readonly maxSupply: FieldRef<"Single1155", 'Int'>
    readonly mintPriceEtnWei: FieldRef<"Single1155", 'Decimal'>
    readonly maxPerWallet: FieldRef<"Single1155", 'Int'>
    readonly royaltyRecipient: FieldRef<"Single1155", 'String'>
    readonly royaltyBps: FieldRef<"Single1155", 'Int'>
    readonly creatorId: FieldRef<"Single1155", 'String'>
    readonly ownerAddress: FieldRef<"Single1155", 'String'>
    readonly description: FieldRef<"Single1155", 'String'>
    readonly imageUrl: FieldRef<"Single1155", 'String'>
    readonly indexStatus: FieldRef<"Single1155", 'IndexStatus'>
    readonly createdAt: FieldRef<"Single1155", 'DateTime'>
    readonly updatedAt: FieldRef<"Single1155", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Single1155 findUnique
   */
  export type Single1155FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single1155Include<ExtArgs> | null
    /**
     * Filter, which Single1155 to fetch.
     */
    where: Single1155WhereUniqueInput
  }

  /**
   * Single1155 findUniqueOrThrow
   */
  export type Single1155FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single1155Include<ExtArgs> | null
    /**
     * Filter, which Single1155 to fetch.
     */
    where: Single1155WhereUniqueInput
  }

  /**
   * Single1155 findFirst
   */
  export type Single1155FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single1155Include<ExtArgs> | null
    /**
     * Filter, which Single1155 to fetch.
     */
    where?: Single1155WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Single1155s to fetch.
     */
    orderBy?: Single1155OrderByWithRelationInput | Single1155OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Single1155s.
     */
    cursor?: Single1155WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Single1155s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Single1155s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Single1155s.
     */
    distinct?: Single1155ScalarFieldEnum | Single1155ScalarFieldEnum[]
  }

  /**
   * Single1155 findFirstOrThrow
   */
  export type Single1155FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single1155Include<ExtArgs> | null
    /**
     * Filter, which Single1155 to fetch.
     */
    where?: Single1155WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Single1155s to fetch.
     */
    orderBy?: Single1155OrderByWithRelationInput | Single1155OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Single1155s.
     */
    cursor?: Single1155WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Single1155s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Single1155s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Single1155s.
     */
    distinct?: Single1155ScalarFieldEnum | Single1155ScalarFieldEnum[]
  }

  /**
   * Single1155 findMany
   */
  export type Single1155FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single1155Include<ExtArgs> | null
    /**
     * Filter, which Single1155s to fetch.
     */
    where?: Single1155WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Single1155s to fetch.
     */
    orderBy?: Single1155OrderByWithRelationInput | Single1155OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Single1155s.
     */
    cursor?: Single1155WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Single1155s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Single1155s.
     */
    skip?: number
    distinct?: Single1155ScalarFieldEnum | Single1155ScalarFieldEnum[]
  }

  /**
   * Single1155 create
   */
  export type Single1155CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single1155Include<ExtArgs> | null
    /**
     * The data needed to create a Single1155.
     */
    data: XOR<Single1155CreateInput, Single1155UncheckedCreateInput>
  }

  /**
   * Single1155 createMany
   */
  export type Single1155CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Single1155s.
     */
    data: Single1155CreateManyInput | Single1155CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Single1155 createManyAndReturn
   */
  export type Single1155CreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155SelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * The data used to create many Single1155s.
     */
    data: Single1155CreateManyInput | Single1155CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Single1155 update
   */
  export type Single1155UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single1155Include<ExtArgs> | null
    /**
     * The data needed to update a Single1155.
     */
    data: XOR<Single1155UpdateInput, Single1155UncheckedUpdateInput>
    /**
     * Choose, which Single1155 to update.
     */
    where: Single1155WhereUniqueInput
  }

  /**
   * Single1155 updateMany
   */
  export type Single1155UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Single1155s.
     */
    data: XOR<Single1155UpdateManyMutationInput, Single1155UncheckedUpdateManyInput>
    /**
     * Filter which Single1155s to update
     */
    where?: Single1155WhereInput
    /**
     * Limit how many Single1155s to update.
     */
    limit?: number
  }

  /**
   * Single1155 updateManyAndReturn
   */
  export type Single1155UpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155SelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * The data used to update Single1155s.
     */
    data: XOR<Single1155UpdateManyMutationInput, Single1155UncheckedUpdateManyInput>
    /**
     * Filter which Single1155s to update
     */
    where?: Single1155WhereInput
    /**
     * Limit how many Single1155s to update.
     */
    limit?: number
  }

  /**
   * Single1155 upsert
   */
  export type Single1155UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single1155Include<ExtArgs> | null
    /**
     * The filter to search for the Single1155 to update in case it exists.
     */
    where: Single1155WhereUniqueInput
    /**
     * In case the Single1155 found by the `where` argument doesn't exist, create a new Single1155 with this data.
     */
    create: XOR<Single1155CreateInput, Single1155UncheckedCreateInput>
    /**
     * In case the Single1155 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Single1155UpdateInput, Single1155UncheckedUpdateInput>
  }

  /**
   * Single1155 delete
   */
  export type Single1155DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single1155Include<ExtArgs> | null
    /**
     * Filter which Single1155 to delete.
     */
    where: Single1155WhereUniqueInput
  }

  /**
   * Single1155 deleteMany
   */
  export type Single1155DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Single1155s to delete
     */
    where?: Single1155WhereInput
    /**
     * Limit how many Single1155s to delete.
     */
    limit?: number
  }

  /**
   * Single1155.assetUploads
   */
  export type Single1155$assetUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadInclude<ExtArgs> | null
    where?: AssetUploadWhereInput
    orderBy?: AssetUploadOrderByWithRelationInput | AssetUploadOrderByWithRelationInput[]
    cursor?: AssetUploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssetUploadScalarFieldEnum | AssetUploadScalarFieldEnum[]
  }

  /**
   * Single1155.deployment
   */
  export type Single1155$deploymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractInclude<ExtArgs> | null
    where?: DeployedContractWhereInput
  }

  /**
   * Single1155.balances
   */
  export type Single1155$balancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Balance
     */
    select?: Erc1155BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Balance
     */
    omit?: Erc1155BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Erc1155BalanceInclude<ExtArgs> | null
    where?: Erc1155BalanceWhereInput
    orderBy?: Erc1155BalanceOrderByWithRelationInput | Erc1155BalanceOrderByWithRelationInput[]
    cursor?: Erc1155BalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Erc1155BalanceScalarFieldEnum | Erc1155BalanceScalarFieldEnum[]
  }

  /**
   * Single1155.nfts
   */
  export type Single1155$nftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFT
     */
    select?: NFTSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFT
     */
    omit?: NFTOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NFTInclude<ExtArgs> | null
    where?: NFTWhereInput
    orderBy?: NFTOrderByWithRelationInput | NFTOrderByWithRelationInput[]
    cursor?: NFTWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NFTScalarFieldEnum | NFTScalarFieldEnum[]
  }

  /**
   * Single1155 without action
   */
  export type Single1155DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single1155Include<ExtArgs> | null
  }


  /**
   * Model Erc1155Balance
   */

  export type AggregateErc1155Balance = {
    _count: Erc1155BalanceCountAggregateOutputType | null
    _avg: Erc1155BalanceAvgAggregateOutputType | null
    _sum: Erc1155BalanceSumAggregateOutputType | null
    _min: Erc1155BalanceMinAggregateOutputType | null
    _max: Erc1155BalanceMaxAggregateOutputType | null
  }

  export type Erc1155BalanceAvgAggregateOutputType = {
    balance: number | null
  }

  export type Erc1155BalanceSumAggregateOutputType = {
    balance: number | null
  }

  export type Erc1155BalanceMinAggregateOutputType = {
    id: string | null
    single1155Id: string | null
    ownerAddress: string | null
    balance: number | null
    updatedAt: Date | null
  }

  export type Erc1155BalanceMaxAggregateOutputType = {
    id: string | null
    single1155Id: string | null
    ownerAddress: string | null
    balance: number | null
    updatedAt: Date | null
  }

  export type Erc1155BalanceCountAggregateOutputType = {
    id: number
    single1155Id: number
    ownerAddress: number
    balance: number
    updatedAt: number
    _all: number
  }


  export type Erc1155BalanceAvgAggregateInputType = {
    balance?: true
  }

  export type Erc1155BalanceSumAggregateInputType = {
    balance?: true
  }

  export type Erc1155BalanceMinAggregateInputType = {
    id?: true
    single1155Id?: true
    ownerAddress?: true
    balance?: true
    updatedAt?: true
  }

  export type Erc1155BalanceMaxAggregateInputType = {
    id?: true
    single1155Id?: true
    ownerAddress?: true
    balance?: true
    updatedAt?: true
  }

  export type Erc1155BalanceCountAggregateInputType = {
    id?: true
    single1155Id?: true
    ownerAddress?: true
    balance?: true
    updatedAt?: true
    _all?: true
  }

  export type Erc1155BalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Erc1155Balance to aggregate.
     */
    where?: Erc1155BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Erc1155Balances to fetch.
     */
    orderBy?: Erc1155BalanceOrderByWithRelationInput | Erc1155BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Erc1155BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Erc1155Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Erc1155Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Erc1155Balances
    **/
    _count?: true | Erc1155BalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Erc1155BalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Erc1155BalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Erc1155BalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Erc1155BalanceMaxAggregateInputType
  }

  export type GetErc1155BalanceAggregateType<T extends Erc1155BalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateErc1155Balance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateErc1155Balance[P]>
      : GetScalarType<T[P], AggregateErc1155Balance[P]>
  }




  export type Erc1155BalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Erc1155BalanceWhereInput
    orderBy?: Erc1155BalanceOrderByWithAggregationInput | Erc1155BalanceOrderByWithAggregationInput[]
    by: Erc1155BalanceScalarFieldEnum[] | Erc1155BalanceScalarFieldEnum
    having?: Erc1155BalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Erc1155BalanceCountAggregateInputType | true
    _avg?: Erc1155BalanceAvgAggregateInputType
    _sum?: Erc1155BalanceSumAggregateInputType
    _min?: Erc1155BalanceMinAggregateInputType
    _max?: Erc1155BalanceMaxAggregateInputType
  }

  export type Erc1155BalanceGroupByOutputType = {
    id: string
    single1155Id: string
    ownerAddress: string
    balance: number
    updatedAt: Date
    _count: Erc1155BalanceCountAggregateOutputType | null
    _avg: Erc1155BalanceAvgAggregateOutputType | null
    _sum: Erc1155BalanceSumAggregateOutputType | null
    _min: Erc1155BalanceMinAggregateOutputType | null
    _max: Erc1155BalanceMaxAggregateOutputType | null
  }

  type GetErc1155BalanceGroupByPayload<T extends Erc1155BalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Erc1155BalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Erc1155BalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Erc1155BalanceGroupByOutputType[P]>
            : GetScalarType<T[P], Erc1155BalanceGroupByOutputType[P]>
        }
      >
    >


  export type Erc1155BalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    single1155Id?: boolean
    ownerAddress?: boolean
    balance?: boolean
    updatedAt?: boolean
    single1155?: boolean | Single1155DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["erc1155Balance"]>

  export type Erc1155BalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    single1155Id?: boolean
    ownerAddress?: boolean
    balance?: boolean
    updatedAt?: boolean
    single1155?: boolean | Single1155DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["erc1155Balance"]>

  export type Erc1155BalanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    single1155Id?: boolean
    ownerAddress?: boolean
    balance?: boolean
    updatedAt?: boolean
    single1155?: boolean | Single1155DefaultArgs<ExtArgs>
  }, ExtArgs["result"]["erc1155Balance"]>

  export type Erc1155BalanceSelectScalar = {
    id?: boolean
    single1155Id?: boolean
    ownerAddress?: boolean
    balance?: boolean
    updatedAt?: boolean
  }

  export type Erc1155BalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "single1155Id" | "ownerAddress" | "balance" | "updatedAt", ExtArgs["result"]["erc1155Balance"]>
  export type Erc1155BalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    single1155?: boolean | Single1155DefaultArgs<ExtArgs>
  }
  export type Erc1155BalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    single1155?: boolean | Single1155DefaultArgs<ExtArgs>
  }
  export type Erc1155BalanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    single1155?: boolean | Single1155DefaultArgs<ExtArgs>
  }

  export type $Erc1155BalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Erc1155Balance"
    objects: {
      single1155: Prisma.$Single1155Payload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      single1155Id: string
      ownerAddress: string
      balance: number
      updatedAt: Date
    }, ExtArgs["result"]["erc1155Balance"]>
    composites: {}
  }

  type Erc1155BalanceGetPayload<S extends boolean | null | undefined | Erc1155BalanceDefaultArgs> = $Result.GetResult<Prisma.$Erc1155BalancePayload, S>

  type Erc1155BalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Erc1155BalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Erc1155BalanceCountAggregateInputType | true
    }

  export interface Erc1155BalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Erc1155Balance'], meta: { name: 'Erc1155Balance' } }
    /**
     * Find zero or one Erc1155Balance that matches the filter.
     * @param {Erc1155BalanceFindUniqueArgs} args - Arguments to find a Erc1155Balance
     * @example
     * // Get one Erc1155Balance
     * const erc1155Balance = await prisma.erc1155Balance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Erc1155BalanceFindUniqueArgs>(args: SelectSubset<T, Erc1155BalanceFindUniqueArgs<ExtArgs>>): Prisma__Erc1155BalanceClient<$Result.GetResult<Prisma.$Erc1155BalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Erc1155Balance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Erc1155BalanceFindUniqueOrThrowArgs} args - Arguments to find a Erc1155Balance
     * @example
     * // Get one Erc1155Balance
     * const erc1155Balance = await prisma.erc1155Balance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Erc1155BalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, Erc1155BalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Erc1155BalanceClient<$Result.GetResult<Prisma.$Erc1155BalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Erc1155Balance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erc1155BalanceFindFirstArgs} args - Arguments to find a Erc1155Balance
     * @example
     * // Get one Erc1155Balance
     * const erc1155Balance = await prisma.erc1155Balance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Erc1155BalanceFindFirstArgs>(args?: SelectSubset<T, Erc1155BalanceFindFirstArgs<ExtArgs>>): Prisma__Erc1155BalanceClient<$Result.GetResult<Prisma.$Erc1155BalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Erc1155Balance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erc1155BalanceFindFirstOrThrowArgs} args - Arguments to find a Erc1155Balance
     * @example
     * // Get one Erc1155Balance
     * const erc1155Balance = await prisma.erc1155Balance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Erc1155BalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, Erc1155BalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__Erc1155BalanceClient<$Result.GetResult<Prisma.$Erc1155BalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Erc1155Balances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erc1155BalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Erc1155Balances
     * const erc1155Balances = await prisma.erc1155Balance.findMany()
     * 
     * // Get first 10 Erc1155Balances
     * const erc1155Balances = await prisma.erc1155Balance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const erc1155BalanceWithIdOnly = await prisma.erc1155Balance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Erc1155BalanceFindManyArgs>(args?: SelectSubset<T, Erc1155BalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Erc1155BalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Erc1155Balance.
     * @param {Erc1155BalanceCreateArgs} args - Arguments to create a Erc1155Balance.
     * @example
     * // Create one Erc1155Balance
     * const Erc1155Balance = await prisma.erc1155Balance.create({
     *   data: {
     *     // ... data to create a Erc1155Balance
     *   }
     * })
     * 
     */
    create<T extends Erc1155BalanceCreateArgs>(args: SelectSubset<T, Erc1155BalanceCreateArgs<ExtArgs>>): Prisma__Erc1155BalanceClient<$Result.GetResult<Prisma.$Erc1155BalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Erc1155Balances.
     * @param {Erc1155BalanceCreateManyArgs} args - Arguments to create many Erc1155Balances.
     * @example
     * // Create many Erc1155Balances
     * const erc1155Balance = await prisma.erc1155Balance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Erc1155BalanceCreateManyArgs>(args?: SelectSubset<T, Erc1155BalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Erc1155Balances and returns the data saved in the database.
     * @param {Erc1155BalanceCreateManyAndReturnArgs} args - Arguments to create many Erc1155Balances.
     * @example
     * // Create many Erc1155Balances
     * const erc1155Balance = await prisma.erc1155Balance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Erc1155Balances and only return the `id`
     * const erc1155BalanceWithIdOnly = await prisma.erc1155Balance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Erc1155BalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, Erc1155BalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Erc1155BalancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Erc1155Balance.
     * @param {Erc1155BalanceDeleteArgs} args - Arguments to delete one Erc1155Balance.
     * @example
     * // Delete one Erc1155Balance
     * const Erc1155Balance = await prisma.erc1155Balance.delete({
     *   where: {
     *     // ... filter to delete one Erc1155Balance
     *   }
     * })
     * 
     */
    delete<T extends Erc1155BalanceDeleteArgs>(args: SelectSubset<T, Erc1155BalanceDeleteArgs<ExtArgs>>): Prisma__Erc1155BalanceClient<$Result.GetResult<Prisma.$Erc1155BalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Erc1155Balance.
     * @param {Erc1155BalanceUpdateArgs} args - Arguments to update one Erc1155Balance.
     * @example
     * // Update one Erc1155Balance
     * const erc1155Balance = await prisma.erc1155Balance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Erc1155BalanceUpdateArgs>(args: SelectSubset<T, Erc1155BalanceUpdateArgs<ExtArgs>>): Prisma__Erc1155BalanceClient<$Result.GetResult<Prisma.$Erc1155BalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Erc1155Balances.
     * @param {Erc1155BalanceDeleteManyArgs} args - Arguments to filter Erc1155Balances to delete.
     * @example
     * // Delete a few Erc1155Balances
     * const { count } = await prisma.erc1155Balance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Erc1155BalanceDeleteManyArgs>(args?: SelectSubset<T, Erc1155BalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Erc1155Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erc1155BalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Erc1155Balances
     * const erc1155Balance = await prisma.erc1155Balance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Erc1155BalanceUpdateManyArgs>(args: SelectSubset<T, Erc1155BalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Erc1155Balances and returns the data updated in the database.
     * @param {Erc1155BalanceUpdateManyAndReturnArgs} args - Arguments to update many Erc1155Balances.
     * @example
     * // Update many Erc1155Balances
     * const erc1155Balance = await prisma.erc1155Balance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Erc1155Balances and only return the `id`
     * const erc1155BalanceWithIdOnly = await prisma.erc1155Balance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Erc1155BalanceUpdateManyAndReturnArgs>(args: SelectSubset<T, Erc1155BalanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Erc1155BalancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Erc1155Balance.
     * @param {Erc1155BalanceUpsertArgs} args - Arguments to update or create a Erc1155Balance.
     * @example
     * // Update or create a Erc1155Balance
     * const erc1155Balance = await prisma.erc1155Balance.upsert({
     *   create: {
     *     // ... data to create a Erc1155Balance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Erc1155Balance we want to update
     *   }
     * })
     */
    upsert<T extends Erc1155BalanceUpsertArgs>(args: SelectSubset<T, Erc1155BalanceUpsertArgs<ExtArgs>>): Prisma__Erc1155BalanceClient<$Result.GetResult<Prisma.$Erc1155BalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Erc1155Balances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erc1155BalanceCountArgs} args - Arguments to filter Erc1155Balances to count.
     * @example
     * // Count the number of Erc1155Balances
     * const count = await prisma.erc1155Balance.count({
     *   where: {
     *     // ... the filter for the Erc1155Balances we want to count
     *   }
     * })
    **/
    count<T extends Erc1155BalanceCountArgs>(
      args?: Subset<T, Erc1155BalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Erc1155BalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Erc1155Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erc1155BalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Erc1155BalanceAggregateArgs>(args: Subset<T, Erc1155BalanceAggregateArgs>): Prisma.PrismaPromise<GetErc1155BalanceAggregateType<T>>

    /**
     * Group by Erc1155Balance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erc1155BalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Erc1155BalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Erc1155BalanceGroupByArgs['orderBy'] }
        : { orderBy?: Erc1155BalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Erc1155BalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetErc1155BalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Erc1155Balance model
   */
  readonly fields: Erc1155BalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Erc1155Balance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Erc1155BalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    single1155<T extends Single1155DefaultArgs<ExtArgs> = {}>(args?: Subset<T, Single1155DefaultArgs<ExtArgs>>): Prisma__Single1155Client<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Erc1155Balance model
   */
  interface Erc1155BalanceFieldRefs {
    readonly id: FieldRef<"Erc1155Balance", 'String'>
    readonly single1155Id: FieldRef<"Erc1155Balance", 'String'>
    readonly ownerAddress: FieldRef<"Erc1155Balance", 'String'>
    readonly balance: FieldRef<"Erc1155Balance", 'Int'>
    readonly updatedAt: FieldRef<"Erc1155Balance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Erc1155Balance findUnique
   */
  export type Erc1155BalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Balance
     */
    select?: Erc1155BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Balance
     */
    omit?: Erc1155BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Erc1155BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Erc1155Balance to fetch.
     */
    where: Erc1155BalanceWhereUniqueInput
  }

  /**
   * Erc1155Balance findUniqueOrThrow
   */
  export type Erc1155BalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Balance
     */
    select?: Erc1155BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Balance
     */
    omit?: Erc1155BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Erc1155BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Erc1155Balance to fetch.
     */
    where: Erc1155BalanceWhereUniqueInput
  }

  /**
   * Erc1155Balance findFirst
   */
  export type Erc1155BalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Balance
     */
    select?: Erc1155BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Balance
     */
    omit?: Erc1155BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Erc1155BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Erc1155Balance to fetch.
     */
    where?: Erc1155BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Erc1155Balances to fetch.
     */
    orderBy?: Erc1155BalanceOrderByWithRelationInput | Erc1155BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Erc1155Balances.
     */
    cursor?: Erc1155BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Erc1155Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Erc1155Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Erc1155Balances.
     */
    distinct?: Erc1155BalanceScalarFieldEnum | Erc1155BalanceScalarFieldEnum[]
  }

  /**
   * Erc1155Balance findFirstOrThrow
   */
  export type Erc1155BalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Balance
     */
    select?: Erc1155BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Balance
     */
    omit?: Erc1155BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Erc1155BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Erc1155Balance to fetch.
     */
    where?: Erc1155BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Erc1155Balances to fetch.
     */
    orderBy?: Erc1155BalanceOrderByWithRelationInput | Erc1155BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Erc1155Balances.
     */
    cursor?: Erc1155BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Erc1155Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Erc1155Balances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Erc1155Balances.
     */
    distinct?: Erc1155BalanceScalarFieldEnum | Erc1155BalanceScalarFieldEnum[]
  }

  /**
   * Erc1155Balance findMany
   */
  export type Erc1155BalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Balance
     */
    select?: Erc1155BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Balance
     */
    omit?: Erc1155BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Erc1155BalanceInclude<ExtArgs> | null
    /**
     * Filter, which Erc1155Balances to fetch.
     */
    where?: Erc1155BalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Erc1155Balances to fetch.
     */
    orderBy?: Erc1155BalanceOrderByWithRelationInput | Erc1155BalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Erc1155Balances.
     */
    cursor?: Erc1155BalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Erc1155Balances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Erc1155Balances.
     */
    skip?: number
    distinct?: Erc1155BalanceScalarFieldEnum | Erc1155BalanceScalarFieldEnum[]
  }

  /**
   * Erc1155Balance create
   */
  export type Erc1155BalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Balance
     */
    select?: Erc1155BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Balance
     */
    omit?: Erc1155BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Erc1155BalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Erc1155Balance.
     */
    data: XOR<Erc1155BalanceCreateInput, Erc1155BalanceUncheckedCreateInput>
  }

  /**
   * Erc1155Balance createMany
   */
  export type Erc1155BalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Erc1155Balances.
     */
    data: Erc1155BalanceCreateManyInput | Erc1155BalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Erc1155Balance createManyAndReturn
   */
  export type Erc1155BalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Balance
     */
    select?: Erc1155BalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Balance
     */
    omit?: Erc1155BalanceOmit<ExtArgs> | null
    /**
     * The data used to create many Erc1155Balances.
     */
    data: Erc1155BalanceCreateManyInput | Erc1155BalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Erc1155BalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Erc1155Balance update
   */
  export type Erc1155BalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Balance
     */
    select?: Erc1155BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Balance
     */
    omit?: Erc1155BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Erc1155BalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Erc1155Balance.
     */
    data: XOR<Erc1155BalanceUpdateInput, Erc1155BalanceUncheckedUpdateInput>
    /**
     * Choose, which Erc1155Balance to update.
     */
    where: Erc1155BalanceWhereUniqueInput
  }

  /**
   * Erc1155Balance updateMany
   */
  export type Erc1155BalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Erc1155Balances.
     */
    data: XOR<Erc1155BalanceUpdateManyMutationInput, Erc1155BalanceUncheckedUpdateManyInput>
    /**
     * Filter which Erc1155Balances to update
     */
    where?: Erc1155BalanceWhereInput
    /**
     * Limit how many Erc1155Balances to update.
     */
    limit?: number
  }

  /**
   * Erc1155Balance updateManyAndReturn
   */
  export type Erc1155BalanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Balance
     */
    select?: Erc1155BalanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Balance
     */
    omit?: Erc1155BalanceOmit<ExtArgs> | null
    /**
     * The data used to update Erc1155Balances.
     */
    data: XOR<Erc1155BalanceUpdateManyMutationInput, Erc1155BalanceUncheckedUpdateManyInput>
    /**
     * Filter which Erc1155Balances to update
     */
    where?: Erc1155BalanceWhereInput
    /**
     * Limit how many Erc1155Balances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Erc1155BalanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Erc1155Balance upsert
   */
  export type Erc1155BalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Balance
     */
    select?: Erc1155BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Balance
     */
    omit?: Erc1155BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Erc1155BalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Erc1155Balance to update in case it exists.
     */
    where: Erc1155BalanceWhereUniqueInput
    /**
     * In case the Erc1155Balance found by the `where` argument doesn't exist, create a new Erc1155Balance with this data.
     */
    create: XOR<Erc1155BalanceCreateInput, Erc1155BalanceUncheckedCreateInput>
    /**
     * In case the Erc1155Balance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Erc1155BalanceUpdateInput, Erc1155BalanceUncheckedUpdateInput>
  }

  /**
   * Erc1155Balance delete
   */
  export type Erc1155BalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Balance
     */
    select?: Erc1155BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Balance
     */
    omit?: Erc1155BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Erc1155BalanceInclude<ExtArgs> | null
    /**
     * Filter which Erc1155Balance to delete.
     */
    where: Erc1155BalanceWhereUniqueInput
  }

  /**
   * Erc1155Balance deleteMany
   */
  export type Erc1155BalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Erc1155Balances to delete
     */
    where?: Erc1155BalanceWhereInput
    /**
     * Limit how many Erc1155Balances to delete.
     */
    limit?: number
  }

  /**
   * Erc1155Balance without action
   */
  export type Erc1155BalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Balance
     */
    select?: Erc1155BalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Balance
     */
    omit?: Erc1155BalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Erc1155BalanceInclude<ExtArgs> | null
  }


  /**
   * Model Erc1155Holding
   */

  export type AggregateErc1155Holding = {
    _count: Erc1155HoldingCountAggregateOutputType | null
    _avg: Erc1155HoldingAvgAggregateOutputType | null
    _sum: Erc1155HoldingSumAggregateOutputType | null
    _min: Erc1155HoldingMinAggregateOutputType | null
    _max: Erc1155HoldingMaxAggregateOutputType | null
  }

  export type Erc1155HoldingAvgAggregateOutputType = {
    balance: number | null
  }

  export type Erc1155HoldingSumAggregateOutputType = {
    balance: number | null
  }

  export type Erc1155HoldingMinAggregateOutputType = {
    id: string | null
    contract: string | null
    tokenId: string | null
    ownerAddress: string | null
    balance: number | null
    updatedAt: Date | null
  }

  export type Erc1155HoldingMaxAggregateOutputType = {
    id: string | null
    contract: string | null
    tokenId: string | null
    ownerAddress: string | null
    balance: number | null
    updatedAt: Date | null
  }

  export type Erc1155HoldingCountAggregateOutputType = {
    id: number
    contract: number
    tokenId: number
    ownerAddress: number
    balance: number
    updatedAt: number
    _all: number
  }


  export type Erc1155HoldingAvgAggregateInputType = {
    balance?: true
  }

  export type Erc1155HoldingSumAggregateInputType = {
    balance?: true
  }

  export type Erc1155HoldingMinAggregateInputType = {
    id?: true
    contract?: true
    tokenId?: true
    ownerAddress?: true
    balance?: true
    updatedAt?: true
  }

  export type Erc1155HoldingMaxAggregateInputType = {
    id?: true
    contract?: true
    tokenId?: true
    ownerAddress?: true
    balance?: true
    updatedAt?: true
  }

  export type Erc1155HoldingCountAggregateInputType = {
    id?: true
    contract?: true
    tokenId?: true
    ownerAddress?: true
    balance?: true
    updatedAt?: true
    _all?: true
  }

  export type Erc1155HoldingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Erc1155Holding to aggregate.
     */
    where?: Erc1155HoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Erc1155Holdings to fetch.
     */
    orderBy?: Erc1155HoldingOrderByWithRelationInput | Erc1155HoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Erc1155HoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Erc1155Holdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Erc1155Holdings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Erc1155Holdings
    **/
    _count?: true | Erc1155HoldingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Erc1155HoldingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Erc1155HoldingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Erc1155HoldingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Erc1155HoldingMaxAggregateInputType
  }

  export type GetErc1155HoldingAggregateType<T extends Erc1155HoldingAggregateArgs> = {
        [P in keyof T & keyof AggregateErc1155Holding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateErc1155Holding[P]>
      : GetScalarType<T[P], AggregateErc1155Holding[P]>
  }




  export type Erc1155HoldingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Erc1155HoldingWhereInput
    orderBy?: Erc1155HoldingOrderByWithAggregationInput | Erc1155HoldingOrderByWithAggregationInput[]
    by: Erc1155HoldingScalarFieldEnum[] | Erc1155HoldingScalarFieldEnum
    having?: Erc1155HoldingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Erc1155HoldingCountAggregateInputType | true
    _avg?: Erc1155HoldingAvgAggregateInputType
    _sum?: Erc1155HoldingSumAggregateInputType
    _min?: Erc1155HoldingMinAggregateInputType
    _max?: Erc1155HoldingMaxAggregateInputType
  }

  export type Erc1155HoldingGroupByOutputType = {
    id: string
    contract: string
    tokenId: string
    ownerAddress: string
    balance: number
    updatedAt: Date
    _count: Erc1155HoldingCountAggregateOutputType | null
    _avg: Erc1155HoldingAvgAggregateOutputType | null
    _sum: Erc1155HoldingSumAggregateOutputType | null
    _min: Erc1155HoldingMinAggregateOutputType | null
    _max: Erc1155HoldingMaxAggregateOutputType | null
  }

  type GetErc1155HoldingGroupByPayload<T extends Erc1155HoldingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Erc1155HoldingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Erc1155HoldingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Erc1155HoldingGroupByOutputType[P]>
            : GetScalarType<T[P], Erc1155HoldingGroupByOutputType[P]>
        }
      >
    >


  export type Erc1155HoldingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    ownerAddress?: boolean
    balance?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["erc1155Holding"]>

  export type Erc1155HoldingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    ownerAddress?: boolean
    balance?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["erc1155Holding"]>

  export type Erc1155HoldingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    ownerAddress?: boolean
    balance?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["erc1155Holding"]>

  export type Erc1155HoldingSelectScalar = {
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    ownerAddress?: boolean
    balance?: boolean
    updatedAt?: boolean
  }

  export type Erc1155HoldingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contract" | "tokenId" | "ownerAddress" | "balance" | "updatedAt", ExtArgs["result"]["erc1155Holding"]>

  export type $Erc1155HoldingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Erc1155Holding"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contract: string
      tokenId: string
      ownerAddress: string
      balance: number
      updatedAt: Date
    }, ExtArgs["result"]["erc1155Holding"]>
    composites: {}
  }

  type Erc1155HoldingGetPayload<S extends boolean | null | undefined | Erc1155HoldingDefaultArgs> = $Result.GetResult<Prisma.$Erc1155HoldingPayload, S>

  type Erc1155HoldingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Erc1155HoldingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Erc1155HoldingCountAggregateInputType | true
    }

  export interface Erc1155HoldingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Erc1155Holding'], meta: { name: 'Erc1155Holding' } }
    /**
     * Find zero or one Erc1155Holding that matches the filter.
     * @param {Erc1155HoldingFindUniqueArgs} args - Arguments to find a Erc1155Holding
     * @example
     * // Get one Erc1155Holding
     * const erc1155Holding = await prisma.erc1155Holding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Erc1155HoldingFindUniqueArgs>(args: SelectSubset<T, Erc1155HoldingFindUniqueArgs<ExtArgs>>): Prisma__Erc1155HoldingClient<$Result.GetResult<Prisma.$Erc1155HoldingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Erc1155Holding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Erc1155HoldingFindUniqueOrThrowArgs} args - Arguments to find a Erc1155Holding
     * @example
     * // Get one Erc1155Holding
     * const erc1155Holding = await prisma.erc1155Holding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Erc1155HoldingFindUniqueOrThrowArgs>(args: SelectSubset<T, Erc1155HoldingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Erc1155HoldingClient<$Result.GetResult<Prisma.$Erc1155HoldingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Erc1155Holding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erc1155HoldingFindFirstArgs} args - Arguments to find a Erc1155Holding
     * @example
     * // Get one Erc1155Holding
     * const erc1155Holding = await prisma.erc1155Holding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Erc1155HoldingFindFirstArgs>(args?: SelectSubset<T, Erc1155HoldingFindFirstArgs<ExtArgs>>): Prisma__Erc1155HoldingClient<$Result.GetResult<Prisma.$Erc1155HoldingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Erc1155Holding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erc1155HoldingFindFirstOrThrowArgs} args - Arguments to find a Erc1155Holding
     * @example
     * // Get one Erc1155Holding
     * const erc1155Holding = await prisma.erc1155Holding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Erc1155HoldingFindFirstOrThrowArgs>(args?: SelectSubset<T, Erc1155HoldingFindFirstOrThrowArgs<ExtArgs>>): Prisma__Erc1155HoldingClient<$Result.GetResult<Prisma.$Erc1155HoldingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Erc1155Holdings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erc1155HoldingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Erc1155Holdings
     * const erc1155Holdings = await prisma.erc1155Holding.findMany()
     * 
     * // Get first 10 Erc1155Holdings
     * const erc1155Holdings = await prisma.erc1155Holding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const erc1155HoldingWithIdOnly = await prisma.erc1155Holding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Erc1155HoldingFindManyArgs>(args?: SelectSubset<T, Erc1155HoldingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Erc1155HoldingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Erc1155Holding.
     * @param {Erc1155HoldingCreateArgs} args - Arguments to create a Erc1155Holding.
     * @example
     * // Create one Erc1155Holding
     * const Erc1155Holding = await prisma.erc1155Holding.create({
     *   data: {
     *     // ... data to create a Erc1155Holding
     *   }
     * })
     * 
     */
    create<T extends Erc1155HoldingCreateArgs>(args: SelectSubset<T, Erc1155HoldingCreateArgs<ExtArgs>>): Prisma__Erc1155HoldingClient<$Result.GetResult<Prisma.$Erc1155HoldingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Erc1155Holdings.
     * @param {Erc1155HoldingCreateManyArgs} args - Arguments to create many Erc1155Holdings.
     * @example
     * // Create many Erc1155Holdings
     * const erc1155Holding = await prisma.erc1155Holding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Erc1155HoldingCreateManyArgs>(args?: SelectSubset<T, Erc1155HoldingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Erc1155Holdings and returns the data saved in the database.
     * @param {Erc1155HoldingCreateManyAndReturnArgs} args - Arguments to create many Erc1155Holdings.
     * @example
     * // Create many Erc1155Holdings
     * const erc1155Holding = await prisma.erc1155Holding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Erc1155Holdings and only return the `id`
     * const erc1155HoldingWithIdOnly = await prisma.erc1155Holding.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends Erc1155HoldingCreateManyAndReturnArgs>(args?: SelectSubset<T, Erc1155HoldingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Erc1155HoldingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Erc1155Holding.
     * @param {Erc1155HoldingDeleteArgs} args - Arguments to delete one Erc1155Holding.
     * @example
     * // Delete one Erc1155Holding
     * const Erc1155Holding = await prisma.erc1155Holding.delete({
     *   where: {
     *     // ... filter to delete one Erc1155Holding
     *   }
     * })
     * 
     */
    delete<T extends Erc1155HoldingDeleteArgs>(args: SelectSubset<T, Erc1155HoldingDeleteArgs<ExtArgs>>): Prisma__Erc1155HoldingClient<$Result.GetResult<Prisma.$Erc1155HoldingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Erc1155Holding.
     * @param {Erc1155HoldingUpdateArgs} args - Arguments to update one Erc1155Holding.
     * @example
     * // Update one Erc1155Holding
     * const erc1155Holding = await prisma.erc1155Holding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Erc1155HoldingUpdateArgs>(args: SelectSubset<T, Erc1155HoldingUpdateArgs<ExtArgs>>): Prisma__Erc1155HoldingClient<$Result.GetResult<Prisma.$Erc1155HoldingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Erc1155Holdings.
     * @param {Erc1155HoldingDeleteManyArgs} args - Arguments to filter Erc1155Holdings to delete.
     * @example
     * // Delete a few Erc1155Holdings
     * const { count } = await prisma.erc1155Holding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Erc1155HoldingDeleteManyArgs>(args?: SelectSubset<T, Erc1155HoldingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Erc1155Holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erc1155HoldingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Erc1155Holdings
     * const erc1155Holding = await prisma.erc1155Holding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Erc1155HoldingUpdateManyArgs>(args: SelectSubset<T, Erc1155HoldingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Erc1155Holdings and returns the data updated in the database.
     * @param {Erc1155HoldingUpdateManyAndReturnArgs} args - Arguments to update many Erc1155Holdings.
     * @example
     * // Update many Erc1155Holdings
     * const erc1155Holding = await prisma.erc1155Holding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Erc1155Holdings and only return the `id`
     * const erc1155HoldingWithIdOnly = await prisma.erc1155Holding.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends Erc1155HoldingUpdateManyAndReturnArgs>(args: SelectSubset<T, Erc1155HoldingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Erc1155HoldingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Erc1155Holding.
     * @param {Erc1155HoldingUpsertArgs} args - Arguments to update or create a Erc1155Holding.
     * @example
     * // Update or create a Erc1155Holding
     * const erc1155Holding = await prisma.erc1155Holding.upsert({
     *   create: {
     *     // ... data to create a Erc1155Holding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Erc1155Holding we want to update
     *   }
     * })
     */
    upsert<T extends Erc1155HoldingUpsertArgs>(args: SelectSubset<T, Erc1155HoldingUpsertArgs<ExtArgs>>): Prisma__Erc1155HoldingClient<$Result.GetResult<Prisma.$Erc1155HoldingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Erc1155Holdings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erc1155HoldingCountArgs} args - Arguments to filter Erc1155Holdings to count.
     * @example
     * // Count the number of Erc1155Holdings
     * const count = await prisma.erc1155Holding.count({
     *   where: {
     *     // ... the filter for the Erc1155Holdings we want to count
     *   }
     * })
    **/
    count<T extends Erc1155HoldingCountArgs>(
      args?: Subset<T, Erc1155HoldingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Erc1155HoldingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Erc1155Holding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erc1155HoldingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Erc1155HoldingAggregateArgs>(args: Subset<T, Erc1155HoldingAggregateArgs>): Prisma.PrismaPromise<GetErc1155HoldingAggregateType<T>>

    /**
     * Group by Erc1155Holding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erc1155HoldingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Erc1155HoldingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Erc1155HoldingGroupByArgs['orderBy'] }
        : { orderBy?: Erc1155HoldingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Erc1155HoldingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetErc1155HoldingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Erc1155Holding model
   */
  readonly fields: Erc1155HoldingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Erc1155Holding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Erc1155HoldingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Erc1155Holding model
   */
  interface Erc1155HoldingFieldRefs {
    readonly id: FieldRef<"Erc1155Holding", 'String'>
    readonly contract: FieldRef<"Erc1155Holding", 'String'>
    readonly tokenId: FieldRef<"Erc1155Holding", 'String'>
    readonly ownerAddress: FieldRef<"Erc1155Holding", 'String'>
    readonly balance: FieldRef<"Erc1155Holding", 'Int'>
    readonly updatedAt: FieldRef<"Erc1155Holding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Erc1155Holding findUnique
   */
  export type Erc1155HoldingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Holding
     */
    select?: Erc1155HoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Holding
     */
    omit?: Erc1155HoldingOmit<ExtArgs> | null
    /**
     * Filter, which Erc1155Holding to fetch.
     */
    where: Erc1155HoldingWhereUniqueInput
  }

  /**
   * Erc1155Holding findUniqueOrThrow
   */
  export type Erc1155HoldingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Holding
     */
    select?: Erc1155HoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Holding
     */
    omit?: Erc1155HoldingOmit<ExtArgs> | null
    /**
     * Filter, which Erc1155Holding to fetch.
     */
    where: Erc1155HoldingWhereUniqueInput
  }

  /**
   * Erc1155Holding findFirst
   */
  export type Erc1155HoldingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Holding
     */
    select?: Erc1155HoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Holding
     */
    omit?: Erc1155HoldingOmit<ExtArgs> | null
    /**
     * Filter, which Erc1155Holding to fetch.
     */
    where?: Erc1155HoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Erc1155Holdings to fetch.
     */
    orderBy?: Erc1155HoldingOrderByWithRelationInput | Erc1155HoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Erc1155Holdings.
     */
    cursor?: Erc1155HoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Erc1155Holdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Erc1155Holdings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Erc1155Holdings.
     */
    distinct?: Erc1155HoldingScalarFieldEnum | Erc1155HoldingScalarFieldEnum[]
  }

  /**
   * Erc1155Holding findFirstOrThrow
   */
  export type Erc1155HoldingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Holding
     */
    select?: Erc1155HoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Holding
     */
    omit?: Erc1155HoldingOmit<ExtArgs> | null
    /**
     * Filter, which Erc1155Holding to fetch.
     */
    where?: Erc1155HoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Erc1155Holdings to fetch.
     */
    orderBy?: Erc1155HoldingOrderByWithRelationInput | Erc1155HoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Erc1155Holdings.
     */
    cursor?: Erc1155HoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Erc1155Holdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Erc1155Holdings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Erc1155Holdings.
     */
    distinct?: Erc1155HoldingScalarFieldEnum | Erc1155HoldingScalarFieldEnum[]
  }

  /**
   * Erc1155Holding findMany
   */
  export type Erc1155HoldingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Holding
     */
    select?: Erc1155HoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Holding
     */
    omit?: Erc1155HoldingOmit<ExtArgs> | null
    /**
     * Filter, which Erc1155Holdings to fetch.
     */
    where?: Erc1155HoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Erc1155Holdings to fetch.
     */
    orderBy?: Erc1155HoldingOrderByWithRelationInput | Erc1155HoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Erc1155Holdings.
     */
    cursor?: Erc1155HoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Erc1155Holdings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Erc1155Holdings.
     */
    skip?: number
    distinct?: Erc1155HoldingScalarFieldEnum | Erc1155HoldingScalarFieldEnum[]
  }

  /**
   * Erc1155Holding create
   */
  export type Erc1155HoldingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Holding
     */
    select?: Erc1155HoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Holding
     */
    omit?: Erc1155HoldingOmit<ExtArgs> | null
    /**
     * The data needed to create a Erc1155Holding.
     */
    data: XOR<Erc1155HoldingCreateInput, Erc1155HoldingUncheckedCreateInput>
  }

  /**
   * Erc1155Holding createMany
   */
  export type Erc1155HoldingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Erc1155Holdings.
     */
    data: Erc1155HoldingCreateManyInput | Erc1155HoldingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Erc1155Holding createManyAndReturn
   */
  export type Erc1155HoldingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Holding
     */
    select?: Erc1155HoldingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Holding
     */
    omit?: Erc1155HoldingOmit<ExtArgs> | null
    /**
     * The data used to create many Erc1155Holdings.
     */
    data: Erc1155HoldingCreateManyInput | Erc1155HoldingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Erc1155Holding update
   */
  export type Erc1155HoldingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Holding
     */
    select?: Erc1155HoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Holding
     */
    omit?: Erc1155HoldingOmit<ExtArgs> | null
    /**
     * The data needed to update a Erc1155Holding.
     */
    data: XOR<Erc1155HoldingUpdateInput, Erc1155HoldingUncheckedUpdateInput>
    /**
     * Choose, which Erc1155Holding to update.
     */
    where: Erc1155HoldingWhereUniqueInput
  }

  /**
   * Erc1155Holding updateMany
   */
  export type Erc1155HoldingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Erc1155Holdings.
     */
    data: XOR<Erc1155HoldingUpdateManyMutationInput, Erc1155HoldingUncheckedUpdateManyInput>
    /**
     * Filter which Erc1155Holdings to update
     */
    where?: Erc1155HoldingWhereInput
    /**
     * Limit how many Erc1155Holdings to update.
     */
    limit?: number
  }

  /**
   * Erc1155Holding updateManyAndReturn
   */
  export type Erc1155HoldingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Holding
     */
    select?: Erc1155HoldingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Holding
     */
    omit?: Erc1155HoldingOmit<ExtArgs> | null
    /**
     * The data used to update Erc1155Holdings.
     */
    data: XOR<Erc1155HoldingUpdateManyMutationInput, Erc1155HoldingUncheckedUpdateManyInput>
    /**
     * Filter which Erc1155Holdings to update
     */
    where?: Erc1155HoldingWhereInput
    /**
     * Limit how many Erc1155Holdings to update.
     */
    limit?: number
  }

  /**
   * Erc1155Holding upsert
   */
  export type Erc1155HoldingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Holding
     */
    select?: Erc1155HoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Holding
     */
    omit?: Erc1155HoldingOmit<ExtArgs> | null
    /**
     * The filter to search for the Erc1155Holding to update in case it exists.
     */
    where: Erc1155HoldingWhereUniqueInput
    /**
     * In case the Erc1155Holding found by the `where` argument doesn't exist, create a new Erc1155Holding with this data.
     */
    create: XOR<Erc1155HoldingCreateInput, Erc1155HoldingUncheckedCreateInput>
    /**
     * In case the Erc1155Holding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Erc1155HoldingUpdateInput, Erc1155HoldingUncheckedUpdateInput>
  }

  /**
   * Erc1155Holding delete
   */
  export type Erc1155HoldingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Holding
     */
    select?: Erc1155HoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Holding
     */
    omit?: Erc1155HoldingOmit<ExtArgs> | null
    /**
     * Filter which Erc1155Holding to delete.
     */
    where: Erc1155HoldingWhereUniqueInput
  }

  /**
   * Erc1155Holding deleteMany
   */
  export type Erc1155HoldingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Erc1155Holdings to delete
     */
    where?: Erc1155HoldingWhereInput
    /**
     * Limit how many Erc1155Holdings to delete.
     */
    limit?: number
  }

  /**
   * Erc1155Holding without action
   */
  export type Erc1155HoldingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Erc1155Holding
     */
    select?: Erc1155HoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Erc1155Holding
     */
    omit?: Erc1155HoldingOmit<ExtArgs> | null
  }


  /**
   * Model MarketplaceListing
   */

  export type AggregateMarketplaceListing = {
    _count: MarketplaceListingCountAggregateOutputType | null
    _avg: MarketplaceListingAvgAggregateOutputType | null
    _sum: MarketplaceListingSumAggregateOutputType | null
    _min: MarketplaceListingMinAggregateOutputType | null
    _max: MarketplaceListingMaxAggregateOutputType | null
  }

  export type MarketplaceListingAvgAggregateOutputType = {
    quantity: number | null
    priceEtnWei: Decimal | null
    priceTokenAmount: Decimal | null
  }

  export type MarketplaceListingSumAggregateOutputType = {
    quantity: number | null
    priceEtnWei: Decimal | null
    priceTokenAmount: Decimal | null
  }

  export type MarketplaceListingMinAggregateOutputType = {
    id: string | null
    nftId: string | null
    sellerAddress: string | null
    quantity: number | null
    priceEtnWei: Decimal | null
    currencyId: string | null
    priceTokenAmount: Decimal | null
    status: $Enums.ListingStatus | null
    startTime: Date | null
    endTime: Date | null
    txHashCreated: string | null
    txHashFilled: string | null
    txHashCancelled: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketplaceListingMaxAggregateOutputType = {
    id: string | null
    nftId: string | null
    sellerAddress: string | null
    quantity: number | null
    priceEtnWei: Decimal | null
    currencyId: string | null
    priceTokenAmount: Decimal | null
    status: $Enums.ListingStatus | null
    startTime: Date | null
    endTime: Date | null
    txHashCreated: string | null
    txHashFilled: string | null
    txHashCancelled: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketplaceListingCountAggregateOutputType = {
    id: number
    nftId: number
    sellerAddress: number
    quantity: number
    priceEtnWei: number
    currencyId: number
    priceTokenAmount: number
    status: number
    startTime: number
    endTime: number
    txHashCreated: number
    txHashFilled: number
    txHashCancelled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketplaceListingAvgAggregateInputType = {
    quantity?: true
    priceEtnWei?: true
    priceTokenAmount?: true
  }

  export type MarketplaceListingSumAggregateInputType = {
    quantity?: true
    priceEtnWei?: true
    priceTokenAmount?: true
  }

  export type MarketplaceListingMinAggregateInputType = {
    id?: true
    nftId?: true
    sellerAddress?: true
    quantity?: true
    priceEtnWei?: true
    currencyId?: true
    priceTokenAmount?: true
    status?: true
    startTime?: true
    endTime?: true
    txHashCreated?: true
    txHashFilled?: true
    txHashCancelled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketplaceListingMaxAggregateInputType = {
    id?: true
    nftId?: true
    sellerAddress?: true
    quantity?: true
    priceEtnWei?: true
    currencyId?: true
    priceTokenAmount?: true
    status?: true
    startTime?: true
    endTime?: true
    txHashCreated?: true
    txHashFilled?: true
    txHashCancelled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketplaceListingCountAggregateInputType = {
    id?: true
    nftId?: true
    sellerAddress?: true
    quantity?: true
    priceEtnWei?: true
    currencyId?: true
    priceTokenAmount?: true
    status?: true
    startTime?: true
    endTime?: true
    txHashCreated?: true
    txHashFilled?: true
    txHashCancelled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketplaceListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceListing to aggregate.
     */
    where?: MarketplaceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceListings to fetch.
     */
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketplaceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketplaceListings
    **/
    _count?: true | MarketplaceListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketplaceListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketplaceListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketplaceListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketplaceListingMaxAggregateInputType
  }

  export type GetMarketplaceListingAggregateType<T extends MarketplaceListingAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketplaceListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketplaceListing[P]>
      : GetScalarType<T[P], AggregateMarketplaceListing[P]>
  }




  export type MarketplaceListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceListingWhereInput
    orderBy?: MarketplaceListingOrderByWithAggregationInput | MarketplaceListingOrderByWithAggregationInput[]
    by: MarketplaceListingScalarFieldEnum[] | MarketplaceListingScalarFieldEnum
    having?: MarketplaceListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketplaceListingCountAggregateInputType | true
    _avg?: MarketplaceListingAvgAggregateInputType
    _sum?: MarketplaceListingSumAggregateInputType
    _min?: MarketplaceListingMinAggregateInputType
    _max?: MarketplaceListingMaxAggregateInputType
  }

  export type MarketplaceListingGroupByOutputType = {
    id: string
    nftId: string
    sellerAddress: string
    quantity: number
    priceEtnWei: Decimal
    currencyId: string | null
    priceTokenAmount: Decimal | null
    status: $Enums.ListingStatus
    startTime: Date
    endTime: Date | null
    txHashCreated: string | null
    txHashFilled: string | null
    txHashCancelled: string | null
    createdAt: Date
    updatedAt: Date
    _count: MarketplaceListingCountAggregateOutputType | null
    _avg: MarketplaceListingAvgAggregateOutputType | null
    _sum: MarketplaceListingSumAggregateOutputType | null
    _min: MarketplaceListingMinAggregateOutputType | null
    _max: MarketplaceListingMaxAggregateOutputType | null
  }

  type GetMarketplaceListingGroupByPayload<T extends MarketplaceListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketplaceListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketplaceListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketplaceListingGroupByOutputType[P]>
            : GetScalarType<T[P], MarketplaceListingGroupByOutputType[P]>
        }
      >
    >


  export type MarketplaceListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nftId?: boolean
    sellerAddress?: boolean
    quantity?: boolean
    priceEtnWei?: boolean
    currencyId?: boolean
    priceTokenAmount?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    txHashCreated?: boolean
    txHashFilled?: boolean
    txHashCancelled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean | MarketplaceListing$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceListing"]>

  export type MarketplaceListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nftId?: boolean
    sellerAddress?: boolean
    quantity?: boolean
    priceEtnWei?: boolean
    currencyId?: boolean
    priceTokenAmount?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    txHashCreated?: boolean
    txHashFilled?: boolean
    txHashCancelled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean | MarketplaceListing$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceListing"]>

  export type MarketplaceListingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nftId?: boolean
    sellerAddress?: boolean
    quantity?: boolean
    priceEtnWei?: boolean
    currencyId?: boolean
    priceTokenAmount?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    txHashCreated?: boolean
    txHashFilled?: boolean
    txHashCancelled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean | MarketplaceListing$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceListing"]>

  export type MarketplaceListingSelectScalar = {
    id?: boolean
    nftId?: boolean
    sellerAddress?: boolean
    quantity?: boolean
    priceEtnWei?: boolean
    currencyId?: boolean
    priceTokenAmount?: boolean
    status?: boolean
    startTime?: boolean
    endTime?: boolean
    txHashCreated?: boolean
    txHashFilled?: boolean
    txHashCancelled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketplaceListingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nftId" | "sellerAddress" | "quantity" | "priceEtnWei" | "currencyId" | "priceTokenAmount" | "status" | "startTime" | "endTime" | "txHashCreated" | "txHashFilled" | "txHashCancelled" | "createdAt" | "updatedAt", ExtArgs["result"]["marketplaceListing"]>
  export type MarketplaceListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | MarketplaceListing$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }
  export type MarketplaceListingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | MarketplaceListing$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }
  export type MarketplaceListingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | MarketplaceListing$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }

  export type $MarketplaceListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketplaceListing"
    objects: {
      currency: Prisma.$CurrencyPayload<ExtArgs> | null
      nft: Prisma.$NFTPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nftId: string
      sellerAddress: string
      quantity: number
      priceEtnWei: Prisma.Decimal
      currencyId: string | null
      priceTokenAmount: Prisma.Decimal | null
      status: $Enums.ListingStatus
      startTime: Date
      endTime: Date | null
      txHashCreated: string | null
      txHashFilled: string | null
      txHashCancelled: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketplaceListing"]>
    composites: {}
  }

  type MarketplaceListingGetPayload<S extends boolean | null | undefined | MarketplaceListingDefaultArgs> = $Result.GetResult<Prisma.$MarketplaceListingPayload, S>

  type MarketplaceListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketplaceListingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketplaceListingCountAggregateInputType | true
    }

  export interface MarketplaceListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketplaceListing'], meta: { name: 'MarketplaceListing' } }
    /**
     * Find zero or one MarketplaceListing that matches the filter.
     * @param {MarketplaceListingFindUniqueArgs} args - Arguments to find a MarketplaceListing
     * @example
     * // Get one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketplaceListingFindUniqueArgs>(args: SelectSubset<T, MarketplaceListingFindUniqueArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketplaceListing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketplaceListingFindUniqueOrThrowArgs} args - Arguments to find a MarketplaceListing
     * @example
     * // Get one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketplaceListingFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketplaceListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketplaceListing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingFindFirstArgs} args - Arguments to find a MarketplaceListing
     * @example
     * // Get one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketplaceListingFindFirstArgs>(args?: SelectSubset<T, MarketplaceListingFindFirstArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketplaceListing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingFindFirstOrThrowArgs} args - Arguments to find a MarketplaceListing
     * @example
     * // Get one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketplaceListingFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketplaceListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketplaceListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketplaceListings
     * const marketplaceListings = await prisma.marketplaceListing.findMany()
     * 
     * // Get first 10 MarketplaceListings
     * const marketplaceListings = await prisma.marketplaceListing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketplaceListingWithIdOnly = await prisma.marketplaceListing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketplaceListingFindManyArgs>(args?: SelectSubset<T, MarketplaceListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketplaceListing.
     * @param {MarketplaceListingCreateArgs} args - Arguments to create a MarketplaceListing.
     * @example
     * // Create one MarketplaceListing
     * const MarketplaceListing = await prisma.marketplaceListing.create({
     *   data: {
     *     // ... data to create a MarketplaceListing
     *   }
     * })
     * 
     */
    create<T extends MarketplaceListingCreateArgs>(args: SelectSubset<T, MarketplaceListingCreateArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketplaceListings.
     * @param {MarketplaceListingCreateManyArgs} args - Arguments to create many MarketplaceListings.
     * @example
     * // Create many MarketplaceListings
     * const marketplaceListing = await prisma.marketplaceListing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketplaceListingCreateManyArgs>(args?: SelectSubset<T, MarketplaceListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketplaceListings and returns the data saved in the database.
     * @param {MarketplaceListingCreateManyAndReturnArgs} args - Arguments to create many MarketplaceListings.
     * @example
     * // Create many MarketplaceListings
     * const marketplaceListing = await prisma.marketplaceListing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketplaceListings and only return the `id`
     * const marketplaceListingWithIdOnly = await prisma.marketplaceListing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketplaceListingCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketplaceListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketplaceListing.
     * @param {MarketplaceListingDeleteArgs} args - Arguments to delete one MarketplaceListing.
     * @example
     * // Delete one MarketplaceListing
     * const MarketplaceListing = await prisma.marketplaceListing.delete({
     *   where: {
     *     // ... filter to delete one MarketplaceListing
     *   }
     * })
     * 
     */
    delete<T extends MarketplaceListingDeleteArgs>(args: SelectSubset<T, MarketplaceListingDeleteArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketplaceListing.
     * @param {MarketplaceListingUpdateArgs} args - Arguments to update one MarketplaceListing.
     * @example
     * // Update one MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketplaceListingUpdateArgs>(args: SelectSubset<T, MarketplaceListingUpdateArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketplaceListings.
     * @param {MarketplaceListingDeleteManyArgs} args - Arguments to filter MarketplaceListings to delete.
     * @example
     * // Delete a few MarketplaceListings
     * const { count } = await prisma.marketplaceListing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketplaceListingDeleteManyArgs>(args?: SelectSubset<T, MarketplaceListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketplaceListings
     * const marketplaceListing = await prisma.marketplaceListing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketplaceListingUpdateManyArgs>(args: SelectSubset<T, MarketplaceListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceListings and returns the data updated in the database.
     * @param {MarketplaceListingUpdateManyAndReturnArgs} args - Arguments to update many MarketplaceListings.
     * @example
     * // Update many MarketplaceListings
     * const marketplaceListing = await prisma.marketplaceListing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketplaceListings and only return the `id`
     * const marketplaceListingWithIdOnly = await prisma.marketplaceListing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketplaceListingUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketplaceListingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketplaceListing.
     * @param {MarketplaceListingUpsertArgs} args - Arguments to update or create a MarketplaceListing.
     * @example
     * // Update or create a MarketplaceListing
     * const marketplaceListing = await prisma.marketplaceListing.upsert({
     *   create: {
     *     // ... data to create a MarketplaceListing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketplaceListing we want to update
     *   }
     * })
     */
    upsert<T extends MarketplaceListingUpsertArgs>(args: SelectSubset<T, MarketplaceListingUpsertArgs<ExtArgs>>): Prisma__MarketplaceListingClient<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketplaceListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingCountArgs} args - Arguments to filter MarketplaceListings to count.
     * @example
     * // Count the number of MarketplaceListings
     * const count = await prisma.marketplaceListing.count({
     *   where: {
     *     // ... the filter for the MarketplaceListings we want to count
     *   }
     * })
    **/
    count<T extends MarketplaceListingCountArgs>(
      args?: Subset<T, MarketplaceListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketplaceListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketplaceListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketplaceListingAggregateArgs>(args: Subset<T, MarketplaceListingAggregateArgs>): Prisma.PrismaPromise<GetMarketplaceListingAggregateType<T>>

    /**
     * Group by MarketplaceListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketplaceListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketplaceListingGroupByArgs['orderBy'] }
        : { orderBy?: MarketplaceListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketplaceListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketplaceListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketplaceListing model
   */
  readonly fields: MarketplaceListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketplaceListing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketplaceListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currency<T extends MarketplaceListing$currencyArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceListing$currencyArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    nft<T extends NFTDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NFTDefaultArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketplaceListing model
   */
  interface MarketplaceListingFieldRefs {
    readonly id: FieldRef<"MarketplaceListing", 'String'>
    readonly nftId: FieldRef<"MarketplaceListing", 'String'>
    readonly sellerAddress: FieldRef<"MarketplaceListing", 'String'>
    readonly quantity: FieldRef<"MarketplaceListing", 'Int'>
    readonly priceEtnWei: FieldRef<"MarketplaceListing", 'Decimal'>
    readonly currencyId: FieldRef<"MarketplaceListing", 'String'>
    readonly priceTokenAmount: FieldRef<"MarketplaceListing", 'Decimal'>
    readonly status: FieldRef<"MarketplaceListing", 'ListingStatus'>
    readonly startTime: FieldRef<"MarketplaceListing", 'DateTime'>
    readonly endTime: FieldRef<"MarketplaceListing", 'DateTime'>
    readonly txHashCreated: FieldRef<"MarketplaceListing", 'String'>
    readonly txHashFilled: FieldRef<"MarketplaceListing", 'String'>
    readonly txHashCancelled: FieldRef<"MarketplaceListing", 'String'>
    readonly createdAt: FieldRef<"MarketplaceListing", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketplaceListing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketplaceListing findUnique
   */
  export type MarketplaceListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListing to fetch.
     */
    where: MarketplaceListingWhereUniqueInput
  }

  /**
   * MarketplaceListing findUniqueOrThrow
   */
  export type MarketplaceListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListing to fetch.
     */
    where: MarketplaceListingWhereUniqueInput
  }

  /**
   * MarketplaceListing findFirst
   */
  export type MarketplaceListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListing to fetch.
     */
    where?: MarketplaceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceListings to fetch.
     */
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceListings.
     */
    cursor?: MarketplaceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceListings.
     */
    distinct?: MarketplaceListingScalarFieldEnum | MarketplaceListingScalarFieldEnum[]
  }

  /**
   * MarketplaceListing findFirstOrThrow
   */
  export type MarketplaceListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListing to fetch.
     */
    where?: MarketplaceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceListings to fetch.
     */
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceListings.
     */
    cursor?: MarketplaceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceListings.
     */
    distinct?: MarketplaceListingScalarFieldEnum | MarketplaceListingScalarFieldEnum[]
  }

  /**
   * MarketplaceListing findMany
   */
  export type MarketplaceListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceListings to fetch.
     */
    where?: MarketplaceListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceListings to fetch.
     */
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketplaceListings.
     */
    cursor?: MarketplaceListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceListings.
     */
    skip?: number
    distinct?: MarketplaceListingScalarFieldEnum | MarketplaceListingScalarFieldEnum[]
  }

  /**
   * MarketplaceListing create
   */
  export type MarketplaceListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketplaceListing.
     */
    data: XOR<MarketplaceListingCreateInput, MarketplaceListingUncheckedCreateInput>
  }

  /**
   * MarketplaceListing createMany
   */
  export type MarketplaceListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketplaceListings.
     */
    data: MarketplaceListingCreateManyInput | MarketplaceListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketplaceListing createManyAndReturn
   */
  export type MarketplaceListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * The data used to create many MarketplaceListings.
     */
    data: MarketplaceListingCreateManyInput | MarketplaceListingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketplaceListing update
   */
  export type MarketplaceListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketplaceListing.
     */
    data: XOR<MarketplaceListingUpdateInput, MarketplaceListingUncheckedUpdateInput>
    /**
     * Choose, which MarketplaceListing to update.
     */
    where: MarketplaceListingWhereUniqueInput
  }

  /**
   * MarketplaceListing updateMany
   */
  export type MarketplaceListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketplaceListings.
     */
    data: XOR<MarketplaceListingUpdateManyMutationInput, MarketplaceListingUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceListings to update
     */
    where?: MarketplaceListingWhereInput
    /**
     * Limit how many MarketplaceListings to update.
     */
    limit?: number
  }

  /**
   * MarketplaceListing updateManyAndReturn
   */
  export type MarketplaceListingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * The data used to update MarketplaceListings.
     */
    data: XOR<MarketplaceListingUpdateManyMutationInput, MarketplaceListingUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceListings to update
     */
    where?: MarketplaceListingWhereInput
    /**
     * Limit how many MarketplaceListings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketplaceListing upsert
   */
  export type MarketplaceListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketplaceListing to update in case it exists.
     */
    where: MarketplaceListingWhereUniqueInput
    /**
     * In case the MarketplaceListing found by the `where` argument doesn't exist, create a new MarketplaceListing with this data.
     */
    create: XOR<MarketplaceListingCreateInput, MarketplaceListingUncheckedCreateInput>
    /**
     * In case the MarketplaceListing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketplaceListingUpdateInput, MarketplaceListingUncheckedUpdateInput>
  }

  /**
   * MarketplaceListing delete
   */
  export type MarketplaceListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    /**
     * Filter which MarketplaceListing to delete.
     */
    where: MarketplaceListingWhereUniqueInput
  }

  /**
   * MarketplaceListing deleteMany
   */
  export type MarketplaceListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceListings to delete
     */
    where?: MarketplaceListingWhereInput
    /**
     * Limit how many MarketplaceListings to delete.
     */
    limit?: number
  }

  /**
   * MarketplaceListing.currency
   */
  export type MarketplaceListing$currencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    where?: CurrencyWhereInput
  }

  /**
   * MarketplaceListing without action
   */
  export type MarketplaceListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
  }


  /**
   * Model Auction
   */

  export type AggregateAuction = {
    _count: AuctionCountAggregateOutputType | null
    _avg: AuctionAvgAggregateOutputType | null
    _sum: AuctionSumAggregateOutputType | null
    _min: AuctionMinAggregateOutputType | null
    _max: AuctionMaxAggregateOutputType | null
  }

  export type AuctionAvgAggregateOutputType = {
    quantity: number | null
    startPriceEtnWei: Decimal | null
    highestBidEtnWei: Decimal | null
    minIncrementEtnWei: Decimal | null
    startPriceTokenAmount: Decimal | null
    highestBidTokenAmount: Decimal | null
    minIncrementTokenAmount: Decimal | null
  }

  export type AuctionSumAggregateOutputType = {
    quantity: number | null
    startPriceEtnWei: Decimal | null
    highestBidEtnWei: Decimal | null
    minIncrementEtnWei: Decimal | null
    startPriceTokenAmount: Decimal | null
    highestBidTokenAmount: Decimal | null
    minIncrementTokenAmount: Decimal | null
  }

  export type AuctionMinAggregateOutputType = {
    id: string | null
    nftId: string | null
    sellerAddress: string | null
    quantity: number | null
    startPriceEtnWei: Decimal | null
    highestBidEtnWei: Decimal | null
    minIncrementEtnWei: Decimal | null
    currencyId: string | null
    startPriceTokenAmount: Decimal | null
    highestBidTokenAmount: Decimal | null
    minIncrementTokenAmount: Decimal | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.AuctionStatus | null
    txHashCreated: string | null
    txHashFinalized: string | null
    txHashCancelled: string | null
    createdAt: Date | null
    updatedAt: Date | null
    highestBidder: string | null
  }

  export type AuctionMaxAggregateOutputType = {
    id: string | null
    nftId: string | null
    sellerAddress: string | null
    quantity: number | null
    startPriceEtnWei: Decimal | null
    highestBidEtnWei: Decimal | null
    minIncrementEtnWei: Decimal | null
    currencyId: string | null
    startPriceTokenAmount: Decimal | null
    highestBidTokenAmount: Decimal | null
    minIncrementTokenAmount: Decimal | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.AuctionStatus | null
    txHashCreated: string | null
    txHashFinalized: string | null
    txHashCancelled: string | null
    createdAt: Date | null
    updatedAt: Date | null
    highestBidder: string | null
  }

  export type AuctionCountAggregateOutputType = {
    id: number
    nftId: number
    sellerAddress: number
    quantity: number
    startPriceEtnWei: number
    highestBidEtnWei: number
    minIncrementEtnWei: number
    currencyId: number
    startPriceTokenAmount: number
    highestBidTokenAmount: number
    minIncrementTokenAmount: number
    startTime: number
    endTime: number
    status: number
    txHashCreated: number
    txHashFinalized: number
    txHashCancelled: number
    createdAt: number
    updatedAt: number
    highestBidder: number
    _all: number
  }


  export type AuctionAvgAggregateInputType = {
    quantity?: true
    startPriceEtnWei?: true
    highestBidEtnWei?: true
    minIncrementEtnWei?: true
    startPriceTokenAmount?: true
    highestBidTokenAmount?: true
    minIncrementTokenAmount?: true
  }

  export type AuctionSumAggregateInputType = {
    quantity?: true
    startPriceEtnWei?: true
    highestBidEtnWei?: true
    minIncrementEtnWei?: true
    startPriceTokenAmount?: true
    highestBidTokenAmount?: true
    minIncrementTokenAmount?: true
  }

  export type AuctionMinAggregateInputType = {
    id?: true
    nftId?: true
    sellerAddress?: true
    quantity?: true
    startPriceEtnWei?: true
    highestBidEtnWei?: true
    minIncrementEtnWei?: true
    currencyId?: true
    startPriceTokenAmount?: true
    highestBidTokenAmount?: true
    minIncrementTokenAmount?: true
    startTime?: true
    endTime?: true
    status?: true
    txHashCreated?: true
    txHashFinalized?: true
    txHashCancelled?: true
    createdAt?: true
    updatedAt?: true
    highestBidder?: true
  }

  export type AuctionMaxAggregateInputType = {
    id?: true
    nftId?: true
    sellerAddress?: true
    quantity?: true
    startPriceEtnWei?: true
    highestBidEtnWei?: true
    minIncrementEtnWei?: true
    currencyId?: true
    startPriceTokenAmount?: true
    highestBidTokenAmount?: true
    minIncrementTokenAmount?: true
    startTime?: true
    endTime?: true
    status?: true
    txHashCreated?: true
    txHashFinalized?: true
    txHashCancelled?: true
    createdAt?: true
    updatedAt?: true
    highestBidder?: true
  }

  export type AuctionCountAggregateInputType = {
    id?: true
    nftId?: true
    sellerAddress?: true
    quantity?: true
    startPriceEtnWei?: true
    highestBidEtnWei?: true
    minIncrementEtnWei?: true
    currencyId?: true
    startPriceTokenAmount?: true
    highestBidTokenAmount?: true
    minIncrementTokenAmount?: true
    startTime?: true
    endTime?: true
    status?: true
    txHashCreated?: true
    txHashFinalized?: true
    txHashCancelled?: true
    createdAt?: true
    updatedAt?: true
    highestBidder?: true
    _all?: true
  }

  export type AuctionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auction to aggregate.
     */
    where?: AuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auctions to fetch.
     */
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Auctions
    **/
    _count?: true | AuctionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuctionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuctionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuctionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuctionMaxAggregateInputType
  }

  export type GetAuctionAggregateType<T extends AuctionAggregateArgs> = {
        [P in keyof T & keyof AggregateAuction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuction[P]>
      : GetScalarType<T[P], AggregateAuction[P]>
  }




  export type AuctionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionWhereInput
    orderBy?: AuctionOrderByWithAggregationInput | AuctionOrderByWithAggregationInput[]
    by: AuctionScalarFieldEnum[] | AuctionScalarFieldEnum
    having?: AuctionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuctionCountAggregateInputType | true
    _avg?: AuctionAvgAggregateInputType
    _sum?: AuctionSumAggregateInputType
    _min?: AuctionMinAggregateInputType
    _max?: AuctionMaxAggregateInputType
  }

  export type AuctionGroupByOutputType = {
    id: string
    nftId: string
    sellerAddress: string
    quantity: number
    startPriceEtnWei: Decimal
    highestBidEtnWei: Decimal | null
    minIncrementEtnWei: Decimal | null
    currencyId: string | null
    startPriceTokenAmount: Decimal | null
    highestBidTokenAmount: Decimal | null
    minIncrementTokenAmount: Decimal | null
    startTime: Date
    endTime: Date
    status: $Enums.AuctionStatus
    txHashCreated: string | null
    txHashFinalized: string | null
    txHashCancelled: string | null
    createdAt: Date
    updatedAt: Date
    highestBidder: string | null
    _count: AuctionCountAggregateOutputType | null
    _avg: AuctionAvgAggregateOutputType | null
    _sum: AuctionSumAggregateOutputType | null
    _min: AuctionMinAggregateOutputType | null
    _max: AuctionMaxAggregateOutputType | null
  }

  type GetAuctionGroupByPayload<T extends AuctionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuctionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuctionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuctionGroupByOutputType[P]>
            : GetScalarType<T[P], AuctionGroupByOutputType[P]>
        }
      >
    >


  export type AuctionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nftId?: boolean
    sellerAddress?: boolean
    quantity?: boolean
    startPriceEtnWei?: boolean
    highestBidEtnWei?: boolean
    minIncrementEtnWei?: boolean
    currencyId?: boolean
    startPriceTokenAmount?: boolean
    highestBidTokenAmount?: boolean
    minIncrementTokenAmount?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    txHashCreated?: boolean
    txHashFinalized?: boolean
    txHashCancelled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highestBidder?: boolean
    currency?: boolean | Auction$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
    bids?: boolean | Auction$bidsArgs<ExtArgs>
    _count?: boolean | AuctionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auction"]>

  export type AuctionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nftId?: boolean
    sellerAddress?: boolean
    quantity?: boolean
    startPriceEtnWei?: boolean
    highestBidEtnWei?: boolean
    minIncrementEtnWei?: boolean
    currencyId?: boolean
    startPriceTokenAmount?: boolean
    highestBidTokenAmount?: boolean
    minIncrementTokenAmount?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    txHashCreated?: boolean
    txHashFinalized?: boolean
    txHashCancelled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highestBidder?: boolean
    currency?: boolean | Auction$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auction"]>

  export type AuctionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nftId?: boolean
    sellerAddress?: boolean
    quantity?: boolean
    startPriceEtnWei?: boolean
    highestBidEtnWei?: boolean
    minIncrementEtnWei?: boolean
    currencyId?: boolean
    startPriceTokenAmount?: boolean
    highestBidTokenAmount?: boolean
    minIncrementTokenAmount?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    txHashCreated?: boolean
    txHashFinalized?: boolean
    txHashCancelled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highestBidder?: boolean
    currency?: boolean | Auction$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auction"]>

  export type AuctionSelectScalar = {
    id?: boolean
    nftId?: boolean
    sellerAddress?: boolean
    quantity?: boolean
    startPriceEtnWei?: boolean
    highestBidEtnWei?: boolean
    minIncrementEtnWei?: boolean
    currencyId?: boolean
    startPriceTokenAmount?: boolean
    highestBidTokenAmount?: boolean
    minIncrementTokenAmount?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    txHashCreated?: boolean
    txHashFinalized?: boolean
    txHashCancelled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    highestBidder?: boolean
  }

  export type AuctionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nftId" | "sellerAddress" | "quantity" | "startPriceEtnWei" | "highestBidEtnWei" | "minIncrementEtnWei" | "currencyId" | "startPriceTokenAmount" | "highestBidTokenAmount" | "minIncrementTokenAmount" | "startTime" | "endTime" | "status" | "txHashCreated" | "txHashFinalized" | "txHashCancelled" | "createdAt" | "updatedAt" | "highestBidder", ExtArgs["result"]["auction"]>
  export type AuctionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | Auction$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
    bids?: boolean | Auction$bidsArgs<ExtArgs>
    _count?: boolean | AuctionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuctionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | Auction$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }
  export type AuctionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | Auction$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }

  export type $AuctionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Auction"
    objects: {
      currency: Prisma.$CurrencyPayload<ExtArgs> | null
      nft: Prisma.$NFTPayload<ExtArgs>
      bids: Prisma.$AuctionBidPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nftId: string
      sellerAddress: string
      quantity: number
      startPriceEtnWei: Prisma.Decimal
      highestBidEtnWei: Prisma.Decimal | null
      minIncrementEtnWei: Prisma.Decimal | null
      currencyId: string | null
      startPriceTokenAmount: Prisma.Decimal | null
      highestBidTokenAmount: Prisma.Decimal | null
      minIncrementTokenAmount: Prisma.Decimal | null
      startTime: Date
      endTime: Date
      status: $Enums.AuctionStatus
      txHashCreated: string | null
      txHashFinalized: string | null
      txHashCancelled: string | null
      createdAt: Date
      updatedAt: Date
      highestBidder: string | null
    }, ExtArgs["result"]["auction"]>
    composites: {}
  }

  type AuctionGetPayload<S extends boolean | null | undefined | AuctionDefaultArgs> = $Result.GetResult<Prisma.$AuctionPayload, S>

  type AuctionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuctionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuctionCountAggregateInputType | true
    }

  export interface AuctionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Auction'], meta: { name: 'Auction' } }
    /**
     * Find zero or one Auction that matches the filter.
     * @param {AuctionFindUniqueArgs} args - Arguments to find a Auction
     * @example
     * // Get one Auction
     * const auction = await prisma.auction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuctionFindUniqueArgs>(args: SelectSubset<T, AuctionFindUniqueArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Auction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuctionFindUniqueOrThrowArgs} args - Arguments to find a Auction
     * @example
     * // Get one Auction
     * const auction = await prisma.auction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuctionFindUniqueOrThrowArgs>(args: SelectSubset<T, AuctionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionFindFirstArgs} args - Arguments to find a Auction
     * @example
     * // Get one Auction
     * const auction = await prisma.auction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuctionFindFirstArgs>(args?: SelectSubset<T, AuctionFindFirstArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Auction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionFindFirstOrThrowArgs} args - Arguments to find a Auction
     * @example
     * // Get one Auction
     * const auction = await prisma.auction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuctionFindFirstOrThrowArgs>(args?: SelectSubset<T, AuctionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Auctions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auctions
     * const auctions = await prisma.auction.findMany()
     * 
     * // Get first 10 Auctions
     * const auctions = await prisma.auction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auctionWithIdOnly = await prisma.auction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuctionFindManyArgs>(args?: SelectSubset<T, AuctionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Auction.
     * @param {AuctionCreateArgs} args - Arguments to create a Auction.
     * @example
     * // Create one Auction
     * const Auction = await prisma.auction.create({
     *   data: {
     *     // ... data to create a Auction
     *   }
     * })
     * 
     */
    create<T extends AuctionCreateArgs>(args: SelectSubset<T, AuctionCreateArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Auctions.
     * @param {AuctionCreateManyArgs} args - Arguments to create many Auctions.
     * @example
     * // Create many Auctions
     * const auction = await prisma.auction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuctionCreateManyArgs>(args?: SelectSubset<T, AuctionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Auctions and returns the data saved in the database.
     * @param {AuctionCreateManyAndReturnArgs} args - Arguments to create many Auctions.
     * @example
     * // Create many Auctions
     * const auction = await prisma.auction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Auctions and only return the `id`
     * const auctionWithIdOnly = await prisma.auction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuctionCreateManyAndReturnArgs>(args?: SelectSubset<T, AuctionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Auction.
     * @param {AuctionDeleteArgs} args - Arguments to delete one Auction.
     * @example
     * // Delete one Auction
     * const Auction = await prisma.auction.delete({
     *   where: {
     *     // ... filter to delete one Auction
     *   }
     * })
     * 
     */
    delete<T extends AuctionDeleteArgs>(args: SelectSubset<T, AuctionDeleteArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Auction.
     * @param {AuctionUpdateArgs} args - Arguments to update one Auction.
     * @example
     * // Update one Auction
     * const auction = await prisma.auction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuctionUpdateArgs>(args: SelectSubset<T, AuctionUpdateArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Auctions.
     * @param {AuctionDeleteManyArgs} args - Arguments to filter Auctions to delete.
     * @example
     * // Delete a few Auctions
     * const { count } = await prisma.auction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuctionDeleteManyArgs>(args?: SelectSubset<T, AuctionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auctions
     * const auction = await prisma.auction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuctionUpdateManyArgs>(args: SelectSubset<T, AuctionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auctions and returns the data updated in the database.
     * @param {AuctionUpdateManyAndReturnArgs} args - Arguments to update many Auctions.
     * @example
     * // Update many Auctions
     * const auction = await prisma.auction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Auctions and only return the `id`
     * const auctionWithIdOnly = await prisma.auction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuctionUpdateManyAndReturnArgs>(args: SelectSubset<T, AuctionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Auction.
     * @param {AuctionUpsertArgs} args - Arguments to update or create a Auction.
     * @example
     * // Update or create a Auction
     * const auction = await prisma.auction.upsert({
     *   create: {
     *     // ... data to create a Auction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auction we want to update
     *   }
     * })
     */
    upsert<T extends AuctionUpsertArgs>(args: SelectSubset<T, AuctionUpsertArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Auctions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionCountArgs} args - Arguments to filter Auctions to count.
     * @example
     * // Count the number of Auctions
     * const count = await prisma.auction.count({
     *   where: {
     *     // ... the filter for the Auctions we want to count
     *   }
     * })
    **/
    count<T extends AuctionCountArgs>(
      args?: Subset<T, AuctionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuctionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuctionAggregateArgs>(args: Subset<T, AuctionAggregateArgs>): Prisma.PrismaPromise<GetAuctionAggregateType<T>>

    /**
     * Group by Auction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuctionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuctionGroupByArgs['orderBy'] }
        : { orderBy?: AuctionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuctionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuctionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Auction model
   */
  readonly fields: AuctionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Auction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuctionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currency<T extends Auction$currencyArgs<ExtArgs> = {}>(args?: Subset<T, Auction$currencyArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    nft<T extends NFTDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NFTDefaultArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bids<T extends Auction$bidsArgs<ExtArgs> = {}>(args?: Subset<T, Auction$bidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Auction model
   */
  interface AuctionFieldRefs {
    readonly id: FieldRef<"Auction", 'String'>
    readonly nftId: FieldRef<"Auction", 'String'>
    readonly sellerAddress: FieldRef<"Auction", 'String'>
    readonly quantity: FieldRef<"Auction", 'Int'>
    readonly startPriceEtnWei: FieldRef<"Auction", 'Decimal'>
    readonly highestBidEtnWei: FieldRef<"Auction", 'Decimal'>
    readonly minIncrementEtnWei: FieldRef<"Auction", 'Decimal'>
    readonly currencyId: FieldRef<"Auction", 'String'>
    readonly startPriceTokenAmount: FieldRef<"Auction", 'Decimal'>
    readonly highestBidTokenAmount: FieldRef<"Auction", 'Decimal'>
    readonly minIncrementTokenAmount: FieldRef<"Auction", 'Decimal'>
    readonly startTime: FieldRef<"Auction", 'DateTime'>
    readonly endTime: FieldRef<"Auction", 'DateTime'>
    readonly status: FieldRef<"Auction", 'AuctionStatus'>
    readonly txHashCreated: FieldRef<"Auction", 'String'>
    readonly txHashFinalized: FieldRef<"Auction", 'String'>
    readonly txHashCancelled: FieldRef<"Auction", 'String'>
    readonly createdAt: FieldRef<"Auction", 'DateTime'>
    readonly updatedAt: FieldRef<"Auction", 'DateTime'>
    readonly highestBidder: FieldRef<"Auction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Auction findUnique
   */
  export type AuctionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auction to fetch.
     */
    where: AuctionWhereUniqueInput
  }

  /**
   * Auction findUniqueOrThrow
   */
  export type AuctionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auction to fetch.
     */
    where: AuctionWhereUniqueInput
  }

  /**
   * Auction findFirst
   */
  export type AuctionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auction to fetch.
     */
    where?: AuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auctions to fetch.
     */
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auctions.
     */
    cursor?: AuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auctions.
     */
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }

  /**
   * Auction findFirstOrThrow
   */
  export type AuctionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auction to fetch.
     */
    where?: AuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auctions to fetch.
     */
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Auctions.
     */
    cursor?: AuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auctions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Auctions.
     */
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }

  /**
   * Auction findMany
   */
  export type AuctionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter, which Auctions to fetch.
     */
    where?: AuctionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Auctions to fetch.
     */
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Auctions.
     */
    cursor?: AuctionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Auctions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Auctions.
     */
    skip?: number
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }

  /**
   * Auction create
   */
  export type AuctionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * The data needed to create a Auction.
     */
    data: XOR<AuctionCreateInput, AuctionUncheckedCreateInput>
  }

  /**
   * Auction createMany
   */
  export type AuctionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Auctions.
     */
    data: AuctionCreateManyInput | AuctionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Auction createManyAndReturn
   */
  export type AuctionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * The data used to create many Auctions.
     */
    data: AuctionCreateManyInput | AuctionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Auction update
   */
  export type AuctionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * The data needed to update a Auction.
     */
    data: XOR<AuctionUpdateInput, AuctionUncheckedUpdateInput>
    /**
     * Choose, which Auction to update.
     */
    where: AuctionWhereUniqueInput
  }

  /**
   * Auction updateMany
   */
  export type AuctionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Auctions.
     */
    data: XOR<AuctionUpdateManyMutationInput, AuctionUncheckedUpdateManyInput>
    /**
     * Filter which Auctions to update
     */
    where?: AuctionWhereInput
    /**
     * Limit how many Auctions to update.
     */
    limit?: number
  }

  /**
   * Auction updateManyAndReturn
   */
  export type AuctionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * The data used to update Auctions.
     */
    data: XOR<AuctionUpdateManyMutationInput, AuctionUncheckedUpdateManyInput>
    /**
     * Filter which Auctions to update
     */
    where?: AuctionWhereInput
    /**
     * Limit how many Auctions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Auction upsert
   */
  export type AuctionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * The filter to search for the Auction to update in case it exists.
     */
    where: AuctionWhereUniqueInput
    /**
     * In case the Auction found by the `where` argument doesn't exist, create a new Auction with this data.
     */
    create: XOR<AuctionCreateInput, AuctionUncheckedCreateInput>
    /**
     * In case the Auction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuctionUpdateInput, AuctionUncheckedUpdateInput>
  }

  /**
   * Auction delete
   */
  export type AuctionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    /**
     * Filter which Auction to delete.
     */
    where: AuctionWhereUniqueInput
  }

  /**
   * Auction deleteMany
   */
  export type AuctionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Auctions to delete
     */
    where?: AuctionWhereInput
    /**
     * Limit how many Auctions to delete.
     */
    limit?: number
  }

  /**
   * Auction.currency
   */
  export type Auction$currencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    where?: CurrencyWhereInput
  }

  /**
   * Auction.bids
   */
  export type Auction$bidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    where?: AuctionBidWhereInput
    orderBy?: AuctionBidOrderByWithRelationInput | AuctionBidOrderByWithRelationInput[]
    cursor?: AuctionBidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionBidScalarFieldEnum | AuctionBidScalarFieldEnum[]
  }

  /**
   * Auction without action
   */
  export type AuctionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
  }


  /**
   * Model AuctionBid
   */

  export type AggregateAuctionBid = {
    _count: AuctionBidCountAggregateOutputType | null
    _avg: AuctionBidAvgAggregateOutputType | null
    _sum: AuctionBidSumAggregateOutputType | null
    _min: AuctionBidMinAggregateOutputType | null
    _max: AuctionBidMaxAggregateOutputType | null
  }

  export type AuctionBidAvgAggregateOutputType = {
    amountWei: Decimal | null
    logIndex: number | null
    blockNumber: number | null
  }

  export type AuctionBidSumAggregateOutputType = {
    amountWei: Decimal | null
    logIndex: number | null
    blockNumber: number | null
  }

  export type AuctionBidMinAggregateOutputType = {
    id: string | null
    auctionId: string | null
    bidderAddress: string | null
    amountWei: Decimal | null
    currencyId: string | null
    txHash: string | null
    logIndex: number | null
    blockNumber: number | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type AuctionBidMaxAggregateOutputType = {
    id: string | null
    auctionId: string | null
    bidderAddress: string | null
    amountWei: Decimal | null
    currencyId: string | null
    txHash: string | null
    logIndex: number | null
    blockNumber: number | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type AuctionBidCountAggregateOutputType = {
    id: number
    auctionId: number
    bidderAddress: number
    amountWei: number
    currencyId: number
    txHash: number
    logIndex: number
    blockNumber: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type AuctionBidAvgAggregateInputType = {
    amountWei?: true
    logIndex?: true
    blockNumber?: true
  }

  export type AuctionBidSumAggregateInputType = {
    amountWei?: true
    logIndex?: true
    blockNumber?: true
  }

  export type AuctionBidMinAggregateInputType = {
    id?: true
    auctionId?: true
    bidderAddress?: true
    amountWei?: true
    currencyId?: true
    txHash?: true
    logIndex?: true
    blockNumber?: true
    timestamp?: true
    createdAt?: true
  }

  export type AuctionBidMaxAggregateInputType = {
    id?: true
    auctionId?: true
    bidderAddress?: true
    amountWei?: true
    currencyId?: true
    txHash?: true
    logIndex?: true
    blockNumber?: true
    timestamp?: true
    createdAt?: true
  }

  export type AuctionBidCountAggregateInputType = {
    id?: true
    auctionId?: true
    bidderAddress?: true
    amountWei?: true
    currencyId?: true
    txHash?: true
    logIndex?: true
    blockNumber?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type AuctionBidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuctionBid to aggregate.
     */
    where?: AuctionBidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionBids to fetch.
     */
    orderBy?: AuctionBidOrderByWithRelationInput | AuctionBidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuctionBidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionBids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionBids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuctionBids
    **/
    _count?: true | AuctionBidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuctionBidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuctionBidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuctionBidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuctionBidMaxAggregateInputType
  }

  export type GetAuctionBidAggregateType<T extends AuctionBidAggregateArgs> = {
        [P in keyof T & keyof AggregateAuctionBid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuctionBid[P]>
      : GetScalarType<T[P], AggregateAuctionBid[P]>
  }




  export type AuctionBidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuctionBidWhereInput
    orderBy?: AuctionBidOrderByWithAggregationInput | AuctionBidOrderByWithAggregationInput[]
    by: AuctionBidScalarFieldEnum[] | AuctionBidScalarFieldEnum
    having?: AuctionBidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuctionBidCountAggregateInputType | true
    _avg?: AuctionBidAvgAggregateInputType
    _sum?: AuctionBidSumAggregateInputType
    _min?: AuctionBidMinAggregateInputType
    _max?: AuctionBidMaxAggregateInputType
  }

  export type AuctionBidGroupByOutputType = {
    id: string
    auctionId: string
    bidderAddress: string
    amountWei: Decimal
    currencyId: string | null
    txHash: string
    logIndex: number
    blockNumber: number
    timestamp: Date
    createdAt: Date
    _count: AuctionBidCountAggregateOutputType | null
    _avg: AuctionBidAvgAggregateOutputType | null
    _sum: AuctionBidSumAggregateOutputType | null
    _min: AuctionBidMinAggregateOutputType | null
    _max: AuctionBidMaxAggregateOutputType | null
  }

  type GetAuctionBidGroupByPayload<T extends AuctionBidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuctionBidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuctionBidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuctionBidGroupByOutputType[P]>
            : GetScalarType<T[P], AuctionBidGroupByOutputType[P]>
        }
      >
    >


  export type AuctionBidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auctionId?: boolean
    bidderAddress?: boolean
    amountWei?: boolean
    currencyId?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    createdAt?: boolean
    auction?: boolean | AuctionDefaultArgs<ExtArgs>
    currency?: boolean | AuctionBid$currencyArgs<ExtArgs>
  }, ExtArgs["result"]["auctionBid"]>

  export type AuctionBidSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auctionId?: boolean
    bidderAddress?: boolean
    amountWei?: boolean
    currencyId?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    createdAt?: boolean
    auction?: boolean | AuctionDefaultArgs<ExtArgs>
    currency?: boolean | AuctionBid$currencyArgs<ExtArgs>
  }, ExtArgs["result"]["auctionBid"]>

  export type AuctionBidSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auctionId?: boolean
    bidderAddress?: boolean
    amountWei?: boolean
    currencyId?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    createdAt?: boolean
    auction?: boolean | AuctionDefaultArgs<ExtArgs>
    currency?: boolean | AuctionBid$currencyArgs<ExtArgs>
  }, ExtArgs["result"]["auctionBid"]>

  export type AuctionBidSelectScalar = {
    id?: boolean
    auctionId?: boolean
    bidderAddress?: boolean
    amountWei?: boolean
    currencyId?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }

  export type AuctionBidOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auctionId" | "bidderAddress" | "amountWei" | "currencyId" | "txHash" | "logIndex" | "blockNumber" | "timestamp" | "createdAt", ExtArgs["result"]["auctionBid"]>
  export type AuctionBidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auction?: boolean | AuctionDefaultArgs<ExtArgs>
    currency?: boolean | AuctionBid$currencyArgs<ExtArgs>
  }
  export type AuctionBidIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auction?: boolean | AuctionDefaultArgs<ExtArgs>
    currency?: boolean | AuctionBid$currencyArgs<ExtArgs>
  }
  export type AuctionBidIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auction?: boolean | AuctionDefaultArgs<ExtArgs>
    currency?: boolean | AuctionBid$currencyArgs<ExtArgs>
  }

  export type $AuctionBidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuctionBid"
    objects: {
      auction: Prisma.$AuctionPayload<ExtArgs>
      currency: Prisma.$CurrencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auctionId: string
      bidderAddress: string
      amountWei: Prisma.Decimal
      currencyId: string | null
      txHash: string
      logIndex: number
      blockNumber: number
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["auctionBid"]>
    composites: {}
  }

  type AuctionBidGetPayload<S extends boolean | null | undefined | AuctionBidDefaultArgs> = $Result.GetResult<Prisma.$AuctionBidPayload, S>

  type AuctionBidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuctionBidFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuctionBidCountAggregateInputType | true
    }

  export interface AuctionBidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuctionBid'], meta: { name: 'AuctionBid' } }
    /**
     * Find zero or one AuctionBid that matches the filter.
     * @param {AuctionBidFindUniqueArgs} args - Arguments to find a AuctionBid
     * @example
     * // Get one AuctionBid
     * const auctionBid = await prisma.auctionBid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuctionBidFindUniqueArgs>(args: SelectSubset<T, AuctionBidFindUniqueArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuctionBid that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuctionBidFindUniqueOrThrowArgs} args - Arguments to find a AuctionBid
     * @example
     * // Get one AuctionBid
     * const auctionBid = await prisma.auctionBid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuctionBidFindUniqueOrThrowArgs>(args: SelectSubset<T, AuctionBidFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuctionBid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionBidFindFirstArgs} args - Arguments to find a AuctionBid
     * @example
     * // Get one AuctionBid
     * const auctionBid = await prisma.auctionBid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuctionBidFindFirstArgs>(args?: SelectSubset<T, AuctionBidFindFirstArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuctionBid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionBidFindFirstOrThrowArgs} args - Arguments to find a AuctionBid
     * @example
     * // Get one AuctionBid
     * const auctionBid = await prisma.auctionBid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuctionBidFindFirstOrThrowArgs>(args?: SelectSubset<T, AuctionBidFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuctionBids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionBidFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuctionBids
     * const auctionBids = await prisma.auctionBid.findMany()
     * 
     * // Get first 10 AuctionBids
     * const auctionBids = await prisma.auctionBid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auctionBidWithIdOnly = await prisma.auctionBid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuctionBidFindManyArgs>(args?: SelectSubset<T, AuctionBidFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuctionBid.
     * @param {AuctionBidCreateArgs} args - Arguments to create a AuctionBid.
     * @example
     * // Create one AuctionBid
     * const AuctionBid = await prisma.auctionBid.create({
     *   data: {
     *     // ... data to create a AuctionBid
     *   }
     * })
     * 
     */
    create<T extends AuctionBidCreateArgs>(args: SelectSubset<T, AuctionBidCreateArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuctionBids.
     * @param {AuctionBidCreateManyArgs} args - Arguments to create many AuctionBids.
     * @example
     * // Create many AuctionBids
     * const auctionBid = await prisma.auctionBid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuctionBidCreateManyArgs>(args?: SelectSubset<T, AuctionBidCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuctionBids and returns the data saved in the database.
     * @param {AuctionBidCreateManyAndReturnArgs} args - Arguments to create many AuctionBids.
     * @example
     * // Create many AuctionBids
     * const auctionBid = await prisma.auctionBid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuctionBids and only return the `id`
     * const auctionBidWithIdOnly = await prisma.auctionBid.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuctionBidCreateManyAndReturnArgs>(args?: SelectSubset<T, AuctionBidCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuctionBid.
     * @param {AuctionBidDeleteArgs} args - Arguments to delete one AuctionBid.
     * @example
     * // Delete one AuctionBid
     * const AuctionBid = await prisma.auctionBid.delete({
     *   where: {
     *     // ... filter to delete one AuctionBid
     *   }
     * })
     * 
     */
    delete<T extends AuctionBidDeleteArgs>(args: SelectSubset<T, AuctionBidDeleteArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuctionBid.
     * @param {AuctionBidUpdateArgs} args - Arguments to update one AuctionBid.
     * @example
     * // Update one AuctionBid
     * const auctionBid = await prisma.auctionBid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuctionBidUpdateArgs>(args: SelectSubset<T, AuctionBidUpdateArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuctionBids.
     * @param {AuctionBidDeleteManyArgs} args - Arguments to filter AuctionBids to delete.
     * @example
     * // Delete a few AuctionBids
     * const { count } = await prisma.auctionBid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuctionBidDeleteManyArgs>(args?: SelectSubset<T, AuctionBidDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuctionBids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionBidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuctionBids
     * const auctionBid = await prisma.auctionBid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuctionBidUpdateManyArgs>(args: SelectSubset<T, AuctionBidUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuctionBids and returns the data updated in the database.
     * @param {AuctionBidUpdateManyAndReturnArgs} args - Arguments to update many AuctionBids.
     * @example
     * // Update many AuctionBids
     * const auctionBid = await prisma.auctionBid.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuctionBids and only return the `id`
     * const auctionBidWithIdOnly = await prisma.auctionBid.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuctionBidUpdateManyAndReturnArgs>(args: SelectSubset<T, AuctionBidUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuctionBid.
     * @param {AuctionBidUpsertArgs} args - Arguments to update or create a AuctionBid.
     * @example
     * // Update or create a AuctionBid
     * const auctionBid = await prisma.auctionBid.upsert({
     *   create: {
     *     // ... data to create a AuctionBid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuctionBid we want to update
     *   }
     * })
     */
    upsert<T extends AuctionBidUpsertArgs>(args: SelectSubset<T, AuctionBidUpsertArgs<ExtArgs>>): Prisma__AuctionBidClient<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuctionBids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionBidCountArgs} args - Arguments to filter AuctionBids to count.
     * @example
     * // Count the number of AuctionBids
     * const count = await prisma.auctionBid.count({
     *   where: {
     *     // ... the filter for the AuctionBids we want to count
     *   }
     * })
    **/
    count<T extends AuctionBidCountArgs>(
      args?: Subset<T, AuctionBidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuctionBidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuctionBid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionBidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuctionBidAggregateArgs>(args: Subset<T, AuctionBidAggregateArgs>): Prisma.PrismaPromise<GetAuctionBidAggregateType<T>>

    /**
     * Group by AuctionBid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuctionBidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuctionBidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuctionBidGroupByArgs['orderBy'] }
        : { orderBy?: AuctionBidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuctionBidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuctionBidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuctionBid model
   */
  readonly fields: AuctionBidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuctionBid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuctionBidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auction<T extends AuctionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuctionDefaultArgs<ExtArgs>>): Prisma__AuctionClient<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currency<T extends AuctionBid$currencyArgs<ExtArgs> = {}>(args?: Subset<T, AuctionBid$currencyArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuctionBid model
   */
  interface AuctionBidFieldRefs {
    readonly id: FieldRef<"AuctionBid", 'String'>
    readonly auctionId: FieldRef<"AuctionBid", 'String'>
    readonly bidderAddress: FieldRef<"AuctionBid", 'String'>
    readonly amountWei: FieldRef<"AuctionBid", 'Decimal'>
    readonly currencyId: FieldRef<"AuctionBid", 'String'>
    readonly txHash: FieldRef<"AuctionBid", 'String'>
    readonly logIndex: FieldRef<"AuctionBid", 'Int'>
    readonly blockNumber: FieldRef<"AuctionBid", 'Int'>
    readonly timestamp: FieldRef<"AuctionBid", 'DateTime'>
    readonly createdAt: FieldRef<"AuctionBid", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuctionBid findUnique
   */
  export type AuctionBidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * Filter, which AuctionBid to fetch.
     */
    where: AuctionBidWhereUniqueInput
  }

  /**
   * AuctionBid findUniqueOrThrow
   */
  export type AuctionBidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * Filter, which AuctionBid to fetch.
     */
    where: AuctionBidWhereUniqueInput
  }

  /**
   * AuctionBid findFirst
   */
  export type AuctionBidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * Filter, which AuctionBid to fetch.
     */
    where?: AuctionBidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionBids to fetch.
     */
    orderBy?: AuctionBidOrderByWithRelationInput | AuctionBidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuctionBids.
     */
    cursor?: AuctionBidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionBids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionBids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuctionBids.
     */
    distinct?: AuctionBidScalarFieldEnum | AuctionBidScalarFieldEnum[]
  }

  /**
   * AuctionBid findFirstOrThrow
   */
  export type AuctionBidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * Filter, which AuctionBid to fetch.
     */
    where?: AuctionBidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionBids to fetch.
     */
    orderBy?: AuctionBidOrderByWithRelationInput | AuctionBidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuctionBids.
     */
    cursor?: AuctionBidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionBids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionBids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuctionBids.
     */
    distinct?: AuctionBidScalarFieldEnum | AuctionBidScalarFieldEnum[]
  }

  /**
   * AuctionBid findMany
   */
  export type AuctionBidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * Filter, which AuctionBids to fetch.
     */
    where?: AuctionBidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuctionBids to fetch.
     */
    orderBy?: AuctionBidOrderByWithRelationInput | AuctionBidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuctionBids.
     */
    cursor?: AuctionBidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuctionBids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuctionBids.
     */
    skip?: number
    distinct?: AuctionBidScalarFieldEnum | AuctionBidScalarFieldEnum[]
  }

  /**
   * AuctionBid create
   */
  export type AuctionBidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * The data needed to create a AuctionBid.
     */
    data: XOR<AuctionBidCreateInput, AuctionBidUncheckedCreateInput>
  }

  /**
   * AuctionBid createMany
   */
  export type AuctionBidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuctionBids.
     */
    data: AuctionBidCreateManyInput | AuctionBidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuctionBid createManyAndReturn
   */
  export type AuctionBidCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * The data used to create many AuctionBids.
     */
    data: AuctionBidCreateManyInput | AuctionBidCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuctionBid update
   */
  export type AuctionBidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * The data needed to update a AuctionBid.
     */
    data: XOR<AuctionBidUpdateInput, AuctionBidUncheckedUpdateInput>
    /**
     * Choose, which AuctionBid to update.
     */
    where: AuctionBidWhereUniqueInput
  }

  /**
   * AuctionBid updateMany
   */
  export type AuctionBidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuctionBids.
     */
    data: XOR<AuctionBidUpdateManyMutationInput, AuctionBidUncheckedUpdateManyInput>
    /**
     * Filter which AuctionBids to update
     */
    where?: AuctionBidWhereInput
    /**
     * Limit how many AuctionBids to update.
     */
    limit?: number
  }

  /**
   * AuctionBid updateManyAndReturn
   */
  export type AuctionBidUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * The data used to update AuctionBids.
     */
    data: XOR<AuctionBidUpdateManyMutationInput, AuctionBidUncheckedUpdateManyInput>
    /**
     * Filter which AuctionBids to update
     */
    where?: AuctionBidWhereInput
    /**
     * Limit how many AuctionBids to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuctionBid upsert
   */
  export type AuctionBidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * The filter to search for the AuctionBid to update in case it exists.
     */
    where: AuctionBidWhereUniqueInput
    /**
     * In case the AuctionBid found by the `where` argument doesn't exist, create a new AuctionBid with this data.
     */
    create: XOR<AuctionBidCreateInput, AuctionBidUncheckedCreateInput>
    /**
     * In case the AuctionBid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuctionBidUpdateInput, AuctionBidUncheckedUpdateInput>
  }

  /**
   * AuctionBid delete
   */
  export type AuctionBidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    /**
     * Filter which AuctionBid to delete.
     */
    where: AuctionBidWhereUniqueInput
  }

  /**
   * AuctionBid deleteMany
   */
  export type AuctionBidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuctionBids to delete
     */
    where?: AuctionBidWhereInput
    /**
     * Limit how many AuctionBids to delete.
     */
    limit?: number
  }

  /**
   * AuctionBid.currency
   */
  export type AuctionBid$currencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    where?: CurrencyWhereInput
  }

  /**
   * AuctionBid without action
   */
  export type AuctionBidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
  }


  /**
   * Model DeployedContract
   */

  export type AggregateDeployedContract = {
    _count: DeployedContractCountAggregateOutputType | null
    _avg: DeployedContractAvgAggregateOutputType | null
    _sum: DeployedContractSumAggregateOutputType | null
    _min: DeployedContractMinAggregateOutputType | null
    _max: DeployedContractMaxAggregateOutputType | null
  }

  export type DeployedContractAvgAggregateOutputType = {
    blockNumber: number | null
    feeAmountEtnWei: Decimal | null
    royaltyBps: number | null
    maxSupply: number | null
  }

  export type DeployedContractSumAggregateOutputType = {
    blockNumber: number | null
    feeAmountEtnWei: Decimal | null
    royaltyBps: number | null
    maxSupply: number | null
  }

  export type DeployedContractMinAggregateOutputType = {
    id: string | null
    contractType: $Enums.ContractType | null
    cloneAddress: string | null
    implementationAddr: string | null
    factoryAddress: string | null
    deployerAddress: string | null
    txHash: string | null
    blockNumber: number | null
    metadataOption: $Enums.MetadataOption | null
    feeRecipient: string | null
    feeAmountEtnWei: Decimal | null
    royaltyRecipient: string | null
    royaltyBps: number | null
    baseURI: string | null
    maxSupply: number | null
    createdAt: Date | null
    collectionId: string | null
    single721Id: string | null
    single1155Id: string | null
  }

  export type DeployedContractMaxAggregateOutputType = {
    id: string | null
    contractType: $Enums.ContractType | null
    cloneAddress: string | null
    implementationAddr: string | null
    factoryAddress: string | null
    deployerAddress: string | null
    txHash: string | null
    blockNumber: number | null
    metadataOption: $Enums.MetadataOption | null
    feeRecipient: string | null
    feeAmountEtnWei: Decimal | null
    royaltyRecipient: string | null
    royaltyBps: number | null
    baseURI: string | null
    maxSupply: number | null
    createdAt: Date | null
    collectionId: string | null
    single721Id: string | null
    single1155Id: string | null
  }

  export type DeployedContractCountAggregateOutputType = {
    id: number
    contractType: number
    cloneAddress: number
    implementationAddr: number
    factoryAddress: number
    deployerAddress: number
    txHash: number
    blockNumber: number
    metadataOption: number
    feeRecipient: number
    feeAmountEtnWei: number
    royaltyRecipient: number
    royaltyBps: number
    baseURI: number
    maxSupply: number
    rawInit: number
    createdAt: number
    collectionId: number
    single721Id: number
    single1155Id: number
    _all: number
  }


  export type DeployedContractAvgAggregateInputType = {
    blockNumber?: true
    feeAmountEtnWei?: true
    royaltyBps?: true
    maxSupply?: true
  }

  export type DeployedContractSumAggregateInputType = {
    blockNumber?: true
    feeAmountEtnWei?: true
    royaltyBps?: true
    maxSupply?: true
  }

  export type DeployedContractMinAggregateInputType = {
    id?: true
    contractType?: true
    cloneAddress?: true
    implementationAddr?: true
    factoryAddress?: true
    deployerAddress?: true
    txHash?: true
    blockNumber?: true
    metadataOption?: true
    feeRecipient?: true
    feeAmountEtnWei?: true
    royaltyRecipient?: true
    royaltyBps?: true
    baseURI?: true
    maxSupply?: true
    createdAt?: true
    collectionId?: true
    single721Id?: true
    single1155Id?: true
  }

  export type DeployedContractMaxAggregateInputType = {
    id?: true
    contractType?: true
    cloneAddress?: true
    implementationAddr?: true
    factoryAddress?: true
    deployerAddress?: true
    txHash?: true
    blockNumber?: true
    metadataOption?: true
    feeRecipient?: true
    feeAmountEtnWei?: true
    royaltyRecipient?: true
    royaltyBps?: true
    baseURI?: true
    maxSupply?: true
    createdAt?: true
    collectionId?: true
    single721Id?: true
    single1155Id?: true
  }

  export type DeployedContractCountAggregateInputType = {
    id?: true
    contractType?: true
    cloneAddress?: true
    implementationAddr?: true
    factoryAddress?: true
    deployerAddress?: true
    txHash?: true
    blockNumber?: true
    metadataOption?: true
    feeRecipient?: true
    feeAmountEtnWei?: true
    royaltyRecipient?: true
    royaltyBps?: true
    baseURI?: true
    maxSupply?: true
    rawInit?: true
    createdAt?: true
    collectionId?: true
    single721Id?: true
    single1155Id?: true
    _all?: true
  }

  export type DeployedContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeployedContract to aggregate.
     */
    where?: DeployedContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeployedContracts to fetch.
     */
    orderBy?: DeployedContractOrderByWithRelationInput | DeployedContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeployedContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeployedContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeployedContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeployedContracts
    **/
    _count?: true | DeployedContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeployedContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeployedContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeployedContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeployedContractMaxAggregateInputType
  }

  export type GetDeployedContractAggregateType<T extends DeployedContractAggregateArgs> = {
        [P in keyof T & keyof AggregateDeployedContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeployedContract[P]>
      : GetScalarType<T[P], AggregateDeployedContract[P]>
  }




  export type DeployedContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeployedContractWhereInput
    orderBy?: DeployedContractOrderByWithAggregationInput | DeployedContractOrderByWithAggregationInput[]
    by: DeployedContractScalarFieldEnum[] | DeployedContractScalarFieldEnum
    having?: DeployedContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeployedContractCountAggregateInputType | true
    _avg?: DeployedContractAvgAggregateInputType
    _sum?: DeployedContractSumAggregateInputType
    _min?: DeployedContractMinAggregateInputType
    _max?: DeployedContractMaxAggregateInputType
  }

  export type DeployedContractGroupByOutputType = {
    id: string
    contractType: $Enums.ContractType
    cloneAddress: string
    implementationAddr: string
    factoryAddress: string
    deployerAddress: string
    txHash: string
    blockNumber: number
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal
    royaltyRecipient: string
    royaltyBps: number
    baseURI: string | null
    maxSupply: number | null
    rawInit: JsonValue | null
    createdAt: Date
    collectionId: string | null
    single721Id: string | null
    single1155Id: string | null
    _count: DeployedContractCountAggregateOutputType | null
    _avg: DeployedContractAvgAggregateOutputType | null
    _sum: DeployedContractSumAggregateOutputType | null
    _min: DeployedContractMinAggregateOutputType | null
    _max: DeployedContractMaxAggregateOutputType | null
  }

  type GetDeployedContractGroupByPayload<T extends DeployedContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeployedContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeployedContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeployedContractGroupByOutputType[P]>
            : GetScalarType<T[P], DeployedContractGroupByOutputType[P]>
        }
      >
    >


  export type DeployedContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractType?: boolean
    cloneAddress?: boolean
    implementationAddr?: boolean
    factoryAddress?: boolean
    deployerAddress?: boolean
    txHash?: boolean
    blockNumber?: boolean
    metadataOption?: boolean
    feeRecipient?: boolean
    feeAmountEtnWei?: boolean
    royaltyRecipient?: boolean
    royaltyBps?: boolean
    baseURI?: boolean
    maxSupply?: boolean
    rawInit?: boolean
    createdAt?: boolean
    collectionId?: boolean
    single721Id?: boolean
    single1155Id?: boolean
    collection?: boolean | DeployedContract$collectionArgs<ExtArgs>
    single1155?: boolean | DeployedContract$single1155Args<ExtArgs>
    single721?: boolean | DeployedContract$single721Args<ExtArgs>
  }, ExtArgs["result"]["deployedContract"]>

  export type DeployedContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractType?: boolean
    cloneAddress?: boolean
    implementationAddr?: boolean
    factoryAddress?: boolean
    deployerAddress?: boolean
    txHash?: boolean
    blockNumber?: boolean
    metadataOption?: boolean
    feeRecipient?: boolean
    feeAmountEtnWei?: boolean
    royaltyRecipient?: boolean
    royaltyBps?: boolean
    baseURI?: boolean
    maxSupply?: boolean
    rawInit?: boolean
    createdAt?: boolean
    collectionId?: boolean
    single721Id?: boolean
    single1155Id?: boolean
    collection?: boolean | DeployedContract$collectionArgs<ExtArgs>
    single1155?: boolean | DeployedContract$single1155Args<ExtArgs>
    single721?: boolean | DeployedContract$single721Args<ExtArgs>
  }, ExtArgs["result"]["deployedContract"]>

  export type DeployedContractSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractType?: boolean
    cloneAddress?: boolean
    implementationAddr?: boolean
    factoryAddress?: boolean
    deployerAddress?: boolean
    txHash?: boolean
    blockNumber?: boolean
    metadataOption?: boolean
    feeRecipient?: boolean
    feeAmountEtnWei?: boolean
    royaltyRecipient?: boolean
    royaltyBps?: boolean
    baseURI?: boolean
    maxSupply?: boolean
    rawInit?: boolean
    createdAt?: boolean
    collectionId?: boolean
    single721Id?: boolean
    single1155Id?: boolean
    collection?: boolean | DeployedContract$collectionArgs<ExtArgs>
    single1155?: boolean | DeployedContract$single1155Args<ExtArgs>
    single721?: boolean | DeployedContract$single721Args<ExtArgs>
  }, ExtArgs["result"]["deployedContract"]>

  export type DeployedContractSelectScalar = {
    id?: boolean
    contractType?: boolean
    cloneAddress?: boolean
    implementationAddr?: boolean
    factoryAddress?: boolean
    deployerAddress?: boolean
    txHash?: boolean
    blockNumber?: boolean
    metadataOption?: boolean
    feeRecipient?: boolean
    feeAmountEtnWei?: boolean
    royaltyRecipient?: boolean
    royaltyBps?: boolean
    baseURI?: boolean
    maxSupply?: boolean
    rawInit?: boolean
    createdAt?: boolean
    collectionId?: boolean
    single721Id?: boolean
    single1155Id?: boolean
  }

  export type DeployedContractOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractType" | "cloneAddress" | "implementationAddr" | "factoryAddress" | "deployerAddress" | "txHash" | "blockNumber" | "metadataOption" | "feeRecipient" | "feeAmountEtnWei" | "royaltyRecipient" | "royaltyBps" | "baseURI" | "maxSupply" | "rawInit" | "createdAt" | "collectionId" | "single721Id" | "single1155Id", ExtArgs["result"]["deployedContract"]>
  export type DeployedContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | DeployedContract$collectionArgs<ExtArgs>
    single1155?: boolean | DeployedContract$single1155Args<ExtArgs>
    single721?: boolean | DeployedContract$single721Args<ExtArgs>
  }
  export type DeployedContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | DeployedContract$collectionArgs<ExtArgs>
    single1155?: boolean | DeployedContract$single1155Args<ExtArgs>
    single721?: boolean | DeployedContract$single721Args<ExtArgs>
  }
  export type DeployedContractIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | DeployedContract$collectionArgs<ExtArgs>
    single1155?: boolean | DeployedContract$single1155Args<ExtArgs>
    single721?: boolean | DeployedContract$single721Args<ExtArgs>
  }

  export type $DeployedContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeployedContract"
    objects: {
      collection: Prisma.$CollectionPayload<ExtArgs> | null
      single1155: Prisma.$Single1155Payload<ExtArgs> | null
      single721: Prisma.$Single721Payload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractType: $Enums.ContractType
      cloneAddress: string
      implementationAddr: string
      factoryAddress: string
      deployerAddress: string
      txHash: string
      blockNumber: number
      metadataOption: $Enums.MetadataOption
      feeRecipient: string
      feeAmountEtnWei: Prisma.Decimal
      royaltyRecipient: string
      royaltyBps: number
      baseURI: string | null
      maxSupply: number | null
      rawInit: Prisma.JsonValue | null
      createdAt: Date
      collectionId: string | null
      single721Id: string | null
      single1155Id: string | null
    }, ExtArgs["result"]["deployedContract"]>
    composites: {}
  }

  type DeployedContractGetPayload<S extends boolean | null | undefined | DeployedContractDefaultArgs> = $Result.GetResult<Prisma.$DeployedContractPayload, S>

  type DeployedContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeployedContractFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeployedContractCountAggregateInputType | true
    }

  export interface DeployedContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeployedContract'], meta: { name: 'DeployedContract' } }
    /**
     * Find zero or one DeployedContract that matches the filter.
     * @param {DeployedContractFindUniqueArgs} args - Arguments to find a DeployedContract
     * @example
     * // Get one DeployedContract
     * const deployedContract = await prisma.deployedContract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeployedContractFindUniqueArgs>(args: SelectSubset<T, DeployedContractFindUniqueArgs<ExtArgs>>): Prisma__DeployedContractClient<$Result.GetResult<Prisma.$DeployedContractPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeployedContract that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeployedContractFindUniqueOrThrowArgs} args - Arguments to find a DeployedContract
     * @example
     * // Get one DeployedContract
     * const deployedContract = await prisma.deployedContract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeployedContractFindUniqueOrThrowArgs>(args: SelectSubset<T, DeployedContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeployedContractClient<$Result.GetResult<Prisma.$DeployedContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeployedContract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeployedContractFindFirstArgs} args - Arguments to find a DeployedContract
     * @example
     * // Get one DeployedContract
     * const deployedContract = await prisma.deployedContract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeployedContractFindFirstArgs>(args?: SelectSubset<T, DeployedContractFindFirstArgs<ExtArgs>>): Prisma__DeployedContractClient<$Result.GetResult<Prisma.$DeployedContractPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeployedContract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeployedContractFindFirstOrThrowArgs} args - Arguments to find a DeployedContract
     * @example
     * // Get one DeployedContract
     * const deployedContract = await prisma.deployedContract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeployedContractFindFirstOrThrowArgs>(args?: SelectSubset<T, DeployedContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeployedContractClient<$Result.GetResult<Prisma.$DeployedContractPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeployedContracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeployedContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeployedContracts
     * const deployedContracts = await prisma.deployedContract.findMany()
     * 
     * // Get first 10 DeployedContracts
     * const deployedContracts = await prisma.deployedContract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deployedContractWithIdOnly = await prisma.deployedContract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeployedContractFindManyArgs>(args?: SelectSubset<T, DeployedContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeployedContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeployedContract.
     * @param {DeployedContractCreateArgs} args - Arguments to create a DeployedContract.
     * @example
     * // Create one DeployedContract
     * const DeployedContract = await prisma.deployedContract.create({
     *   data: {
     *     // ... data to create a DeployedContract
     *   }
     * })
     * 
     */
    create<T extends DeployedContractCreateArgs>(args: SelectSubset<T, DeployedContractCreateArgs<ExtArgs>>): Prisma__DeployedContractClient<$Result.GetResult<Prisma.$DeployedContractPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeployedContracts.
     * @param {DeployedContractCreateManyArgs} args - Arguments to create many DeployedContracts.
     * @example
     * // Create many DeployedContracts
     * const deployedContract = await prisma.deployedContract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeployedContractCreateManyArgs>(args?: SelectSubset<T, DeployedContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeployedContracts and returns the data saved in the database.
     * @param {DeployedContractCreateManyAndReturnArgs} args - Arguments to create many DeployedContracts.
     * @example
     * // Create many DeployedContracts
     * const deployedContract = await prisma.deployedContract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeployedContracts and only return the `id`
     * const deployedContractWithIdOnly = await prisma.deployedContract.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeployedContractCreateManyAndReturnArgs>(args?: SelectSubset<T, DeployedContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeployedContractPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeployedContract.
     * @param {DeployedContractDeleteArgs} args - Arguments to delete one DeployedContract.
     * @example
     * // Delete one DeployedContract
     * const DeployedContract = await prisma.deployedContract.delete({
     *   where: {
     *     // ... filter to delete one DeployedContract
     *   }
     * })
     * 
     */
    delete<T extends DeployedContractDeleteArgs>(args: SelectSubset<T, DeployedContractDeleteArgs<ExtArgs>>): Prisma__DeployedContractClient<$Result.GetResult<Prisma.$DeployedContractPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeployedContract.
     * @param {DeployedContractUpdateArgs} args - Arguments to update one DeployedContract.
     * @example
     * // Update one DeployedContract
     * const deployedContract = await prisma.deployedContract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeployedContractUpdateArgs>(args: SelectSubset<T, DeployedContractUpdateArgs<ExtArgs>>): Prisma__DeployedContractClient<$Result.GetResult<Prisma.$DeployedContractPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeployedContracts.
     * @param {DeployedContractDeleteManyArgs} args - Arguments to filter DeployedContracts to delete.
     * @example
     * // Delete a few DeployedContracts
     * const { count } = await prisma.deployedContract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeployedContractDeleteManyArgs>(args?: SelectSubset<T, DeployedContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeployedContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeployedContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeployedContracts
     * const deployedContract = await prisma.deployedContract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeployedContractUpdateManyArgs>(args: SelectSubset<T, DeployedContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeployedContracts and returns the data updated in the database.
     * @param {DeployedContractUpdateManyAndReturnArgs} args - Arguments to update many DeployedContracts.
     * @example
     * // Update many DeployedContracts
     * const deployedContract = await prisma.deployedContract.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeployedContracts and only return the `id`
     * const deployedContractWithIdOnly = await prisma.deployedContract.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeployedContractUpdateManyAndReturnArgs>(args: SelectSubset<T, DeployedContractUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeployedContractPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeployedContract.
     * @param {DeployedContractUpsertArgs} args - Arguments to update or create a DeployedContract.
     * @example
     * // Update or create a DeployedContract
     * const deployedContract = await prisma.deployedContract.upsert({
     *   create: {
     *     // ... data to create a DeployedContract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeployedContract we want to update
     *   }
     * })
     */
    upsert<T extends DeployedContractUpsertArgs>(args: SelectSubset<T, DeployedContractUpsertArgs<ExtArgs>>): Prisma__DeployedContractClient<$Result.GetResult<Prisma.$DeployedContractPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeployedContracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeployedContractCountArgs} args - Arguments to filter DeployedContracts to count.
     * @example
     * // Count the number of DeployedContracts
     * const count = await prisma.deployedContract.count({
     *   where: {
     *     // ... the filter for the DeployedContracts we want to count
     *   }
     * })
    **/
    count<T extends DeployedContractCountArgs>(
      args?: Subset<T, DeployedContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeployedContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeployedContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeployedContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeployedContractAggregateArgs>(args: Subset<T, DeployedContractAggregateArgs>): Prisma.PrismaPromise<GetDeployedContractAggregateType<T>>

    /**
     * Group by DeployedContract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeployedContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeployedContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeployedContractGroupByArgs['orderBy'] }
        : { orderBy?: DeployedContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeployedContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeployedContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeployedContract model
   */
  readonly fields: DeployedContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeployedContract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeployedContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends DeployedContract$collectionArgs<ExtArgs> = {}>(args?: Subset<T, DeployedContract$collectionArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    single1155<T extends DeployedContract$single1155Args<ExtArgs> = {}>(args?: Subset<T, DeployedContract$single1155Args<ExtArgs>>): Prisma__Single1155Client<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    single721<T extends DeployedContract$single721Args<ExtArgs> = {}>(args?: Subset<T, DeployedContract$single721Args<ExtArgs>>): Prisma__Single721Client<$Result.GetResult<Prisma.$Single721Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeployedContract model
   */
  interface DeployedContractFieldRefs {
    readonly id: FieldRef<"DeployedContract", 'String'>
    readonly contractType: FieldRef<"DeployedContract", 'ContractType'>
    readonly cloneAddress: FieldRef<"DeployedContract", 'String'>
    readonly implementationAddr: FieldRef<"DeployedContract", 'String'>
    readonly factoryAddress: FieldRef<"DeployedContract", 'String'>
    readonly deployerAddress: FieldRef<"DeployedContract", 'String'>
    readonly txHash: FieldRef<"DeployedContract", 'String'>
    readonly blockNumber: FieldRef<"DeployedContract", 'Int'>
    readonly metadataOption: FieldRef<"DeployedContract", 'MetadataOption'>
    readonly feeRecipient: FieldRef<"DeployedContract", 'String'>
    readonly feeAmountEtnWei: FieldRef<"DeployedContract", 'Decimal'>
    readonly royaltyRecipient: FieldRef<"DeployedContract", 'String'>
    readonly royaltyBps: FieldRef<"DeployedContract", 'Int'>
    readonly baseURI: FieldRef<"DeployedContract", 'String'>
    readonly maxSupply: FieldRef<"DeployedContract", 'Int'>
    readonly rawInit: FieldRef<"DeployedContract", 'Json'>
    readonly createdAt: FieldRef<"DeployedContract", 'DateTime'>
    readonly collectionId: FieldRef<"DeployedContract", 'String'>
    readonly single721Id: FieldRef<"DeployedContract", 'String'>
    readonly single1155Id: FieldRef<"DeployedContract", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeployedContract findUnique
   */
  export type DeployedContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractInclude<ExtArgs> | null
    /**
     * Filter, which DeployedContract to fetch.
     */
    where: DeployedContractWhereUniqueInput
  }

  /**
   * DeployedContract findUniqueOrThrow
   */
  export type DeployedContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractInclude<ExtArgs> | null
    /**
     * Filter, which DeployedContract to fetch.
     */
    where: DeployedContractWhereUniqueInput
  }

  /**
   * DeployedContract findFirst
   */
  export type DeployedContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractInclude<ExtArgs> | null
    /**
     * Filter, which DeployedContract to fetch.
     */
    where?: DeployedContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeployedContracts to fetch.
     */
    orderBy?: DeployedContractOrderByWithRelationInput | DeployedContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeployedContracts.
     */
    cursor?: DeployedContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeployedContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeployedContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeployedContracts.
     */
    distinct?: DeployedContractScalarFieldEnum | DeployedContractScalarFieldEnum[]
  }

  /**
   * DeployedContract findFirstOrThrow
   */
  export type DeployedContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractInclude<ExtArgs> | null
    /**
     * Filter, which DeployedContract to fetch.
     */
    where?: DeployedContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeployedContracts to fetch.
     */
    orderBy?: DeployedContractOrderByWithRelationInput | DeployedContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeployedContracts.
     */
    cursor?: DeployedContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeployedContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeployedContracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeployedContracts.
     */
    distinct?: DeployedContractScalarFieldEnum | DeployedContractScalarFieldEnum[]
  }

  /**
   * DeployedContract findMany
   */
  export type DeployedContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractInclude<ExtArgs> | null
    /**
     * Filter, which DeployedContracts to fetch.
     */
    where?: DeployedContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeployedContracts to fetch.
     */
    orderBy?: DeployedContractOrderByWithRelationInput | DeployedContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeployedContracts.
     */
    cursor?: DeployedContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeployedContracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeployedContracts.
     */
    skip?: number
    distinct?: DeployedContractScalarFieldEnum | DeployedContractScalarFieldEnum[]
  }

  /**
   * DeployedContract create
   */
  export type DeployedContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractInclude<ExtArgs> | null
    /**
     * The data needed to create a DeployedContract.
     */
    data: XOR<DeployedContractCreateInput, DeployedContractUncheckedCreateInput>
  }

  /**
   * DeployedContract createMany
   */
  export type DeployedContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeployedContracts.
     */
    data: DeployedContractCreateManyInput | DeployedContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeployedContract createManyAndReturn
   */
  export type DeployedContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * The data used to create many DeployedContracts.
     */
    data: DeployedContractCreateManyInput | DeployedContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeployedContract update
   */
  export type DeployedContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractInclude<ExtArgs> | null
    /**
     * The data needed to update a DeployedContract.
     */
    data: XOR<DeployedContractUpdateInput, DeployedContractUncheckedUpdateInput>
    /**
     * Choose, which DeployedContract to update.
     */
    where: DeployedContractWhereUniqueInput
  }

  /**
   * DeployedContract updateMany
   */
  export type DeployedContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeployedContracts.
     */
    data: XOR<DeployedContractUpdateManyMutationInput, DeployedContractUncheckedUpdateManyInput>
    /**
     * Filter which DeployedContracts to update
     */
    where?: DeployedContractWhereInput
    /**
     * Limit how many DeployedContracts to update.
     */
    limit?: number
  }

  /**
   * DeployedContract updateManyAndReturn
   */
  export type DeployedContractUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * The data used to update DeployedContracts.
     */
    data: XOR<DeployedContractUpdateManyMutationInput, DeployedContractUncheckedUpdateManyInput>
    /**
     * Filter which DeployedContracts to update
     */
    where?: DeployedContractWhereInput
    /**
     * Limit how many DeployedContracts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeployedContract upsert
   */
  export type DeployedContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractInclude<ExtArgs> | null
    /**
     * The filter to search for the DeployedContract to update in case it exists.
     */
    where: DeployedContractWhereUniqueInput
    /**
     * In case the DeployedContract found by the `where` argument doesn't exist, create a new DeployedContract with this data.
     */
    create: XOR<DeployedContractCreateInput, DeployedContractUncheckedCreateInput>
    /**
     * In case the DeployedContract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeployedContractUpdateInput, DeployedContractUncheckedUpdateInput>
  }

  /**
   * DeployedContract delete
   */
  export type DeployedContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractInclude<ExtArgs> | null
    /**
     * Filter which DeployedContract to delete.
     */
    where: DeployedContractWhereUniqueInput
  }

  /**
   * DeployedContract deleteMany
   */
  export type DeployedContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeployedContracts to delete
     */
    where?: DeployedContractWhereInput
    /**
     * Limit how many DeployedContracts to delete.
     */
    limit?: number
  }

  /**
   * DeployedContract.collection
   */
  export type DeployedContract$collectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    where?: CollectionWhereInput
  }

  /**
   * DeployedContract.single1155
   */
  export type DeployedContract$single1155Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single1155Include<ExtArgs> | null
    where?: Single1155WhereInput
  }

  /**
   * DeployedContract.single721
   */
  export type DeployedContract$single721Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single721Include<ExtArgs> | null
    where?: Single721WhereInput
  }

  /**
   * DeployedContract without action
   */
  export type DeployedContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeployedContract
     */
    select?: DeployedContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeployedContract
     */
    omit?: DeployedContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeployedContractInclude<ExtArgs> | null
  }


  /**
   * Model FeeConfig
   */

  export type AggregateFeeConfig = {
    _count: FeeConfigCountAggregateOutputType | null
    _avg: FeeConfigAvgAggregateOutputType | null
    _sum: FeeConfigSumAggregateOutputType | null
    _min: FeeConfigMinAggregateOutputType | null
    _max: FeeConfigMaxAggregateOutputType | null
  }

  export type FeeConfigAvgAggregateOutputType = {
    feeAmountEtnWei: Decimal | null
    targetUsdCents: number | null
    lastPriceUsd: Decimal | null
  }

  export type FeeConfigSumAggregateOutputType = {
    feeAmountEtnWei: Decimal | null
    targetUsdCents: number | null
    lastPriceUsd: Decimal | null
  }

  export type FeeConfigMinAggregateOutputType = {
    id: string | null
    contractType: $Enums.ContractType | null
    metadataOption: $Enums.MetadataOption | null
    feeRecipient: string | null
    feeAmountEtnWei: Decimal | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedByUserId: string | null
    targetUsdCents: number | null
    pricingSource: string | null
    pricingPair: string | null
    lastPriceUsd: Decimal | null
    lastPriceAt: Date | null
  }

  export type FeeConfigMaxAggregateOutputType = {
    id: string | null
    contractType: $Enums.ContractType | null
    metadataOption: $Enums.MetadataOption | null
    feeRecipient: string | null
    feeAmountEtnWei: Decimal | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    updatedByUserId: string | null
    targetUsdCents: number | null
    pricingSource: string | null
    pricingPair: string | null
    lastPriceUsd: Decimal | null
    lastPriceAt: Date | null
  }

  export type FeeConfigCountAggregateOutputType = {
    id: number
    contractType: number
    metadataOption: number
    feeRecipient: number
    feeAmountEtnWei: number
    active: number
    createdAt: number
    updatedAt: number
    updatedByUserId: number
    targetUsdCents: number
    pricingSource: number
    pricingPair: number
    lastPriceUsd: number
    lastPriceAt: number
    _all: number
  }


  export type FeeConfigAvgAggregateInputType = {
    feeAmountEtnWei?: true
    targetUsdCents?: true
    lastPriceUsd?: true
  }

  export type FeeConfigSumAggregateInputType = {
    feeAmountEtnWei?: true
    targetUsdCents?: true
    lastPriceUsd?: true
  }

  export type FeeConfigMinAggregateInputType = {
    id?: true
    contractType?: true
    metadataOption?: true
    feeRecipient?: true
    feeAmountEtnWei?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    updatedByUserId?: true
    targetUsdCents?: true
    pricingSource?: true
    pricingPair?: true
    lastPriceUsd?: true
    lastPriceAt?: true
  }

  export type FeeConfigMaxAggregateInputType = {
    id?: true
    contractType?: true
    metadataOption?: true
    feeRecipient?: true
    feeAmountEtnWei?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    updatedByUserId?: true
    targetUsdCents?: true
    pricingSource?: true
    pricingPair?: true
    lastPriceUsd?: true
    lastPriceAt?: true
  }

  export type FeeConfigCountAggregateInputType = {
    id?: true
    contractType?: true
    metadataOption?: true
    feeRecipient?: true
    feeAmountEtnWei?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    updatedByUserId?: true
    targetUsdCents?: true
    pricingSource?: true
    pricingPair?: true
    lastPriceUsd?: true
    lastPriceAt?: true
    _all?: true
  }

  export type FeeConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeConfig to aggregate.
     */
    where?: FeeConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeConfigs to fetch.
     */
    orderBy?: FeeConfigOrderByWithRelationInput | FeeConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeConfigs
    **/
    _count?: true | FeeConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeConfigMaxAggregateInputType
  }

  export type GetFeeConfigAggregateType<T extends FeeConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeConfig[P]>
      : GetScalarType<T[P], AggregateFeeConfig[P]>
  }




  export type FeeConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeConfigWhereInput
    orderBy?: FeeConfigOrderByWithAggregationInput | FeeConfigOrderByWithAggregationInput[]
    by: FeeConfigScalarFieldEnum[] | FeeConfigScalarFieldEnum
    having?: FeeConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeConfigCountAggregateInputType | true
    _avg?: FeeConfigAvgAggregateInputType
    _sum?: FeeConfigSumAggregateInputType
    _min?: FeeConfigMinAggregateInputType
    _max?: FeeConfigMaxAggregateInputType
  }

  export type FeeConfigGroupByOutputType = {
    id: string
    contractType: $Enums.ContractType
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal
    active: boolean
    createdAt: Date
    updatedAt: Date
    updatedByUserId: string | null
    targetUsdCents: number | null
    pricingSource: string
    pricingPair: string
    lastPriceUsd: Decimal | null
    lastPriceAt: Date | null
    _count: FeeConfigCountAggregateOutputType | null
    _avg: FeeConfigAvgAggregateOutputType | null
    _sum: FeeConfigSumAggregateOutputType | null
    _min: FeeConfigMinAggregateOutputType | null
    _max: FeeConfigMaxAggregateOutputType | null
  }

  type GetFeeConfigGroupByPayload<T extends FeeConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeConfigGroupByOutputType[P]>
            : GetScalarType<T[P], FeeConfigGroupByOutputType[P]>
        }
      >
    >


  export type FeeConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractType?: boolean
    metadataOption?: boolean
    feeRecipient?: boolean
    feeAmountEtnWei?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedByUserId?: boolean
    targetUsdCents?: boolean
    pricingSource?: boolean
    pricingPair?: boolean
    lastPriceUsd?: boolean
    lastPriceAt?: boolean
    logs?: boolean | FeeConfig$logsArgs<ExtArgs>
    _count?: boolean | FeeConfigCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeConfig"]>

  export type FeeConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractType?: boolean
    metadataOption?: boolean
    feeRecipient?: boolean
    feeAmountEtnWei?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedByUserId?: boolean
    targetUsdCents?: boolean
    pricingSource?: boolean
    pricingPair?: boolean
    lastPriceUsd?: boolean
    lastPriceAt?: boolean
  }, ExtArgs["result"]["feeConfig"]>

  export type FeeConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractType?: boolean
    metadataOption?: boolean
    feeRecipient?: boolean
    feeAmountEtnWei?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedByUserId?: boolean
    targetUsdCents?: boolean
    pricingSource?: boolean
    pricingPair?: boolean
    lastPriceUsd?: boolean
    lastPriceAt?: boolean
  }, ExtArgs["result"]["feeConfig"]>

  export type FeeConfigSelectScalar = {
    id?: boolean
    contractType?: boolean
    metadataOption?: boolean
    feeRecipient?: boolean
    feeAmountEtnWei?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    updatedByUserId?: boolean
    targetUsdCents?: boolean
    pricingSource?: boolean
    pricingPair?: boolean
    lastPriceUsd?: boolean
    lastPriceAt?: boolean
  }

  export type FeeConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractType" | "metadataOption" | "feeRecipient" | "feeAmountEtnWei" | "active" | "createdAt" | "updatedAt" | "updatedByUserId" | "targetUsdCents" | "pricingSource" | "pricingPair" | "lastPriceUsd" | "lastPriceAt", ExtArgs["result"]["feeConfig"]>
  export type FeeConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | FeeConfig$logsArgs<ExtArgs>
    _count?: boolean | FeeConfigCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeeConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FeeConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FeeConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeConfig"
    objects: {
      logs: Prisma.$FeeConfigLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractType: $Enums.ContractType
      metadataOption: $Enums.MetadataOption
      feeRecipient: string
      feeAmountEtnWei: Prisma.Decimal
      active: boolean
      createdAt: Date
      updatedAt: Date
      updatedByUserId: string | null
      targetUsdCents: number | null
      pricingSource: string
      pricingPair: string
      lastPriceUsd: Prisma.Decimal | null
      lastPriceAt: Date | null
    }, ExtArgs["result"]["feeConfig"]>
    composites: {}
  }

  type FeeConfigGetPayload<S extends boolean | null | undefined | FeeConfigDefaultArgs> = $Result.GetResult<Prisma.$FeeConfigPayload, S>

  type FeeConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeeConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeeConfigCountAggregateInputType | true
    }

  export interface FeeConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeConfig'], meta: { name: 'FeeConfig' } }
    /**
     * Find zero or one FeeConfig that matches the filter.
     * @param {FeeConfigFindUniqueArgs} args - Arguments to find a FeeConfig
     * @example
     * // Get one FeeConfig
     * const feeConfig = await prisma.feeConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeConfigFindUniqueArgs>(args: SelectSubset<T, FeeConfigFindUniqueArgs<ExtArgs>>): Prisma__FeeConfigClient<$Result.GetResult<Prisma.$FeeConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeeConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeeConfigFindUniqueOrThrowArgs} args - Arguments to find a FeeConfig
     * @example
     * // Get one FeeConfig
     * const feeConfig = await prisma.feeConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeConfigClient<$Result.GetResult<Prisma.$FeeConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeConfigFindFirstArgs} args - Arguments to find a FeeConfig
     * @example
     * // Get one FeeConfig
     * const feeConfig = await prisma.feeConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeConfigFindFirstArgs>(args?: SelectSubset<T, FeeConfigFindFirstArgs<ExtArgs>>): Prisma__FeeConfigClient<$Result.GetResult<Prisma.$FeeConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeConfigFindFirstOrThrowArgs} args - Arguments to find a FeeConfig
     * @example
     * // Get one FeeConfig
     * const feeConfig = await prisma.feeConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeConfigClient<$Result.GetResult<Prisma.$FeeConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeeConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeConfigs
     * const feeConfigs = await prisma.feeConfig.findMany()
     * 
     * // Get first 10 FeeConfigs
     * const feeConfigs = await prisma.feeConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeConfigWithIdOnly = await prisma.feeConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeConfigFindManyArgs>(args?: SelectSubset<T, FeeConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeeConfig.
     * @param {FeeConfigCreateArgs} args - Arguments to create a FeeConfig.
     * @example
     * // Create one FeeConfig
     * const FeeConfig = await prisma.feeConfig.create({
     *   data: {
     *     // ... data to create a FeeConfig
     *   }
     * })
     * 
     */
    create<T extends FeeConfigCreateArgs>(args: SelectSubset<T, FeeConfigCreateArgs<ExtArgs>>): Prisma__FeeConfigClient<$Result.GetResult<Prisma.$FeeConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeeConfigs.
     * @param {FeeConfigCreateManyArgs} args - Arguments to create many FeeConfigs.
     * @example
     * // Create many FeeConfigs
     * const feeConfig = await prisma.feeConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeConfigCreateManyArgs>(args?: SelectSubset<T, FeeConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeeConfigs and returns the data saved in the database.
     * @param {FeeConfigCreateManyAndReturnArgs} args - Arguments to create many FeeConfigs.
     * @example
     * // Create many FeeConfigs
     * const feeConfig = await prisma.feeConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeeConfigs and only return the `id`
     * const feeConfigWithIdOnly = await prisma.feeConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeeConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, FeeConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeeConfig.
     * @param {FeeConfigDeleteArgs} args - Arguments to delete one FeeConfig.
     * @example
     * // Delete one FeeConfig
     * const FeeConfig = await prisma.feeConfig.delete({
     *   where: {
     *     // ... filter to delete one FeeConfig
     *   }
     * })
     * 
     */
    delete<T extends FeeConfigDeleteArgs>(args: SelectSubset<T, FeeConfigDeleteArgs<ExtArgs>>): Prisma__FeeConfigClient<$Result.GetResult<Prisma.$FeeConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeeConfig.
     * @param {FeeConfigUpdateArgs} args - Arguments to update one FeeConfig.
     * @example
     * // Update one FeeConfig
     * const feeConfig = await prisma.feeConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeConfigUpdateArgs>(args: SelectSubset<T, FeeConfigUpdateArgs<ExtArgs>>): Prisma__FeeConfigClient<$Result.GetResult<Prisma.$FeeConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeeConfigs.
     * @param {FeeConfigDeleteManyArgs} args - Arguments to filter FeeConfigs to delete.
     * @example
     * // Delete a few FeeConfigs
     * const { count } = await prisma.feeConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeConfigDeleteManyArgs>(args?: SelectSubset<T, FeeConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeConfigs
     * const feeConfig = await prisma.feeConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeConfigUpdateManyArgs>(args: SelectSubset<T, FeeConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeConfigs and returns the data updated in the database.
     * @param {FeeConfigUpdateManyAndReturnArgs} args - Arguments to update many FeeConfigs.
     * @example
     * // Update many FeeConfigs
     * const feeConfig = await prisma.feeConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeeConfigs and only return the `id`
     * const feeConfigWithIdOnly = await prisma.feeConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeeConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, FeeConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeeConfig.
     * @param {FeeConfigUpsertArgs} args - Arguments to update or create a FeeConfig.
     * @example
     * // Update or create a FeeConfig
     * const feeConfig = await prisma.feeConfig.upsert({
     *   create: {
     *     // ... data to create a FeeConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeConfig we want to update
     *   }
     * })
     */
    upsert<T extends FeeConfigUpsertArgs>(args: SelectSubset<T, FeeConfigUpsertArgs<ExtArgs>>): Prisma__FeeConfigClient<$Result.GetResult<Prisma.$FeeConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeeConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeConfigCountArgs} args - Arguments to filter FeeConfigs to count.
     * @example
     * // Count the number of FeeConfigs
     * const count = await prisma.feeConfig.count({
     *   where: {
     *     // ... the filter for the FeeConfigs we want to count
     *   }
     * })
    **/
    count<T extends FeeConfigCountArgs>(
      args?: Subset<T, FeeConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeConfigAggregateArgs>(args: Subset<T, FeeConfigAggregateArgs>): Prisma.PrismaPromise<GetFeeConfigAggregateType<T>>

    /**
     * Group by FeeConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeConfigGroupByArgs['orderBy'] }
        : { orderBy?: FeeConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeConfig model
   */
  readonly fields: FeeConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    logs<T extends FeeConfig$logsArgs<ExtArgs> = {}>(args?: Subset<T, FeeConfig$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeConfigLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeeConfig model
   */
  interface FeeConfigFieldRefs {
    readonly id: FieldRef<"FeeConfig", 'String'>
    readonly contractType: FieldRef<"FeeConfig", 'ContractType'>
    readonly metadataOption: FieldRef<"FeeConfig", 'MetadataOption'>
    readonly feeRecipient: FieldRef<"FeeConfig", 'String'>
    readonly feeAmountEtnWei: FieldRef<"FeeConfig", 'Decimal'>
    readonly active: FieldRef<"FeeConfig", 'Boolean'>
    readonly createdAt: FieldRef<"FeeConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"FeeConfig", 'DateTime'>
    readonly updatedByUserId: FieldRef<"FeeConfig", 'String'>
    readonly targetUsdCents: FieldRef<"FeeConfig", 'Int'>
    readonly pricingSource: FieldRef<"FeeConfig", 'String'>
    readonly pricingPair: FieldRef<"FeeConfig", 'String'>
    readonly lastPriceUsd: FieldRef<"FeeConfig", 'Decimal'>
    readonly lastPriceAt: FieldRef<"FeeConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeeConfig findUnique
   */
  export type FeeConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfig
     */
    select?: FeeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfig
     */
    omit?: FeeConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigInclude<ExtArgs> | null
    /**
     * Filter, which FeeConfig to fetch.
     */
    where: FeeConfigWhereUniqueInput
  }

  /**
   * FeeConfig findUniqueOrThrow
   */
  export type FeeConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfig
     */
    select?: FeeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfig
     */
    omit?: FeeConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigInclude<ExtArgs> | null
    /**
     * Filter, which FeeConfig to fetch.
     */
    where: FeeConfigWhereUniqueInput
  }

  /**
   * FeeConfig findFirst
   */
  export type FeeConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfig
     */
    select?: FeeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfig
     */
    omit?: FeeConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigInclude<ExtArgs> | null
    /**
     * Filter, which FeeConfig to fetch.
     */
    where?: FeeConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeConfigs to fetch.
     */
    orderBy?: FeeConfigOrderByWithRelationInput | FeeConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeConfigs.
     */
    cursor?: FeeConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeConfigs.
     */
    distinct?: FeeConfigScalarFieldEnum | FeeConfigScalarFieldEnum[]
  }

  /**
   * FeeConfig findFirstOrThrow
   */
  export type FeeConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfig
     */
    select?: FeeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfig
     */
    omit?: FeeConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigInclude<ExtArgs> | null
    /**
     * Filter, which FeeConfig to fetch.
     */
    where?: FeeConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeConfigs to fetch.
     */
    orderBy?: FeeConfigOrderByWithRelationInput | FeeConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeConfigs.
     */
    cursor?: FeeConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeConfigs.
     */
    distinct?: FeeConfigScalarFieldEnum | FeeConfigScalarFieldEnum[]
  }

  /**
   * FeeConfig findMany
   */
  export type FeeConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfig
     */
    select?: FeeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfig
     */
    omit?: FeeConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigInclude<ExtArgs> | null
    /**
     * Filter, which FeeConfigs to fetch.
     */
    where?: FeeConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeConfigs to fetch.
     */
    orderBy?: FeeConfigOrderByWithRelationInput | FeeConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeConfigs.
     */
    cursor?: FeeConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeConfigs.
     */
    skip?: number
    distinct?: FeeConfigScalarFieldEnum | FeeConfigScalarFieldEnum[]
  }

  /**
   * FeeConfig create
   */
  export type FeeConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfig
     */
    select?: FeeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfig
     */
    omit?: FeeConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeConfig.
     */
    data: XOR<FeeConfigCreateInput, FeeConfigUncheckedCreateInput>
  }

  /**
   * FeeConfig createMany
   */
  export type FeeConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeeConfigs.
     */
    data: FeeConfigCreateManyInput | FeeConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeeConfig createManyAndReturn
   */
  export type FeeConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfig
     */
    select?: FeeConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfig
     */
    omit?: FeeConfigOmit<ExtArgs> | null
    /**
     * The data used to create many FeeConfigs.
     */
    data: FeeConfigCreateManyInput | FeeConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeeConfig update
   */
  export type FeeConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfig
     */
    select?: FeeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfig
     */
    omit?: FeeConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeConfig.
     */
    data: XOR<FeeConfigUpdateInput, FeeConfigUncheckedUpdateInput>
    /**
     * Choose, which FeeConfig to update.
     */
    where: FeeConfigWhereUniqueInput
  }

  /**
   * FeeConfig updateMany
   */
  export type FeeConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeConfigs.
     */
    data: XOR<FeeConfigUpdateManyMutationInput, FeeConfigUncheckedUpdateManyInput>
    /**
     * Filter which FeeConfigs to update
     */
    where?: FeeConfigWhereInput
    /**
     * Limit how many FeeConfigs to update.
     */
    limit?: number
  }

  /**
   * FeeConfig updateManyAndReturn
   */
  export type FeeConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfig
     */
    select?: FeeConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfig
     */
    omit?: FeeConfigOmit<ExtArgs> | null
    /**
     * The data used to update FeeConfigs.
     */
    data: XOR<FeeConfigUpdateManyMutationInput, FeeConfigUncheckedUpdateManyInput>
    /**
     * Filter which FeeConfigs to update
     */
    where?: FeeConfigWhereInput
    /**
     * Limit how many FeeConfigs to update.
     */
    limit?: number
  }

  /**
   * FeeConfig upsert
   */
  export type FeeConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfig
     */
    select?: FeeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfig
     */
    omit?: FeeConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeConfig to update in case it exists.
     */
    where: FeeConfigWhereUniqueInput
    /**
     * In case the FeeConfig found by the `where` argument doesn't exist, create a new FeeConfig with this data.
     */
    create: XOR<FeeConfigCreateInput, FeeConfigUncheckedCreateInput>
    /**
     * In case the FeeConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeConfigUpdateInput, FeeConfigUncheckedUpdateInput>
  }

  /**
   * FeeConfig delete
   */
  export type FeeConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfig
     */
    select?: FeeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfig
     */
    omit?: FeeConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigInclude<ExtArgs> | null
    /**
     * Filter which FeeConfig to delete.
     */
    where: FeeConfigWhereUniqueInput
  }

  /**
   * FeeConfig deleteMany
   */
  export type FeeConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeConfigs to delete
     */
    where?: FeeConfigWhereInput
    /**
     * Limit how many FeeConfigs to delete.
     */
    limit?: number
  }

  /**
   * FeeConfig.logs
   */
  export type FeeConfig$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfigLog
     */
    select?: FeeConfigLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfigLog
     */
    omit?: FeeConfigLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigLogInclude<ExtArgs> | null
    where?: FeeConfigLogWhereInput
    orderBy?: FeeConfigLogOrderByWithRelationInput | FeeConfigLogOrderByWithRelationInput[]
    cursor?: FeeConfigLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeConfigLogScalarFieldEnum | FeeConfigLogScalarFieldEnum[]
  }

  /**
   * FeeConfig without action
   */
  export type FeeConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfig
     */
    select?: FeeConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfig
     */
    omit?: FeeConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigInclude<ExtArgs> | null
  }


  /**
   * Model FeeConfigLog
   */

  export type AggregateFeeConfigLog = {
    _count: FeeConfigLogCountAggregateOutputType | null
    _avg: FeeConfigLogAvgAggregateOutputType | null
    _sum: FeeConfigLogSumAggregateOutputType | null
    _min: FeeConfigLogMinAggregateOutputType | null
    _max: FeeConfigLogMaxAggregateOutputType | null
  }

  export type FeeConfigLogAvgAggregateOutputType = {
    previousAmountEtnWei: Decimal | null
    newAmountEtnWei: Decimal | null
  }

  export type FeeConfigLogSumAggregateOutputType = {
    previousAmountEtnWei: Decimal | null
    newAmountEtnWei: Decimal | null
  }

  export type FeeConfigLogMinAggregateOutputType = {
    id: string | null
    feeConfigId: string | null
    previousRecipient: string | null
    newRecipient: string | null
    previousAmountEtnWei: Decimal | null
    newAmountEtnWei: Decimal | null
    changedByUserId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type FeeConfigLogMaxAggregateOutputType = {
    id: string | null
    feeConfigId: string | null
    previousRecipient: string | null
    newRecipient: string | null
    previousAmountEtnWei: Decimal | null
    newAmountEtnWei: Decimal | null
    changedByUserId: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type FeeConfigLogCountAggregateOutputType = {
    id: number
    feeConfigId: number
    previousRecipient: number
    newRecipient: number
    previousAmountEtnWei: number
    newAmountEtnWei: number
    changedByUserId: number
    reason: number
    createdAt: number
    _all: number
  }


  export type FeeConfigLogAvgAggregateInputType = {
    previousAmountEtnWei?: true
    newAmountEtnWei?: true
  }

  export type FeeConfigLogSumAggregateInputType = {
    previousAmountEtnWei?: true
    newAmountEtnWei?: true
  }

  export type FeeConfigLogMinAggregateInputType = {
    id?: true
    feeConfigId?: true
    previousRecipient?: true
    newRecipient?: true
    previousAmountEtnWei?: true
    newAmountEtnWei?: true
    changedByUserId?: true
    reason?: true
    createdAt?: true
  }

  export type FeeConfigLogMaxAggregateInputType = {
    id?: true
    feeConfigId?: true
    previousRecipient?: true
    newRecipient?: true
    previousAmountEtnWei?: true
    newAmountEtnWei?: true
    changedByUserId?: true
    reason?: true
    createdAt?: true
  }

  export type FeeConfigLogCountAggregateInputType = {
    id?: true
    feeConfigId?: true
    previousRecipient?: true
    newRecipient?: true
    previousAmountEtnWei?: true
    newAmountEtnWei?: true
    changedByUserId?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type FeeConfigLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeConfigLog to aggregate.
     */
    where?: FeeConfigLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeConfigLogs to fetch.
     */
    orderBy?: FeeConfigLogOrderByWithRelationInput | FeeConfigLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeConfigLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeConfigLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeConfigLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeConfigLogs
    **/
    _count?: true | FeeConfigLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeConfigLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeConfigLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeConfigLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeConfigLogMaxAggregateInputType
  }

  export type GetFeeConfigLogAggregateType<T extends FeeConfigLogAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeConfigLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeConfigLog[P]>
      : GetScalarType<T[P], AggregateFeeConfigLog[P]>
  }




  export type FeeConfigLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeConfigLogWhereInput
    orderBy?: FeeConfigLogOrderByWithAggregationInput | FeeConfigLogOrderByWithAggregationInput[]
    by: FeeConfigLogScalarFieldEnum[] | FeeConfigLogScalarFieldEnum
    having?: FeeConfigLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeConfigLogCountAggregateInputType | true
    _avg?: FeeConfigLogAvgAggregateInputType
    _sum?: FeeConfigLogSumAggregateInputType
    _min?: FeeConfigLogMinAggregateInputType
    _max?: FeeConfigLogMaxAggregateInputType
  }

  export type FeeConfigLogGroupByOutputType = {
    id: string
    feeConfigId: string
    previousRecipient: string | null
    newRecipient: string | null
    previousAmountEtnWei: Decimal | null
    newAmountEtnWei: Decimal | null
    changedByUserId: string | null
    reason: string | null
    createdAt: Date
    _count: FeeConfigLogCountAggregateOutputType | null
    _avg: FeeConfigLogAvgAggregateOutputType | null
    _sum: FeeConfigLogSumAggregateOutputType | null
    _min: FeeConfigLogMinAggregateOutputType | null
    _max: FeeConfigLogMaxAggregateOutputType | null
  }

  type GetFeeConfigLogGroupByPayload<T extends FeeConfigLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeConfigLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeConfigLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeConfigLogGroupByOutputType[P]>
            : GetScalarType<T[P], FeeConfigLogGroupByOutputType[P]>
        }
      >
    >


  export type FeeConfigLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeConfigId?: boolean
    previousRecipient?: boolean
    newRecipient?: boolean
    previousAmountEtnWei?: boolean
    newAmountEtnWei?: boolean
    changedByUserId?: boolean
    reason?: boolean
    createdAt?: boolean
    feeConfig?: boolean | FeeConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeConfigLog"]>

  export type FeeConfigLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeConfigId?: boolean
    previousRecipient?: boolean
    newRecipient?: boolean
    previousAmountEtnWei?: boolean
    newAmountEtnWei?: boolean
    changedByUserId?: boolean
    reason?: boolean
    createdAt?: boolean
    feeConfig?: boolean | FeeConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeConfigLog"]>

  export type FeeConfigLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feeConfigId?: boolean
    previousRecipient?: boolean
    newRecipient?: boolean
    previousAmountEtnWei?: boolean
    newAmountEtnWei?: boolean
    changedByUserId?: boolean
    reason?: boolean
    createdAt?: boolean
    feeConfig?: boolean | FeeConfigDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeConfigLog"]>

  export type FeeConfigLogSelectScalar = {
    id?: boolean
    feeConfigId?: boolean
    previousRecipient?: boolean
    newRecipient?: boolean
    previousAmountEtnWei?: boolean
    newAmountEtnWei?: boolean
    changedByUserId?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type FeeConfigLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feeConfigId" | "previousRecipient" | "newRecipient" | "previousAmountEtnWei" | "newAmountEtnWei" | "changedByUserId" | "reason" | "createdAt", ExtArgs["result"]["feeConfigLog"]>
  export type FeeConfigLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeConfig?: boolean | FeeConfigDefaultArgs<ExtArgs>
  }
  export type FeeConfigLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeConfig?: boolean | FeeConfigDefaultArgs<ExtArgs>
  }
  export type FeeConfigLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeConfig?: boolean | FeeConfigDefaultArgs<ExtArgs>
  }

  export type $FeeConfigLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeConfigLog"
    objects: {
      feeConfig: Prisma.$FeeConfigPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      feeConfigId: string
      previousRecipient: string | null
      newRecipient: string | null
      previousAmountEtnWei: Prisma.Decimal | null
      newAmountEtnWei: Prisma.Decimal | null
      changedByUserId: string | null
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["feeConfigLog"]>
    composites: {}
  }

  type FeeConfigLogGetPayload<S extends boolean | null | undefined | FeeConfigLogDefaultArgs> = $Result.GetResult<Prisma.$FeeConfigLogPayload, S>

  type FeeConfigLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeeConfigLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeeConfigLogCountAggregateInputType | true
    }

  export interface FeeConfigLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeConfigLog'], meta: { name: 'FeeConfigLog' } }
    /**
     * Find zero or one FeeConfigLog that matches the filter.
     * @param {FeeConfigLogFindUniqueArgs} args - Arguments to find a FeeConfigLog
     * @example
     * // Get one FeeConfigLog
     * const feeConfigLog = await prisma.feeConfigLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeConfigLogFindUniqueArgs>(args: SelectSubset<T, FeeConfigLogFindUniqueArgs<ExtArgs>>): Prisma__FeeConfigLogClient<$Result.GetResult<Prisma.$FeeConfigLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeeConfigLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeeConfigLogFindUniqueOrThrowArgs} args - Arguments to find a FeeConfigLog
     * @example
     * // Get one FeeConfigLog
     * const feeConfigLog = await prisma.feeConfigLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeConfigLogFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeConfigLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeConfigLogClient<$Result.GetResult<Prisma.$FeeConfigLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeConfigLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeConfigLogFindFirstArgs} args - Arguments to find a FeeConfigLog
     * @example
     * // Get one FeeConfigLog
     * const feeConfigLog = await prisma.feeConfigLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeConfigLogFindFirstArgs>(args?: SelectSubset<T, FeeConfigLogFindFirstArgs<ExtArgs>>): Prisma__FeeConfigLogClient<$Result.GetResult<Prisma.$FeeConfigLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeConfigLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeConfigLogFindFirstOrThrowArgs} args - Arguments to find a FeeConfigLog
     * @example
     * // Get one FeeConfigLog
     * const feeConfigLog = await prisma.feeConfigLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeConfigLogFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeConfigLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeConfigLogClient<$Result.GetResult<Prisma.$FeeConfigLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeeConfigLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeConfigLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeConfigLogs
     * const feeConfigLogs = await prisma.feeConfigLog.findMany()
     * 
     * // Get first 10 FeeConfigLogs
     * const feeConfigLogs = await prisma.feeConfigLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeConfigLogWithIdOnly = await prisma.feeConfigLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeConfigLogFindManyArgs>(args?: SelectSubset<T, FeeConfigLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeConfigLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeeConfigLog.
     * @param {FeeConfigLogCreateArgs} args - Arguments to create a FeeConfigLog.
     * @example
     * // Create one FeeConfigLog
     * const FeeConfigLog = await prisma.feeConfigLog.create({
     *   data: {
     *     // ... data to create a FeeConfigLog
     *   }
     * })
     * 
     */
    create<T extends FeeConfigLogCreateArgs>(args: SelectSubset<T, FeeConfigLogCreateArgs<ExtArgs>>): Prisma__FeeConfigLogClient<$Result.GetResult<Prisma.$FeeConfigLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeeConfigLogs.
     * @param {FeeConfigLogCreateManyArgs} args - Arguments to create many FeeConfigLogs.
     * @example
     * // Create many FeeConfigLogs
     * const feeConfigLog = await prisma.feeConfigLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeConfigLogCreateManyArgs>(args?: SelectSubset<T, FeeConfigLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeeConfigLogs and returns the data saved in the database.
     * @param {FeeConfigLogCreateManyAndReturnArgs} args - Arguments to create many FeeConfigLogs.
     * @example
     * // Create many FeeConfigLogs
     * const feeConfigLog = await prisma.feeConfigLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeeConfigLogs and only return the `id`
     * const feeConfigLogWithIdOnly = await prisma.feeConfigLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeeConfigLogCreateManyAndReturnArgs>(args?: SelectSubset<T, FeeConfigLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeConfigLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeeConfigLog.
     * @param {FeeConfigLogDeleteArgs} args - Arguments to delete one FeeConfigLog.
     * @example
     * // Delete one FeeConfigLog
     * const FeeConfigLog = await prisma.feeConfigLog.delete({
     *   where: {
     *     // ... filter to delete one FeeConfigLog
     *   }
     * })
     * 
     */
    delete<T extends FeeConfigLogDeleteArgs>(args: SelectSubset<T, FeeConfigLogDeleteArgs<ExtArgs>>): Prisma__FeeConfigLogClient<$Result.GetResult<Prisma.$FeeConfigLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeeConfigLog.
     * @param {FeeConfigLogUpdateArgs} args - Arguments to update one FeeConfigLog.
     * @example
     * // Update one FeeConfigLog
     * const feeConfigLog = await prisma.feeConfigLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeConfigLogUpdateArgs>(args: SelectSubset<T, FeeConfigLogUpdateArgs<ExtArgs>>): Prisma__FeeConfigLogClient<$Result.GetResult<Prisma.$FeeConfigLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeeConfigLogs.
     * @param {FeeConfigLogDeleteManyArgs} args - Arguments to filter FeeConfigLogs to delete.
     * @example
     * // Delete a few FeeConfigLogs
     * const { count } = await prisma.feeConfigLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeConfigLogDeleteManyArgs>(args?: SelectSubset<T, FeeConfigLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeConfigLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeConfigLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeConfigLogs
     * const feeConfigLog = await prisma.feeConfigLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeConfigLogUpdateManyArgs>(args: SelectSubset<T, FeeConfigLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeConfigLogs and returns the data updated in the database.
     * @param {FeeConfigLogUpdateManyAndReturnArgs} args - Arguments to update many FeeConfigLogs.
     * @example
     * // Update many FeeConfigLogs
     * const feeConfigLog = await prisma.feeConfigLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeeConfigLogs and only return the `id`
     * const feeConfigLogWithIdOnly = await prisma.feeConfigLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeeConfigLogUpdateManyAndReturnArgs>(args: SelectSubset<T, FeeConfigLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeConfigLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeeConfigLog.
     * @param {FeeConfigLogUpsertArgs} args - Arguments to update or create a FeeConfigLog.
     * @example
     * // Update or create a FeeConfigLog
     * const feeConfigLog = await prisma.feeConfigLog.upsert({
     *   create: {
     *     // ... data to create a FeeConfigLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeConfigLog we want to update
     *   }
     * })
     */
    upsert<T extends FeeConfigLogUpsertArgs>(args: SelectSubset<T, FeeConfigLogUpsertArgs<ExtArgs>>): Prisma__FeeConfigLogClient<$Result.GetResult<Prisma.$FeeConfigLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeeConfigLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeConfigLogCountArgs} args - Arguments to filter FeeConfigLogs to count.
     * @example
     * // Count the number of FeeConfigLogs
     * const count = await prisma.feeConfigLog.count({
     *   where: {
     *     // ... the filter for the FeeConfigLogs we want to count
     *   }
     * })
    **/
    count<T extends FeeConfigLogCountArgs>(
      args?: Subset<T, FeeConfigLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeConfigLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeConfigLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeConfigLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeConfigLogAggregateArgs>(args: Subset<T, FeeConfigLogAggregateArgs>): Prisma.PrismaPromise<GetFeeConfigLogAggregateType<T>>

    /**
     * Group by FeeConfigLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeConfigLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeConfigLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeConfigLogGroupByArgs['orderBy'] }
        : { orderBy?: FeeConfigLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeConfigLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeConfigLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeConfigLog model
   */
  readonly fields: FeeConfigLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeConfigLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeConfigLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feeConfig<T extends FeeConfigDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeeConfigDefaultArgs<ExtArgs>>): Prisma__FeeConfigClient<$Result.GetResult<Prisma.$FeeConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeeConfigLog model
   */
  interface FeeConfigLogFieldRefs {
    readonly id: FieldRef<"FeeConfigLog", 'String'>
    readonly feeConfigId: FieldRef<"FeeConfigLog", 'String'>
    readonly previousRecipient: FieldRef<"FeeConfigLog", 'String'>
    readonly newRecipient: FieldRef<"FeeConfigLog", 'String'>
    readonly previousAmountEtnWei: FieldRef<"FeeConfigLog", 'Decimal'>
    readonly newAmountEtnWei: FieldRef<"FeeConfigLog", 'Decimal'>
    readonly changedByUserId: FieldRef<"FeeConfigLog", 'String'>
    readonly reason: FieldRef<"FeeConfigLog", 'String'>
    readonly createdAt: FieldRef<"FeeConfigLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeeConfigLog findUnique
   */
  export type FeeConfigLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfigLog
     */
    select?: FeeConfigLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfigLog
     */
    omit?: FeeConfigLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigLogInclude<ExtArgs> | null
    /**
     * Filter, which FeeConfigLog to fetch.
     */
    where: FeeConfigLogWhereUniqueInput
  }

  /**
   * FeeConfigLog findUniqueOrThrow
   */
  export type FeeConfigLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfigLog
     */
    select?: FeeConfigLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfigLog
     */
    omit?: FeeConfigLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigLogInclude<ExtArgs> | null
    /**
     * Filter, which FeeConfigLog to fetch.
     */
    where: FeeConfigLogWhereUniqueInput
  }

  /**
   * FeeConfigLog findFirst
   */
  export type FeeConfigLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfigLog
     */
    select?: FeeConfigLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfigLog
     */
    omit?: FeeConfigLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigLogInclude<ExtArgs> | null
    /**
     * Filter, which FeeConfigLog to fetch.
     */
    where?: FeeConfigLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeConfigLogs to fetch.
     */
    orderBy?: FeeConfigLogOrderByWithRelationInput | FeeConfigLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeConfigLogs.
     */
    cursor?: FeeConfigLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeConfigLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeConfigLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeConfigLogs.
     */
    distinct?: FeeConfigLogScalarFieldEnum | FeeConfigLogScalarFieldEnum[]
  }

  /**
   * FeeConfigLog findFirstOrThrow
   */
  export type FeeConfigLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfigLog
     */
    select?: FeeConfigLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfigLog
     */
    omit?: FeeConfigLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigLogInclude<ExtArgs> | null
    /**
     * Filter, which FeeConfigLog to fetch.
     */
    where?: FeeConfigLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeConfigLogs to fetch.
     */
    orderBy?: FeeConfigLogOrderByWithRelationInput | FeeConfigLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeConfigLogs.
     */
    cursor?: FeeConfigLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeConfigLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeConfigLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeConfigLogs.
     */
    distinct?: FeeConfigLogScalarFieldEnum | FeeConfigLogScalarFieldEnum[]
  }

  /**
   * FeeConfigLog findMany
   */
  export type FeeConfigLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfigLog
     */
    select?: FeeConfigLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfigLog
     */
    omit?: FeeConfigLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigLogInclude<ExtArgs> | null
    /**
     * Filter, which FeeConfigLogs to fetch.
     */
    where?: FeeConfigLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeConfigLogs to fetch.
     */
    orderBy?: FeeConfigLogOrderByWithRelationInput | FeeConfigLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeConfigLogs.
     */
    cursor?: FeeConfigLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeConfigLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeConfigLogs.
     */
    skip?: number
    distinct?: FeeConfigLogScalarFieldEnum | FeeConfigLogScalarFieldEnum[]
  }

  /**
   * FeeConfigLog create
   */
  export type FeeConfigLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfigLog
     */
    select?: FeeConfigLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfigLog
     */
    omit?: FeeConfigLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigLogInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeConfigLog.
     */
    data: XOR<FeeConfigLogCreateInput, FeeConfigLogUncheckedCreateInput>
  }

  /**
   * FeeConfigLog createMany
   */
  export type FeeConfigLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeeConfigLogs.
     */
    data: FeeConfigLogCreateManyInput | FeeConfigLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeeConfigLog createManyAndReturn
   */
  export type FeeConfigLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfigLog
     */
    select?: FeeConfigLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfigLog
     */
    omit?: FeeConfigLogOmit<ExtArgs> | null
    /**
     * The data used to create many FeeConfigLogs.
     */
    data: FeeConfigLogCreateManyInput | FeeConfigLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeConfigLog update
   */
  export type FeeConfigLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfigLog
     */
    select?: FeeConfigLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfigLog
     */
    omit?: FeeConfigLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigLogInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeConfigLog.
     */
    data: XOR<FeeConfigLogUpdateInput, FeeConfigLogUncheckedUpdateInput>
    /**
     * Choose, which FeeConfigLog to update.
     */
    where: FeeConfigLogWhereUniqueInput
  }

  /**
   * FeeConfigLog updateMany
   */
  export type FeeConfigLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeConfigLogs.
     */
    data: XOR<FeeConfigLogUpdateManyMutationInput, FeeConfigLogUncheckedUpdateManyInput>
    /**
     * Filter which FeeConfigLogs to update
     */
    where?: FeeConfigLogWhereInput
    /**
     * Limit how many FeeConfigLogs to update.
     */
    limit?: number
  }

  /**
   * FeeConfigLog updateManyAndReturn
   */
  export type FeeConfigLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfigLog
     */
    select?: FeeConfigLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfigLog
     */
    omit?: FeeConfigLogOmit<ExtArgs> | null
    /**
     * The data used to update FeeConfigLogs.
     */
    data: XOR<FeeConfigLogUpdateManyMutationInput, FeeConfigLogUncheckedUpdateManyInput>
    /**
     * Filter which FeeConfigLogs to update
     */
    where?: FeeConfigLogWhereInput
    /**
     * Limit how many FeeConfigLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeConfigLog upsert
   */
  export type FeeConfigLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfigLog
     */
    select?: FeeConfigLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfigLog
     */
    omit?: FeeConfigLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigLogInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeConfigLog to update in case it exists.
     */
    where: FeeConfigLogWhereUniqueInput
    /**
     * In case the FeeConfigLog found by the `where` argument doesn't exist, create a new FeeConfigLog with this data.
     */
    create: XOR<FeeConfigLogCreateInput, FeeConfigLogUncheckedCreateInput>
    /**
     * In case the FeeConfigLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeConfigLogUpdateInput, FeeConfigLogUncheckedUpdateInput>
  }

  /**
   * FeeConfigLog delete
   */
  export type FeeConfigLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfigLog
     */
    select?: FeeConfigLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfigLog
     */
    omit?: FeeConfigLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigLogInclude<ExtArgs> | null
    /**
     * Filter which FeeConfigLog to delete.
     */
    where: FeeConfigLogWhereUniqueInput
  }

  /**
   * FeeConfigLog deleteMany
   */
  export type FeeConfigLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeConfigLogs to delete
     */
    where?: FeeConfigLogWhereInput
    /**
     * Limit how many FeeConfigLogs to delete.
     */
    limit?: number
  }

  /**
   * FeeConfigLog without action
   */
  export type FeeConfigLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeConfigLog
     */
    select?: FeeConfigLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeConfigLog
     */
    omit?: FeeConfigLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeConfigLogInclude<ExtArgs> | null
  }


  /**
   * Model PublicSale
   */

  export type AggregatePublicSale = {
    _count: PublicSaleCountAggregateOutputType | null
    _avg: PublicSaleAvgAggregateOutputType | null
    _sum: PublicSaleSumAggregateOutputType | null
    _min: PublicSaleMinAggregateOutputType | null
    _max: PublicSaleMaxAggregateOutputType | null
  }

  export type PublicSaleAvgAggregateOutputType = {
    priceEtnWei: Decimal | null
    maxPerWallet: number | null
    maxPerTx: number | null
  }

  export type PublicSaleSumAggregateOutputType = {
    priceEtnWei: Decimal | null
    maxPerWallet: number | null
    maxPerTx: number | null
  }

  export type PublicSaleMinAggregateOutputType = {
    id: string | null
    collectionId: string | null
    startTime: Date | null
    priceEtnWei: Decimal | null
    maxPerWallet: number | null
    maxPerTx: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PublicSaleMaxAggregateOutputType = {
    id: string | null
    collectionId: string | null
    startTime: Date | null
    priceEtnWei: Decimal | null
    maxPerWallet: number | null
    maxPerTx: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PublicSaleCountAggregateOutputType = {
    id: number
    collectionId: number
    startTime: number
    priceEtnWei: number
    maxPerWallet: number
    maxPerTx: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PublicSaleAvgAggregateInputType = {
    priceEtnWei?: true
    maxPerWallet?: true
    maxPerTx?: true
  }

  export type PublicSaleSumAggregateInputType = {
    priceEtnWei?: true
    maxPerWallet?: true
    maxPerTx?: true
  }

  export type PublicSaleMinAggregateInputType = {
    id?: true
    collectionId?: true
    startTime?: true
    priceEtnWei?: true
    maxPerWallet?: true
    maxPerTx?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PublicSaleMaxAggregateInputType = {
    id?: true
    collectionId?: true
    startTime?: true
    priceEtnWei?: true
    maxPerWallet?: true
    maxPerTx?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PublicSaleCountAggregateInputType = {
    id?: true
    collectionId?: true
    startTime?: true
    priceEtnWei?: true
    maxPerWallet?: true
    maxPerTx?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PublicSaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublicSale to aggregate.
     */
    where?: PublicSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicSales to fetch.
     */
    orderBy?: PublicSaleOrderByWithRelationInput | PublicSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublicSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PublicSales
    **/
    _count?: true | PublicSaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PublicSaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PublicSaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicSaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicSaleMaxAggregateInputType
  }

  export type GetPublicSaleAggregateType<T extends PublicSaleAggregateArgs> = {
        [P in keyof T & keyof AggregatePublicSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublicSale[P]>
      : GetScalarType<T[P], AggregatePublicSale[P]>
  }




  export type PublicSaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicSaleWhereInput
    orderBy?: PublicSaleOrderByWithAggregationInput | PublicSaleOrderByWithAggregationInput[]
    by: PublicSaleScalarFieldEnum[] | PublicSaleScalarFieldEnum
    having?: PublicSaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicSaleCountAggregateInputType | true
    _avg?: PublicSaleAvgAggregateInputType
    _sum?: PublicSaleSumAggregateInputType
    _min?: PublicSaleMinAggregateInputType
    _max?: PublicSaleMaxAggregateInputType
  }

  export type PublicSaleGroupByOutputType = {
    id: string
    collectionId: string
    startTime: Date
    priceEtnWei: Decimal
    maxPerWallet: number
    maxPerTx: number
    createdAt: Date
    updatedAt: Date
    _count: PublicSaleCountAggregateOutputType | null
    _avg: PublicSaleAvgAggregateOutputType | null
    _sum: PublicSaleSumAggregateOutputType | null
    _min: PublicSaleMinAggregateOutputType | null
    _max: PublicSaleMaxAggregateOutputType | null
  }

  type GetPublicSaleGroupByPayload<T extends PublicSaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicSaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicSaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicSaleGroupByOutputType[P]>
            : GetScalarType<T[P], PublicSaleGroupByOutputType[P]>
        }
      >
    >


  export type PublicSaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionId?: boolean
    startTime?: boolean
    priceEtnWei?: boolean
    maxPerWallet?: boolean
    maxPerTx?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publicSale"]>

  export type PublicSaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionId?: boolean
    startTime?: boolean
    priceEtnWei?: boolean
    maxPerWallet?: boolean
    maxPerTx?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publicSale"]>

  export type PublicSaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionId?: boolean
    startTime?: boolean
    priceEtnWei?: boolean
    maxPerWallet?: boolean
    maxPerTx?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publicSale"]>

  export type PublicSaleSelectScalar = {
    id?: boolean
    collectionId?: boolean
    startTime?: boolean
    priceEtnWei?: boolean
    maxPerWallet?: boolean
    maxPerTx?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PublicSaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "collectionId" | "startTime" | "priceEtnWei" | "maxPerWallet" | "maxPerTx" | "createdAt" | "updatedAt", ExtArgs["result"]["publicSale"]>
  export type PublicSaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }
  export type PublicSaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }
  export type PublicSaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }

  export type $PublicSalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PublicSale"
    objects: {
      collection: Prisma.$CollectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      collectionId: string
      startTime: Date
      priceEtnWei: Prisma.Decimal
      maxPerWallet: number
      maxPerTx: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["publicSale"]>
    composites: {}
  }

  type PublicSaleGetPayload<S extends boolean | null | undefined | PublicSaleDefaultArgs> = $Result.GetResult<Prisma.$PublicSalePayload, S>

  type PublicSaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PublicSaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PublicSaleCountAggregateInputType | true
    }

  export interface PublicSaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PublicSale'], meta: { name: 'PublicSale' } }
    /**
     * Find zero or one PublicSale that matches the filter.
     * @param {PublicSaleFindUniqueArgs} args - Arguments to find a PublicSale
     * @example
     * // Get one PublicSale
     * const publicSale = await prisma.publicSale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PublicSaleFindUniqueArgs>(args: SelectSubset<T, PublicSaleFindUniqueArgs<ExtArgs>>): Prisma__PublicSaleClient<$Result.GetResult<Prisma.$PublicSalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PublicSale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PublicSaleFindUniqueOrThrowArgs} args - Arguments to find a PublicSale
     * @example
     * // Get one PublicSale
     * const publicSale = await prisma.publicSale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PublicSaleFindUniqueOrThrowArgs>(args: SelectSubset<T, PublicSaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PublicSaleClient<$Result.GetResult<Prisma.$PublicSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PublicSale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicSaleFindFirstArgs} args - Arguments to find a PublicSale
     * @example
     * // Get one PublicSale
     * const publicSale = await prisma.publicSale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PublicSaleFindFirstArgs>(args?: SelectSubset<T, PublicSaleFindFirstArgs<ExtArgs>>): Prisma__PublicSaleClient<$Result.GetResult<Prisma.$PublicSalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PublicSale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicSaleFindFirstOrThrowArgs} args - Arguments to find a PublicSale
     * @example
     * // Get one PublicSale
     * const publicSale = await prisma.publicSale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PublicSaleFindFirstOrThrowArgs>(args?: SelectSubset<T, PublicSaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PublicSaleClient<$Result.GetResult<Prisma.$PublicSalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PublicSales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicSaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PublicSales
     * const publicSales = await prisma.publicSale.findMany()
     * 
     * // Get first 10 PublicSales
     * const publicSales = await prisma.publicSale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publicSaleWithIdOnly = await prisma.publicSale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PublicSaleFindManyArgs>(args?: SelectSubset<T, PublicSaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PublicSale.
     * @param {PublicSaleCreateArgs} args - Arguments to create a PublicSale.
     * @example
     * // Create one PublicSale
     * const PublicSale = await prisma.publicSale.create({
     *   data: {
     *     // ... data to create a PublicSale
     *   }
     * })
     * 
     */
    create<T extends PublicSaleCreateArgs>(args: SelectSubset<T, PublicSaleCreateArgs<ExtArgs>>): Prisma__PublicSaleClient<$Result.GetResult<Prisma.$PublicSalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PublicSales.
     * @param {PublicSaleCreateManyArgs} args - Arguments to create many PublicSales.
     * @example
     * // Create many PublicSales
     * const publicSale = await prisma.publicSale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PublicSaleCreateManyArgs>(args?: SelectSubset<T, PublicSaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PublicSales and returns the data saved in the database.
     * @param {PublicSaleCreateManyAndReturnArgs} args - Arguments to create many PublicSales.
     * @example
     * // Create many PublicSales
     * const publicSale = await prisma.publicSale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PublicSales and only return the `id`
     * const publicSaleWithIdOnly = await prisma.publicSale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PublicSaleCreateManyAndReturnArgs>(args?: SelectSubset<T, PublicSaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicSalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PublicSale.
     * @param {PublicSaleDeleteArgs} args - Arguments to delete one PublicSale.
     * @example
     * // Delete one PublicSale
     * const PublicSale = await prisma.publicSale.delete({
     *   where: {
     *     // ... filter to delete one PublicSale
     *   }
     * })
     * 
     */
    delete<T extends PublicSaleDeleteArgs>(args: SelectSubset<T, PublicSaleDeleteArgs<ExtArgs>>): Prisma__PublicSaleClient<$Result.GetResult<Prisma.$PublicSalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PublicSale.
     * @param {PublicSaleUpdateArgs} args - Arguments to update one PublicSale.
     * @example
     * // Update one PublicSale
     * const publicSale = await prisma.publicSale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PublicSaleUpdateArgs>(args: SelectSubset<T, PublicSaleUpdateArgs<ExtArgs>>): Prisma__PublicSaleClient<$Result.GetResult<Prisma.$PublicSalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PublicSales.
     * @param {PublicSaleDeleteManyArgs} args - Arguments to filter PublicSales to delete.
     * @example
     * // Delete a few PublicSales
     * const { count } = await prisma.publicSale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PublicSaleDeleteManyArgs>(args?: SelectSubset<T, PublicSaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PublicSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicSaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PublicSales
     * const publicSale = await prisma.publicSale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PublicSaleUpdateManyArgs>(args: SelectSubset<T, PublicSaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PublicSales and returns the data updated in the database.
     * @param {PublicSaleUpdateManyAndReturnArgs} args - Arguments to update many PublicSales.
     * @example
     * // Update many PublicSales
     * const publicSale = await prisma.publicSale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PublicSales and only return the `id`
     * const publicSaleWithIdOnly = await prisma.publicSale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PublicSaleUpdateManyAndReturnArgs>(args: SelectSubset<T, PublicSaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicSalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PublicSale.
     * @param {PublicSaleUpsertArgs} args - Arguments to update or create a PublicSale.
     * @example
     * // Update or create a PublicSale
     * const publicSale = await prisma.publicSale.upsert({
     *   create: {
     *     // ... data to create a PublicSale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PublicSale we want to update
     *   }
     * })
     */
    upsert<T extends PublicSaleUpsertArgs>(args: SelectSubset<T, PublicSaleUpsertArgs<ExtArgs>>): Prisma__PublicSaleClient<$Result.GetResult<Prisma.$PublicSalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PublicSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicSaleCountArgs} args - Arguments to filter PublicSales to count.
     * @example
     * // Count the number of PublicSales
     * const count = await prisma.publicSale.count({
     *   where: {
     *     // ... the filter for the PublicSales we want to count
     *   }
     * })
    **/
    count<T extends PublicSaleCountArgs>(
      args?: Subset<T, PublicSaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicSaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PublicSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicSaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicSaleAggregateArgs>(args: Subset<T, PublicSaleAggregateArgs>): Prisma.PrismaPromise<GetPublicSaleAggregateType<T>>

    /**
     * Group by PublicSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicSaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicSaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicSaleGroupByArgs['orderBy'] }
        : { orderBy?: PublicSaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicSaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PublicSale model
   */
  readonly fields: PublicSaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PublicSale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublicSaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends CollectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionDefaultArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PublicSale model
   */
  interface PublicSaleFieldRefs {
    readonly id: FieldRef<"PublicSale", 'String'>
    readonly collectionId: FieldRef<"PublicSale", 'String'>
    readonly startTime: FieldRef<"PublicSale", 'DateTime'>
    readonly priceEtnWei: FieldRef<"PublicSale", 'Decimal'>
    readonly maxPerWallet: FieldRef<"PublicSale", 'Int'>
    readonly maxPerTx: FieldRef<"PublicSale", 'Int'>
    readonly createdAt: FieldRef<"PublicSale", 'DateTime'>
    readonly updatedAt: FieldRef<"PublicSale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PublicSale findUnique
   */
  export type PublicSaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicSale
     */
    select?: PublicSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicSale
     */
    omit?: PublicSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicSaleInclude<ExtArgs> | null
    /**
     * Filter, which PublicSale to fetch.
     */
    where: PublicSaleWhereUniqueInput
  }

  /**
   * PublicSale findUniqueOrThrow
   */
  export type PublicSaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicSale
     */
    select?: PublicSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicSale
     */
    omit?: PublicSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicSaleInclude<ExtArgs> | null
    /**
     * Filter, which PublicSale to fetch.
     */
    where: PublicSaleWhereUniqueInput
  }

  /**
   * PublicSale findFirst
   */
  export type PublicSaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicSale
     */
    select?: PublicSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicSale
     */
    omit?: PublicSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicSaleInclude<ExtArgs> | null
    /**
     * Filter, which PublicSale to fetch.
     */
    where?: PublicSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicSales to fetch.
     */
    orderBy?: PublicSaleOrderByWithRelationInput | PublicSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublicSales.
     */
    cursor?: PublicSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublicSales.
     */
    distinct?: PublicSaleScalarFieldEnum | PublicSaleScalarFieldEnum[]
  }

  /**
   * PublicSale findFirstOrThrow
   */
  export type PublicSaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicSale
     */
    select?: PublicSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicSale
     */
    omit?: PublicSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicSaleInclude<ExtArgs> | null
    /**
     * Filter, which PublicSale to fetch.
     */
    where?: PublicSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicSales to fetch.
     */
    orderBy?: PublicSaleOrderByWithRelationInput | PublicSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublicSales.
     */
    cursor?: PublicSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublicSales.
     */
    distinct?: PublicSaleScalarFieldEnum | PublicSaleScalarFieldEnum[]
  }

  /**
   * PublicSale findMany
   */
  export type PublicSaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicSale
     */
    select?: PublicSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicSale
     */
    omit?: PublicSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicSaleInclude<ExtArgs> | null
    /**
     * Filter, which PublicSales to fetch.
     */
    where?: PublicSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublicSales to fetch.
     */
    orderBy?: PublicSaleOrderByWithRelationInput | PublicSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PublicSales.
     */
    cursor?: PublicSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublicSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublicSales.
     */
    skip?: number
    distinct?: PublicSaleScalarFieldEnum | PublicSaleScalarFieldEnum[]
  }

  /**
   * PublicSale create
   */
  export type PublicSaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicSale
     */
    select?: PublicSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicSale
     */
    omit?: PublicSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicSaleInclude<ExtArgs> | null
    /**
     * The data needed to create a PublicSale.
     */
    data: XOR<PublicSaleCreateInput, PublicSaleUncheckedCreateInput>
  }

  /**
   * PublicSale createMany
   */
  export type PublicSaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PublicSales.
     */
    data: PublicSaleCreateManyInput | PublicSaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PublicSale createManyAndReturn
   */
  export type PublicSaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicSale
     */
    select?: PublicSaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PublicSale
     */
    omit?: PublicSaleOmit<ExtArgs> | null
    /**
     * The data used to create many PublicSales.
     */
    data: PublicSaleCreateManyInput | PublicSaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicSaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PublicSale update
   */
  export type PublicSaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicSale
     */
    select?: PublicSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicSale
     */
    omit?: PublicSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicSaleInclude<ExtArgs> | null
    /**
     * The data needed to update a PublicSale.
     */
    data: XOR<PublicSaleUpdateInput, PublicSaleUncheckedUpdateInput>
    /**
     * Choose, which PublicSale to update.
     */
    where: PublicSaleWhereUniqueInput
  }

  /**
   * PublicSale updateMany
   */
  export type PublicSaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PublicSales.
     */
    data: XOR<PublicSaleUpdateManyMutationInput, PublicSaleUncheckedUpdateManyInput>
    /**
     * Filter which PublicSales to update
     */
    where?: PublicSaleWhereInput
    /**
     * Limit how many PublicSales to update.
     */
    limit?: number
  }

  /**
   * PublicSale updateManyAndReturn
   */
  export type PublicSaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicSale
     */
    select?: PublicSaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PublicSale
     */
    omit?: PublicSaleOmit<ExtArgs> | null
    /**
     * The data used to update PublicSales.
     */
    data: XOR<PublicSaleUpdateManyMutationInput, PublicSaleUncheckedUpdateManyInput>
    /**
     * Filter which PublicSales to update
     */
    where?: PublicSaleWhereInput
    /**
     * Limit how many PublicSales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicSaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PublicSale upsert
   */
  export type PublicSaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicSale
     */
    select?: PublicSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicSale
     */
    omit?: PublicSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicSaleInclude<ExtArgs> | null
    /**
     * The filter to search for the PublicSale to update in case it exists.
     */
    where: PublicSaleWhereUniqueInput
    /**
     * In case the PublicSale found by the `where` argument doesn't exist, create a new PublicSale with this data.
     */
    create: XOR<PublicSaleCreateInput, PublicSaleUncheckedCreateInput>
    /**
     * In case the PublicSale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublicSaleUpdateInput, PublicSaleUncheckedUpdateInput>
  }

  /**
   * PublicSale delete
   */
  export type PublicSaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicSale
     */
    select?: PublicSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicSale
     */
    omit?: PublicSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicSaleInclude<ExtArgs> | null
    /**
     * Filter which PublicSale to delete.
     */
    where: PublicSaleWhereUniqueInput
  }

  /**
   * PublicSale deleteMany
   */
  export type PublicSaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublicSales to delete
     */
    where?: PublicSaleWhereInput
    /**
     * Limit how many PublicSales to delete.
     */
    limit?: number
  }

  /**
   * PublicSale without action
   */
  export type PublicSaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicSale
     */
    select?: PublicSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublicSale
     */
    omit?: PublicSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublicSaleInclude<ExtArgs> | null
  }


  /**
   * Model Presale
   */

  export type AggregatePresale = {
    _count: PresaleCountAggregateOutputType | null
    _avg: PresaleAvgAggregateOutputType | null
    _sum: PresaleSumAggregateOutputType | null
    _min: PresaleMinAggregateOutputType | null
    _max: PresaleMaxAggregateOutputType | null
  }

  export type PresaleAvgAggregateOutputType = {
    priceEtnWei: Decimal | null
    maxSupply: number | null
    whitelistCount: number | null
  }

  export type PresaleSumAggregateOutputType = {
    priceEtnWei: Decimal | null
    maxSupply: number | null
    whitelistCount: number | null
  }

  export type PresaleMinAggregateOutputType = {
    id: string | null
    collectionId: string | null
    startTime: Date | null
    endTime: Date | null
    priceEtnWei: Decimal | null
    maxSupply: number | null
    merkleRoot: string | null
    whitelistCount: number | null
    allowlistCommit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PresaleMaxAggregateOutputType = {
    id: string | null
    collectionId: string | null
    startTime: Date | null
    endTime: Date | null
    priceEtnWei: Decimal | null
    maxSupply: number | null
    merkleRoot: string | null
    whitelistCount: number | null
    allowlistCommit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PresaleCountAggregateOutputType = {
    id: number
    collectionId: number
    startTime: number
    endTime: number
    priceEtnWei: number
    maxSupply: number
    merkleRoot: number
    whitelistCount: number
    allowlistCommit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PresaleAvgAggregateInputType = {
    priceEtnWei?: true
    maxSupply?: true
    whitelistCount?: true
  }

  export type PresaleSumAggregateInputType = {
    priceEtnWei?: true
    maxSupply?: true
    whitelistCount?: true
  }

  export type PresaleMinAggregateInputType = {
    id?: true
    collectionId?: true
    startTime?: true
    endTime?: true
    priceEtnWei?: true
    maxSupply?: true
    merkleRoot?: true
    whitelistCount?: true
    allowlistCommit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PresaleMaxAggregateInputType = {
    id?: true
    collectionId?: true
    startTime?: true
    endTime?: true
    priceEtnWei?: true
    maxSupply?: true
    merkleRoot?: true
    whitelistCount?: true
    allowlistCommit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PresaleCountAggregateInputType = {
    id?: true
    collectionId?: true
    startTime?: true
    endTime?: true
    priceEtnWei?: true
    maxSupply?: true
    merkleRoot?: true
    whitelistCount?: true
    allowlistCommit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PresaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Presale to aggregate.
     */
    where?: PresaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presales to fetch.
     */
    orderBy?: PresaleOrderByWithRelationInput | PresaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PresaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Presales
    **/
    _count?: true | PresaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PresaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PresaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PresaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PresaleMaxAggregateInputType
  }

  export type GetPresaleAggregateType<T extends PresaleAggregateArgs> = {
        [P in keyof T & keyof AggregatePresale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePresale[P]>
      : GetScalarType<T[P], AggregatePresale[P]>
  }




  export type PresaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresaleWhereInput
    orderBy?: PresaleOrderByWithAggregationInput | PresaleOrderByWithAggregationInput[]
    by: PresaleScalarFieldEnum[] | PresaleScalarFieldEnum
    having?: PresaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PresaleCountAggregateInputType | true
    _avg?: PresaleAvgAggregateInputType
    _sum?: PresaleSumAggregateInputType
    _min?: PresaleMinAggregateInputType
    _max?: PresaleMaxAggregateInputType
  }

  export type PresaleGroupByOutputType = {
    id: string
    collectionId: string
    startTime: Date
    endTime: Date
    priceEtnWei: Decimal
    maxSupply: number
    merkleRoot: string
    whitelistCount: number | null
    allowlistCommit: string | null
    createdAt: Date
    updatedAt: Date
    _count: PresaleCountAggregateOutputType | null
    _avg: PresaleAvgAggregateOutputType | null
    _sum: PresaleSumAggregateOutputType | null
    _min: PresaleMinAggregateOutputType | null
    _max: PresaleMaxAggregateOutputType | null
  }

  type GetPresaleGroupByPayload<T extends PresaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PresaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PresaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PresaleGroupByOutputType[P]>
            : GetScalarType<T[P], PresaleGroupByOutputType[P]>
        }
      >
    >


  export type PresaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionId?: boolean
    startTime?: boolean
    endTime?: boolean
    priceEtnWei?: boolean
    maxSupply?: boolean
    merkleRoot?: boolean
    whitelistCount?: boolean
    allowlistCommit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
    whitelist?: boolean | Presale$whitelistArgs<ExtArgs>
    _count?: boolean | PresaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presale"]>

  export type PresaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionId?: boolean
    startTime?: boolean
    endTime?: boolean
    priceEtnWei?: boolean
    maxSupply?: boolean
    merkleRoot?: boolean
    whitelistCount?: boolean
    allowlistCommit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presale"]>

  export type PresaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionId?: boolean
    startTime?: boolean
    endTime?: boolean
    priceEtnWei?: boolean
    maxSupply?: boolean
    merkleRoot?: boolean
    whitelistCount?: boolean
    allowlistCommit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presale"]>

  export type PresaleSelectScalar = {
    id?: boolean
    collectionId?: boolean
    startTime?: boolean
    endTime?: boolean
    priceEtnWei?: boolean
    maxSupply?: boolean
    merkleRoot?: boolean
    whitelistCount?: boolean
    allowlistCommit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PresaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "collectionId" | "startTime" | "endTime" | "priceEtnWei" | "maxSupply" | "merkleRoot" | "whitelistCount" | "allowlistCommit" | "createdAt" | "updatedAt", ExtArgs["result"]["presale"]>
  export type PresaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
    whitelist?: boolean | Presale$whitelistArgs<ExtArgs>
    _count?: boolean | PresaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PresaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }
  export type PresaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
  }

  export type $PresalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Presale"
    objects: {
      collection: Prisma.$CollectionPayload<ExtArgs>
      whitelist: Prisma.$PresaleWhitelistAddressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      collectionId: string
      startTime: Date
      endTime: Date
      priceEtnWei: Prisma.Decimal
      maxSupply: number
      merkleRoot: string
      whitelistCount: number | null
      allowlistCommit: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["presale"]>
    composites: {}
  }

  type PresaleGetPayload<S extends boolean | null | undefined | PresaleDefaultArgs> = $Result.GetResult<Prisma.$PresalePayload, S>

  type PresaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PresaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PresaleCountAggregateInputType | true
    }

  export interface PresaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Presale'], meta: { name: 'Presale' } }
    /**
     * Find zero or one Presale that matches the filter.
     * @param {PresaleFindUniqueArgs} args - Arguments to find a Presale
     * @example
     * // Get one Presale
     * const presale = await prisma.presale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PresaleFindUniqueArgs>(args: SelectSubset<T, PresaleFindUniqueArgs<ExtArgs>>): Prisma__PresaleClient<$Result.GetResult<Prisma.$PresalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Presale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PresaleFindUniqueOrThrowArgs} args - Arguments to find a Presale
     * @example
     * // Get one Presale
     * const presale = await prisma.presale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PresaleFindUniqueOrThrowArgs>(args: SelectSubset<T, PresaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PresaleClient<$Result.GetResult<Prisma.$PresalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Presale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleFindFirstArgs} args - Arguments to find a Presale
     * @example
     * // Get one Presale
     * const presale = await prisma.presale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PresaleFindFirstArgs>(args?: SelectSubset<T, PresaleFindFirstArgs<ExtArgs>>): Prisma__PresaleClient<$Result.GetResult<Prisma.$PresalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Presale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleFindFirstOrThrowArgs} args - Arguments to find a Presale
     * @example
     * // Get one Presale
     * const presale = await prisma.presale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PresaleFindFirstOrThrowArgs>(args?: SelectSubset<T, PresaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PresaleClient<$Result.GetResult<Prisma.$PresalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Presales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Presales
     * const presales = await prisma.presale.findMany()
     * 
     * // Get first 10 Presales
     * const presales = await prisma.presale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const presaleWithIdOnly = await prisma.presale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PresaleFindManyArgs>(args?: SelectSubset<T, PresaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Presale.
     * @param {PresaleCreateArgs} args - Arguments to create a Presale.
     * @example
     * // Create one Presale
     * const Presale = await prisma.presale.create({
     *   data: {
     *     // ... data to create a Presale
     *   }
     * })
     * 
     */
    create<T extends PresaleCreateArgs>(args: SelectSubset<T, PresaleCreateArgs<ExtArgs>>): Prisma__PresaleClient<$Result.GetResult<Prisma.$PresalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Presales.
     * @param {PresaleCreateManyArgs} args - Arguments to create many Presales.
     * @example
     * // Create many Presales
     * const presale = await prisma.presale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PresaleCreateManyArgs>(args?: SelectSubset<T, PresaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Presales and returns the data saved in the database.
     * @param {PresaleCreateManyAndReturnArgs} args - Arguments to create many Presales.
     * @example
     * // Create many Presales
     * const presale = await prisma.presale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Presales and only return the `id`
     * const presaleWithIdOnly = await prisma.presale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PresaleCreateManyAndReturnArgs>(args?: SelectSubset<T, PresaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Presale.
     * @param {PresaleDeleteArgs} args - Arguments to delete one Presale.
     * @example
     * // Delete one Presale
     * const Presale = await prisma.presale.delete({
     *   where: {
     *     // ... filter to delete one Presale
     *   }
     * })
     * 
     */
    delete<T extends PresaleDeleteArgs>(args: SelectSubset<T, PresaleDeleteArgs<ExtArgs>>): Prisma__PresaleClient<$Result.GetResult<Prisma.$PresalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Presale.
     * @param {PresaleUpdateArgs} args - Arguments to update one Presale.
     * @example
     * // Update one Presale
     * const presale = await prisma.presale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PresaleUpdateArgs>(args: SelectSubset<T, PresaleUpdateArgs<ExtArgs>>): Prisma__PresaleClient<$Result.GetResult<Prisma.$PresalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Presales.
     * @param {PresaleDeleteManyArgs} args - Arguments to filter Presales to delete.
     * @example
     * // Delete a few Presales
     * const { count } = await prisma.presale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PresaleDeleteManyArgs>(args?: SelectSubset<T, PresaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Presales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Presales
     * const presale = await prisma.presale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PresaleUpdateManyArgs>(args: SelectSubset<T, PresaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Presales and returns the data updated in the database.
     * @param {PresaleUpdateManyAndReturnArgs} args - Arguments to update many Presales.
     * @example
     * // Update many Presales
     * const presale = await prisma.presale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Presales and only return the `id`
     * const presaleWithIdOnly = await prisma.presale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PresaleUpdateManyAndReturnArgs>(args: SelectSubset<T, PresaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Presale.
     * @param {PresaleUpsertArgs} args - Arguments to update or create a Presale.
     * @example
     * // Update or create a Presale
     * const presale = await prisma.presale.upsert({
     *   create: {
     *     // ... data to create a Presale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Presale we want to update
     *   }
     * })
     */
    upsert<T extends PresaleUpsertArgs>(args: SelectSubset<T, PresaleUpsertArgs<ExtArgs>>): Prisma__PresaleClient<$Result.GetResult<Prisma.$PresalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Presales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleCountArgs} args - Arguments to filter Presales to count.
     * @example
     * // Count the number of Presales
     * const count = await prisma.presale.count({
     *   where: {
     *     // ... the filter for the Presales we want to count
     *   }
     * })
    **/
    count<T extends PresaleCountArgs>(
      args?: Subset<T, PresaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PresaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Presale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PresaleAggregateArgs>(args: Subset<T, PresaleAggregateArgs>): Prisma.PrismaPromise<GetPresaleAggregateType<T>>

    /**
     * Group by Presale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PresaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PresaleGroupByArgs['orderBy'] }
        : { orderBy?: PresaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PresaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPresaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Presale model
   */
  readonly fields: PresaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Presale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PresaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends CollectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionDefaultArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    whitelist<T extends Presale$whitelistArgs<ExtArgs> = {}>(args?: Subset<T, Presale$whitelistArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresaleWhitelistAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Presale model
   */
  interface PresaleFieldRefs {
    readonly id: FieldRef<"Presale", 'String'>
    readonly collectionId: FieldRef<"Presale", 'String'>
    readonly startTime: FieldRef<"Presale", 'DateTime'>
    readonly endTime: FieldRef<"Presale", 'DateTime'>
    readonly priceEtnWei: FieldRef<"Presale", 'Decimal'>
    readonly maxSupply: FieldRef<"Presale", 'Int'>
    readonly merkleRoot: FieldRef<"Presale", 'String'>
    readonly whitelistCount: FieldRef<"Presale", 'Int'>
    readonly allowlistCommit: FieldRef<"Presale", 'String'>
    readonly createdAt: FieldRef<"Presale", 'DateTime'>
    readonly updatedAt: FieldRef<"Presale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Presale findUnique
   */
  export type PresaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presale
     */
    select?: PresaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presale
     */
    omit?: PresaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleInclude<ExtArgs> | null
    /**
     * Filter, which Presale to fetch.
     */
    where: PresaleWhereUniqueInput
  }

  /**
   * Presale findUniqueOrThrow
   */
  export type PresaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presale
     */
    select?: PresaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presale
     */
    omit?: PresaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleInclude<ExtArgs> | null
    /**
     * Filter, which Presale to fetch.
     */
    where: PresaleWhereUniqueInput
  }

  /**
   * Presale findFirst
   */
  export type PresaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presale
     */
    select?: PresaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presale
     */
    omit?: PresaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleInclude<ExtArgs> | null
    /**
     * Filter, which Presale to fetch.
     */
    where?: PresaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presales to fetch.
     */
    orderBy?: PresaleOrderByWithRelationInput | PresaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Presales.
     */
    cursor?: PresaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Presales.
     */
    distinct?: PresaleScalarFieldEnum | PresaleScalarFieldEnum[]
  }

  /**
   * Presale findFirstOrThrow
   */
  export type PresaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presale
     */
    select?: PresaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presale
     */
    omit?: PresaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleInclude<ExtArgs> | null
    /**
     * Filter, which Presale to fetch.
     */
    where?: PresaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presales to fetch.
     */
    orderBy?: PresaleOrderByWithRelationInput | PresaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Presales.
     */
    cursor?: PresaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Presales.
     */
    distinct?: PresaleScalarFieldEnum | PresaleScalarFieldEnum[]
  }

  /**
   * Presale findMany
   */
  export type PresaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presale
     */
    select?: PresaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presale
     */
    omit?: PresaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleInclude<ExtArgs> | null
    /**
     * Filter, which Presales to fetch.
     */
    where?: PresaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presales to fetch.
     */
    orderBy?: PresaleOrderByWithRelationInput | PresaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Presales.
     */
    cursor?: PresaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presales.
     */
    skip?: number
    distinct?: PresaleScalarFieldEnum | PresaleScalarFieldEnum[]
  }

  /**
   * Presale create
   */
  export type PresaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presale
     */
    select?: PresaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presale
     */
    omit?: PresaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleInclude<ExtArgs> | null
    /**
     * The data needed to create a Presale.
     */
    data: XOR<PresaleCreateInput, PresaleUncheckedCreateInput>
  }

  /**
   * Presale createMany
   */
  export type PresaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Presales.
     */
    data: PresaleCreateManyInput | PresaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Presale createManyAndReturn
   */
  export type PresaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presale
     */
    select?: PresaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Presale
     */
    omit?: PresaleOmit<ExtArgs> | null
    /**
     * The data used to create many Presales.
     */
    data: PresaleCreateManyInput | PresaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Presale update
   */
  export type PresaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presale
     */
    select?: PresaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presale
     */
    omit?: PresaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleInclude<ExtArgs> | null
    /**
     * The data needed to update a Presale.
     */
    data: XOR<PresaleUpdateInput, PresaleUncheckedUpdateInput>
    /**
     * Choose, which Presale to update.
     */
    where: PresaleWhereUniqueInput
  }

  /**
   * Presale updateMany
   */
  export type PresaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Presales.
     */
    data: XOR<PresaleUpdateManyMutationInput, PresaleUncheckedUpdateManyInput>
    /**
     * Filter which Presales to update
     */
    where?: PresaleWhereInput
    /**
     * Limit how many Presales to update.
     */
    limit?: number
  }

  /**
   * Presale updateManyAndReturn
   */
  export type PresaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presale
     */
    select?: PresaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Presale
     */
    omit?: PresaleOmit<ExtArgs> | null
    /**
     * The data used to update Presales.
     */
    data: XOR<PresaleUpdateManyMutationInput, PresaleUncheckedUpdateManyInput>
    /**
     * Filter which Presales to update
     */
    where?: PresaleWhereInput
    /**
     * Limit how many Presales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Presale upsert
   */
  export type PresaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presale
     */
    select?: PresaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presale
     */
    omit?: PresaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleInclude<ExtArgs> | null
    /**
     * The filter to search for the Presale to update in case it exists.
     */
    where: PresaleWhereUniqueInput
    /**
     * In case the Presale found by the `where` argument doesn't exist, create a new Presale with this data.
     */
    create: XOR<PresaleCreateInput, PresaleUncheckedCreateInput>
    /**
     * In case the Presale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PresaleUpdateInput, PresaleUncheckedUpdateInput>
  }

  /**
   * Presale delete
   */
  export type PresaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presale
     */
    select?: PresaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presale
     */
    omit?: PresaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleInclude<ExtArgs> | null
    /**
     * Filter which Presale to delete.
     */
    where: PresaleWhereUniqueInput
  }

  /**
   * Presale deleteMany
   */
  export type PresaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Presales to delete
     */
    where?: PresaleWhereInput
    /**
     * Limit how many Presales to delete.
     */
    limit?: number
  }

  /**
   * Presale.whitelist
   */
  export type Presale$whitelistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleWhitelistAddress
     */
    select?: PresaleWhitelistAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleWhitelistAddress
     */
    omit?: PresaleWhitelistAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleWhitelistAddressInclude<ExtArgs> | null
    where?: PresaleWhitelistAddressWhereInput
    orderBy?: PresaleWhitelistAddressOrderByWithRelationInput | PresaleWhitelistAddressOrderByWithRelationInput[]
    cursor?: PresaleWhitelistAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PresaleWhitelistAddressScalarFieldEnum | PresaleWhitelistAddressScalarFieldEnum[]
  }

  /**
   * Presale without action
   */
  export type PresaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Presale
     */
    select?: PresaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Presale
     */
    omit?: PresaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleInclude<ExtArgs> | null
  }


  /**
   * Model PresaleWhitelistAddress
   */

  export type AggregatePresaleWhitelistAddress = {
    _count: PresaleWhitelistAddressCountAggregateOutputType | null
    _avg: PresaleWhitelistAddressAvgAggregateOutputType | null
    _sum: PresaleWhitelistAddressSumAggregateOutputType | null
    _min: PresaleWhitelistAddressMinAggregateOutputType | null
    _max: PresaleWhitelistAddressMaxAggregateOutputType | null
  }

  export type PresaleWhitelistAddressAvgAggregateOutputType = {
    maxAllocation: number | null
  }

  export type PresaleWhitelistAddressSumAggregateOutputType = {
    maxAllocation: number | null
  }

  export type PresaleWhitelistAddressMinAggregateOutputType = {
    id: string | null
    presaleId: string | null
    address: string | null
    maxAllocation: number | null
  }

  export type PresaleWhitelistAddressMaxAggregateOutputType = {
    id: string | null
    presaleId: string | null
    address: string | null
    maxAllocation: number | null
  }

  export type PresaleWhitelistAddressCountAggregateOutputType = {
    id: number
    presaleId: number
    address: number
    maxAllocation: number
    _all: number
  }


  export type PresaleWhitelistAddressAvgAggregateInputType = {
    maxAllocation?: true
  }

  export type PresaleWhitelistAddressSumAggregateInputType = {
    maxAllocation?: true
  }

  export type PresaleWhitelistAddressMinAggregateInputType = {
    id?: true
    presaleId?: true
    address?: true
    maxAllocation?: true
  }

  export type PresaleWhitelistAddressMaxAggregateInputType = {
    id?: true
    presaleId?: true
    address?: true
    maxAllocation?: true
  }

  export type PresaleWhitelistAddressCountAggregateInputType = {
    id?: true
    presaleId?: true
    address?: true
    maxAllocation?: true
    _all?: true
  }

  export type PresaleWhitelistAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PresaleWhitelistAddress to aggregate.
     */
    where?: PresaleWhitelistAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresaleWhitelistAddresses to fetch.
     */
    orderBy?: PresaleWhitelistAddressOrderByWithRelationInput | PresaleWhitelistAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PresaleWhitelistAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresaleWhitelistAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresaleWhitelistAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PresaleWhitelistAddresses
    **/
    _count?: true | PresaleWhitelistAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PresaleWhitelistAddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PresaleWhitelistAddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PresaleWhitelistAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PresaleWhitelistAddressMaxAggregateInputType
  }

  export type GetPresaleWhitelistAddressAggregateType<T extends PresaleWhitelistAddressAggregateArgs> = {
        [P in keyof T & keyof AggregatePresaleWhitelistAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePresaleWhitelistAddress[P]>
      : GetScalarType<T[P], AggregatePresaleWhitelistAddress[P]>
  }




  export type PresaleWhitelistAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresaleWhitelistAddressWhereInput
    orderBy?: PresaleWhitelistAddressOrderByWithAggregationInput | PresaleWhitelistAddressOrderByWithAggregationInput[]
    by: PresaleWhitelistAddressScalarFieldEnum[] | PresaleWhitelistAddressScalarFieldEnum
    having?: PresaleWhitelistAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PresaleWhitelistAddressCountAggregateInputType | true
    _avg?: PresaleWhitelistAddressAvgAggregateInputType
    _sum?: PresaleWhitelistAddressSumAggregateInputType
    _min?: PresaleWhitelistAddressMinAggregateInputType
    _max?: PresaleWhitelistAddressMaxAggregateInputType
  }

  export type PresaleWhitelistAddressGroupByOutputType = {
    id: string
    presaleId: string
    address: string
    maxAllocation: number | null
    _count: PresaleWhitelistAddressCountAggregateOutputType | null
    _avg: PresaleWhitelistAddressAvgAggregateOutputType | null
    _sum: PresaleWhitelistAddressSumAggregateOutputType | null
    _min: PresaleWhitelistAddressMinAggregateOutputType | null
    _max: PresaleWhitelistAddressMaxAggregateOutputType | null
  }

  type GetPresaleWhitelistAddressGroupByPayload<T extends PresaleWhitelistAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PresaleWhitelistAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PresaleWhitelistAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PresaleWhitelistAddressGroupByOutputType[P]>
            : GetScalarType<T[P], PresaleWhitelistAddressGroupByOutputType[P]>
        }
      >
    >


  export type PresaleWhitelistAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    presaleId?: boolean
    address?: boolean
    maxAllocation?: boolean
    presale?: boolean | PresaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presaleWhitelistAddress"]>

  export type PresaleWhitelistAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    presaleId?: boolean
    address?: boolean
    maxAllocation?: boolean
    presale?: boolean | PresaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presaleWhitelistAddress"]>

  export type PresaleWhitelistAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    presaleId?: boolean
    address?: boolean
    maxAllocation?: boolean
    presale?: boolean | PresaleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["presaleWhitelistAddress"]>

  export type PresaleWhitelistAddressSelectScalar = {
    id?: boolean
    presaleId?: boolean
    address?: boolean
    maxAllocation?: boolean
  }

  export type PresaleWhitelistAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "presaleId" | "address" | "maxAllocation", ExtArgs["result"]["presaleWhitelistAddress"]>
  export type PresaleWhitelistAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    presale?: boolean | PresaleDefaultArgs<ExtArgs>
  }
  export type PresaleWhitelistAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    presale?: boolean | PresaleDefaultArgs<ExtArgs>
  }
  export type PresaleWhitelistAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    presale?: boolean | PresaleDefaultArgs<ExtArgs>
  }

  export type $PresaleWhitelistAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PresaleWhitelistAddress"
    objects: {
      presale: Prisma.$PresalePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      presaleId: string
      address: string
      maxAllocation: number | null
    }, ExtArgs["result"]["presaleWhitelistAddress"]>
    composites: {}
  }

  type PresaleWhitelistAddressGetPayload<S extends boolean | null | undefined | PresaleWhitelistAddressDefaultArgs> = $Result.GetResult<Prisma.$PresaleWhitelistAddressPayload, S>

  type PresaleWhitelistAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PresaleWhitelistAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PresaleWhitelistAddressCountAggregateInputType | true
    }

  export interface PresaleWhitelistAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PresaleWhitelistAddress'], meta: { name: 'PresaleWhitelistAddress' } }
    /**
     * Find zero or one PresaleWhitelistAddress that matches the filter.
     * @param {PresaleWhitelistAddressFindUniqueArgs} args - Arguments to find a PresaleWhitelistAddress
     * @example
     * // Get one PresaleWhitelistAddress
     * const presaleWhitelistAddress = await prisma.presaleWhitelistAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PresaleWhitelistAddressFindUniqueArgs>(args: SelectSubset<T, PresaleWhitelistAddressFindUniqueArgs<ExtArgs>>): Prisma__PresaleWhitelistAddressClient<$Result.GetResult<Prisma.$PresaleWhitelistAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PresaleWhitelistAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PresaleWhitelistAddressFindUniqueOrThrowArgs} args - Arguments to find a PresaleWhitelistAddress
     * @example
     * // Get one PresaleWhitelistAddress
     * const presaleWhitelistAddress = await prisma.presaleWhitelistAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PresaleWhitelistAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, PresaleWhitelistAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PresaleWhitelistAddressClient<$Result.GetResult<Prisma.$PresaleWhitelistAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PresaleWhitelistAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleWhitelistAddressFindFirstArgs} args - Arguments to find a PresaleWhitelistAddress
     * @example
     * // Get one PresaleWhitelistAddress
     * const presaleWhitelistAddress = await prisma.presaleWhitelistAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PresaleWhitelistAddressFindFirstArgs>(args?: SelectSubset<T, PresaleWhitelistAddressFindFirstArgs<ExtArgs>>): Prisma__PresaleWhitelistAddressClient<$Result.GetResult<Prisma.$PresaleWhitelistAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PresaleWhitelistAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleWhitelistAddressFindFirstOrThrowArgs} args - Arguments to find a PresaleWhitelistAddress
     * @example
     * // Get one PresaleWhitelistAddress
     * const presaleWhitelistAddress = await prisma.presaleWhitelistAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PresaleWhitelistAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, PresaleWhitelistAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__PresaleWhitelistAddressClient<$Result.GetResult<Prisma.$PresaleWhitelistAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PresaleWhitelistAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleWhitelistAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PresaleWhitelistAddresses
     * const presaleWhitelistAddresses = await prisma.presaleWhitelistAddress.findMany()
     * 
     * // Get first 10 PresaleWhitelistAddresses
     * const presaleWhitelistAddresses = await prisma.presaleWhitelistAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const presaleWhitelistAddressWithIdOnly = await prisma.presaleWhitelistAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PresaleWhitelistAddressFindManyArgs>(args?: SelectSubset<T, PresaleWhitelistAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresaleWhitelistAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PresaleWhitelistAddress.
     * @param {PresaleWhitelistAddressCreateArgs} args - Arguments to create a PresaleWhitelistAddress.
     * @example
     * // Create one PresaleWhitelistAddress
     * const PresaleWhitelistAddress = await prisma.presaleWhitelistAddress.create({
     *   data: {
     *     // ... data to create a PresaleWhitelistAddress
     *   }
     * })
     * 
     */
    create<T extends PresaleWhitelistAddressCreateArgs>(args: SelectSubset<T, PresaleWhitelistAddressCreateArgs<ExtArgs>>): Prisma__PresaleWhitelistAddressClient<$Result.GetResult<Prisma.$PresaleWhitelistAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PresaleWhitelistAddresses.
     * @param {PresaleWhitelistAddressCreateManyArgs} args - Arguments to create many PresaleWhitelistAddresses.
     * @example
     * // Create many PresaleWhitelistAddresses
     * const presaleWhitelistAddress = await prisma.presaleWhitelistAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PresaleWhitelistAddressCreateManyArgs>(args?: SelectSubset<T, PresaleWhitelistAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PresaleWhitelistAddresses and returns the data saved in the database.
     * @param {PresaleWhitelistAddressCreateManyAndReturnArgs} args - Arguments to create many PresaleWhitelistAddresses.
     * @example
     * // Create many PresaleWhitelistAddresses
     * const presaleWhitelistAddress = await prisma.presaleWhitelistAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PresaleWhitelistAddresses and only return the `id`
     * const presaleWhitelistAddressWithIdOnly = await prisma.presaleWhitelistAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PresaleWhitelistAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, PresaleWhitelistAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresaleWhitelistAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PresaleWhitelistAddress.
     * @param {PresaleWhitelistAddressDeleteArgs} args - Arguments to delete one PresaleWhitelistAddress.
     * @example
     * // Delete one PresaleWhitelistAddress
     * const PresaleWhitelistAddress = await prisma.presaleWhitelistAddress.delete({
     *   where: {
     *     // ... filter to delete one PresaleWhitelistAddress
     *   }
     * })
     * 
     */
    delete<T extends PresaleWhitelistAddressDeleteArgs>(args: SelectSubset<T, PresaleWhitelistAddressDeleteArgs<ExtArgs>>): Prisma__PresaleWhitelistAddressClient<$Result.GetResult<Prisma.$PresaleWhitelistAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PresaleWhitelistAddress.
     * @param {PresaleWhitelistAddressUpdateArgs} args - Arguments to update one PresaleWhitelistAddress.
     * @example
     * // Update one PresaleWhitelistAddress
     * const presaleWhitelistAddress = await prisma.presaleWhitelistAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PresaleWhitelistAddressUpdateArgs>(args: SelectSubset<T, PresaleWhitelistAddressUpdateArgs<ExtArgs>>): Prisma__PresaleWhitelistAddressClient<$Result.GetResult<Prisma.$PresaleWhitelistAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PresaleWhitelistAddresses.
     * @param {PresaleWhitelistAddressDeleteManyArgs} args - Arguments to filter PresaleWhitelistAddresses to delete.
     * @example
     * // Delete a few PresaleWhitelistAddresses
     * const { count } = await prisma.presaleWhitelistAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PresaleWhitelistAddressDeleteManyArgs>(args?: SelectSubset<T, PresaleWhitelistAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PresaleWhitelistAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleWhitelistAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PresaleWhitelistAddresses
     * const presaleWhitelistAddress = await prisma.presaleWhitelistAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PresaleWhitelistAddressUpdateManyArgs>(args: SelectSubset<T, PresaleWhitelistAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PresaleWhitelistAddresses and returns the data updated in the database.
     * @param {PresaleWhitelistAddressUpdateManyAndReturnArgs} args - Arguments to update many PresaleWhitelistAddresses.
     * @example
     * // Update many PresaleWhitelistAddresses
     * const presaleWhitelistAddress = await prisma.presaleWhitelistAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PresaleWhitelistAddresses and only return the `id`
     * const presaleWhitelistAddressWithIdOnly = await prisma.presaleWhitelistAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PresaleWhitelistAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, PresaleWhitelistAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresaleWhitelistAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PresaleWhitelistAddress.
     * @param {PresaleWhitelistAddressUpsertArgs} args - Arguments to update or create a PresaleWhitelistAddress.
     * @example
     * // Update or create a PresaleWhitelistAddress
     * const presaleWhitelistAddress = await prisma.presaleWhitelistAddress.upsert({
     *   create: {
     *     // ... data to create a PresaleWhitelistAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PresaleWhitelistAddress we want to update
     *   }
     * })
     */
    upsert<T extends PresaleWhitelistAddressUpsertArgs>(args: SelectSubset<T, PresaleWhitelistAddressUpsertArgs<ExtArgs>>): Prisma__PresaleWhitelistAddressClient<$Result.GetResult<Prisma.$PresaleWhitelistAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PresaleWhitelistAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleWhitelistAddressCountArgs} args - Arguments to filter PresaleWhitelistAddresses to count.
     * @example
     * // Count the number of PresaleWhitelistAddresses
     * const count = await prisma.presaleWhitelistAddress.count({
     *   where: {
     *     // ... the filter for the PresaleWhitelistAddresses we want to count
     *   }
     * })
    **/
    count<T extends PresaleWhitelistAddressCountArgs>(
      args?: Subset<T, PresaleWhitelistAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PresaleWhitelistAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PresaleWhitelistAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleWhitelistAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PresaleWhitelistAddressAggregateArgs>(args: Subset<T, PresaleWhitelistAddressAggregateArgs>): Prisma.PrismaPromise<GetPresaleWhitelistAddressAggregateType<T>>

    /**
     * Group by PresaleWhitelistAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleWhitelistAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PresaleWhitelistAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PresaleWhitelistAddressGroupByArgs['orderBy'] }
        : { orderBy?: PresaleWhitelistAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PresaleWhitelistAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPresaleWhitelistAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PresaleWhitelistAddress model
   */
  readonly fields: PresaleWhitelistAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PresaleWhitelistAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PresaleWhitelistAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    presale<T extends PresaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PresaleDefaultArgs<ExtArgs>>): Prisma__PresaleClient<$Result.GetResult<Prisma.$PresalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PresaleWhitelistAddress model
   */
  interface PresaleWhitelistAddressFieldRefs {
    readonly id: FieldRef<"PresaleWhitelistAddress", 'String'>
    readonly presaleId: FieldRef<"PresaleWhitelistAddress", 'String'>
    readonly address: FieldRef<"PresaleWhitelistAddress", 'String'>
    readonly maxAllocation: FieldRef<"PresaleWhitelistAddress", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PresaleWhitelistAddress findUnique
   */
  export type PresaleWhitelistAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleWhitelistAddress
     */
    select?: PresaleWhitelistAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleWhitelistAddress
     */
    omit?: PresaleWhitelistAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleWhitelistAddressInclude<ExtArgs> | null
    /**
     * Filter, which PresaleWhitelistAddress to fetch.
     */
    where: PresaleWhitelistAddressWhereUniqueInput
  }

  /**
   * PresaleWhitelistAddress findUniqueOrThrow
   */
  export type PresaleWhitelistAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleWhitelistAddress
     */
    select?: PresaleWhitelistAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleWhitelistAddress
     */
    omit?: PresaleWhitelistAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleWhitelistAddressInclude<ExtArgs> | null
    /**
     * Filter, which PresaleWhitelistAddress to fetch.
     */
    where: PresaleWhitelistAddressWhereUniqueInput
  }

  /**
   * PresaleWhitelistAddress findFirst
   */
  export type PresaleWhitelistAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleWhitelistAddress
     */
    select?: PresaleWhitelistAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleWhitelistAddress
     */
    omit?: PresaleWhitelistAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleWhitelistAddressInclude<ExtArgs> | null
    /**
     * Filter, which PresaleWhitelistAddress to fetch.
     */
    where?: PresaleWhitelistAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresaleWhitelistAddresses to fetch.
     */
    orderBy?: PresaleWhitelistAddressOrderByWithRelationInput | PresaleWhitelistAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PresaleWhitelistAddresses.
     */
    cursor?: PresaleWhitelistAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresaleWhitelistAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresaleWhitelistAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PresaleWhitelistAddresses.
     */
    distinct?: PresaleWhitelistAddressScalarFieldEnum | PresaleWhitelistAddressScalarFieldEnum[]
  }

  /**
   * PresaleWhitelistAddress findFirstOrThrow
   */
  export type PresaleWhitelistAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleWhitelistAddress
     */
    select?: PresaleWhitelistAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleWhitelistAddress
     */
    omit?: PresaleWhitelistAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleWhitelistAddressInclude<ExtArgs> | null
    /**
     * Filter, which PresaleWhitelistAddress to fetch.
     */
    where?: PresaleWhitelistAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresaleWhitelistAddresses to fetch.
     */
    orderBy?: PresaleWhitelistAddressOrderByWithRelationInput | PresaleWhitelistAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PresaleWhitelistAddresses.
     */
    cursor?: PresaleWhitelistAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresaleWhitelistAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresaleWhitelistAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PresaleWhitelistAddresses.
     */
    distinct?: PresaleWhitelistAddressScalarFieldEnum | PresaleWhitelistAddressScalarFieldEnum[]
  }

  /**
   * PresaleWhitelistAddress findMany
   */
  export type PresaleWhitelistAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleWhitelistAddress
     */
    select?: PresaleWhitelistAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleWhitelistAddress
     */
    omit?: PresaleWhitelistAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleWhitelistAddressInclude<ExtArgs> | null
    /**
     * Filter, which PresaleWhitelistAddresses to fetch.
     */
    where?: PresaleWhitelistAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresaleWhitelistAddresses to fetch.
     */
    orderBy?: PresaleWhitelistAddressOrderByWithRelationInput | PresaleWhitelistAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PresaleWhitelistAddresses.
     */
    cursor?: PresaleWhitelistAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresaleWhitelistAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresaleWhitelistAddresses.
     */
    skip?: number
    distinct?: PresaleWhitelistAddressScalarFieldEnum | PresaleWhitelistAddressScalarFieldEnum[]
  }

  /**
   * PresaleWhitelistAddress create
   */
  export type PresaleWhitelistAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleWhitelistAddress
     */
    select?: PresaleWhitelistAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleWhitelistAddress
     */
    omit?: PresaleWhitelistAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleWhitelistAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a PresaleWhitelistAddress.
     */
    data: XOR<PresaleWhitelistAddressCreateInput, PresaleWhitelistAddressUncheckedCreateInput>
  }

  /**
   * PresaleWhitelistAddress createMany
   */
  export type PresaleWhitelistAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PresaleWhitelistAddresses.
     */
    data: PresaleWhitelistAddressCreateManyInput | PresaleWhitelistAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PresaleWhitelistAddress createManyAndReturn
   */
  export type PresaleWhitelistAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleWhitelistAddress
     */
    select?: PresaleWhitelistAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleWhitelistAddress
     */
    omit?: PresaleWhitelistAddressOmit<ExtArgs> | null
    /**
     * The data used to create many PresaleWhitelistAddresses.
     */
    data: PresaleWhitelistAddressCreateManyInput | PresaleWhitelistAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleWhitelistAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PresaleWhitelistAddress update
   */
  export type PresaleWhitelistAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleWhitelistAddress
     */
    select?: PresaleWhitelistAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleWhitelistAddress
     */
    omit?: PresaleWhitelistAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleWhitelistAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a PresaleWhitelistAddress.
     */
    data: XOR<PresaleWhitelistAddressUpdateInput, PresaleWhitelistAddressUncheckedUpdateInput>
    /**
     * Choose, which PresaleWhitelistAddress to update.
     */
    where: PresaleWhitelistAddressWhereUniqueInput
  }

  /**
   * PresaleWhitelistAddress updateMany
   */
  export type PresaleWhitelistAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PresaleWhitelistAddresses.
     */
    data: XOR<PresaleWhitelistAddressUpdateManyMutationInput, PresaleWhitelistAddressUncheckedUpdateManyInput>
    /**
     * Filter which PresaleWhitelistAddresses to update
     */
    where?: PresaleWhitelistAddressWhereInput
    /**
     * Limit how many PresaleWhitelistAddresses to update.
     */
    limit?: number
  }

  /**
   * PresaleWhitelistAddress updateManyAndReturn
   */
  export type PresaleWhitelistAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleWhitelistAddress
     */
    select?: PresaleWhitelistAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleWhitelistAddress
     */
    omit?: PresaleWhitelistAddressOmit<ExtArgs> | null
    /**
     * The data used to update PresaleWhitelistAddresses.
     */
    data: XOR<PresaleWhitelistAddressUpdateManyMutationInput, PresaleWhitelistAddressUncheckedUpdateManyInput>
    /**
     * Filter which PresaleWhitelistAddresses to update
     */
    where?: PresaleWhitelistAddressWhereInput
    /**
     * Limit how many PresaleWhitelistAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleWhitelistAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PresaleWhitelistAddress upsert
   */
  export type PresaleWhitelistAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleWhitelistAddress
     */
    select?: PresaleWhitelistAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleWhitelistAddress
     */
    omit?: PresaleWhitelistAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleWhitelistAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the PresaleWhitelistAddress to update in case it exists.
     */
    where: PresaleWhitelistAddressWhereUniqueInput
    /**
     * In case the PresaleWhitelistAddress found by the `where` argument doesn't exist, create a new PresaleWhitelistAddress with this data.
     */
    create: XOR<PresaleWhitelistAddressCreateInput, PresaleWhitelistAddressUncheckedCreateInput>
    /**
     * In case the PresaleWhitelistAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PresaleWhitelistAddressUpdateInput, PresaleWhitelistAddressUncheckedUpdateInput>
  }

  /**
   * PresaleWhitelistAddress delete
   */
  export type PresaleWhitelistAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleWhitelistAddress
     */
    select?: PresaleWhitelistAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleWhitelistAddress
     */
    omit?: PresaleWhitelistAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleWhitelistAddressInclude<ExtArgs> | null
    /**
     * Filter which PresaleWhitelistAddress to delete.
     */
    where: PresaleWhitelistAddressWhereUniqueInput
  }

  /**
   * PresaleWhitelistAddress deleteMany
   */
  export type PresaleWhitelistAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PresaleWhitelistAddresses to delete
     */
    where?: PresaleWhitelistAddressWhereInput
    /**
     * Limit how many PresaleWhitelistAddresses to delete.
     */
    limit?: number
  }

  /**
   * PresaleWhitelistAddress without action
   */
  export type PresaleWhitelistAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleWhitelistAddress
     */
    select?: PresaleWhitelistAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleWhitelistAddress
     */
    omit?: PresaleWhitelistAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PresaleWhitelistAddressInclude<ExtArgs> | null
  }


  /**
   * Model PresaleDraft
   */

  export type AggregatePresaleDraft = {
    _count: PresaleDraftCountAggregateOutputType | null
    _avg: PresaleDraftAvgAggregateOutputType | null
    _sum: PresaleDraftSumAggregateOutputType | null
    _min: PresaleDraftMinAggregateOutputType | null
    _max: PresaleDraftMaxAggregateOutputType | null
  }

  export type PresaleDraftAvgAggregateOutputType = {
    count: number | null
  }

  export type PresaleDraftSumAggregateOutputType = {
    count: number | null
  }

  export type PresaleDraftMinAggregateOutputType = {
    id: string | null
    creatorUserId: string | null
    count: number | null
    merkleRoot: string | null
    sha256Commit: string | null
    status: $Enums.DraftStatus | null
    consumedAt: Date | null
    consumedByPresaleId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type PresaleDraftMaxAggregateOutputType = {
    id: string | null
    creatorUserId: string | null
    count: number | null
    merkleRoot: string | null
    sha256Commit: string | null
    status: $Enums.DraftStatus | null
    consumedAt: Date | null
    consumedByPresaleId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type PresaleDraftCountAggregateOutputType = {
    id: number
    creatorUserId: number
    addresses: number
    count: number
    merkleRoot: number
    sha256Commit: number
    status: number
    consumedAt: number
    consumedByPresaleId: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type PresaleDraftAvgAggregateInputType = {
    count?: true
  }

  export type PresaleDraftSumAggregateInputType = {
    count?: true
  }

  export type PresaleDraftMinAggregateInputType = {
    id?: true
    creatorUserId?: true
    count?: true
    merkleRoot?: true
    sha256Commit?: true
    status?: true
    consumedAt?: true
    consumedByPresaleId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type PresaleDraftMaxAggregateInputType = {
    id?: true
    creatorUserId?: true
    count?: true
    merkleRoot?: true
    sha256Commit?: true
    status?: true
    consumedAt?: true
    consumedByPresaleId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type PresaleDraftCountAggregateInputType = {
    id?: true
    creatorUserId?: true
    addresses?: true
    count?: true
    merkleRoot?: true
    sha256Commit?: true
    status?: true
    consumedAt?: true
    consumedByPresaleId?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type PresaleDraftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PresaleDraft to aggregate.
     */
    where?: PresaleDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresaleDrafts to fetch.
     */
    orderBy?: PresaleDraftOrderByWithRelationInput | PresaleDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PresaleDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresaleDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresaleDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PresaleDrafts
    **/
    _count?: true | PresaleDraftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PresaleDraftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PresaleDraftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PresaleDraftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PresaleDraftMaxAggregateInputType
  }

  export type GetPresaleDraftAggregateType<T extends PresaleDraftAggregateArgs> = {
        [P in keyof T & keyof AggregatePresaleDraft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePresaleDraft[P]>
      : GetScalarType<T[P], AggregatePresaleDraft[P]>
  }




  export type PresaleDraftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PresaleDraftWhereInput
    orderBy?: PresaleDraftOrderByWithAggregationInput | PresaleDraftOrderByWithAggregationInput[]
    by: PresaleDraftScalarFieldEnum[] | PresaleDraftScalarFieldEnum
    having?: PresaleDraftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PresaleDraftCountAggregateInputType | true
    _avg?: PresaleDraftAvgAggregateInputType
    _sum?: PresaleDraftSumAggregateInputType
    _min?: PresaleDraftMinAggregateInputType
    _max?: PresaleDraftMaxAggregateInputType
  }

  export type PresaleDraftGroupByOutputType = {
    id: string
    creatorUserId: string
    addresses: JsonValue
    count: number
    merkleRoot: string
    sha256Commit: string
    status: $Enums.DraftStatus
    consumedAt: Date | null
    consumedByPresaleId: string | null
    createdAt: Date
    expiresAt: Date | null
    _count: PresaleDraftCountAggregateOutputType | null
    _avg: PresaleDraftAvgAggregateOutputType | null
    _sum: PresaleDraftSumAggregateOutputType | null
    _min: PresaleDraftMinAggregateOutputType | null
    _max: PresaleDraftMaxAggregateOutputType | null
  }

  type GetPresaleDraftGroupByPayload<T extends PresaleDraftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PresaleDraftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PresaleDraftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PresaleDraftGroupByOutputType[P]>
            : GetScalarType<T[P], PresaleDraftGroupByOutputType[P]>
        }
      >
    >


  export type PresaleDraftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorUserId?: boolean
    addresses?: boolean
    count?: boolean
    merkleRoot?: boolean
    sha256Commit?: boolean
    status?: boolean
    consumedAt?: boolean
    consumedByPresaleId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["presaleDraft"]>

  export type PresaleDraftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorUserId?: boolean
    addresses?: boolean
    count?: boolean
    merkleRoot?: boolean
    sha256Commit?: boolean
    status?: boolean
    consumedAt?: boolean
    consumedByPresaleId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["presaleDraft"]>

  export type PresaleDraftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorUserId?: boolean
    addresses?: boolean
    count?: boolean
    merkleRoot?: boolean
    sha256Commit?: boolean
    status?: boolean
    consumedAt?: boolean
    consumedByPresaleId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["presaleDraft"]>

  export type PresaleDraftSelectScalar = {
    id?: boolean
    creatorUserId?: boolean
    addresses?: boolean
    count?: boolean
    merkleRoot?: boolean
    sha256Commit?: boolean
    status?: boolean
    consumedAt?: boolean
    consumedByPresaleId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type PresaleDraftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "creatorUserId" | "addresses" | "count" | "merkleRoot" | "sha256Commit" | "status" | "consumedAt" | "consumedByPresaleId" | "createdAt" | "expiresAt", ExtArgs["result"]["presaleDraft"]>

  export type $PresaleDraftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PresaleDraft"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorUserId: string
      addresses: Prisma.JsonValue
      count: number
      merkleRoot: string
      sha256Commit: string
      status: $Enums.DraftStatus
      consumedAt: Date | null
      consumedByPresaleId: string | null
      createdAt: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["presaleDraft"]>
    composites: {}
  }

  type PresaleDraftGetPayload<S extends boolean | null | undefined | PresaleDraftDefaultArgs> = $Result.GetResult<Prisma.$PresaleDraftPayload, S>

  type PresaleDraftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PresaleDraftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PresaleDraftCountAggregateInputType | true
    }

  export interface PresaleDraftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PresaleDraft'], meta: { name: 'PresaleDraft' } }
    /**
     * Find zero or one PresaleDraft that matches the filter.
     * @param {PresaleDraftFindUniqueArgs} args - Arguments to find a PresaleDraft
     * @example
     * // Get one PresaleDraft
     * const presaleDraft = await prisma.presaleDraft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PresaleDraftFindUniqueArgs>(args: SelectSubset<T, PresaleDraftFindUniqueArgs<ExtArgs>>): Prisma__PresaleDraftClient<$Result.GetResult<Prisma.$PresaleDraftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PresaleDraft that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PresaleDraftFindUniqueOrThrowArgs} args - Arguments to find a PresaleDraft
     * @example
     * // Get one PresaleDraft
     * const presaleDraft = await prisma.presaleDraft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PresaleDraftFindUniqueOrThrowArgs>(args: SelectSubset<T, PresaleDraftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PresaleDraftClient<$Result.GetResult<Prisma.$PresaleDraftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PresaleDraft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleDraftFindFirstArgs} args - Arguments to find a PresaleDraft
     * @example
     * // Get one PresaleDraft
     * const presaleDraft = await prisma.presaleDraft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PresaleDraftFindFirstArgs>(args?: SelectSubset<T, PresaleDraftFindFirstArgs<ExtArgs>>): Prisma__PresaleDraftClient<$Result.GetResult<Prisma.$PresaleDraftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PresaleDraft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleDraftFindFirstOrThrowArgs} args - Arguments to find a PresaleDraft
     * @example
     * // Get one PresaleDraft
     * const presaleDraft = await prisma.presaleDraft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PresaleDraftFindFirstOrThrowArgs>(args?: SelectSubset<T, PresaleDraftFindFirstOrThrowArgs<ExtArgs>>): Prisma__PresaleDraftClient<$Result.GetResult<Prisma.$PresaleDraftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PresaleDrafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleDraftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PresaleDrafts
     * const presaleDrafts = await prisma.presaleDraft.findMany()
     * 
     * // Get first 10 PresaleDrafts
     * const presaleDrafts = await prisma.presaleDraft.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const presaleDraftWithIdOnly = await prisma.presaleDraft.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PresaleDraftFindManyArgs>(args?: SelectSubset<T, PresaleDraftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresaleDraftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PresaleDraft.
     * @param {PresaleDraftCreateArgs} args - Arguments to create a PresaleDraft.
     * @example
     * // Create one PresaleDraft
     * const PresaleDraft = await prisma.presaleDraft.create({
     *   data: {
     *     // ... data to create a PresaleDraft
     *   }
     * })
     * 
     */
    create<T extends PresaleDraftCreateArgs>(args: SelectSubset<T, PresaleDraftCreateArgs<ExtArgs>>): Prisma__PresaleDraftClient<$Result.GetResult<Prisma.$PresaleDraftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PresaleDrafts.
     * @param {PresaleDraftCreateManyArgs} args - Arguments to create many PresaleDrafts.
     * @example
     * // Create many PresaleDrafts
     * const presaleDraft = await prisma.presaleDraft.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PresaleDraftCreateManyArgs>(args?: SelectSubset<T, PresaleDraftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PresaleDrafts and returns the data saved in the database.
     * @param {PresaleDraftCreateManyAndReturnArgs} args - Arguments to create many PresaleDrafts.
     * @example
     * // Create many PresaleDrafts
     * const presaleDraft = await prisma.presaleDraft.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PresaleDrafts and only return the `id`
     * const presaleDraftWithIdOnly = await prisma.presaleDraft.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PresaleDraftCreateManyAndReturnArgs>(args?: SelectSubset<T, PresaleDraftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresaleDraftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PresaleDraft.
     * @param {PresaleDraftDeleteArgs} args - Arguments to delete one PresaleDraft.
     * @example
     * // Delete one PresaleDraft
     * const PresaleDraft = await prisma.presaleDraft.delete({
     *   where: {
     *     // ... filter to delete one PresaleDraft
     *   }
     * })
     * 
     */
    delete<T extends PresaleDraftDeleteArgs>(args: SelectSubset<T, PresaleDraftDeleteArgs<ExtArgs>>): Prisma__PresaleDraftClient<$Result.GetResult<Prisma.$PresaleDraftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PresaleDraft.
     * @param {PresaleDraftUpdateArgs} args - Arguments to update one PresaleDraft.
     * @example
     * // Update one PresaleDraft
     * const presaleDraft = await prisma.presaleDraft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PresaleDraftUpdateArgs>(args: SelectSubset<T, PresaleDraftUpdateArgs<ExtArgs>>): Prisma__PresaleDraftClient<$Result.GetResult<Prisma.$PresaleDraftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PresaleDrafts.
     * @param {PresaleDraftDeleteManyArgs} args - Arguments to filter PresaleDrafts to delete.
     * @example
     * // Delete a few PresaleDrafts
     * const { count } = await prisma.presaleDraft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PresaleDraftDeleteManyArgs>(args?: SelectSubset<T, PresaleDraftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PresaleDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleDraftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PresaleDrafts
     * const presaleDraft = await prisma.presaleDraft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PresaleDraftUpdateManyArgs>(args: SelectSubset<T, PresaleDraftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PresaleDrafts and returns the data updated in the database.
     * @param {PresaleDraftUpdateManyAndReturnArgs} args - Arguments to update many PresaleDrafts.
     * @example
     * // Update many PresaleDrafts
     * const presaleDraft = await prisma.presaleDraft.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PresaleDrafts and only return the `id`
     * const presaleDraftWithIdOnly = await prisma.presaleDraft.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PresaleDraftUpdateManyAndReturnArgs>(args: SelectSubset<T, PresaleDraftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PresaleDraftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PresaleDraft.
     * @param {PresaleDraftUpsertArgs} args - Arguments to update or create a PresaleDraft.
     * @example
     * // Update or create a PresaleDraft
     * const presaleDraft = await prisma.presaleDraft.upsert({
     *   create: {
     *     // ... data to create a PresaleDraft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PresaleDraft we want to update
     *   }
     * })
     */
    upsert<T extends PresaleDraftUpsertArgs>(args: SelectSubset<T, PresaleDraftUpsertArgs<ExtArgs>>): Prisma__PresaleDraftClient<$Result.GetResult<Prisma.$PresaleDraftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PresaleDrafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleDraftCountArgs} args - Arguments to filter PresaleDrafts to count.
     * @example
     * // Count the number of PresaleDrafts
     * const count = await prisma.presaleDraft.count({
     *   where: {
     *     // ... the filter for the PresaleDrafts we want to count
     *   }
     * })
    **/
    count<T extends PresaleDraftCountArgs>(
      args?: Subset<T, PresaleDraftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PresaleDraftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PresaleDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleDraftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PresaleDraftAggregateArgs>(args: Subset<T, PresaleDraftAggregateArgs>): Prisma.PrismaPromise<GetPresaleDraftAggregateType<T>>

    /**
     * Group by PresaleDraft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PresaleDraftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PresaleDraftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PresaleDraftGroupByArgs['orderBy'] }
        : { orderBy?: PresaleDraftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PresaleDraftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPresaleDraftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PresaleDraft model
   */
  readonly fields: PresaleDraftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PresaleDraft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PresaleDraftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PresaleDraft model
   */
  interface PresaleDraftFieldRefs {
    readonly id: FieldRef<"PresaleDraft", 'String'>
    readonly creatorUserId: FieldRef<"PresaleDraft", 'String'>
    readonly addresses: FieldRef<"PresaleDraft", 'Json'>
    readonly count: FieldRef<"PresaleDraft", 'Int'>
    readonly merkleRoot: FieldRef<"PresaleDraft", 'String'>
    readonly sha256Commit: FieldRef<"PresaleDraft", 'String'>
    readonly status: FieldRef<"PresaleDraft", 'DraftStatus'>
    readonly consumedAt: FieldRef<"PresaleDraft", 'DateTime'>
    readonly consumedByPresaleId: FieldRef<"PresaleDraft", 'String'>
    readonly createdAt: FieldRef<"PresaleDraft", 'DateTime'>
    readonly expiresAt: FieldRef<"PresaleDraft", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PresaleDraft findUnique
   */
  export type PresaleDraftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleDraft
     */
    select?: PresaleDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleDraft
     */
    omit?: PresaleDraftOmit<ExtArgs> | null
    /**
     * Filter, which PresaleDraft to fetch.
     */
    where: PresaleDraftWhereUniqueInput
  }

  /**
   * PresaleDraft findUniqueOrThrow
   */
  export type PresaleDraftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleDraft
     */
    select?: PresaleDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleDraft
     */
    omit?: PresaleDraftOmit<ExtArgs> | null
    /**
     * Filter, which PresaleDraft to fetch.
     */
    where: PresaleDraftWhereUniqueInput
  }

  /**
   * PresaleDraft findFirst
   */
  export type PresaleDraftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleDraft
     */
    select?: PresaleDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleDraft
     */
    omit?: PresaleDraftOmit<ExtArgs> | null
    /**
     * Filter, which PresaleDraft to fetch.
     */
    where?: PresaleDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresaleDrafts to fetch.
     */
    orderBy?: PresaleDraftOrderByWithRelationInput | PresaleDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PresaleDrafts.
     */
    cursor?: PresaleDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresaleDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresaleDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PresaleDrafts.
     */
    distinct?: PresaleDraftScalarFieldEnum | PresaleDraftScalarFieldEnum[]
  }

  /**
   * PresaleDraft findFirstOrThrow
   */
  export type PresaleDraftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleDraft
     */
    select?: PresaleDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleDraft
     */
    omit?: PresaleDraftOmit<ExtArgs> | null
    /**
     * Filter, which PresaleDraft to fetch.
     */
    where?: PresaleDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresaleDrafts to fetch.
     */
    orderBy?: PresaleDraftOrderByWithRelationInput | PresaleDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PresaleDrafts.
     */
    cursor?: PresaleDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresaleDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresaleDrafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PresaleDrafts.
     */
    distinct?: PresaleDraftScalarFieldEnum | PresaleDraftScalarFieldEnum[]
  }

  /**
   * PresaleDraft findMany
   */
  export type PresaleDraftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleDraft
     */
    select?: PresaleDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleDraft
     */
    omit?: PresaleDraftOmit<ExtArgs> | null
    /**
     * Filter, which PresaleDrafts to fetch.
     */
    where?: PresaleDraftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PresaleDrafts to fetch.
     */
    orderBy?: PresaleDraftOrderByWithRelationInput | PresaleDraftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PresaleDrafts.
     */
    cursor?: PresaleDraftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PresaleDrafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PresaleDrafts.
     */
    skip?: number
    distinct?: PresaleDraftScalarFieldEnum | PresaleDraftScalarFieldEnum[]
  }

  /**
   * PresaleDraft create
   */
  export type PresaleDraftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleDraft
     */
    select?: PresaleDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleDraft
     */
    omit?: PresaleDraftOmit<ExtArgs> | null
    /**
     * The data needed to create a PresaleDraft.
     */
    data: XOR<PresaleDraftCreateInput, PresaleDraftUncheckedCreateInput>
  }

  /**
   * PresaleDraft createMany
   */
  export type PresaleDraftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PresaleDrafts.
     */
    data: PresaleDraftCreateManyInput | PresaleDraftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PresaleDraft createManyAndReturn
   */
  export type PresaleDraftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleDraft
     */
    select?: PresaleDraftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleDraft
     */
    omit?: PresaleDraftOmit<ExtArgs> | null
    /**
     * The data used to create many PresaleDrafts.
     */
    data: PresaleDraftCreateManyInput | PresaleDraftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PresaleDraft update
   */
  export type PresaleDraftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleDraft
     */
    select?: PresaleDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleDraft
     */
    omit?: PresaleDraftOmit<ExtArgs> | null
    /**
     * The data needed to update a PresaleDraft.
     */
    data: XOR<PresaleDraftUpdateInput, PresaleDraftUncheckedUpdateInput>
    /**
     * Choose, which PresaleDraft to update.
     */
    where: PresaleDraftWhereUniqueInput
  }

  /**
   * PresaleDraft updateMany
   */
  export type PresaleDraftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PresaleDrafts.
     */
    data: XOR<PresaleDraftUpdateManyMutationInput, PresaleDraftUncheckedUpdateManyInput>
    /**
     * Filter which PresaleDrafts to update
     */
    where?: PresaleDraftWhereInput
    /**
     * Limit how many PresaleDrafts to update.
     */
    limit?: number
  }

  /**
   * PresaleDraft updateManyAndReturn
   */
  export type PresaleDraftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleDraft
     */
    select?: PresaleDraftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleDraft
     */
    omit?: PresaleDraftOmit<ExtArgs> | null
    /**
     * The data used to update PresaleDrafts.
     */
    data: XOR<PresaleDraftUpdateManyMutationInput, PresaleDraftUncheckedUpdateManyInput>
    /**
     * Filter which PresaleDrafts to update
     */
    where?: PresaleDraftWhereInput
    /**
     * Limit how many PresaleDrafts to update.
     */
    limit?: number
  }

  /**
   * PresaleDraft upsert
   */
  export type PresaleDraftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleDraft
     */
    select?: PresaleDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleDraft
     */
    omit?: PresaleDraftOmit<ExtArgs> | null
    /**
     * The filter to search for the PresaleDraft to update in case it exists.
     */
    where: PresaleDraftWhereUniqueInput
    /**
     * In case the PresaleDraft found by the `where` argument doesn't exist, create a new PresaleDraft with this data.
     */
    create: XOR<PresaleDraftCreateInput, PresaleDraftUncheckedCreateInput>
    /**
     * In case the PresaleDraft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PresaleDraftUpdateInput, PresaleDraftUncheckedUpdateInput>
  }

  /**
   * PresaleDraft delete
   */
  export type PresaleDraftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleDraft
     */
    select?: PresaleDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleDraft
     */
    omit?: PresaleDraftOmit<ExtArgs> | null
    /**
     * Filter which PresaleDraft to delete.
     */
    where: PresaleDraftWhereUniqueInput
  }

  /**
   * PresaleDraft deleteMany
   */
  export type PresaleDraftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PresaleDrafts to delete
     */
    where?: PresaleDraftWhereInput
    /**
     * Limit how many PresaleDrafts to delete.
     */
    limit?: number
  }

  /**
   * PresaleDraft without action
   */
  export type PresaleDraftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PresaleDraft
     */
    select?: PresaleDraftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PresaleDraft
     */
    omit?: PresaleDraftOmit<ExtArgs> | null
  }


  /**
   * Model AssetUpload
   */

  export type AggregateAssetUpload = {
    _count: AssetUploadCountAggregateOutputType | null
    _avg: AssetUploadAvgAggregateOutputType | null
    _sum: AssetUploadSumAggregateOutputType | null
    _min: AssetUploadMinAggregateOutputType | null
    _max: AssetUploadMaxAggregateOutputType | null
  }

  export type AssetUploadAvgAggregateOutputType = {
    bytes: number | null
  }

  export type AssetUploadSumAggregateOutputType = {
    bytes: number | null
  }

  export type AssetUploadMinAggregateOutputType = {
    id: string | null
    uploaderUserId: string | null
    collectionId: string | null
    single721Id: string | null
    single1155Id: string | null
    provider: string | null
    cid: string | null
    url: string | null
    bytes: number | null
    sha256: string | null
    contentType: string | null
    originalName: string | null
    createdAt: Date | null
  }

  export type AssetUploadMaxAggregateOutputType = {
    id: string | null
    uploaderUserId: string | null
    collectionId: string | null
    single721Id: string | null
    single1155Id: string | null
    provider: string | null
    cid: string | null
    url: string | null
    bytes: number | null
    sha256: string | null
    contentType: string | null
    originalName: string | null
    createdAt: Date | null
  }

  export type AssetUploadCountAggregateOutputType = {
    id: number
    uploaderUserId: number
    collectionId: number
    single721Id: number
    single1155Id: number
    provider: number
    cid: number
    url: number
    bytes: number
    sha256: number
    contentType: number
    originalName: number
    createdAt: number
    _all: number
  }


  export type AssetUploadAvgAggregateInputType = {
    bytes?: true
  }

  export type AssetUploadSumAggregateInputType = {
    bytes?: true
  }

  export type AssetUploadMinAggregateInputType = {
    id?: true
    uploaderUserId?: true
    collectionId?: true
    single721Id?: true
    single1155Id?: true
    provider?: true
    cid?: true
    url?: true
    bytes?: true
    sha256?: true
    contentType?: true
    originalName?: true
    createdAt?: true
  }

  export type AssetUploadMaxAggregateInputType = {
    id?: true
    uploaderUserId?: true
    collectionId?: true
    single721Id?: true
    single1155Id?: true
    provider?: true
    cid?: true
    url?: true
    bytes?: true
    sha256?: true
    contentType?: true
    originalName?: true
    createdAt?: true
  }

  export type AssetUploadCountAggregateInputType = {
    id?: true
    uploaderUserId?: true
    collectionId?: true
    single721Id?: true
    single1155Id?: true
    provider?: true
    cid?: true
    url?: true
    bytes?: true
    sha256?: true
    contentType?: true
    originalName?: true
    createdAt?: true
    _all?: true
  }

  export type AssetUploadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetUpload to aggregate.
     */
    where?: AssetUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetUploads to fetch.
     */
    orderBy?: AssetUploadOrderByWithRelationInput | AssetUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssetUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssetUploads
    **/
    _count?: true | AssetUploadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssetUploadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssetUploadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssetUploadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssetUploadMaxAggregateInputType
  }

  export type GetAssetUploadAggregateType<T extends AssetUploadAggregateArgs> = {
        [P in keyof T & keyof AggregateAssetUpload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssetUpload[P]>
      : GetScalarType<T[P], AggregateAssetUpload[P]>
  }




  export type AssetUploadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssetUploadWhereInput
    orderBy?: AssetUploadOrderByWithAggregationInput | AssetUploadOrderByWithAggregationInput[]
    by: AssetUploadScalarFieldEnum[] | AssetUploadScalarFieldEnum
    having?: AssetUploadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssetUploadCountAggregateInputType | true
    _avg?: AssetUploadAvgAggregateInputType
    _sum?: AssetUploadSumAggregateInputType
    _min?: AssetUploadMinAggregateInputType
    _max?: AssetUploadMaxAggregateInputType
  }

  export type AssetUploadGroupByOutputType = {
    id: string
    uploaderUserId: string | null
    collectionId: string | null
    single721Id: string | null
    single1155Id: string | null
    provider: string
    cid: string
    url: string | null
    bytes: number | null
    sha256: string | null
    contentType: string | null
    originalName: string | null
    createdAt: Date
    _count: AssetUploadCountAggregateOutputType | null
    _avg: AssetUploadAvgAggregateOutputType | null
    _sum: AssetUploadSumAggregateOutputType | null
    _min: AssetUploadMinAggregateOutputType | null
    _max: AssetUploadMaxAggregateOutputType | null
  }

  type GetAssetUploadGroupByPayload<T extends AssetUploadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssetUploadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssetUploadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssetUploadGroupByOutputType[P]>
            : GetScalarType<T[P], AssetUploadGroupByOutputType[P]>
        }
      >
    >


  export type AssetUploadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uploaderUserId?: boolean
    collectionId?: boolean
    single721Id?: boolean
    single1155Id?: boolean
    provider?: boolean
    cid?: boolean
    url?: boolean
    bytes?: boolean
    sha256?: boolean
    contentType?: boolean
    originalName?: boolean
    createdAt?: boolean
    collection?: boolean | AssetUpload$collectionArgs<ExtArgs>
    single1155?: boolean | AssetUpload$single1155Args<ExtArgs>
    single721?: boolean | AssetUpload$single721Args<ExtArgs>
  }, ExtArgs["result"]["assetUpload"]>

  export type AssetUploadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uploaderUserId?: boolean
    collectionId?: boolean
    single721Id?: boolean
    single1155Id?: boolean
    provider?: boolean
    cid?: boolean
    url?: boolean
    bytes?: boolean
    sha256?: boolean
    contentType?: boolean
    originalName?: boolean
    createdAt?: boolean
    collection?: boolean | AssetUpload$collectionArgs<ExtArgs>
    single1155?: boolean | AssetUpload$single1155Args<ExtArgs>
    single721?: boolean | AssetUpload$single721Args<ExtArgs>
  }, ExtArgs["result"]["assetUpload"]>

  export type AssetUploadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uploaderUserId?: boolean
    collectionId?: boolean
    single721Id?: boolean
    single1155Id?: boolean
    provider?: boolean
    cid?: boolean
    url?: boolean
    bytes?: boolean
    sha256?: boolean
    contentType?: boolean
    originalName?: boolean
    createdAt?: boolean
    collection?: boolean | AssetUpload$collectionArgs<ExtArgs>
    single1155?: boolean | AssetUpload$single1155Args<ExtArgs>
    single721?: boolean | AssetUpload$single721Args<ExtArgs>
  }, ExtArgs["result"]["assetUpload"]>

  export type AssetUploadSelectScalar = {
    id?: boolean
    uploaderUserId?: boolean
    collectionId?: boolean
    single721Id?: boolean
    single1155Id?: boolean
    provider?: boolean
    cid?: boolean
    url?: boolean
    bytes?: boolean
    sha256?: boolean
    contentType?: boolean
    originalName?: boolean
    createdAt?: boolean
  }

  export type AssetUploadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uploaderUserId" | "collectionId" | "single721Id" | "single1155Id" | "provider" | "cid" | "url" | "bytes" | "sha256" | "contentType" | "originalName" | "createdAt", ExtArgs["result"]["assetUpload"]>
  export type AssetUploadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | AssetUpload$collectionArgs<ExtArgs>
    single1155?: boolean | AssetUpload$single1155Args<ExtArgs>
    single721?: boolean | AssetUpload$single721Args<ExtArgs>
  }
  export type AssetUploadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | AssetUpload$collectionArgs<ExtArgs>
    single1155?: boolean | AssetUpload$single1155Args<ExtArgs>
    single721?: boolean | AssetUpload$single721Args<ExtArgs>
  }
  export type AssetUploadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | AssetUpload$collectionArgs<ExtArgs>
    single1155?: boolean | AssetUpload$single1155Args<ExtArgs>
    single721?: boolean | AssetUpload$single721Args<ExtArgs>
  }

  export type $AssetUploadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssetUpload"
    objects: {
      collection: Prisma.$CollectionPayload<ExtArgs> | null
      single1155: Prisma.$Single1155Payload<ExtArgs> | null
      single721: Prisma.$Single721Payload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uploaderUserId: string | null
      collectionId: string | null
      single721Id: string | null
      single1155Id: string | null
      provider: string
      cid: string
      url: string | null
      bytes: number | null
      sha256: string | null
      contentType: string | null
      originalName: string | null
      createdAt: Date
    }, ExtArgs["result"]["assetUpload"]>
    composites: {}
  }

  type AssetUploadGetPayload<S extends boolean | null | undefined | AssetUploadDefaultArgs> = $Result.GetResult<Prisma.$AssetUploadPayload, S>

  type AssetUploadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssetUploadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssetUploadCountAggregateInputType | true
    }

  export interface AssetUploadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssetUpload'], meta: { name: 'AssetUpload' } }
    /**
     * Find zero or one AssetUpload that matches the filter.
     * @param {AssetUploadFindUniqueArgs} args - Arguments to find a AssetUpload
     * @example
     * // Get one AssetUpload
     * const assetUpload = await prisma.assetUpload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssetUploadFindUniqueArgs>(args: SelectSubset<T, AssetUploadFindUniqueArgs<ExtArgs>>): Prisma__AssetUploadClient<$Result.GetResult<Prisma.$AssetUploadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssetUpload that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssetUploadFindUniqueOrThrowArgs} args - Arguments to find a AssetUpload
     * @example
     * // Get one AssetUpload
     * const assetUpload = await prisma.assetUpload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssetUploadFindUniqueOrThrowArgs>(args: SelectSubset<T, AssetUploadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssetUploadClient<$Result.GetResult<Prisma.$AssetUploadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetUpload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUploadFindFirstArgs} args - Arguments to find a AssetUpload
     * @example
     * // Get one AssetUpload
     * const assetUpload = await prisma.assetUpload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssetUploadFindFirstArgs>(args?: SelectSubset<T, AssetUploadFindFirstArgs<ExtArgs>>): Prisma__AssetUploadClient<$Result.GetResult<Prisma.$AssetUploadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssetUpload that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUploadFindFirstOrThrowArgs} args - Arguments to find a AssetUpload
     * @example
     * // Get one AssetUpload
     * const assetUpload = await prisma.assetUpload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssetUploadFindFirstOrThrowArgs>(args?: SelectSubset<T, AssetUploadFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssetUploadClient<$Result.GetResult<Prisma.$AssetUploadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssetUploads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUploadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssetUploads
     * const assetUploads = await prisma.assetUpload.findMany()
     * 
     * // Get first 10 AssetUploads
     * const assetUploads = await prisma.assetUpload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assetUploadWithIdOnly = await prisma.assetUpload.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssetUploadFindManyArgs>(args?: SelectSubset<T, AssetUploadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetUploadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssetUpload.
     * @param {AssetUploadCreateArgs} args - Arguments to create a AssetUpload.
     * @example
     * // Create one AssetUpload
     * const AssetUpload = await prisma.assetUpload.create({
     *   data: {
     *     // ... data to create a AssetUpload
     *   }
     * })
     * 
     */
    create<T extends AssetUploadCreateArgs>(args: SelectSubset<T, AssetUploadCreateArgs<ExtArgs>>): Prisma__AssetUploadClient<$Result.GetResult<Prisma.$AssetUploadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssetUploads.
     * @param {AssetUploadCreateManyArgs} args - Arguments to create many AssetUploads.
     * @example
     * // Create many AssetUploads
     * const assetUpload = await prisma.assetUpload.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssetUploadCreateManyArgs>(args?: SelectSubset<T, AssetUploadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssetUploads and returns the data saved in the database.
     * @param {AssetUploadCreateManyAndReturnArgs} args - Arguments to create many AssetUploads.
     * @example
     * // Create many AssetUploads
     * const assetUpload = await prisma.assetUpload.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssetUploads and only return the `id`
     * const assetUploadWithIdOnly = await prisma.assetUpload.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssetUploadCreateManyAndReturnArgs>(args?: SelectSubset<T, AssetUploadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetUploadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssetUpload.
     * @param {AssetUploadDeleteArgs} args - Arguments to delete one AssetUpload.
     * @example
     * // Delete one AssetUpload
     * const AssetUpload = await prisma.assetUpload.delete({
     *   where: {
     *     // ... filter to delete one AssetUpload
     *   }
     * })
     * 
     */
    delete<T extends AssetUploadDeleteArgs>(args: SelectSubset<T, AssetUploadDeleteArgs<ExtArgs>>): Prisma__AssetUploadClient<$Result.GetResult<Prisma.$AssetUploadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssetUpload.
     * @param {AssetUploadUpdateArgs} args - Arguments to update one AssetUpload.
     * @example
     * // Update one AssetUpload
     * const assetUpload = await prisma.assetUpload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssetUploadUpdateArgs>(args: SelectSubset<T, AssetUploadUpdateArgs<ExtArgs>>): Prisma__AssetUploadClient<$Result.GetResult<Prisma.$AssetUploadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssetUploads.
     * @param {AssetUploadDeleteManyArgs} args - Arguments to filter AssetUploads to delete.
     * @example
     * // Delete a few AssetUploads
     * const { count } = await prisma.assetUpload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssetUploadDeleteManyArgs>(args?: SelectSubset<T, AssetUploadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUploadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssetUploads
     * const assetUpload = await prisma.assetUpload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssetUploadUpdateManyArgs>(args: SelectSubset<T, AssetUploadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssetUploads and returns the data updated in the database.
     * @param {AssetUploadUpdateManyAndReturnArgs} args - Arguments to update many AssetUploads.
     * @example
     * // Update many AssetUploads
     * const assetUpload = await prisma.assetUpload.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AssetUploads and only return the `id`
     * const assetUploadWithIdOnly = await prisma.assetUpload.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssetUploadUpdateManyAndReturnArgs>(args: SelectSubset<T, AssetUploadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssetUploadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssetUpload.
     * @param {AssetUploadUpsertArgs} args - Arguments to update or create a AssetUpload.
     * @example
     * // Update or create a AssetUpload
     * const assetUpload = await prisma.assetUpload.upsert({
     *   create: {
     *     // ... data to create a AssetUpload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssetUpload we want to update
     *   }
     * })
     */
    upsert<T extends AssetUploadUpsertArgs>(args: SelectSubset<T, AssetUploadUpsertArgs<ExtArgs>>): Prisma__AssetUploadClient<$Result.GetResult<Prisma.$AssetUploadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssetUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUploadCountArgs} args - Arguments to filter AssetUploads to count.
     * @example
     * // Count the number of AssetUploads
     * const count = await prisma.assetUpload.count({
     *   where: {
     *     // ... the filter for the AssetUploads we want to count
     *   }
     * })
    **/
    count<T extends AssetUploadCountArgs>(
      args?: Subset<T, AssetUploadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssetUploadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssetUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUploadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssetUploadAggregateArgs>(args: Subset<T, AssetUploadAggregateArgs>): Prisma.PrismaPromise<GetAssetUploadAggregateType<T>>

    /**
     * Group by AssetUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssetUploadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssetUploadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssetUploadGroupByArgs['orderBy'] }
        : { orderBy?: AssetUploadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssetUploadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssetUploadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssetUpload model
   */
  readonly fields: AssetUploadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssetUpload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssetUploadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends AssetUpload$collectionArgs<ExtArgs> = {}>(args?: Subset<T, AssetUpload$collectionArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    single1155<T extends AssetUpload$single1155Args<ExtArgs> = {}>(args?: Subset<T, AssetUpload$single1155Args<ExtArgs>>): Prisma__Single1155Client<$Result.GetResult<Prisma.$Single1155Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    single721<T extends AssetUpload$single721Args<ExtArgs> = {}>(args?: Subset<T, AssetUpload$single721Args<ExtArgs>>): Prisma__Single721Client<$Result.GetResult<Prisma.$Single721Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssetUpload model
   */
  interface AssetUploadFieldRefs {
    readonly id: FieldRef<"AssetUpload", 'String'>
    readonly uploaderUserId: FieldRef<"AssetUpload", 'String'>
    readonly collectionId: FieldRef<"AssetUpload", 'String'>
    readonly single721Id: FieldRef<"AssetUpload", 'String'>
    readonly single1155Id: FieldRef<"AssetUpload", 'String'>
    readonly provider: FieldRef<"AssetUpload", 'String'>
    readonly cid: FieldRef<"AssetUpload", 'String'>
    readonly url: FieldRef<"AssetUpload", 'String'>
    readonly bytes: FieldRef<"AssetUpload", 'Int'>
    readonly sha256: FieldRef<"AssetUpload", 'String'>
    readonly contentType: FieldRef<"AssetUpload", 'String'>
    readonly originalName: FieldRef<"AssetUpload", 'String'>
    readonly createdAt: FieldRef<"AssetUpload", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssetUpload findUnique
   */
  export type AssetUploadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadInclude<ExtArgs> | null
    /**
     * Filter, which AssetUpload to fetch.
     */
    where: AssetUploadWhereUniqueInput
  }

  /**
   * AssetUpload findUniqueOrThrow
   */
  export type AssetUploadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadInclude<ExtArgs> | null
    /**
     * Filter, which AssetUpload to fetch.
     */
    where: AssetUploadWhereUniqueInput
  }

  /**
   * AssetUpload findFirst
   */
  export type AssetUploadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadInclude<ExtArgs> | null
    /**
     * Filter, which AssetUpload to fetch.
     */
    where?: AssetUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetUploads to fetch.
     */
    orderBy?: AssetUploadOrderByWithRelationInput | AssetUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetUploads.
     */
    cursor?: AssetUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetUploads.
     */
    distinct?: AssetUploadScalarFieldEnum | AssetUploadScalarFieldEnum[]
  }

  /**
   * AssetUpload findFirstOrThrow
   */
  export type AssetUploadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadInclude<ExtArgs> | null
    /**
     * Filter, which AssetUpload to fetch.
     */
    where?: AssetUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetUploads to fetch.
     */
    orderBy?: AssetUploadOrderByWithRelationInput | AssetUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssetUploads.
     */
    cursor?: AssetUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssetUploads.
     */
    distinct?: AssetUploadScalarFieldEnum | AssetUploadScalarFieldEnum[]
  }

  /**
   * AssetUpload findMany
   */
  export type AssetUploadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadInclude<ExtArgs> | null
    /**
     * Filter, which AssetUploads to fetch.
     */
    where?: AssetUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssetUploads to fetch.
     */
    orderBy?: AssetUploadOrderByWithRelationInput | AssetUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssetUploads.
     */
    cursor?: AssetUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssetUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssetUploads.
     */
    skip?: number
    distinct?: AssetUploadScalarFieldEnum | AssetUploadScalarFieldEnum[]
  }

  /**
   * AssetUpload create
   */
  export type AssetUploadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadInclude<ExtArgs> | null
    /**
     * The data needed to create a AssetUpload.
     */
    data: XOR<AssetUploadCreateInput, AssetUploadUncheckedCreateInput>
  }

  /**
   * AssetUpload createMany
   */
  export type AssetUploadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssetUploads.
     */
    data: AssetUploadCreateManyInput | AssetUploadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssetUpload createManyAndReturn
   */
  export type AssetUploadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * The data used to create many AssetUploads.
     */
    data: AssetUploadCreateManyInput | AssetUploadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetUpload update
   */
  export type AssetUploadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadInclude<ExtArgs> | null
    /**
     * The data needed to update a AssetUpload.
     */
    data: XOR<AssetUploadUpdateInput, AssetUploadUncheckedUpdateInput>
    /**
     * Choose, which AssetUpload to update.
     */
    where: AssetUploadWhereUniqueInput
  }

  /**
   * AssetUpload updateMany
   */
  export type AssetUploadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssetUploads.
     */
    data: XOR<AssetUploadUpdateManyMutationInput, AssetUploadUncheckedUpdateManyInput>
    /**
     * Filter which AssetUploads to update
     */
    where?: AssetUploadWhereInput
    /**
     * Limit how many AssetUploads to update.
     */
    limit?: number
  }

  /**
   * AssetUpload updateManyAndReturn
   */
  export type AssetUploadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * The data used to update AssetUploads.
     */
    data: XOR<AssetUploadUpdateManyMutationInput, AssetUploadUncheckedUpdateManyInput>
    /**
     * Filter which AssetUploads to update
     */
    where?: AssetUploadWhereInput
    /**
     * Limit how many AssetUploads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssetUpload upsert
   */
  export type AssetUploadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadInclude<ExtArgs> | null
    /**
     * The filter to search for the AssetUpload to update in case it exists.
     */
    where: AssetUploadWhereUniqueInput
    /**
     * In case the AssetUpload found by the `where` argument doesn't exist, create a new AssetUpload with this data.
     */
    create: XOR<AssetUploadCreateInput, AssetUploadUncheckedCreateInput>
    /**
     * In case the AssetUpload was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssetUploadUpdateInput, AssetUploadUncheckedUpdateInput>
  }

  /**
   * AssetUpload delete
   */
  export type AssetUploadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadInclude<ExtArgs> | null
    /**
     * Filter which AssetUpload to delete.
     */
    where: AssetUploadWhereUniqueInput
  }

  /**
   * AssetUpload deleteMany
   */
  export type AssetUploadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssetUploads to delete
     */
    where?: AssetUploadWhereInput
    /**
     * Limit how many AssetUploads to delete.
     */
    limit?: number
  }

  /**
   * AssetUpload.collection
   */
  export type AssetUpload$collectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    where?: CollectionWhereInput
  }

  /**
   * AssetUpload.single1155
   */
  export type AssetUpload$single1155Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single1155
     */
    select?: Single1155Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single1155
     */
    omit?: Single1155Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single1155Include<ExtArgs> | null
    where?: Single1155WhereInput
  }

  /**
   * AssetUpload.single721
   */
  export type AssetUpload$single721Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Single721
     */
    select?: Single721Select<ExtArgs> | null
    /**
     * Omit specific fields from the Single721
     */
    omit?: Single721Omit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Single721Include<ExtArgs> | null
    where?: Single721WhereInput
  }

  /**
   * AssetUpload without action
   */
  export type AssetUploadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssetUpload
     */
    select?: AssetUploadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssetUpload
     */
    omit?: AssetUploadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssetUploadInclude<ExtArgs> | null
  }


  /**
   * Model CollectionSubmission
   */

  export type AggregateCollectionSubmission = {
    _count: CollectionSubmissionCountAggregateOutputType | null
    _avg: CollectionSubmissionAvgAggregateOutputType | null
    _sum: CollectionSubmissionSumAggregateOutputType | null
    _min: CollectionSubmissionMinAggregateOutputType | null
    _max: CollectionSubmissionMaxAggregateOutputType | null
  }

  export type CollectionSubmissionAvgAggregateOutputType = {
    supply: number | null
    feePaidWei: Decimal | null
  }

  export type CollectionSubmissionSumAggregateOutputType = {
    supply: number | null
    feePaidWei: Decimal | null
  }

  export type CollectionSubmissionMinAggregateOutputType = {
    id: string | null
    submittedByUserId: string | null
    contract: string | null
    ownerAddress: string | null
    name: string | null
    symbol: string | null
    logoUrl: string | null
    coverUrl: string | null
    baseUri: string | null
    supply: number | null
    description: string | null
    website: string | null
    x: string | null
    instagram: string | null
    telegram: string | null
    feeTxHash: string | null
    feePaidWei: Decimal | null
    feeVerifiedAt: Date | null
    ownershipVerified: boolean | null
    status: $Enums.SubmissionStatus | null
    statusReason: string | null
    reviewedByUserId: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionSubmissionMaxAggregateOutputType = {
    id: string | null
    submittedByUserId: string | null
    contract: string | null
    ownerAddress: string | null
    name: string | null
    symbol: string | null
    logoUrl: string | null
    coverUrl: string | null
    baseUri: string | null
    supply: number | null
    description: string | null
    website: string | null
    x: string | null
    instagram: string | null
    telegram: string | null
    feeTxHash: string | null
    feePaidWei: Decimal | null
    feeVerifiedAt: Date | null
    ownershipVerified: boolean | null
    status: $Enums.SubmissionStatus | null
    statusReason: string | null
    reviewedByUserId: string | null
    reviewedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CollectionSubmissionCountAggregateOutputType = {
    id: number
    submittedByUserId: number
    contract: number
    ownerAddress: number
    name: number
    symbol: number
    logoUrl: number
    coverUrl: number
    baseUri: number
    supply: number
    description: number
    website: number
    x: number
    instagram: number
    telegram: number
    feeTxHash: number
    feePaidWei: number
    feeVerifiedAt: number
    ownershipVerified: number
    status: number
    statusReason: number
    reviewedByUserId: number
    reviewedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CollectionSubmissionAvgAggregateInputType = {
    supply?: true
    feePaidWei?: true
  }

  export type CollectionSubmissionSumAggregateInputType = {
    supply?: true
    feePaidWei?: true
  }

  export type CollectionSubmissionMinAggregateInputType = {
    id?: true
    submittedByUserId?: true
    contract?: true
    ownerAddress?: true
    name?: true
    symbol?: true
    logoUrl?: true
    coverUrl?: true
    baseUri?: true
    supply?: true
    description?: true
    website?: true
    x?: true
    instagram?: true
    telegram?: true
    feeTxHash?: true
    feePaidWei?: true
    feeVerifiedAt?: true
    ownershipVerified?: true
    status?: true
    statusReason?: true
    reviewedByUserId?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionSubmissionMaxAggregateInputType = {
    id?: true
    submittedByUserId?: true
    contract?: true
    ownerAddress?: true
    name?: true
    symbol?: true
    logoUrl?: true
    coverUrl?: true
    baseUri?: true
    supply?: true
    description?: true
    website?: true
    x?: true
    instagram?: true
    telegram?: true
    feeTxHash?: true
    feePaidWei?: true
    feeVerifiedAt?: true
    ownershipVerified?: true
    status?: true
    statusReason?: true
    reviewedByUserId?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CollectionSubmissionCountAggregateInputType = {
    id?: true
    submittedByUserId?: true
    contract?: true
    ownerAddress?: true
    name?: true
    symbol?: true
    logoUrl?: true
    coverUrl?: true
    baseUri?: true
    supply?: true
    description?: true
    website?: true
    x?: true
    instagram?: true
    telegram?: true
    feeTxHash?: true
    feePaidWei?: true
    feeVerifiedAt?: true
    ownershipVerified?: true
    status?: true
    statusReason?: true
    reviewedByUserId?: true
    reviewedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CollectionSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionSubmission to aggregate.
     */
    where?: CollectionSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionSubmissions to fetch.
     */
    orderBy?: CollectionSubmissionOrderByWithRelationInput | CollectionSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CollectionSubmissions
    **/
    _count?: true | CollectionSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionSubmissionMaxAggregateInputType
  }

  export type GetCollectionSubmissionAggregateType<T extends CollectionSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectionSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectionSubmission[P]>
      : GetScalarType<T[P], AggregateCollectionSubmission[P]>
  }




  export type CollectionSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionSubmissionWhereInput
    orderBy?: CollectionSubmissionOrderByWithAggregationInput | CollectionSubmissionOrderByWithAggregationInput[]
    by: CollectionSubmissionScalarFieldEnum[] | CollectionSubmissionScalarFieldEnum
    having?: CollectionSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionSubmissionCountAggregateInputType | true
    _avg?: CollectionSubmissionAvgAggregateInputType
    _sum?: CollectionSubmissionSumAggregateInputType
    _min?: CollectionSubmissionMinAggregateInputType
    _max?: CollectionSubmissionMaxAggregateInputType
  }

  export type CollectionSubmissionGroupByOutputType = {
    id: string
    submittedByUserId: string
    contract: string
    ownerAddress: string | null
    name: string | null
    symbol: string | null
    logoUrl: string | null
    coverUrl: string | null
    baseUri: string | null
    supply: number | null
    description: string | null
    website: string | null
    x: string | null
    instagram: string | null
    telegram: string | null
    feeTxHash: string | null
    feePaidWei: Decimal | null
    feeVerifiedAt: Date | null
    ownershipVerified: boolean
    status: $Enums.SubmissionStatus
    statusReason: string | null
    reviewedByUserId: string | null
    reviewedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CollectionSubmissionCountAggregateOutputType | null
    _avg: CollectionSubmissionAvgAggregateOutputType | null
    _sum: CollectionSubmissionSumAggregateOutputType | null
    _min: CollectionSubmissionMinAggregateOutputType | null
    _max: CollectionSubmissionMaxAggregateOutputType | null
  }

  type GetCollectionSubmissionGroupByPayload<T extends CollectionSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type CollectionSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    submittedByUserId?: boolean
    contract?: boolean
    ownerAddress?: boolean
    name?: boolean
    symbol?: boolean
    logoUrl?: boolean
    coverUrl?: boolean
    baseUri?: boolean
    supply?: boolean
    description?: boolean
    website?: boolean
    x?: boolean
    instagram?: boolean
    telegram?: boolean
    feeTxHash?: boolean
    feePaidWei?: boolean
    feeVerifiedAt?: boolean
    ownershipVerified?: boolean
    status?: boolean
    statusReason?: boolean
    reviewedByUserId?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submittedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionSubmission"]>

  export type CollectionSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    submittedByUserId?: boolean
    contract?: boolean
    ownerAddress?: boolean
    name?: boolean
    symbol?: boolean
    logoUrl?: boolean
    coverUrl?: boolean
    baseUri?: boolean
    supply?: boolean
    description?: boolean
    website?: boolean
    x?: boolean
    instagram?: boolean
    telegram?: boolean
    feeTxHash?: boolean
    feePaidWei?: boolean
    feeVerifiedAt?: boolean
    ownershipVerified?: boolean
    status?: boolean
    statusReason?: boolean
    reviewedByUserId?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submittedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionSubmission"]>

  export type CollectionSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    submittedByUserId?: boolean
    contract?: boolean
    ownerAddress?: boolean
    name?: boolean
    symbol?: boolean
    logoUrl?: boolean
    coverUrl?: boolean
    baseUri?: boolean
    supply?: boolean
    description?: boolean
    website?: boolean
    x?: boolean
    instagram?: boolean
    telegram?: boolean
    feeTxHash?: boolean
    feePaidWei?: boolean
    feeVerifiedAt?: boolean
    ownershipVerified?: boolean
    status?: boolean
    statusReason?: boolean
    reviewedByUserId?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submittedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collectionSubmission"]>

  export type CollectionSubmissionSelectScalar = {
    id?: boolean
    submittedByUserId?: boolean
    contract?: boolean
    ownerAddress?: boolean
    name?: boolean
    symbol?: boolean
    logoUrl?: boolean
    coverUrl?: boolean
    baseUri?: boolean
    supply?: boolean
    description?: boolean
    website?: boolean
    x?: boolean
    instagram?: boolean
    telegram?: boolean
    feeTxHash?: boolean
    feePaidWei?: boolean
    feeVerifiedAt?: boolean
    ownershipVerified?: boolean
    status?: boolean
    statusReason?: boolean
    reviewedByUserId?: boolean
    reviewedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CollectionSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "submittedByUserId" | "contract" | "ownerAddress" | "name" | "symbol" | "logoUrl" | "coverUrl" | "baseUri" | "supply" | "description" | "website" | "x" | "instagram" | "telegram" | "feeTxHash" | "feePaidWei" | "feeVerifiedAt" | "ownershipVerified" | "status" | "statusReason" | "reviewedByUserId" | "reviewedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["collectionSubmission"]>
  export type CollectionSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submittedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CollectionSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submittedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CollectionSubmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    submittedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CollectionSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CollectionSubmission"
    objects: {
      submittedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      submittedByUserId: string
      contract: string
      ownerAddress: string | null
      name: string | null
      symbol: string | null
      logoUrl: string | null
      coverUrl: string | null
      baseUri: string | null
      supply: number | null
      description: string | null
      website: string | null
      x: string | null
      instagram: string | null
      telegram: string | null
      feeTxHash: string | null
      feePaidWei: Prisma.Decimal | null
      feeVerifiedAt: Date | null
      ownershipVerified: boolean
      status: $Enums.SubmissionStatus
      statusReason: string | null
      reviewedByUserId: string | null
      reviewedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["collectionSubmission"]>
    composites: {}
  }

  type CollectionSubmissionGetPayload<S extends boolean | null | undefined | CollectionSubmissionDefaultArgs> = $Result.GetResult<Prisma.$CollectionSubmissionPayload, S>

  type CollectionSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionSubmissionCountAggregateInputType | true
    }

  export interface CollectionSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CollectionSubmission'], meta: { name: 'CollectionSubmission' } }
    /**
     * Find zero or one CollectionSubmission that matches the filter.
     * @param {CollectionSubmissionFindUniqueArgs} args - Arguments to find a CollectionSubmission
     * @example
     * // Get one CollectionSubmission
     * const collectionSubmission = await prisma.collectionSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionSubmissionFindUniqueArgs>(args: SelectSubset<T, CollectionSubmissionFindUniqueArgs<ExtArgs>>): Prisma__CollectionSubmissionClient<$Result.GetResult<Prisma.$CollectionSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CollectionSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionSubmissionFindUniqueOrThrowArgs} args - Arguments to find a CollectionSubmission
     * @example
     * // Get one CollectionSubmission
     * const collectionSubmission = await prisma.collectionSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionSubmissionClient<$Result.GetResult<Prisma.$CollectionSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionSubmissionFindFirstArgs} args - Arguments to find a CollectionSubmission
     * @example
     * // Get one CollectionSubmission
     * const collectionSubmission = await prisma.collectionSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionSubmissionFindFirstArgs>(args?: SelectSubset<T, CollectionSubmissionFindFirstArgs<ExtArgs>>): Prisma__CollectionSubmissionClient<$Result.GetResult<Prisma.$CollectionSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CollectionSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionSubmissionFindFirstOrThrowArgs} args - Arguments to find a CollectionSubmission
     * @example
     * // Get one CollectionSubmission
     * const collectionSubmission = await prisma.collectionSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionSubmissionClient<$Result.GetResult<Prisma.$CollectionSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CollectionSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CollectionSubmissions
     * const collectionSubmissions = await prisma.collectionSubmission.findMany()
     * 
     * // Get first 10 CollectionSubmissions
     * const collectionSubmissions = await prisma.collectionSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionSubmissionWithIdOnly = await prisma.collectionSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionSubmissionFindManyArgs>(args?: SelectSubset<T, CollectionSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CollectionSubmission.
     * @param {CollectionSubmissionCreateArgs} args - Arguments to create a CollectionSubmission.
     * @example
     * // Create one CollectionSubmission
     * const CollectionSubmission = await prisma.collectionSubmission.create({
     *   data: {
     *     // ... data to create a CollectionSubmission
     *   }
     * })
     * 
     */
    create<T extends CollectionSubmissionCreateArgs>(args: SelectSubset<T, CollectionSubmissionCreateArgs<ExtArgs>>): Prisma__CollectionSubmissionClient<$Result.GetResult<Prisma.$CollectionSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CollectionSubmissions.
     * @param {CollectionSubmissionCreateManyArgs} args - Arguments to create many CollectionSubmissions.
     * @example
     * // Create many CollectionSubmissions
     * const collectionSubmission = await prisma.collectionSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionSubmissionCreateManyArgs>(args?: SelectSubset<T, CollectionSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CollectionSubmissions and returns the data saved in the database.
     * @param {CollectionSubmissionCreateManyAndReturnArgs} args - Arguments to create many CollectionSubmissions.
     * @example
     * // Create many CollectionSubmissions
     * const collectionSubmission = await prisma.collectionSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CollectionSubmissions and only return the `id`
     * const collectionSubmissionWithIdOnly = await prisma.collectionSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CollectionSubmission.
     * @param {CollectionSubmissionDeleteArgs} args - Arguments to delete one CollectionSubmission.
     * @example
     * // Delete one CollectionSubmission
     * const CollectionSubmission = await prisma.collectionSubmission.delete({
     *   where: {
     *     // ... filter to delete one CollectionSubmission
     *   }
     * })
     * 
     */
    delete<T extends CollectionSubmissionDeleteArgs>(args: SelectSubset<T, CollectionSubmissionDeleteArgs<ExtArgs>>): Prisma__CollectionSubmissionClient<$Result.GetResult<Prisma.$CollectionSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CollectionSubmission.
     * @param {CollectionSubmissionUpdateArgs} args - Arguments to update one CollectionSubmission.
     * @example
     * // Update one CollectionSubmission
     * const collectionSubmission = await prisma.collectionSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionSubmissionUpdateArgs>(args: SelectSubset<T, CollectionSubmissionUpdateArgs<ExtArgs>>): Prisma__CollectionSubmissionClient<$Result.GetResult<Prisma.$CollectionSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CollectionSubmissions.
     * @param {CollectionSubmissionDeleteManyArgs} args - Arguments to filter CollectionSubmissions to delete.
     * @example
     * // Delete a few CollectionSubmissions
     * const { count } = await prisma.collectionSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionSubmissionDeleteManyArgs>(args?: SelectSubset<T, CollectionSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CollectionSubmissions
     * const collectionSubmission = await prisma.collectionSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionSubmissionUpdateManyArgs>(args: SelectSubset<T, CollectionSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CollectionSubmissions and returns the data updated in the database.
     * @param {CollectionSubmissionUpdateManyAndReturnArgs} args - Arguments to update many CollectionSubmissions.
     * @example
     * // Update many CollectionSubmissions
     * const collectionSubmission = await prisma.collectionSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CollectionSubmissions and only return the `id`
     * const collectionSubmissionWithIdOnly = await prisma.collectionSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CollectionSubmission.
     * @param {CollectionSubmissionUpsertArgs} args - Arguments to update or create a CollectionSubmission.
     * @example
     * // Update or create a CollectionSubmission
     * const collectionSubmission = await prisma.collectionSubmission.upsert({
     *   create: {
     *     // ... data to create a CollectionSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CollectionSubmission we want to update
     *   }
     * })
     */
    upsert<T extends CollectionSubmissionUpsertArgs>(args: SelectSubset<T, CollectionSubmissionUpsertArgs<ExtArgs>>): Prisma__CollectionSubmissionClient<$Result.GetResult<Prisma.$CollectionSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CollectionSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionSubmissionCountArgs} args - Arguments to filter CollectionSubmissions to count.
     * @example
     * // Count the number of CollectionSubmissions
     * const count = await prisma.collectionSubmission.count({
     *   where: {
     *     // ... the filter for the CollectionSubmissions we want to count
     *   }
     * })
    **/
    count<T extends CollectionSubmissionCountArgs>(
      args?: Subset<T, CollectionSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CollectionSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionSubmissionAggregateArgs>(args: Subset<T, CollectionSubmissionAggregateArgs>): Prisma.PrismaPromise<GetCollectionSubmissionAggregateType<T>>

    /**
     * Group by CollectionSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: CollectionSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CollectionSubmission model
   */
  readonly fields: CollectionSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CollectionSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    submittedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CollectionSubmission model
   */
  interface CollectionSubmissionFieldRefs {
    readonly id: FieldRef<"CollectionSubmission", 'String'>
    readonly submittedByUserId: FieldRef<"CollectionSubmission", 'String'>
    readonly contract: FieldRef<"CollectionSubmission", 'String'>
    readonly ownerAddress: FieldRef<"CollectionSubmission", 'String'>
    readonly name: FieldRef<"CollectionSubmission", 'String'>
    readonly symbol: FieldRef<"CollectionSubmission", 'String'>
    readonly logoUrl: FieldRef<"CollectionSubmission", 'String'>
    readonly coverUrl: FieldRef<"CollectionSubmission", 'String'>
    readonly baseUri: FieldRef<"CollectionSubmission", 'String'>
    readonly supply: FieldRef<"CollectionSubmission", 'Int'>
    readonly description: FieldRef<"CollectionSubmission", 'String'>
    readonly website: FieldRef<"CollectionSubmission", 'String'>
    readonly x: FieldRef<"CollectionSubmission", 'String'>
    readonly instagram: FieldRef<"CollectionSubmission", 'String'>
    readonly telegram: FieldRef<"CollectionSubmission", 'String'>
    readonly feeTxHash: FieldRef<"CollectionSubmission", 'String'>
    readonly feePaidWei: FieldRef<"CollectionSubmission", 'Decimal'>
    readonly feeVerifiedAt: FieldRef<"CollectionSubmission", 'DateTime'>
    readonly ownershipVerified: FieldRef<"CollectionSubmission", 'Boolean'>
    readonly status: FieldRef<"CollectionSubmission", 'SubmissionStatus'>
    readonly statusReason: FieldRef<"CollectionSubmission", 'String'>
    readonly reviewedByUserId: FieldRef<"CollectionSubmission", 'String'>
    readonly reviewedAt: FieldRef<"CollectionSubmission", 'DateTime'>
    readonly createdAt: FieldRef<"CollectionSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"CollectionSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CollectionSubmission findUnique
   */
  export type CollectionSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionSubmission
     */
    select?: CollectionSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionSubmission
     */
    omit?: CollectionSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which CollectionSubmission to fetch.
     */
    where: CollectionSubmissionWhereUniqueInput
  }

  /**
   * CollectionSubmission findUniqueOrThrow
   */
  export type CollectionSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionSubmission
     */
    select?: CollectionSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionSubmission
     */
    omit?: CollectionSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which CollectionSubmission to fetch.
     */
    where: CollectionSubmissionWhereUniqueInput
  }

  /**
   * CollectionSubmission findFirst
   */
  export type CollectionSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionSubmission
     */
    select?: CollectionSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionSubmission
     */
    omit?: CollectionSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which CollectionSubmission to fetch.
     */
    where?: CollectionSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionSubmissions to fetch.
     */
    orderBy?: CollectionSubmissionOrderByWithRelationInput | CollectionSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionSubmissions.
     */
    cursor?: CollectionSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionSubmissions.
     */
    distinct?: CollectionSubmissionScalarFieldEnum | CollectionSubmissionScalarFieldEnum[]
  }

  /**
   * CollectionSubmission findFirstOrThrow
   */
  export type CollectionSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionSubmission
     */
    select?: CollectionSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionSubmission
     */
    omit?: CollectionSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which CollectionSubmission to fetch.
     */
    where?: CollectionSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionSubmissions to fetch.
     */
    orderBy?: CollectionSubmissionOrderByWithRelationInput | CollectionSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CollectionSubmissions.
     */
    cursor?: CollectionSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CollectionSubmissions.
     */
    distinct?: CollectionSubmissionScalarFieldEnum | CollectionSubmissionScalarFieldEnum[]
  }

  /**
   * CollectionSubmission findMany
   */
  export type CollectionSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionSubmission
     */
    select?: CollectionSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionSubmission
     */
    omit?: CollectionSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which CollectionSubmissions to fetch.
     */
    where?: CollectionSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CollectionSubmissions to fetch.
     */
    orderBy?: CollectionSubmissionOrderByWithRelationInput | CollectionSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CollectionSubmissions.
     */
    cursor?: CollectionSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CollectionSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CollectionSubmissions.
     */
    skip?: number
    distinct?: CollectionSubmissionScalarFieldEnum | CollectionSubmissionScalarFieldEnum[]
  }

  /**
   * CollectionSubmission create
   */
  export type CollectionSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionSubmission
     */
    select?: CollectionSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionSubmission
     */
    omit?: CollectionSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a CollectionSubmission.
     */
    data: XOR<CollectionSubmissionCreateInput, CollectionSubmissionUncheckedCreateInput>
  }

  /**
   * CollectionSubmission createMany
   */
  export type CollectionSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CollectionSubmissions.
     */
    data: CollectionSubmissionCreateManyInput | CollectionSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CollectionSubmission createManyAndReturn
   */
  export type CollectionSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionSubmission
     */
    select?: CollectionSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionSubmission
     */
    omit?: CollectionSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many CollectionSubmissions.
     */
    data: CollectionSubmissionCreateManyInput | CollectionSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionSubmission update
   */
  export type CollectionSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionSubmission
     */
    select?: CollectionSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionSubmission
     */
    omit?: CollectionSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a CollectionSubmission.
     */
    data: XOR<CollectionSubmissionUpdateInput, CollectionSubmissionUncheckedUpdateInput>
    /**
     * Choose, which CollectionSubmission to update.
     */
    where: CollectionSubmissionWhereUniqueInput
  }

  /**
   * CollectionSubmission updateMany
   */
  export type CollectionSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CollectionSubmissions.
     */
    data: XOR<CollectionSubmissionUpdateManyMutationInput, CollectionSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which CollectionSubmissions to update
     */
    where?: CollectionSubmissionWhereInput
    /**
     * Limit how many CollectionSubmissions to update.
     */
    limit?: number
  }

  /**
   * CollectionSubmission updateManyAndReturn
   */
  export type CollectionSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionSubmission
     */
    select?: CollectionSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionSubmission
     */
    omit?: CollectionSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update CollectionSubmissions.
     */
    data: XOR<CollectionSubmissionUpdateManyMutationInput, CollectionSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which CollectionSubmissions to update
     */
    where?: CollectionSubmissionWhereInput
    /**
     * Limit how many CollectionSubmissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionSubmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CollectionSubmission upsert
   */
  export type CollectionSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionSubmission
     */
    select?: CollectionSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionSubmission
     */
    omit?: CollectionSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the CollectionSubmission to update in case it exists.
     */
    where: CollectionSubmissionWhereUniqueInput
    /**
     * In case the CollectionSubmission found by the `where` argument doesn't exist, create a new CollectionSubmission with this data.
     */
    create: XOR<CollectionSubmissionCreateInput, CollectionSubmissionUncheckedCreateInput>
    /**
     * In case the CollectionSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionSubmissionUpdateInput, CollectionSubmissionUncheckedUpdateInput>
  }

  /**
   * CollectionSubmission delete
   */
  export type CollectionSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionSubmission
     */
    select?: CollectionSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionSubmission
     */
    omit?: CollectionSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionSubmissionInclude<ExtArgs> | null
    /**
     * Filter which CollectionSubmission to delete.
     */
    where: CollectionSubmissionWhereUniqueInput
  }

  /**
   * CollectionSubmission deleteMany
   */
  export type CollectionSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CollectionSubmissions to delete
     */
    where?: CollectionSubmissionWhereInput
    /**
     * Limit how many CollectionSubmissions to delete.
     */
    limit?: number
  }

  /**
   * CollectionSubmission without action
   */
  export type CollectionSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionSubmission
     */
    select?: CollectionSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CollectionSubmission
     */
    omit?: CollectionSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model NFTRarity
   */

  export type AggregateNFTRarity = {
    _count: NFTRarityCountAggregateOutputType | null
    _avg: NFTRarityAvgAggregateOutputType | null
    _sum: NFTRaritySumAggregateOutputType | null
    _min: NFTRarityMinAggregateOutputType | null
    _max: NFTRarityMaxAggregateOutputType | null
  }

  export type NFTRarityAvgAggregateOutputType = {
    score: Decimal | null
    rank: number | null
  }

  export type NFTRaritySumAggregateOutputType = {
    score: Decimal | null
    rank: number | null
  }

  export type NFTRarityMinAggregateOutputType = {
    contract: string | null
    tokenId: string | null
    score: Decimal | null
    rank: number | null
    updatedAt: Date | null
  }

  export type NFTRarityMaxAggregateOutputType = {
    contract: string | null
    tokenId: string | null
    score: Decimal | null
    rank: number | null
    updatedAt: Date | null
  }

  export type NFTRarityCountAggregateOutputType = {
    contract: number
    tokenId: number
    score: number
    rank: number
    updatedAt: number
    _all: number
  }


  export type NFTRarityAvgAggregateInputType = {
    score?: true
    rank?: true
  }

  export type NFTRaritySumAggregateInputType = {
    score?: true
    rank?: true
  }

  export type NFTRarityMinAggregateInputType = {
    contract?: true
    tokenId?: true
    score?: true
    rank?: true
    updatedAt?: true
  }

  export type NFTRarityMaxAggregateInputType = {
    contract?: true
    tokenId?: true
    score?: true
    rank?: true
    updatedAt?: true
  }

  export type NFTRarityCountAggregateInputType = {
    contract?: true
    tokenId?: true
    score?: true
    rank?: true
    updatedAt?: true
    _all?: true
  }

  export type NFTRarityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NFTRarity to aggregate.
     */
    where?: NFTRarityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTRarities to fetch.
     */
    orderBy?: NFTRarityOrderByWithRelationInput | NFTRarityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NFTRarityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTRarities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTRarities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NFTRarities
    **/
    _count?: true | NFTRarityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NFTRarityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NFTRaritySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NFTRarityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NFTRarityMaxAggregateInputType
  }

  export type GetNFTRarityAggregateType<T extends NFTRarityAggregateArgs> = {
        [P in keyof T & keyof AggregateNFTRarity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNFTRarity[P]>
      : GetScalarType<T[P], AggregateNFTRarity[P]>
  }




  export type NFTRarityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NFTRarityWhereInput
    orderBy?: NFTRarityOrderByWithAggregationInput | NFTRarityOrderByWithAggregationInput[]
    by: NFTRarityScalarFieldEnum[] | NFTRarityScalarFieldEnum
    having?: NFTRarityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NFTRarityCountAggregateInputType | true
    _avg?: NFTRarityAvgAggregateInputType
    _sum?: NFTRaritySumAggregateInputType
    _min?: NFTRarityMinAggregateInputType
    _max?: NFTRarityMaxAggregateInputType
  }

  export type NFTRarityGroupByOutputType = {
    contract: string
    tokenId: string
    score: Decimal
    rank: number
    updatedAt: Date
    _count: NFTRarityCountAggregateOutputType | null
    _avg: NFTRarityAvgAggregateOutputType | null
    _sum: NFTRaritySumAggregateOutputType | null
    _min: NFTRarityMinAggregateOutputType | null
    _max: NFTRarityMaxAggregateOutputType | null
  }

  type GetNFTRarityGroupByPayload<T extends NFTRarityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NFTRarityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NFTRarityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NFTRarityGroupByOutputType[P]>
            : GetScalarType<T[P], NFTRarityGroupByOutputType[P]>
        }
      >
    >


  export type NFTRaritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contract?: boolean
    tokenId?: boolean
    score?: boolean
    rank?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["nFTRarity"]>

  export type NFTRaritySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contract?: boolean
    tokenId?: boolean
    score?: boolean
    rank?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["nFTRarity"]>

  export type NFTRaritySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contract?: boolean
    tokenId?: boolean
    score?: boolean
    rank?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["nFTRarity"]>

  export type NFTRaritySelectScalar = {
    contract?: boolean
    tokenId?: boolean
    score?: boolean
    rank?: boolean
    updatedAt?: boolean
  }

  export type NFTRarityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"contract" | "tokenId" | "score" | "rank" | "updatedAt", ExtArgs["result"]["nFTRarity"]>

  export type $NFTRarityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NFTRarity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      contract: string
      tokenId: string
      score: Prisma.Decimal
      rank: number
      updatedAt: Date
    }, ExtArgs["result"]["nFTRarity"]>
    composites: {}
  }

  type NFTRarityGetPayload<S extends boolean | null | undefined | NFTRarityDefaultArgs> = $Result.GetResult<Prisma.$NFTRarityPayload, S>

  type NFTRarityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NFTRarityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NFTRarityCountAggregateInputType | true
    }

  export interface NFTRarityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NFTRarity'], meta: { name: 'NFTRarity' } }
    /**
     * Find zero or one NFTRarity that matches the filter.
     * @param {NFTRarityFindUniqueArgs} args - Arguments to find a NFTRarity
     * @example
     * // Get one NFTRarity
     * const nFTRarity = await prisma.nFTRarity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NFTRarityFindUniqueArgs>(args: SelectSubset<T, NFTRarityFindUniqueArgs<ExtArgs>>): Prisma__NFTRarityClient<$Result.GetResult<Prisma.$NFTRarityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NFTRarity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NFTRarityFindUniqueOrThrowArgs} args - Arguments to find a NFTRarity
     * @example
     * // Get one NFTRarity
     * const nFTRarity = await prisma.nFTRarity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NFTRarityFindUniqueOrThrowArgs>(args: SelectSubset<T, NFTRarityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NFTRarityClient<$Result.GetResult<Prisma.$NFTRarityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NFTRarity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTRarityFindFirstArgs} args - Arguments to find a NFTRarity
     * @example
     * // Get one NFTRarity
     * const nFTRarity = await prisma.nFTRarity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NFTRarityFindFirstArgs>(args?: SelectSubset<T, NFTRarityFindFirstArgs<ExtArgs>>): Prisma__NFTRarityClient<$Result.GetResult<Prisma.$NFTRarityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NFTRarity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTRarityFindFirstOrThrowArgs} args - Arguments to find a NFTRarity
     * @example
     * // Get one NFTRarity
     * const nFTRarity = await prisma.nFTRarity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NFTRarityFindFirstOrThrowArgs>(args?: SelectSubset<T, NFTRarityFindFirstOrThrowArgs<ExtArgs>>): Prisma__NFTRarityClient<$Result.GetResult<Prisma.$NFTRarityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NFTRarities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTRarityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NFTRarities
     * const nFTRarities = await prisma.nFTRarity.findMany()
     * 
     * // Get first 10 NFTRarities
     * const nFTRarities = await prisma.nFTRarity.findMany({ take: 10 })
     * 
     * // Only select the `contract`
     * const nFTRarityWithContractOnly = await prisma.nFTRarity.findMany({ select: { contract: true } })
     * 
     */
    findMany<T extends NFTRarityFindManyArgs>(args?: SelectSubset<T, NFTRarityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTRarityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NFTRarity.
     * @param {NFTRarityCreateArgs} args - Arguments to create a NFTRarity.
     * @example
     * // Create one NFTRarity
     * const NFTRarity = await prisma.nFTRarity.create({
     *   data: {
     *     // ... data to create a NFTRarity
     *   }
     * })
     * 
     */
    create<T extends NFTRarityCreateArgs>(args: SelectSubset<T, NFTRarityCreateArgs<ExtArgs>>): Prisma__NFTRarityClient<$Result.GetResult<Prisma.$NFTRarityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NFTRarities.
     * @param {NFTRarityCreateManyArgs} args - Arguments to create many NFTRarities.
     * @example
     * // Create many NFTRarities
     * const nFTRarity = await prisma.nFTRarity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NFTRarityCreateManyArgs>(args?: SelectSubset<T, NFTRarityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NFTRarities and returns the data saved in the database.
     * @param {NFTRarityCreateManyAndReturnArgs} args - Arguments to create many NFTRarities.
     * @example
     * // Create many NFTRarities
     * const nFTRarity = await prisma.nFTRarity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NFTRarities and only return the `contract`
     * const nFTRarityWithContractOnly = await prisma.nFTRarity.createManyAndReturn({
     *   select: { contract: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NFTRarityCreateManyAndReturnArgs>(args?: SelectSubset<T, NFTRarityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTRarityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NFTRarity.
     * @param {NFTRarityDeleteArgs} args - Arguments to delete one NFTRarity.
     * @example
     * // Delete one NFTRarity
     * const NFTRarity = await prisma.nFTRarity.delete({
     *   where: {
     *     // ... filter to delete one NFTRarity
     *   }
     * })
     * 
     */
    delete<T extends NFTRarityDeleteArgs>(args: SelectSubset<T, NFTRarityDeleteArgs<ExtArgs>>): Prisma__NFTRarityClient<$Result.GetResult<Prisma.$NFTRarityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NFTRarity.
     * @param {NFTRarityUpdateArgs} args - Arguments to update one NFTRarity.
     * @example
     * // Update one NFTRarity
     * const nFTRarity = await prisma.nFTRarity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NFTRarityUpdateArgs>(args: SelectSubset<T, NFTRarityUpdateArgs<ExtArgs>>): Prisma__NFTRarityClient<$Result.GetResult<Prisma.$NFTRarityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NFTRarities.
     * @param {NFTRarityDeleteManyArgs} args - Arguments to filter NFTRarities to delete.
     * @example
     * // Delete a few NFTRarities
     * const { count } = await prisma.nFTRarity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NFTRarityDeleteManyArgs>(args?: SelectSubset<T, NFTRarityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NFTRarities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTRarityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NFTRarities
     * const nFTRarity = await prisma.nFTRarity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NFTRarityUpdateManyArgs>(args: SelectSubset<T, NFTRarityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NFTRarities and returns the data updated in the database.
     * @param {NFTRarityUpdateManyAndReturnArgs} args - Arguments to update many NFTRarities.
     * @example
     * // Update many NFTRarities
     * const nFTRarity = await prisma.nFTRarity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NFTRarities and only return the `contract`
     * const nFTRarityWithContractOnly = await prisma.nFTRarity.updateManyAndReturn({
     *   select: { contract: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NFTRarityUpdateManyAndReturnArgs>(args: SelectSubset<T, NFTRarityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NFTRarityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NFTRarity.
     * @param {NFTRarityUpsertArgs} args - Arguments to update or create a NFTRarity.
     * @example
     * // Update or create a NFTRarity
     * const nFTRarity = await prisma.nFTRarity.upsert({
     *   create: {
     *     // ... data to create a NFTRarity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NFTRarity we want to update
     *   }
     * })
     */
    upsert<T extends NFTRarityUpsertArgs>(args: SelectSubset<T, NFTRarityUpsertArgs<ExtArgs>>): Prisma__NFTRarityClient<$Result.GetResult<Prisma.$NFTRarityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NFTRarities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTRarityCountArgs} args - Arguments to filter NFTRarities to count.
     * @example
     * // Count the number of NFTRarities
     * const count = await prisma.nFTRarity.count({
     *   where: {
     *     // ... the filter for the NFTRarities we want to count
     *   }
     * })
    **/
    count<T extends NFTRarityCountArgs>(
      args?: Subset<T, NFTRarityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NFTRarityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NFTRarity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTRarityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NFTRarityAggregateArgs>(args: Subset<T, NFTRarityAggregateArgs>): Prisma.PrismaPromise<GetNFTRarityAggregateType<T>>

    /**
     * Group by NFTRarity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NFTRarityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NFTRarityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NFTRarityGroupByArgs['orderBy'] }
        : { orderBy?: NFTRarityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NFTRarityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNFTRarityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NFTRarity model
   */
  readonly fields: NFTRarityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NFTRarity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NFTRarityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NFTRarity model
   */
  interface NFTRarityFieldRefs {
    readonly contract: FieldRef<"NFTRarity", 'String'>
    readonly tokenId: FieldRef<"NFTRarity", 'String'>
    readonly score: FieldRef<"NFTRarity", 'Decimal'>
    readonly rank: FieldRef<"NFTRarity", 'Int'>
    readonly updatedAt: FieldRef<"NFTRarity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NFTRarity findUnique
   */
  export type NFTRarityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTRarity
     */
    select?: NFTRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTRarity
     */
    omit?: NFTRarityOmit<ExtArgs> | null
    /**
     * Filter, which NFTRarity to fetch.
     */
    where: NFTRarityWhereUniqueInput
  }

  /**
   * NFTRarity findUniqueOrThrow
   */
  export type NFTRarityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTRarity
     */
    select?: NFTRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTRarity
     */
    omit?: NFTRarityOmit<ExtArgs> | null
    /**
     * Filter, which NFTRarity to fetch.
     */
    where: NFTRarityWhereUniqueInput
  }

  /**
   * NFTRarity findFirst
   */
  export type NFTRarityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTRarity
     */
    select?: NFTRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTRarity
     */
    omit?: NFTRarityOmit<ExtArgs> | null
    /**
     * Filter, which NFTRarity to fetch.
     */
    where?: NFTRarityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTRarities to fetch.
     */
    orderBy?: NFTRarityOrderByWithRelationInput | NFTRarityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NFTRarities.
     */
    cursor?: NFTRarityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTRarities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTRarities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NFTRarities.
     */
    distinct?: NFTRarityScalarFieldEnum | NFTRarityScalarFieldEnum[]
  }

  /**
   * NFTRarity findFirstOrThrow
   */
  export type NFTRarityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTRarity
     */
    select?: NFTRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTRarity
     */
    omit?: NFTRarityOmit<ExtArgs> | null
    /**
     * Filter, which NFTRarity to fetch.
     */
    where?: NFTRarityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTRarities to fetch.
     */
    orderBy?: NFTRarityOrderByWithRelationInput | NFTRarityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NFTRarities.
     */
    cursor?: NFTRarityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTRarities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTRarities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NFTRarities.
     */
    distinct?: NFTRarityScalarFieldEnum | NFTRarityScalarFieldEnum[]
  }

  /**
   * NFTRarity findMany
   */
  export type NFTRarityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTRarity
     */
    select?: NFTRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTRarity
     */
    omit?: NFTRarityOmit<ExtArgs> | null
    /**
     * Filter, which NFTRarities to fetch.
     */
    where?: NFTRarityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NFTRarities to fetch.
     */
    orderBy?: NFTRarityOrderByWithRelationInput | NFTRarityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NFTRarities.
     */
    cursor?: NFTRarityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NFTRarities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NFTRarities.
     */
    skip?: number
    distinct?: NFTRarityScalarFieldEnum | NFTRarityScalarFieldEnum[]
  }

  /**
   * NFTRarity create
   */
  export type NFTRarityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTRarity
     */
    select?: NFTRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTRarity
     */
    omit?: NFTRarityOmit<ExtArgs> | null
    /**
     * The data needed to create a NFTRarity.
     */
    data: XOR<NFTRarityCreateInput, NFTRarityUncheckedCreateInput>
  }

  /**
   * NFTRarity createMany
   */
  export type NFTRarityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NFTRarities.
     */
    data: NFTRarityCreateManyInput | NFTRarityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NFTRarity createManyAndReturn
   */
  export type NFTRarityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTRarity
     */
    select?: NFTRaritySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NFTRarity
     */
    omit?: NFTRarityOmit<ExtArgs> | null
    /**
     * The data used to create many NFTRarities.
     */
    data: NFTRarityCreateManyInput | NFTRarityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NFTRarity update
   */
  export type NFTRarityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTRarity
     */
    select?: NFTRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTRarity
     */
    omit?: NFTRarityOmit<ExtArgs> | null
    /**
     * The data needed to update a NFTRarity.
     */
    data: XOR<NFTRarityUpdateInput, NFTRarityUncheckedUpdateInput>
    /**
     * Choose, which NFTRarity to update.
     */
    where: NFTRarityWhereUniqueInput
  }

  /**
   * NFTRarity updateMany
   */
  export type NFTRarityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NFTRarities.
     */
    data: XOR<NFTRarityUpdateManyMutationInput, NFTRarityUncheckedUpdateManyInput>
    /**
     * Filter which NFTRarities to update
     */
    where?: NFTRarityWhereInput
    /**
     * Limit how many NFTRarities to update.
     */
    limit?: number
  }

  /**
   * NFTRarity updateManyAndReturn
   */
  export type NFTRarityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTRarity
     */
    select?: NFTRaritySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NFTRarity
     */
    omit?: NFTRarityOmit<ExtArgs> | null
    /**
     * The data used to update NFTRarities.
     */
    data: XOR<NFTRarityUpdateManyMutationInput, NFTRarityUncheckedUpdateManyInput>
    /**
     * Filter which NFTRarities to update
     */
    where?: NFTRarityWhereInput
    /**
     * Limit how many NFTRarities to update.
     */
    limit?: number
  }

  /**
   * NFTRarity upsert
   */
  export type NFTRarityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTRarity
     */
    select?: NFTRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTRarity
     */
    omit?: NFTRarityOmit<ExtArgs> | null
    /**
     * The filter to search for the NFTRarity to update in case it exists.
     */
    where: NFTRarityWhereUniqueInput
    /**
     * In case the NFTRarity found by the `where` argument doesn't exist, create a new NFTRarity with this data.
     */
    create: XOR<NFTRarityCreateInput, NFTRarityUncheckedCreateInput>
    /**
     * In case the NFTRarity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NFTRarityUpdateInput, NFTRarityUncheckedUpdateInput>
  }

  /**
   * NFTRarity delete
   */
  export type NFTRarityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTRarity
     */
    select?: NFTRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTRarity
     */
    omit?: NFTRarityOmit<ExtArgs> | null
    /**
     * Filter which NFTRarity to delete.
     */
    where: NFTRarityWhereUniqueInput
  }

  /**
   * NFTRarity deleteMany
   */
  export type NFTRarityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NFTRarities to delete
     */
    where?: NFTRarityWhereInput
    /**
     * Limit how many NFTRarities to delete.
     */
    limit?: number
  }

  /**
   * NFTRarity without action
   */
  export type NFTRarityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NFTRarity
     */
    select?: NFTRaritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NFTRarity
     */
    omit?: NFTRarityOmit<ExtArgs> | null
  }


  /**
   * Model HolderReward
   */

  export type AggregateHolderReward = {
    _count: HolderRewardCountAggregateOutputType | null
    _avg: HolderRewardAvgAggregateOutputType | null
    _sum: HolderRewardSumAggregateOutputType | null
    _min: HolderRewardMinAggregateOutputType | null
    _max: HolderRewardMaxAggregateOutputType | null
  }

  export type HolderRewardAvgAggregateOutputType = {
    last_acc_per_token: Decimal | null
    claimed_etn: Decimal | null
  }

  export type HolderRewardSumAggregateOutputType = {
    last_acc_per_token: Decimal | null
    claimed_etn: Decimal | null
  }

  export type HolderRewardMinAggregateOutputType = {
    user_id: string | null
    wallet_address: string | null
    last_acc_per_token: Decimal | null
    claimed_etn: Decimal | null
    updated_at: Date | null
  }

  export type HolderRewardMaxAggregateOutputType = {
    user_id: string | null
    wallet_address: string | null
    last_acc_per_token: Decimal | null
    claimed_etn: Decimal | null
    updated_at: Date | null
  }

  export type HolderRewardCountAggregateOutputType = {
    user_id: number
    wallet_address: number
    last_acc_per_token: number
    claimed_etn: number
    updated_at: number
    _all: number
  }


  export type HolderRewardAvgAggregateInputType = {
    last_acc_per_token?: true
    claimed_etn?: true
  }

  export type HolderRewardSumAggregateInputType = {
    last_acc_per_token?: true
    claimed_etn?: true
  }

  export type HolderRewardMinAggregateInputType = {
    user_id?: true
    wallet_address?: true
    last_acc_per_token?: true
    claimed_etn?: true
    updated_at?: true
  }

  export type HolderRewardMaxAggregateInputType = {
    user_id?: true
    wallet_address?: true
    last_acc_per_token?: true
    claimed_etn?: true
    updated_at?: true
  }

  export type HolderRewardCountAggregateInputType = {
    user_id?: true
    wallet_address?: true
    last_acc_per_token?: true
    claimed_etn?: true
    updated_at?: true
    _all?: true
  }

  export type HolderRewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HolderReward to aggregate.
     */
    where?: HolderRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HolderRewards to fetch.
     */
    orderBy?: HolderRewardOrderByWithRelationInput | HolderRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HolderRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HolderRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HolderRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HolderRewards
    **/
    _count?: true | HolderRewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HolderRewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HolderRewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HolderRewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HolderRewardMaxAggregateInputType
  }

  export type GetHolderRewardAggregateType<T extends HolderRewardAggregateArgs> = {
        [P in keyof T & keyof AggregateHolderReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHolderReward[P]>
      : GetScalarType<T[P], AggregateHolderReward[P]>
  }




  export type HolderRewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HolderRewardWhereInput
    orderBy?: HolderRewardOrderByWithAggregationInput | HolderRewardOrderByWithAggregationInput[]
    by: HolderRewardScalarFieldEnum[] | HolderRewardScalarFieldEnum
    having?: HolderRewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HolderRewardCountAggregateInputType | true
    _avg?: HolderRewardAvgAggregateInputType
    _sum?: HolderRewardSumAggregateInputType
    _min?: HolderRewardMinAggregateInputType
    _max?: HolderRewardMaxAggregateInputType
  }

  export type HolderRewardGroupByOutputType = {
    user_id: string
    wallet_address: string | null
    last_acc_per_token: Decimal
    claimed_etn: Decimal
    updated_at: Date
    _count: HolderRewardCountAggregateOutputType | null
    _avg: HolderRewardAvgAggregateOutputType | null
    _sum: HolderRewardSumAggregateOutputType | null
    _min: HolderRewardMinAggregateOutputType | null
    _max: HolderRewardMaxAggregateOutputType | null
  }

  type GetHolderRewardGroupByPayload<T extends HolderRewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HolderRewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HolderRewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HolderRewardGroupByOutputType[P]>
            : GetScalarType<T[P], HolderRewardGroupByOutputType[P]>
        }
      >
    >


  export type HolderRewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    wallet_address?: boolean
    last_acc_per_token?: boolean
    claimed_etn?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["holderReward"]>

  export type HolderRewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    wallet_address?: boolean
    last_acc_per_token?: boolean
    claimed_etn?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["holderReward"]>

  export type HolderRewardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    wallet_address?: boolean
    last_acc_per_token?: boolean
    claimed_etn?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["holderReward"]>

  export type HolderRewardSelectScalar = {
    user_id?: boolean
    wallet_address?: boolean
    last_acc_per_token?: boolean
    claimed_etn?: boolean
    updated_at?: boolean
  }

  export type HolderRewardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "wallet_address" | "last_acc_per_token" | "claimed_etn" | "updated_at", ExtArgs["result"]["holderReward"]>

  export type $HolderRewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HolderReward"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      wallet_address: string | null
      last_acc_per_token: Prisma.Decimal
      claimed_etn: Prisma.Decimal
      updated_at: Date
    }, ExtArgs["result"]["holderReward"]>
    composites: {}
  }

  type HolderRewardGetPayload<S extends boolean | null | undefined | HolderRewardDefaultArgs> = $Result.GetResult<Prisma.$HolderRewardPayload, S>

  type HolderRewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HolderRewardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HolderRewardCountAggregateInputType | true
    }

  export interface HolderRewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HolderReward'], meta: { name: 'HolderReward' } }
    /**
     * Find zero or one HolderReward that matches the filter.
     * @param {HolderRewardFindUniqueArgs} args - Arguments to find a HolderReward
     * @example
     * // Get one HolderReward
     * const holderReward = await prisma.holderReward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HolderRewardFindUniqueArgs>(args: SelectSubset<T, HolderRewardFindUniqueArgs<ExtArgs>>): Prisma__HolderRewardClient<$Result.GetResult<Prisma.$HolderRewardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HolderReward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HolderRewardFindUniqueOrThrowArgs} args - Arguments to find a HolderReward
     * @example
     * // Get one HolderReward
     * const holderReward = await prisma.holderReward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HolderRewardFindUniqueOrThrowArgs>(args: SelectSubset<T, HolderRewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HolderRewardClient<$Result.GetResult<Prisma.$HolderRewardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HolderReward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolderRewardFindFirstArgs} args - Arguments to find a HolderReward
     * @example
     * // Get one HolderReward
     * const holderReward = await prisma.holderReward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HolderRewardFindFirstArgs>(args?: SelectSubset<T, HolderRewardFindFirstArgs<ExtArgs>>): Prisma__HolderRewardClient<$Result.GetResult<Prisma.$HolderRewardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HolderReward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolderRewardFindFirstOrThrowArgs} args - Arguments to find a HolderReward
     * @example
     * // Get one HolderReward
     * const holderReward = await prisma.holderReward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HolderRewardFindFirstOrThrowArgs>(args?: SelectSubset<T, HolderRewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__HolderRewardClient<$Result.GetResult<Prisma.$HolderRewardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HolderRewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolderRewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HolderRewards
     * const holderRewards = await prisma.holderReward.findMany()
     * 
     * // Get first 10 HolderRewards
     * const holderRewards = await prisma.holderReward.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const holderRewardWithUser_idOnly = await prisma.holderReward.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends HolderRewardFindManyArgs>(args?: SelectSubset<T, HolderRewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolderRewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HolderReward.
     * @param {HolderRewardCreateArgs} args - Arguments to create a HolderReward.
     * @example
     * // Create one HolderReward
     * const HolderReward = await prisma.holderReward.create({
     *   data: {
     *     // ... data to create a HolderReward
     *   }
     * })
     * 
     */
    create<T extends HolderRewardCreateArgs>(args: SelectSubset<T, HolderRewardCreateArgs<ExtArgs>>): Prisma__HolderRewardClient<$Result.GetResult<Prisma.$HolderRewardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HolderRewards.
     * @param {HolderRewardCreateManyArgs} args - Arguments to create many HolderRewards.
     * @example
     * // Create many HolderRewards
     * const holderReward = await prisma.holderReward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HolderRewardCreateManyArgs>(args?: SelectSubset<T, HolderRewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HolderRewards and returns the data saved in the database.
     * @param {HolderRewardCreateManyAndReturnArgs} args - Arguments to create many HolderRewards.
     * @example
     * // Create many HolderRewards
     * const holderReward = await prisma.holderReward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HolderRewards and only return the `user_id`
     * const holderRewardWithUser_idOnly = await prisma.holderReward.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HolderRewardCreateManyAndReturnArgs>(args?: SelectSubset<T, HolderRewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolderRewardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HolderReward.
     * @param {HolderRewardDeleteArgs} args - Arguments to delete one HolderReward.
     * @example
     * // Delete one HolderReward
     * const HolderReward = await prisma.holderReward.delete({
     *   where: {
     *     // ... filter to delete one HolderReward
     *   }
     * })
     * 
     */
    delete<T extends HolderRewardDeleteArgs>(args: SelectSubset<T, HolderRewardDeleteArgs<ExtArgs>>): Prisma__HolderRewardClient<$Result.GetResult<Prisma.$HolderRewardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HolderReward.
     * @param {HolderRewardUpdateArgs} args - Arguments to update one HolderReward.
     * @example
     * // Update one HolderReward
     * const holderReward = await prisma.holderReward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HolderRewardUpdateArgs>(args: SelectSubset<T, HolderRewardUpdateArgs<ExtArgs>>): Prisma__HolderRewardClient<$Result.GetResult<Prisma.$HolderRewardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HolderRewards.
     * @param {HolderRewardDeleteManyArgs} args - Arguments to filter HolderRewards to delete.
     * @example
     * // Delete a few HolderRewards
     * const { count } = await prisma.holderReward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HolderRewardDeleteManyArgs>(args?: SelectSubset<T, HolderRewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HolderRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolderRewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HolderRewards
     * const holderReward = await prisma.holderReward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HolderRewardUpdateManyArgs>(args: SelectSubset<T, HolderRewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HolderRewards and returns the data updated in the database.
     * @param {HolderRewardUpdateManyAndReturnArgs} args - Arguments to update many HolderRewards.
     * @example
     * // Update many HolderRewards
     * const holderReward = await prisma.holderReward.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HolderRewards and only return the `user_id`
     * const holderRewardWithUser_idOnly = await prisma.holderReward.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HolderRewardUpdateManyAndReturnArgs>(args: SelectSubset<T, HolderRewardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolderRewardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HolderReward.
     * @param {HolderRewardUpsertArgs} args - Arguments to update or create a HolderReward.
     * @example
     * // Update or create a HolderReward
     * const holderReward = await prisma.holderReward.upsert({
     *   create: {
     *     // ... data to create a HolderReward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HolderReward we want to update
     *   }
     * })
     */
    upsert<T extends HolderRewardUpsertArgs>(args: SelectSubset<T, HolderRewardUpsertArgs<ExtArgs>>): Prisma__HolderRewardClient<$Result.GetResult<Prisma.$HolderRewardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HolderRewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolderRewardCountArgs} args - Arguments to filter HolderRewards to count.
     * @example
     * // Count the number of HolderRewards
     * const count = await prisma.holderReward.count({
     *   where: {
     *     // ... the filter for the HolderRewards we want to count
     *   }
     * })
    **/
    count<T extends HolderRewardCountArgs>(
      args?: Subset<T, HolderRewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HolderRewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HolderReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolderRewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HolderRewardAggregateArgs>(args: Subset<T, HolderRewardAggregateArgs>): Prisma.PrismaPromise<GetHolderRewardAggregateType<T>>

    /**
     * Group by HolderReward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolderRewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HolderRewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HolderRewardGroupByArgs['orderBy'] }
        : { orderBy?: HolderRewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HolderRewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHolderRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HolderReward model
   */
  readonly fields: HolderRewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HolderReward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HolderRewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HolderReward model
   */
  interface HolderRewardFieldRefs {
    readonly user_id: FieldRef<"HolderReward", 'String'>
    readonly wallet_address: FieldRef<"HolderReward", 'String'>
    readonly last_acc_per_token: FieldRef<"HolderReward", 'Decimal'>
    readonly claimed_etn: FieldRef<"HolderReward", 'Decimal'>
    readonly updated_at: FieldRef<"HolderReward", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HolderReward findUnique
   */
  export type HolderRewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderReward
     */
    select?: HolderRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderReward
     */
    omit?: HolderRewardOmit<ExtArgs> | null
    /**
     * Filter, which HolderReward to fetch.
     */
    where: HolderRewardWhereUniqueInput
  }

  /**
   * HolderReward findUniqueOrThrow
   */
  export type HolderRewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderReward
     */
    select?: HolderRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderReward
     */
    omit?: HolderRewardOmit<ExtArgs> | null
    /**
     * Filter, which HolderReward to fetch.
     */
    where: HolderRewardWhereUniqueInput
  }

  /**
   * HolderReward findFirst
   */
  export type HolderRewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderReward
     */
    select?: HolderRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderReward
     */
    omit?: HolderRewardOmit<ExtArgs> | null
    /**
     * Filter, which HolderReward to fetch.
     */
    where?: HolderRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HolderRewards to fetch.
     */
    orderBy?: HolderRewardOrderByWithRelationInput | HolderRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HolderRewards.
     */
    cursor?: HolderRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HolderRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HolderRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HolderRewards.
     */
    distinct?: HolderRewardScalarFieldEnum | HolderRewardScalarFieldEnum[]
  }

  /**
   * HolderReward findFirstOrThrow
   */
  export type HolderRewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderReward
     */
    select?: HolderRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderReward
     */
    omit?: HolderRewardOmit<ExtArgs> | null
    /**
     * Filter, which HolderReward to fetch.
     */
    where?: HolderRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HolderRewards to fetch.
     */
    orderBy?: HolderRewardOrderByWithRelationInput | HolderRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HolderRewards.
     */
    cursor?: HolderRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HolderRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HolderRewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HolderRewards.
     */
    distinct?: HolderRewardScalarFieldEnum | HolderRewardScalarFieldEnum[]
  }

  /**
   * HolderReward findMany
   */
  export type HolderRewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderReward
     */
    select?: HolderRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderReward
     */
    omit?: HolderRewardOmit<ExtArgs> | null
    /**
     * Filter, which HolderRewards to fetch.
     */
    where?: HolderRewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HolderRewards to fetch.
     */
    orderBy?: HolderRewardOrderByWithRelationInput | HolderRewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HolderRewards.
     */
    cursor?: HolderRewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HolderRewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HolderRewards.
     */
    skip?: number
    distinct?: HolderRewardScalarFieldEnum | HolderRewardScalarFieldEnum[]
  }

  /**
   * HolderReward create
   */
  export type HolderRewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderReward
     */
    select?: HolderRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderReward
     */
    omit?: HolderRewardOmit<ExtArgs> | null
    /**
     * The data needed to create a HolderReward.
     */
    data: XOR<HolderRewardCreateInput, HolderRewardUncheckedCreateInput>
  }

  /**
   * HolderReward createMany
   */
  export type HolderRewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HolderRewards.
     */
    data: HolderRewardCreateManyInput | HolderRewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HolderReward createManyAndReturn
   */
  export type HolderRewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderReward
     */
    select?: HolderRewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HolderReward
     */
    omit?: HolderRewardOmit<ExtArgs> | null
    /**
     * The data used to create many HolderRewards.
     */
    data: HolderRewardCreateManyInput | HolderRewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HolderReward update
   */
  export type HolderRewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderReward
     */
    select?: HolderRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderReward
     */
    omit?: HolderRewardOmit<ExtArgs> | null
    /**
     * The data needed to update a HolderReward.
     */
    data: XOR<HolderRewardUpdateInput, HolderRewardUncheckedUpdateInput>
    /**
     * Choose, which HolderReward to update.
     */
    where: HolderRewardWhereUniqueInput
  }

  /**
   * HolderReward updateMany
   */
  export type HolderRewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HolderRewards.
     */
    data: XOR<HolderRewardUpdateManyMutationInput, HolderRewardUncheckedUpdateManyInput>
    /**
     * Filter which HolderRewards to update
     */
    where?: HolderRewardWhereInput
    /**
     * Limit how many HolderRewards to update.
     */
    limit?: number
  }

  /**
   * HolderReward updateManyAndReturn
   */
  export type HolderRewardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderReward
     */
    select?: HolderRewardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HolderReward
     */
    omit?: HolderRewardOmit<ExtArgs> | null
    /**
     * The data used to update HolderRewards.
     */
    data: XOR<HolderRewardUpdateManyMutationInput, HolderRewardUncheckedUpdateManyInput>
    /**
     * Filter which HolderRewards to update
     */
    where?: HolderRewardWhereInput
    /**
     * Limit how many HolderRewards to update.
     */
    limit?: number
  }

  /**
   * HolderReward upsert
   */
  export type HolderRewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderReward
     */
    select?: HolderRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderReward
     */
    omit?: HolderRewardOmit<ExtArgs> | null
    /**
     * The filter to search for the HolderReward to update in case it exists.
     */
    where: HolderRewardWhereUniqueInput
    /**
     * In case the HolderReward found by the `where` argument doesn't exist, create a new HolderReward with this data.
     */
    create: XOR<HolderRewardCreateInput, HolderRewardUncheckedCreateInput>
    /**
     * In case the HolderReward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HolderRewardUpdateInput, HolderRewardUncheckedUpdateInput>
  }

  /**
   * HolderReward delete
   */
  export type HolderRewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderReward
     */
    select?: HolderRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderReward
     */
    omit?: HolderRewardOmit<ExtArgs> | null
    /**
     * Filter which HolderReward to delete.
     */
    where: HolderRewardWhereUniqueInput
  }

  /**
   * HolderReward deleteMany
   */
  export type HolderRewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HolderRewards to delete
     */
    where?: HolderRewardWhereInput
    /**
     * Limit how many HolderRewards to delete.
     */
    limit?: number
  }

  /**
   * HolderReward without action
   */
  export type HolderRewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderReward
     */
    select?: HolderRewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderReward
     */
    omit?: HolderRewardOmit<ExtArgs> | null
  }


  /**
   * Model RewardAccumulator
   */

  export type AggregateRewardAccumulator = {
    _count: RewardAccumulatorCountAggregateOutputType | null
    _avg: RewardAccumulatorAvgAggregateOutputType | null
    _sum: RewardAccumulatorSumAggregateOutputType | null
    _min: RewardAccumulatorMinAggregateOutputType | null
    _max: RewardAccumulatorMaxAggregateOutputType | null
  }

  export type RewardAccumulatorAvgAggregateOutputType = {
    acc_per_token: Decimal | null
  }

  export type RewardAccumulatorSumAggregateOutputType = {
    acc_per_token: Decimal | null
  }

  export type RewardAccumulatorMinAggregateOutputType = {
    id: string | null
    acc_per_token: Decimal | null
    updated_at: Date | null
  }

  export type RewardAccumulatorMaxAggregateOutputType = {
    id: string | null
    acc_per_token: Decimal | null
    updated_at: Date | null
  }

  export type RewardAccumulatorCountAggregateOutputType = {
    id: number
    acc_per_token: number
    updated_at: number
    _all: number
  }


  export type RewardAccumulatorAvgAggregateInputType = {
    acc_per_token?: true
  }

  export type RewardAccumulatorSumAggregateInputType = {
    acc_per_token?: true
  }

  export type RewardAccumulatorMinAggregateInputType = {
    id?: true
    acc_per_token?: true
    updated_at?: true
  }

  export type RewardAccumulatorMaxAggregateInputType = {
    id?: true
    acc_per_token?: true
    updated_at?: true
  }

  export type RewardAccumulatorCountAggregateInputType = {
    id?: true
    acc_per_token?: true
    updated_at?: true
    _all?: true
  }

  export type RewardAccumulatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardAccumulator to aggregate.
     */
    where?: RewardAccumulatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardAccumulators to fetch.
     */
    orderBy?: RewardAccumulatorOrderByWithRelationInput | RewardAccumulatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardAccumulatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardAccumulators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardAccumulators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardAccumulators
    **/
    _count?: true | RewardAccumulatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardAccumulatorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardAccumulatorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardAccumulatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardAccumulatorMaxAggregateInputType
  }

  export type GetRewardAccumulatorAggregateType<T extends RewardAccumulatorAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardAccumulator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardAccumulator[P]>
      : GetScalarType<T[P], AggregateRewardAccumulator[P]>
  }




  export type RewardAccumulatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardAccumulatorWhereInput
    orderBy?: RewardAccumulatorOrderByWithAggregationInput | RewardAccumulatorOrderByWithAggregationInput[]
    by: RewardAccumulatorScalarFieldEnum[] | RewardAccumulatorScalarFieldEnum
    having?: RewardAccumulatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardAccumulatorCountAggregateInputType | true
    _avg?: RewardAccumulatorAvgAggregateInputType
    _sum?: RewardAccumulatorSumAggregateInputType
    _min?: RewardAccumulatorMinAggregateInputType
    _max?: RewardAccumulatorMaxAggregateInputType
  }

  export type RewardAccumulatorGroupByOutputType = {
    id: string
    acc_per_token: Decimal
    updated_at: Date
    _count: RewardAccumulatorCountAggregateOutputType | null
    _avg: RewardAccumulatorAvgAggregateOutputType | null
    _sum: RewardAccumulatorSumAggregateOutputType | null
    _min: RewardAccumulatorMinAggregateOutputType | null
    _max: RewardAccumulatorMaxAggregateOutputType | null
  }

  type GetRewardAccumulatorGroupByPayload<T extends RewardAccumulatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardAccumulatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardAccumulatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardAccumulatorGroupByOutputType[P]>
            : GetScalarType<T[P], RewardAccumulatorGroupByOutputType[P]>
        }
      >
    >


  export type RewardAccumulatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acc_per_token?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["rewardAccumulator"]>

  export type RewardAccumulatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acc_per_token?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["rewardAccumulator"]>

  export type RewardAccumulatorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acc_per_token?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["rewardAccumulator"]>

  export type RewardAccumulatorSelectScalar = {
    id?: boolean
    acc_per_token?: boolean
    updated_at?: boolean
  }

  export type RewardAccumulatorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "acc_per_token" | "updated_at", ExtArgs["result"]["rewardAccumulator"]>

  export type $RewardAccumulatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RewardAccumulator"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      acc_per_token: Prisma.Decimal
      updated_at: Date
    }, ExtArgs["result"]["rewardAccumulator"]>
    composites: {}
  }

  type RewardAccumulatorGetPayload<S extends boolean | null | undefined | RewardAccumulatorDefaultArgs> = $Result.GetResult<Prisma.$RewardAccumulatorPayload, S>

  type RewardAccumulatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RewardAccumulatorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardAccumulatorCountAggregateInputType | true
    }

  export interface RewardAccumulatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RewardAccumulator'], meta: { name: 'RewardAccumulator' } }
    /**
     * Find zero or one RewardAccumulator that matches the filter.
     * @param {RewardAccumulatorFindUniqueArgs} args - Arguments to find a RewardAccumulator
     * @example
     * // Get one RewardAccumulator
     * const rewardAccumulator = await prisma.rewardAccumulator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardAccumulatorFindUniqueArgs>(args: SelectSubset<T, RewardAccumulatorFindUniqueArgs<ExtArgs>>): Prisma__RewardAccumulatorClient<$Result.GetResult<Prisma.$RewardAccumulatorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RewardAccumulator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardAccumulatorFindUniqueOrThrowArgs} args - Arguments to find a RewardAccumulator
     * @example
     * // Get one RewardAccumulator
     * const rewardAccumulator = await prisma.rewardAccumulator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardAccumulatorFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardAccumulatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardAccumulatorClient<$Result.GetResult<Prisma.$RewardAccumulatorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardAccumulator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccumulatorFindFirstArgs} args - Arguments to find a RewardAccumulator
     * @example
     * // Get one RewardAccumulator
     * const rewardAccumulator = await prisma.rewardAccumulator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardAccumulatorFindFirstArgs>(args?: SelectSubset<T, RewardAccumulatorFindFirstArgs<ExtArgs>>): Prisma__RewardAccumulatorClient<$Result.GetResult<Prisma.$RewardAccumulatorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardAccumulator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccumulatorFindFirstOrThrowArgs} args - Arguments to find a RewardAccumulator
     * @example
     * // Get one RewardAccumulator
     * const rewardAccumulator = await prisma.rewardAccumulator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardAccumulatorFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardAccumulatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardAccumulatorClient<$Result.GetResult<Prisma.$RewardAccumulatorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RewardAccumulators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccumulatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardAccumulators
     * const rewardAccumulators = await prisma.rewardAccumulator.findMany()
     * 
     * // Get first 10 RewardAccumulators
     * const rewardAccumulators = await prisma.rewardAccumulator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardAccumulatorWithIdOnly = await prisma.rewardAccumulator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardAccumulatorFindManyArgs>(args?: SelectSubset<T, RewardAccumulatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardAccumulatorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RewardAccumulator.
     * @param {RewardAccumulatorCreateArgs} args - Arguments to create a RewardAccumulator.
     * @example
     * // Create one RewardAccumulator
     * const RewardAccumulator = await prisma.rewardAccumulator.create({
     *   data: {
     *     // ... data to create a RewardAccumulator
     *   }
     * })
     * 
     */
    create<T extends RewardAccumulatorCreateArgs>(args: SelectSubset<T, RewardAccumulatorCreateArgs<ExtArgs>>): Prisma__RewardAccumulatorClient<$Result.GetResult<Prisma.$RewardAccumulatorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RewardAccumulators.
     * @param {RewardAccumulatorCreateManyArgs} args - Arguments to create many RewardAccumulators.
     * @example
     * // Create many RewardAccumulators
     * const rewardAccumulator = await prisma.rewardAccumulator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardAccumulatorCreateManyArgs>(args?: SelectSubset<T, RewardAccumulatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RewardAccumulators and returns the data saved in the database.
     * @param {RewardAccumulatorCreateManyAndReturnArgs} args - Arguments to create many RewardAccumulators.
     * @example
     * // Create many RewardAccumulators
     * const rewardAccumulator = await prisma.rewardAccumulator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RewardAccumulators and only return the `id`
     * const rewardAccumulatorWithIdOnly = await prisma.rewardAccumulator.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardAccumulatorCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardAccumulatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardAccumulatorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RewardAccumulator.
     * @param {RewardAccumulatorDeleteArgs} args - Arguments to delete one RewardAccumulator.
     * @example
     * // Delete one RewardAccumulator
     * const RewardAccumulator = await prisma.rewardAccumulator.delete({
     *   where: {
     *     // ... filter to delete one RewardAccumulator
     *   }
     * })
     * 
     */
    delete<T extends RewardAccumulatorDeleteArgs>(args: SelectSubset<T, RewardAccumulatorDeleteArgs<ExtArgs>>): Prisma__RewardAccumulatorClient<$Result.GetResult<Prisma.$RewardAccumulatorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RewardAccumulator.
     * @param {RewardAccumulatorUpdateArgs} args - Arguments to update one RewardAccumulator.
     * @example
     * // Update one RewardAccumulator
     * const rewardAccumulator = await prisma.rewardAccumulator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardAccumulatorUpdateArgs>(args: SelectSubset<T, RewardAccumulatorUpdateArgs<ExtArgs>>): Prisma__RewardAccumulatorClient<$Result.GetResult<Prisma.$RewardAccumulatorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RewardAccumulators.
     * @param {RewardAccumulatorDeleteManyArgs} args - Arguments to filter RewardAccumulators to delete.
     * @example
     * // Delete a few RewardAccumulators
     * const { count } = await prisma.rewardAccumulator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardAccumulatorDeleteManyArgs>(args?: SelectSubset<T, RewardAccumulatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardAccumulators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccumulatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardAccumulators
     * const rewardAccumulator = await prisma.rewardAccumulator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardAccumulatorUpdateManyArgs>(args: SelectSubset<T, RewardAccumulatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardAccumulators and returns the data updated in the database.
     * @param {RewardAccumulatorUpdateManyAndReturnArgs} args - Arguments to update many RewardAccumulators.
     * @example
     * // Update many RewardAccumulators
     * const rewardAccumulator = await prisma.rewardAccumulator.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RewardAccumulators and only return the `id`
     * const rewardAccumulatorWithIdOnly = await prisma.rewardAccumulator.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RewardAccumulatorUpdateManyAndReturnArgs>(args: SelectSubset<T, RewardAccumulatorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardAccumulatorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RewardAccumulator.
     * @param {RewardAccumulatorUpsertArgs} args - Arguments to update or create a RewardAccumulator.
     * @example
     * // Update or create a RewardAccumulator
     * const rewardAccumulator = await prisma.rewardAccumulator.upsert({
     *   create: {
     *     // ... data to create a RewardAccumulator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardAccumulator we want to update
     *   }
     * })
     */
    upsert<T extends RewardAccumulatorUpsertArgs>(args: SelectSubset<T, RewardAccumulatorUpsertArgs<ExtArgs>>): Prisma__RewardAccumulatorClient<$Result.GetResult<Prisma.$RewardAccumulatorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RewardAccumulators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccumulatorCountArgs} args - Arguments to filter RewardAccumulators to count.
     * @example
     * // Count the number of RewardAccumulators
     * const count = await prisma.rewardAccumulator.count({
     *   where: {
     *     // ... the filter for the RewardAccumulators we want to count
     *   }
     * })
    **/
    count<T extends RewardAccumulatorCountArgs>(
      args?: Subset<T, RewardAccumulatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardAccumulatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardAccumulator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccumulatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardAccumulatorAggregateArgs>(args: Subset<T, RewardAccumulatorAggregateArgs>): Prisma.PrismaPromise<GetRewardAccumulatorAggregateType<T>>

    /**
     * Group by RewardAccumulator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccumulatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardAccumulatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardAccumulatorGroupByArgs['orderBy'] }
        : { orderBy?: RewardAccumulatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardAccumulatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardAccumulatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RewardAccumulator model
   */
  readonly fields: RewardAccumulatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardAccumulator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardAccumulatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RewardAccumulator model
   */
  interface RewardAccumulatorFieldRefs {
    readonly id: FieldRef<"RewardAccumulator", 'String'>
    readonly acc_per_token: FieldRef<"RewardAccumulator", 'Decimal'>
    readonly updated_at: FieldRef<"RewardAccumulator", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RewardAccumulator findUnique
   */
  export type RewardAccumulatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulator
     */
    select?: RewardAccumulatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulator
     */
    omit?: RewardAccumulatorOmit<ExtArgs> | null
    /**
     * Filter, which RewardAccumulator to fetch.
     */
    where: RewardAccumulatorWhereUniqueInput
  }

  /**
   * RewardAccumulator findUniqueOrThrow
   */
  export type RewardAccumulatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulator
     */
    select?: RewardAccumulatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulator
     */
    omit?: RewardAccumulatorOmit<ExtArgs> | null
    /**
     * Filter, which RewardAccumulator to fetch.
     */
    where: RewardAccumulatorWhereUniqueInput
  }

  /**
   * RewardAccumulator findFirst
   */
  export type RewardAccumulatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulator
     */
    select?: RewardAccumulatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulator
     */
    omit?: RewardAccumulatorOmit<ExtArgs> | null
    /**
     * Filter, which RewardAccumulator to fetch.
     */
    where?: RewardAccumulatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardAccumulators to fetch.
     */
    orderBy?: RewardAccumulatorOrderByWithRelationInput | RewardAccumulatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardAccumulators.
     */
    cursor?: RewardAccumulatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardAccumulators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardAccumulators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardAccumulators.
     */
    distinct?: RewardAccumulatorScalarFieldEnum | RewardAccumulatorScalarFieldEnum[]
  }

  /**
   * RewardAccumulator findFirstOrThrow
   */
  export type RewardAccumulatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulator
     */
    select?: RewardAccumulatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulator
     */
    omit?: RewardAccumulatorOmit<ExtArgs> | null
    /**
     * Filter, which RewardAccumulator to fetch.
     */
    where?: RewardAccumulatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardAccumulators to fetch.
     */
    orderBy?: RewardAccumulatorOrderByWithRelationInput | RewardAccumulatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardAccumulators.
     */
    cursor?: RewardAccumulatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardAccumulators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardAccumulators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardAccumulators.
     */
    distinct?: RewardAccumulatorScalarFieldEnum | RewardAccumulatorScalarFieldEnum[]
  }

  /**
   * RewardAccumulator findMany
   */
  export type RewardAccumulatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulator
     */
    select?: RewardAccumulatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulator
     */
    omit?: RewardAccumulatorOmit<ExtArgs> | null
    /**
     * Filter, which RewardAccumulators to fetch.
     */
    where?: RewardAccumulatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardAccumulators to fetch.
     */
    orderBy?: RewardAccumulatorOrderByWithRelationInput | RewardAccumulatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardAccumulators.
     */
    cursor?: RewardAccumulatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardAccumulators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardAccumulators.
     */
    skip?: number
    distinct?: RewardAccumulatorScalarFieldEnum | RewardAccumulatorScalarFieldEnum[]
  }

  /**
   * RewardAccumulator create
   */
  export type RewardAccumulatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulator
     */
    select?: RewardAccumulatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulator
     */
    omit?: RewardAccumulatorOmit<ExtArgs> | null
    /**
     * The data needed to create a RewardAccumulator.
     */
    data: XOR<RewardAccumulatorCreateInput, RewardAccumulatorUncheckedCreateInput>
  }

  /**
   * RewardAccumulator createMany
   */
  export type RewardAccumulatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RewardAccumulators.
     */
    data: RewardAccumulatorCreateManyInput | RewardAccumulatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RewardAccumulator createManyAndReturn
   */
  export type RewardAccumulatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulator
     */
    select?: RewardAccumulatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulator
     */
    omit?: RewardAccumulatorOmit<ExtArgs> | null
    /**
     * The data used to create many RewardAccumulators.
     */
    data: RewardAccumulatorCreateManyInput | RewardAccumulatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RewardAccumulator update
   */
  export type RewardAccumulatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulator
     */
    select?: RewardAccumulatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulator
     */
    omit?: RewardAccumulatorOmit<ExtArgs> | null
    /**
     * The data needed to update a RewardAccumulator.
     */
    data: XOR<RewardAccumulatorUpdateInput, RewardAccumulatorUncheckedUpdateInput>
    /**
     * Choose, which RewardAccumulator to update.
     */
    where: RewardAccumulatorWhereUniqueInput
  }

  /**
   * RewardAccumulator updateMany
   */
  export type RewardAccumulatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RewardAccumulators.
     */
    data: XOR<RewardAccumulatorUpdateManyMutationInput, RewardAccumulatorUncheckedUpdateManyInput>
    /**
     * Filter which RewardAccumulators to update
     */
    where?: RewardAccumulatorWhereInput
    /**
     * Limit how many RewardAccumulators to update.
     */
    limit?: number
  }

  /**
   * RewardAccumulator updateManyAndReturn
   */
  export type RewardAccumulatorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulator
     */
    select?: RewardAccumulatorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulator
     */
    omit?: RewardAccumulatorOmit<ExtArgs> | null
    /**
     * The data used to update RewardAccumulators.
     */
    data: XOR<RewardAccumulatorUpdateManyMutationInput, RewardAccumulatorUncheckedUpdateManyInput>
    /**
     * Filter which RewardAccumulators to update
     */
    where?: RewardAccumulatorWhereInput
    /**
     * Limit how many RewardAccumulators to update.
     */
    limit?: number
  }

  /**
   * RewardAccumulator upsert
   */
  export type RewardAccumulatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulator
     */
    select?: RewardAccumulatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulator
     */
    omit?: RewardAccumulatorOmit<ExtArgs> | null
    /**
     * The filter to search for the RewardAccumulator to update in case it exists.
     */
    where: RewardAccumulatorWhereUniqueInput
    /**
     * In case the RewardAccumulator found by the `where` argument doesn't exist, create a new RewardAccumulator with this data.
     */
    create: XOR<RewardAccumulatorCreateInput, RewardAccumulatorUncheckedCreateInput>
    /**
     * In case the RewardAccumulator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardAccumulatorUpdateInput, RewardAccumulatorUncheckedUpdateInput>
  }

  /**
   * RewardAccumulator delete
   */
  export type RewardAccumulatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulator
     */
    select?: RewardAccumulatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulator
     */
    omit?: RewardAccumulatorOmit<ExtArgs> | null
    /**
     * Filter which RewardAccumulator to delete.
     */
    where: RewardAccumulatorWhereUniqueInput
  }

  /**
   * RewardAccumulator deleteMany
   */
  export type RewardAccumulatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardAccumulators to delete
     */
    where?: RewardAccumulatorWhereInput
    /**
     * Limit how many RewardAccumulators to delete.
     */
    limit?: number
  }

  /**
   * RewardAccumulator without action
   */
  export type RewardAccumulatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulator
     */
    select?: RewardAccumulatorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulator
     */
    omit?: RewardAccumulatorOmit<ExtArgs> | null
  }


  /**
   * Model FeaturedCycle
   */

  export type AggregateFeaturedCycle = {
    _count: FeaturedCycleCountAggregateOutputType | null
    _avg: FeaturedCycleAvgAggregateOutputType | null
    _sum: FeaturedCycleSumAggregateOutputType | null
    _min: FeaturedCycleMinAggregateOutputType | null
    _max: FeaturedCycleMaxAggregateOutputType | null
  }

  export type FeaturedCycleAvgAggregateOutputType = {
    minBidWei: Decimal | null
    winnerAmountWei: Decimal | null
  }

  export type FeaturedCycleSumAggregateOutputType = {
    minBidWei: Decimal | null
    winnerAmountWei: Decimal | null
  }

  export type FeaturedCycleMinAggregateOutputType = {
    id: string | null
    cycleId: string | null
    startAt: Date | null
    endAt: Date | null
    status: $Enums.FeaturedCycleStatus | null
    minBidWei: Decimal | null
    winnerBidId: string | null
    winnerCollectionContract: string | null
    winnerAmountWei: Decimal | null
    finalizedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeaturedCycleMaxAggregateOutputType = {
    id: string | null
    cycleId: string | null
    startAt: Date | null
    endAt: Date | null
    status: $Enums.FeaturedCycleStatus | null
    minBidWei: Decimal | null
    winnerBidId: string | null
    winnerCollectionContract: string | null
    winnerAmountWei: Decimal | null
    finalizedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeaturedCycleCountAggregateOutputType = {
    id: number
    cycleId: number
    startAt: number
    endAt: number
    status: number
    minBidWei: number
    winnerBidId: number
    winnerCollectionContract: number
    winnerAmountWei: number
    finalizedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeaturedCycleAvgAggregateInputType = {
    minBidWei?: true
    winnerAmountWei?: true
  }

  export type FeaturedCycleSumAggregateInputType = {
    minBidWei?: true
    winnerAmountWei?: true
  }

  export type FeaturedCycleMinAggregateInputType = {
    id?: true
    cycleId?: true
    startAt?: true
    endAt?: true
    status?: true
    minBidWei?: true
    winnerBidId?: true
    winnerCollectionContract?: true
    winnerAmountWei?: true
    finalizedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeaturedCycleMaxAggregateInputType = {
    id?: true
    cycleId?: true
    startAt?: true
    endAt?: true
    status?: true
    minBidWei?: true
    winnerBidId?: true
    winnerCollectionContract?: true
    winnerAmountWei?: true
    finalizedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeaturedCycleCountAggregateInputType = {
    id?: true
    cycleId?: true
    startAt?: true
    endAt?: true
    status?: true
    minBidWei?: true
    winnerBidId?: true
    winnerCollectionContract?: true
    winnerAmountWei?: true
    finalizedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeaturedCycleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedCycle to aggregate.
     */
    where?: FeaturedCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedCycles to fetch.
     */
    orderBy?: FeaturedCycleOrderByWithRelationInput | FeaturedCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeaturedCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeaturedCycles
    **/
    _count?: true | FeaturedCycleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeaturedCycleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeaturedCycleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturedCycleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturedCycleMaxAggregateInputType
  }

  export type GetFeaturedCycleAggregateType<T extends FeaturedCycleAggregateArgs> = {
        [P in keyof T & keyof AggregateFeaturedCycle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeaturedCycle[P]>
      : GetScalarType<T[P], AggregateFeaturedCycle[P]>
  }




  export type FeaturedCycleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedCycleWhereInput
    orderBy?: FeaturedCycleOrderByWithAggregationInput | FeaturedCycleOrderByWithAggregationInput[]
    by: FeaturedCycleScalarFieldEnum[] | FeaturedCycleScalarFieldEnum
    having?: FeaturedCycleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturedCycleCountAggregateInputType | true
    _avg?: FeaturedCycleAvgAggregateInputType
    _sum?: FeaturedCycleSumAggregateInputType
    _min?: FeaturedCycleMinAggregateInputType
    _max?: FeaturedCycleMaxAggregateInputType
  }

  export type FeaturedCycleGroupByOutputType = {
    id: string
    cycleId: string
    startAt: Date
    endAt: Date
    status: $Enums.FeaturedCycleStatus
    minBidWei: Decimal
    winnerBidId: string | null
    winnerCollectionContract: string | null
    winnerAmountWei: Decimal | null
    finalizedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FeaturedCycleCountAggregateOutputType | null
    _avg: FeaturedCycleAvgAggregateOutputType | null
    _sum: FeaturedCycleSumAggregateOutputType | null
    _min: FeaturedCycleMinAggregateOutputType | null
    _max: FeaturedCycleMaxAggregateOutputType | null
  }

  type GetFeaturedCycleGroupByPayload<T extends FeaturedCycleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeaturedCycleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturedCycleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturedCycleGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturedCycleGroupByOutputType[P]>
        }
      >
    >


  export type FeaturedCycleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cycleId?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    minBidWei?: boolean
    winnerBidId?: boolean
    winnerCollectionContract?: boolean
    winnerAmountWei?: boolean
    finalizedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bids?: boolean | FeaturedCycle$bidsArgs<ExtArgs>
    winnerBid?: boolean | FeaturedCycle$winnerBidArgs<ExtArgs>
    winnerCollection?: boolean | FeaturedCycle$winnerCollectionArgs<ExtArgs>
    _count?: boolean | FeaturedCycleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredCycle"]>

  export type FeaturedCycleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cycleId?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    minBidWei?: boolean
    winnerBidId?: boolean
    winnerCollectionContract?: boolean
    winnerAmountWei?: boolean
    finalizedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    winnerBid?: boolean | FeaturedCycle$winnerBidArgs<ExtArgs>
    winnerCollection?: boolean | FeaturedCycle$winnerCollectionArgs<ExtArgs>
  }, ExtArgs["result"]["featuredCycle"]>

  export type FeaturedCycleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cycleId?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    minBidWei?: boolean
    winnerBidId?: boolean
    winnerCollectionContract?: boolean
    winnerAmountWei?: boolean
    finalizedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    winnerBid?: boolean | FeaturedCycle$winnerBidArgs<ExtArgs>
    winnerCollection?: boolean | FeaturedCycle$winnerCollectionArgs<ExtArgs>
  }, ExtArgs["result"]["featuredCycle"]>

  export type FeaturedCycleSelectScalar = {
    id?: boolean
    cycleId?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    minBidWei?: boolean
    winnerBidId?: boolean
    winnerCollectionContract?: boolean
    winnerAmountWei?: boolean
    finalizedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeaturedCycleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cycleId" | "startAt" | "endAt" | "status" | "minBidWei" | "winnerBidId" | "winnerCollectionContract" | "winnerAmountWei" | "finalizedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["featuredCycle"]>
  export type FeaturedCycleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bids?: boolean | FeaturedCycle$bidsArgs<ExtArgs>
    winnerBid?: boolean | FeaturedCycle$winnerBidArgs<ExtArgs>
    winnerCollection?: boolean | FeaturedCycle$winnerCollectionArgs<ExtArgs>
    _count?: boolean | FeaturedCycleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeaturedCycleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    winnerBid?: boolean | FeaturedCycle$winnerBidArgs<ExtArgs>
    winnerCollection?: boolean | FeaturedCycle$winnerCollectionArgs<ExtArgs>
  }
  export type FeaturedCycleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    winnerBid?: boolean | FeaturedCycle$winnerBidArgs<ExtArgs>
    winnerCollection?: boolean | FeaturedCycle$winnerCollectionArgs<ExtArgs>
  }

  export type $FeaturedCyclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeaturedCycle"
    objects: {
      bids: Prisma.$FeaturedBidPayload<ExtArgs>[]
      winnerBid: Prisma.$FeaturedBidPayload<ExtArgs> | null
      winnerCollection: Prisma.$CollectionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cycleId: string
      startAt: Date
      endAt: Date
      status: $Enums.FeaturedCycleStatus
      minBidWei: Prisma.Decimal
      winnerBidId: string | null
      winnerCollectionContract: string | null
      winnerAmountWei: Prisma.Decimal | null
      finalizedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featuredCycle"]>
    composites: {}
  }

  type FeaturedCycleGetPayload<S extends boolean | null | undefined | FeaturedCycleDefaultArgs> = $Result.GetResult<Prisma.$FeaturedCyclePayload, S>

  type FeaturedCycleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeaturedCycleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeaturedCycleCountAggregateInputType | true
    }

  export interface FeaturedCycleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeaturedCycle'], meta: { name: 'FeaturedCycle' } }
    /**
     * Find zero or one FeaturedCycle that matches the filter.
     * @param {FeaturedCycleFindUniqueArgs} args - Arguments to find a FeaturedCycle
     * @example
     * // Get one FeaturedCycle
     * const featuredCycle = await prisma.featuredCycle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeaturedCycleFindUniqueArgs>(args: SelectSubset<T, FeaturedCycleFindUniqueArgs<ExtArgs>>): Prisma__FeaturedCycleClient<$Result.GetResult<Prisma.$FeaturedCyclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeaturedCycle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeaturedCycleFindUniqueOrThrowArgs} args - Arguments to find a FeaturedCycle
     * @example
     * // Get one FeaturedCycle
     * const featuredCycle = await prisma.featuredCycle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeaturedCycleFindUniqueOrThrowArgs>(args: SelectSubset<T, FeaturedCycleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeaturedCycleClient<$Result.GetResult<Prisma.$FeaturedCyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeaturedCycle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedCycleFindFirstArgs} args - Arguments to find a FeaturedCycle
     * @example
     * // Get one FeaturedCycle
     * const featuredCycle = await prisma.featuredCycle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeaturedCycleFindFirstArgs>(args?: SelectSubset<T, FeaturedCycleFindFirstArgs<ExtArgs>>): Prisma__FeaturedCycleClient<$Result.GetResult<Prisma.$FeaturedCyclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeaturedCycle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedCycleFindFirstOrThrowArgs} args - Arguments to find a FeaturedCycle
     * @example
     * // Get one FeaturedCycle
     * const featuredCycle = await prisma.featuredCycle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeaturedCycleFindFirstOrThrowArgs>(args?: SelectSubset<T, FeaturedCycleFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeaturedCycleClient<$Result.GetResult<Prisma.$FeaturedCyclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeaturedCycles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedCycleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeaturedCycles
     * const featuredCycles = await prisma.featuredCycle.findMany()
     * 
     * // Get first 10 FeaturedCycles
     * const featuredCycles = await prisma.featuredCycle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featuredCycleWithIdOnly = await prisma.featuredCycle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeaturedCycleFindManyArgs>(args?: SelectSubset<T, FeaturedCycleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedCyclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeaturedCycle.
     * @param {FeaturedCycleCreateArgs} args - Arguments to create a FeaturedCycle.
     * @example
     * // Create one FeaturedCycle
     * const FeaturedCycle = await prisma.featuredCycle.create({
     *   data: {
     *     // ... data to create a FeaturedCycle
     *   }
     * })
     * 
     */
    create<T extends FeaturedCycleCreateArgs>(args: SelectSubset<T, FeaturedCycleCreateArgs<ExtArgs>>): Prisma__FeaturedCycleClient<$Result.GetResult<Prisma.$FeaturedCyclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeaturedCycles.
     * @param {FeaturedCycleCreateManyArgs} args - Arguments to create many FeaturedCycles.
     * @example
     * // Create many FeaturedCycles
     * const featuredCycle = await prisma.featuredCycle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeaturedCycleCreateManyArgs>(args?: SelectSubset<T, FeaturedCycleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeaturedCycles and returns the data saved in the database.
     * @param {FeaturedCycleCreateManyAndReturnArgs} args - Arguments to create many FeaturedCycles.
     * @example
     * // Create many FeaturedCycles
     * const featuredCycle = await prisma.featuredCycle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeaturedCycles and only return the `id`
     * const featuredCycleWithIdOnly = await prisma.featuredCycle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeaturedCycleCreateManyAndReturnArgs>(args?: SelectSubset<T, FeaturedCycleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedCyclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeaturedCycle.
     * @param {FeaturedCycleDeleteArgs} args - Arguments to delete one FeaturedCycle.
     * @example
     * // Delete one FeaturedCycle
     * const FeaturedCycle = await prisma.featuredCycle.delete({
     *   where: {
     *     // ... filter to delete one FeaturedCycle
     *   }
     * })
     * 
     */
    delete<T extends FeaturedCycleDeleteArgs>(args: SelectSubset<T, FeaturedCycleDeleteArgs<ExtArgs>>): Prisma__FeaturedCycleClient<$Result.GetResult<Prisma.$FeaturedCyclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeaturedCycle.
     * @param {FeaturedCycleUpdateArgs} args - Arguments to update one FeaturedCycle.
     * @example
     * // Update one FeaturedCycle
     * const featuredCycle = await prisma.featuredCycle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeaturedCycleUpdateArgs>(args: SelectSubset<T, FeaturedCycleUpdateArgs<ExtArgs>>): Prisma__FeaturedCycleClient<$Result.GetResult<Prisma.$FeaturedCyclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeaturedCycles.
     * @param {FeaturedCycleDeleteManyArgs} args - Arguments to filter FeaturedCycles to delete.
     * @example
     * // Delete a few FeaturedCycles
     * const { count } = await prisma.featuredCycle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeaturedCycleDeleteManyArgs>(args?: SelectSubset<T, FeaturedCycleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedCycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedCycleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeaturedCycles
     * const featuredCycle = await prisma.featuredCycle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeaturedCycleUpdateManyArgs>(args: SelectSubset<T, FeaturedCycleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedCycles and returns the data updated in the database.
     * @param {FeaturedCycleUpdateManyAndReturnArgs} args - Arguments to update many FeaturedCycles.
     * @example
     * // Update many FeaturedCycles
     * const featuredCycle = await prisma.featuredCycle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeaturedCycles and only return the `id`
     * const featuredCycleWithIdOnly = await prisma.featuredCycle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeaturedCycleUpdateManyAndReturnArgs>(args: SelectSubset<T, FeaturedCycleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedCyclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeaturedCycle.
     * @param {FeaturedCycleUpsertArgs} args - Arguments to update or create a FeaturedCycle.
     * @example
     * // Update or create a FeaturedCycle
     * const featuredCycle = await prisma.featuredCycle.upsert({
     *   create: {
     *     // ... data to create a FeaturedCycle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeaturedCycle we want to update
     *   }
     * })
     */
    upsert<T extends FeaturedCycleUpsertArgs>(args: SelectSubset<T, FeaturedCycleUpsertArgs<ExtArgs>>): Prisma__FeaturedCycleClient<$Result.GetResult<Prisma.$FeaturedCyclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeaturedCycles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedCycleCountArgs} args - Arguments to filter FeaturedCycles to count.
     * @example
     * // Count the number of FeaturedCycles
     * const count = await prisma.featuredCycle.count({
     *   where: {
     *     // ... the filter for the FeaturedCycles we want to count
     *   }
     * })
    **/
    count<T extends FeaturedCycleCountArgs>(
      args?: Subset<T, FeaturedCycleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturedCycleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeaturedCycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedCycleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturedCycleAggregateArgs>(args: Subset<T, FeaturedCycleAggregateArgs>): Prisma.PrismaPromise<GetFeaturedCycleAggregateType<T>>

    /**
     * Group by FeaturedCycle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedCycleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeaturedCycleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeaturedCycleGroupByArgs['orderBy'] }
        : { orderBy?: FeaturedCycleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeaturedCycleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturedCycleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeaturedCycle model
   */
  readonly fields: FeaturedCycleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeaturedCycle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeaturedCycleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bids<T extends FeaturedCycle$bidsArgs<ExtArgs> = {}>(args?: Subset<T, FeaturedCycle$bidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    winnerBid<T extends FeaturedCycle$winnerBidArgs<ExtArgs> = {}>(args?: Subset<T, FeaturedCycle$winnerBidArgs<ExtArgs>>): Prisma__FeaturedBidClient<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    winnerCollection<T extends FeaturedCycle$winnerCollectionArgs<ExtArgs> = {}>(args?: Subset<T, FeaturedCycle$winnerCollectionArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeaturedCycle model
   */
  interface FeaturedCycleFieldRefs {
    readonly id: FieldRef<"FeaturedCycle", 'String'>
    readonly cycleId: FieldRef<"FeaturedCycle", 'String'>
    readonly startAt: FieldRef<"FeaturedCycle", 'DateTime'>
    readonly endAt: FieldRef<"FeaturedCycle", 'DateTime'>
    readonly status: FieldRef<"FeaturedCycle", 'FeaturedCycleStatus'>
    readonly minBidWei: FieldRef<"FeaturedCycle", 'Decimal'>
    readonly winnerBidId: FieldRef<"FeaturedCycle", 'String'>
    readonly winnerCollectionContract: FieldRef<"FeaturedCycle", 'String'>
    readonly winnerAmountWei: FieldRef<"FeaturedCycle", 'Decimal'>
    readonly finalizedAt: FieldRef<"FeaturedCycle", 'DateTime'>
    readonly createdAt: FieldRef<"FeaturedCycle", 'DateTime'>
    readonly updatedAt: FieldRef<"FeaturedCycle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeaturedCycle findUnique
   */
  export type FeaturedCycleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycle
     */
    select?: FeaturedCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedCycle
     */
    omit?: FeaturedCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedCycleInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedCycle to fetch.
     */
    where: FeaturedCycleWhereUniqueInput
  }

  /**
   * FeaturedCycle findUniqueOrThrow
   */
  export type FeaturedCycleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycle
     */
    select?: FeaturedCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedCycle
     */
    omit?: FeaturedCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedCycleInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedCycle to fetch.
     */
    where: FeaturedCycleWhereUniqueInput
  }

  /**
   * FeaturedCycle findFirst
   */
  export type FeaturedCycleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycle
     */
    select?: FeaturedCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedCycle
     */
    omit?: FeaturedCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedCycleInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedCycle to fetch.
     */
    where?: FeaturedCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedCycles to fetch.
     */
    orderBy?: FeaturedCycleOrderByWithRelationInput | FeaturedCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedCycles.
     */
    cursor?: FeaturedCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedCycles.
     */
    distinct?: FeaturedCycleScalarFieldEnum | FeaturedCycleScalarFieldEnum[]
  }

  /**
   * FeaturedCycle findFirstOrThrow
   */
  export type FeaturedCycleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycle
     */
    select?: FeaturedCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedCycle
     */
    omit?: FeaturedCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedCycleInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedCycle to fetch.
     */
    where?: FeaturedCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedCycles to fetch.
     */
    orderBy?: FeaturedCycleOrderByWithRelationInput | FeaturedCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedCycles.
     */
    cursor?: FeaturedCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedCycles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedCycles.
     */
    distinct?: FeaturedCycleScalarFieldEnum | FeaturedCycleScalarFieldEnum[]
  }

  /**
   * FeaturedCycle findMany
   */
  export type FeaturedCycleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycle
     */
    select?: FeaturedCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedCycle
     */
    omit?: FeaturedCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedCycleInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedCycles to fetch.
     */
    where?: FeaturedCycleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedCycles to fetch.
     */
    orderBy?: FeaturedCycleOrderByWithRelationInput | FeaturedCycleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeaturedCycles.
     */
    cursor?: FeaturedCycleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedCycles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedCycles.
     */
    skip?: number
    distinct?: FeaturedCycleScalarFieldEnum | FeaturedCycleScalarFieldEnum[]
  }

  /**
   * FeaturedCycle create
   */
  export type FeaturedCycleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycle
     */
    select?: FeaturedCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedCycle
     */
    omit?: FeaturedCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedCycleInclude<ExtArgs> | null
    /**
     * The data needed to create a FeaturedCycle.
     */
    data: XOR<FeaturedCycleCreateInput, FeaturedCycleUncheckedCreateInput>
  }

  /**
   * FeaturedCycle createMany
   */
  export type FeaturedCycleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeaturedCycles.
     */
    data: FeaturedCycleCreateManyInput | FeaturedCycleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeaturedCycle createManyAndReturn
   */
  export type FeaturedCycleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycle
     */
    select?: FeaturedCycleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedCycle
     */
    omit?: FeaturedCycleOmit<ExtArgs> | null
    /**
     * The data used to create many FeaturedCycles.
     */
    data: FeaturedCycleCreateManyInput | FeaturedCycleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedCycleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeaturedCycle update
   */
  export type FeaturedCycleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycle
     */
    select?: FeaturedCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedCycle
     */
    omit?: FeaturedCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedCycleInclude<ExtArgs> | null
    /**
     * The data needed to update a FeaturedCycle.
     */
    data: XOR<FeaturedCycleUpdateInput, FeaturedCycleUncheckedUpdateInput>
    /**
     * Choose, which FeaturedCycle to update.
     */
    where: FeaturedCycleWhereUniqueInput
  }

  /**
   * FeaturedCycle updateMany
   */
  export type FeaturedCycleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeaturedCycles.
     */
    data: XOR<FeaturedCycleUpdateManyMutationInput, FeaturedCycleUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedCycles to update
     */
    where?: FeaturedCycleWhereInput
    /**
     * Limit how many FeaturedCycles to update.
     */
    limit?: number
  }

  /**
   * FeaturedCycle updateManyAndReturn
   */
  export type FeaturedCycleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycle
     */
    select?: FeaturedCycleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedCycle
     */
    omit?: FeaturedCycleOmit<ExtArgs> | null
    /**
     * The data used to update FeaturedCycles.
     */
    data: XOR<FeaturedCycleUpdateManyMutationInput, FeaturedCycleUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedCycles to update
     */
    where?: FeaturedCycleWhereInput
    /**
     * Limit how many FeaturedCycles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedCycleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeaturedCycle upsert
   */
  export type FeaturedCycleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycle
     */
    select?: FeaturedCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedCycle
     */
    omit?: FeaturedCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedCycleInclude<ExtArgs> | null
    /**
     * The filter to search for the FeaturedCycle to update in case it exists.
     */
    where: FeaturedCycleWhereUniqueInput
    /**
     * In case the FeaturedCycle found by the `where` argument doesn't exist, create a new FeaturedCycle with this data.
     */
    create: XOR<FeaturedCycleCreateInput, FeaturedCycleUncheckedCreateInput>
    /**
     * In case the FeaturedCycle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeaturedCycleUpdateInput, FeaturedCycleUncheckedUpdateInput>
  }

  /**
   * FeaturedCycle delete
   */
  export type FeaturedCycleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycle
     */
    select?: FeaturedCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedCycle
     */
    omit?: FeaturedCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedCycleInclude<ExtArgs> | null
    /**
     * Filter which FeaturedCycle to delete.
     */
    where: FeaturedCycleWhereUniqueInput
  }

  /**
   * FeaturedCycle deleteMany
   */
  export type FeaturedCycleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedCycles to delete
     */
    where?: FeaturedCycleWhereInput
    /**
     * Limit how many FeaturedCycles to delete.
     */
    limit?: number
  }

  /**
   * FeaturedCycle.bids
   */
  export type FeaturedCycle$bidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidInclude<ExtArgs> | null
    where?: FeaturedBidWhereInput
    orderBy?: FeaturedBidOrderByWithRelationInput | FeaturedBidOrderByWithRelationInput[]
    cursor?: FeaturedBidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeaturedBidScalarFieldEnum | FeaturedBidScalarFieldEnum[]
  }

  /**
   * FeaturedCycle.winnerBid
   */
  export type FeaturedCycle$winnerBidArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidInclude<ExtArgs> | null
    where?: FeaturedBidWhereInput
  }

  /**
   * FeaturedCycle.winnerCollection
   */
  export type FeaturedCycle$winnerCollectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    where?: CollectionWhereInput
  }

  /**
   * FeaturedCycle without action
   */
  export type FeaturedCycleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycle
     */
    select?: FeaturedCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedCycle
     */
    omit?: FeaturedCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedCycleInclude<ExtArgs> | null
  }


  /**
   * Model FeaturedBid
   */

  export type AggregateFeaturedBid = {
    _count: FeaturedBidCountAggregateOutputType | null
    _avg: FeaturedBidAvgAggregateOutputType | null
    _sum: FeaturedBidSumAggregateOutputType | null
    _min: FeaturedBidMinAggregateOutputType | null
    _max: FeaturedBidMaxAggregateOutputType | null
  }

  export type FeaturedBidAvgAggregateOutputType = {
    totalBidWei: Decimal | null
    txCount: number | null
  }

  export type FeaturedBidSumAggregateOutputType = {
    totalBidWei: Decimal | null
    txCount: number | null
  }

  export type FeaturedBidMinAggregateOutputType = {
    id: string | null
    cycleId: string | null
    bidderAddress: string | null
    bidderUserId: string | null
    collectionContract: string | null
    totalBidWei: Decimal | null
    txCount: number | null
    lastTxHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeaturedBidMaxAggregateOutputType = {
    id: string | null
    cycleId: string | null
    bidderAddress: string | null
    bidderUserId: string | null
    collectionContract: string | null
    totalBidWei: Decimal | null
    txCount: number | null
    lastTxHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeaturedBidCountAggregateOutputType = {
    id: number
    cycleId: number
    bidderAddress: number
    bidderUserId: number
    collectionContract: number
    totalBidWei: number
    txCount: number
    lastTxHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeaturedBidAvgAggregateInputType = {
    totalBidWei?: true
    txCount?: true
  }

  export type FeaturedBidSumAggregateInputType = {
    totalBidWei?: true
    txCount?: true
  }

  export type FeaturedBidMinAggregateInputType = {
    id?: true
    cycleId?: true
    bidderAddress?: true
    bidderUserId?: true
    collectionContract?: true
    totalBidWei?: true
    txCount?: true
    lastTxHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeaturedBidMaxAggregateInputType = {
    id?: true
    cycleId?: true
    bidderAddress?: true
    bidderUserId?: true
    collectionContract?: true
    totalBidWei?: true
    txCount?: true
    lastTxHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeaturedBidCountAggregateInputType = {
    id?: true
    cycleId?: true
    bidderAddress?: true
    bidderUserId?: true
    collectionContract?: true
    totalBidWei?: true
    txCount?: true
    lastTxHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeaturedBidAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedBid to aggregate.
     */
    where?: FeaturedBidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedBids to fetch.
     */
    orderBy?: FeaturedBidOrderByWithRelationInput | FeaturedBidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeaturedBidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedBids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedBids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeaturedBids
    **/
    _count?: true | FeaturedBidCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeaturedBidAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeaturedBidSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturedBidMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturedBidMaxAggregateInputType
  }

  export type GetFeaturedBidAggregateType<T extends FeaturedBidAggregateArgs> = {
        [P in keyof T & keyof AggregateFeaturedBid]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeaturedBid[P]>
      : GetScalarType<T[P], AggregateFeaturedBid[P]>
  }




  export type FeaturedBidGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeaturedBidWhereInput
    orderBy?: FeaturedBidOrderByWithAggregationInput | FeaturedBidOrderByWithAggregationInput[]
    by: FeaturedBidScalarFieldEnum[] | FeaturedBidScalarFieldEnum
    having?: FeaturedBidScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturedBidCountAggregateInputType | true
    _avg?: FeaturedBidAvgAggregateInputType
    _sum?: FeaturedBidSumAggregateInputType
    _min?: FeaturedBidMinAggregateInputType
    _max?: FeaturedBidMaxAggregateInputType
  }

  export type FeaturedBidGroupByOutputType = {
    id: string
    cycleId: string
    bidderAddress: string
    bidderUserId: string | null
    collectionContract: string
    totalBidWei: Decimal
    txCount: number
    lastTxHash: string | null
    createdAt: Date
    updatedAt: Date
    _count: FeaturedBidCountAggregateOutputType | null
    _avg: FeaturedBidAvgAggregateOutputType | null
    _sum: FeaturedBidSumAggregateOutputType | null
    _min: FeaturedBidMinAggregateOutputType | null
    _max: FeaturedBidMaxAggregateOutputType | null
  }

  type GetFeaturedBidGroupByPayload<T extends FeaturedBidGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeaturedBidGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturedBidGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturedBidGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturedBidGroupByOutputType[P]>
        }
      >
    >


  export type FeaturedBidSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cycleId?: boolean
    bidderAddress?: boolean
    bidderUserId?: boolean
    collectionContract?: boolean
    totalBidWei?: boolean
    txCount?: boolean
    lastTxHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bidder?: boolean | FeaturedBid$bidderArgs<ExtArgs>
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
    cycle?: boolean | FeaturedCycleDefaultArgs<ExtArgs>
    winnerOf?: boolean | FeaturedBid$winnerOfArgs<ExtArgs>
  }, ExtArgs["result"]["featuredBid"]>

  export type FeaturedBidSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cycleId?: boolean
    bidderAddress?: boolean
    bidderUserId?: boolean
    collectionContract?: boolean
    totalBidWei?: boolean
    txCount?: boolean
    lastTxHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bidder?: boolean | FeaturedBid$bidderArgs<ExtArgs>
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
    cycle?: boolean | FeaturedCycleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredBid"]>

  export type FeaturedBidSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cycleId?: boolean
    bidderAddress?: boolean
    bidderUserId?: boolean
    collectionContract?: boolean
    totalBidWei?: boolean
    txCount?: boolean
    lastTxHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bidder?: boolean | FeaturedBid$bidderArgs<ExtArgs>
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
    cycle?: boolean | FeaturedCycleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["featuredBid"]>

  export type FeaturedBidSelectScalar = {
    id?: boolean
    cycleId?: boolean
    bidderAddress?: boolean
    bidderUserId?: boolean
    collectionContract?: boolean
    totalBidWei?: boolean
    txCount?: boolean
    lastTxHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeaturedBidOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cycleId" | "bidderAddress" | "bidderUserId" | "collectionContract" | "totalBidWei" | "txCount" | "lastTxHash" | "createdAt" | "updatedAt", ExtArgs["result"]["featuredBid"]>
  export type FeaturedBidInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidder?: boolean | FeaturedBid$bidderArgs<ExtArgs>
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
    cycle?: boolean | FeaturedCycleDefaultArgs<ExtArgs>
    winnerOf?: boolean | FeaturedBid$winnerOfArgs<ExtArgs>
  }
  export type FeaturedBidIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidder?: boolean | FeaturedBid$bidderArgs<ExtArgs>
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
    cycle?: boolean | FeaturedCycleDefaultArgs<ExtArgs>
  }
  export type FeaturedBidIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bidder?: boolean | FeaturedBid$bidderArgs<ExtArgs>
    collection?: boolean | CollectionDefaultArgs<ExtArgs>
    cycle?: boolean | FeaturedCycleDefaultArgs<ExtArgs>
  }

  export type $FeaturedBidPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeaturedBid"
    objects: {
      bidder: Prisma.$UserPayload<ExtArgs> | null
      collection: Prisma.$CollectionPayload<ExtArgs>
      cycle: Prisma.$FeaturedCyclePayload<ExtArgs>
      winnerOf: Prisma.$FeaturedCyclePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cycleId: string
      bidderAddress: string
      bidderUserId: string | null
      collectionContract: string
      totalBidWei: Prisma.Decimal
      txCount: number
      lastTxHash: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["featuredBid"]>
    composites: {}
  }

  type FeaturedBidGetPayload<S extends boolean | null | undefined | FeaturedBidDefaultArgs> = $Result.GetResult<Prisma.$FeaturedBidPayload, S>

  type FeaturedBidCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeaturedBidFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeaturedBidCountAggregateInputType | true
    }

  export interface FeaturedBidDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeaturedBid'], meta: { name: 'FeaturedBid' } }
    /**
     * Find zero or one FeaturedBid that matches the filter.
     * @param {FeaturedBidFindUniqueArgs} args - Arguments to find a FeaturedBid
     * @example
     * // Get one FeaturedBid
     * const featuredBid = await prisma.featuredBid.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeaturedBidFindUniqueArgs>(args: SelectSubset<T, FeaturedBidFindUniqueArgs<ExtArgs>>): Prisma__FeaturedBidClient<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeaturedBid that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeaturedBidFindUniqueOrThrowArgs} args - Arguments to find a FeaturedBid
     * @example
     * // Get one FeaturedBid
     * const featuredBid = await prisma.featuredBid.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeaturedBidFindUniqueOrThrowArgs>(args: SelectSubset<T, FeaturedBidFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeaturedBidClient<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeaturedBid that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedBidFindFirstArgs} args - Arguments to find a FeaturedBid
     * @example
     * // Get one FeaturedBid
     * const featuredBid = await prisma.featuredBid.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeaturedBidFindFirstArgs>(args?: SelectSubset<T, FeaturedBidFindFirstArgs<ExtArgs>>): Prisma__FeaturedBidClient<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeaturedBid that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedBidFindFirstOrThrowArgs} args - Arguments to find a FeaturedBid
     * @example
     * // Get one FeaturedBid
     * const featuredBid = await prisma.featuredBid.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeaturedBidFindFirstOrThrowArgs>(args?: SelectSubset<T, FeaturedBidFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeaturedBidClient<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeaturedBids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedBidFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeaturedBids
     * const featuredBids = await prisma.featuredBid.findMany()
     * 
     * // Get first 10 FeaturedBids
     * const featuredBids = await prisma.featuredBid.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featuredBidWithIdOnly = await prisma.featuredBid.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeaturedBidFindManyArgs>(args?: SelectSubset<T, FeaturedBidFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeaturedBid.
     * @param {FeaturedBidCreateArgs} args - Arguments to create a FeaturedBid.
     * @example
     * // Create one FeaturedBid
     * const FeaturedBid = await prisma.featuredBid.create({
     *   data: {
     *     // ... data to create a FeaturedBid
     *   }
     * })
     * 
     */
    create<T extends FeaturedBidCreateArgs>(args: SelectSubset<T, FeaturedBidCreateArgs<ExtArgs>>): Prisma__FeaturedBidClient<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeaturedBids.
     * @param {FeaturedBidCreateManyArgs} args - Arguments to create many FeaturedBids.
     * @example
     * // Create many FeaturedBids
     * const featuredBid = await prisma.featuredBid.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeaturedBidCreateManyArgs>(args?: SelectSubset<T, FeaturedBidCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeaturedBids and returns the data saved in the database.
     * @param {FeaturedBidCreateManyAndReturnArgs} args - Arguments to create many FeaturedBids.
     * @example
     * // Create many FeaturedBids
     * const featuredBid = await prisma.featuredBid.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeaturedBids and only return the `id`
     * const featuredBidWithIdOnly = await prisma.featuredBid.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeaturedBidCreateManyAndReturnArgs>(args?: SelectSubset<T, FeaturedBidCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeaturedBid.
     * @param {FeaturedBidDeleteArgs} args - Arguments to delete one FeaturedBid.
     * @example
     * // Delete one FeaturedBid
     * const FeaturedBid = await prisma.featuredBid.delete({
     *   where: {
     *     // ... filter to delete one FeaturedBid
     *   }
     * })
     * 
     */
    delete<T extends FeaturedBidDeleteArgs>(args: SelectSubset<T, FeaturedBidDeleteArgs<ExtArgs>>): Prisma__FeaturedBidClient<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeaturedBid.
     * @param {FeaturedBidUpdateArgs} args - Arguments to update one FeaturedBid.
     * @example
     * // Update one FeaturedBid
     * const featuredBid = await prisma.featuredBid.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeaturedBidUpdateArgs>(args: SelectSubset<T, FeaturedBidUpdateArgs<ExtArgs>>): Prisma__FeaturedBidClient<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeaturedBids.
     * @param {FeaturedBidDeleteManyArgs} args - Arguments to filter FeaturedBids to delete.
     * @example
     * // Delete a few FeaturedBids
     * const { count } = await prisma.featuredBid.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeaturedBidDeleteManyArgs>(args?: SelectSubset<T, FeaturedBidDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedBids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedBidUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeaturedBids
     * const featuredBid = await prisma.featuredBid.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeaturedBidUpdateManyArgs>(args: SelectSubset<T, FeaturedBidUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeaturedBids and returns the data updated in the database.
     * @param {FeaturedBidUpdateManyAndReturnArgs} args - Arguments to update many FeaturedBids.
     * @example
     * // Update many FeaturedBids
     * const featuredBid = await prisma.featuredBid.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeaturedBids and only return the `id`
     * const featuredBidWithIdOnly = await prisma.featuredBid.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeaturedBidUpdateManyAndReturnArgs>(args: SelectSubset<T, FeaturedBidUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeaturedBid.
     * @param {FeaturedBidUpsertArgs} args - Arguments to update or create a FeaturedBid.
     * @example
     * // Update or create a FeaturedBid
     * const featuredBid = await prisma.featuredBid.upsert({
     *   create: {
     *     // ... data to create a FeaturedBid
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeaturedBid we want to update
     *   }
     * })
     */
    upsert<T extends FeaturedBidUpsertArgs>(args: SelectSubset<T, FeaturedBidUpsertArgs<ExtArgs>>): Prisma__FeaturedBidClient<$Result.GetResult<Prisma.$FeaturedBidPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeaturedBids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedBidCountArgs} args - Arguments to filter FeaturedBids to count.
     * @example
     * // Count the number of FeaturedBids
     * const count = await prisma.featuredBid.count({
     *   where: {
     *     // ... the filter for the FeaturedBids we want to count
     *   }
     * })
    **/
    count<T extends FeaturedBidCountArgs>(
      args?: Subset<T, FeaturedBidCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturedBidCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeaturedBid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedBidAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturedBidAggregateArgs>(args: Subset<T, FeaturedBidAggregateArgs>): Prisma.PrismaPromise<GetFeaturedBidAggregateType<T>>

    /**
     * Group by FeaturedBid.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturedBidGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeaturedBidGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeaturedBidGroupByArgs['orderBy'] }
        : { orderBy?: FeaturedBidGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeaturedBidGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturedBidGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeaturedBid model
   */
  readonly fields: FeaturedBidFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeaturedBid.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeaturedBidClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bidder<T extends FeaturedBid$bidderArgs<ExtArgs> = {}>(args?: Subset<T, FeaturedBid$bidderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    collection<T extends CollectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CollectionDefaultArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cycle<T extends FeaturedCycleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeaturedCycleDefaultArgs<ExtArgs>>): Prisma__FeaturedCycleClient<$Result.GetResult<Prisma.$FeaturedCyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    winnerOf<T extends FeaturedBid$winnerOfArgs<ExtArgs> = {}>(args?: Subset<T, FeaturedBid$winnerOfArgs<ExtArgs>>): Prisma__FeaturedCycleClient<$Result.GetResult<Prisma.$FeaturedCyclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeaturedBid model
   */
  interface FeaturedBidFieldRefs {
    readonly id: FieldRef<"FeaturedBid", 'String'>
    readonly cycleId: FieldRef<"FeaturedBid", 'String'>
    readonly bidderAddress: FieldRef<"FeaturedBid", 'String'>
    readonly bidderUserId: FieldRef<"FeaturedBid", 'String'>
    readonly collectionContract: FieldRef<"FeaturedBid", 'String'>
    readonly totalBidWei: FieldRef<"FeaturedBid", 'Decimal'>
    readonly txCount: FieldRef<"FeaturedBid", 'Int'>
    readonly lastTxHash: FieldRef<"FeaturedBid", 'String'>
    readonly createdAt: FieldRef<"FeaturedBid", 'DateTime'>
    readonly updatedAt: FieldRef<"FeaturedBid", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeaturedBid findUnique
   */
  export type FeaturedBidFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedBid to fetch.
     */
    where: FeaturedBidWhereUniqueInput
  }

  /**
   * FeaturedBid findUniqueOrThrow
   */
  export type FeaturedBidFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedBid to fetch.
     */
    where: FeaturedBidWhereUniqueInput
  }

  /**
   * FeaturedBid findFirst
   */
  export type FeaturedBidFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedBid to fetch.
     */
    where?: FeaturedBidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedBids to fetch.
     */
    orderBy?: FeaturedBidOrderByWithRelationInput | FeaturedBidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedBids.
     */
    cursor?: FeaturedBidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedBids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedBids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedBids.
     */
    distinct?: FeaturedBidScalarFieldEnum | FeaturedBidScalarFieldEnum[]
  }

  /**
   * FeaturedBid findFirstOrThrow
   */
  export type FeaturedBidFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedBid to fetch.
     */
    where?: FeaturedBidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedBids to fetch.
     */
    orderBy?: FeaturedBidOrderByWithRelationInput | FeaturedBidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeaturedBids.
     */
    cursor?: FeaturedBidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedBids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedBids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeaturedBids.
     */
    distinct?: FeaturedBidScalarFieldEnum | FeaturedBidScalarFieldEnum[]
  }

  /**
   * FeaturedBid findMany
   */
  export type FeaturedBidFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidInclude<ExtArgs> | null
    /**
     * Filter, which FeaturedBids to fetch.
     */
    where?: FeaturedBidWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeaturedBids to fetch.
     */
    orderBy?: FeaturedBidOrderByWithRelationInput | FeaturedBidOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeaturedBids.
     */
    cursor?: FeaturedBidWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeaturedBids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeaturedBids.
     */
    skip?: number
    distinct?: FeaturedBidScalarFieldEnum | FeaturedBidScalarFieldEnum[]
  }

  /**
   * FeaturedBid create
   */
  export type FeaturedBidCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidInclude<ExtArgs> | null
    /**
     * The data needed to create a FeaturedBid.
     */
    data: XOR<FeaturedBidCreateInput, FeaturedBidUncheckedCreateInput>
  }

  /**
   * FeaturedBid createMany
   */
  export type FeaturedBidCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeaturedBids.
     */
    data: FeaturedBidCreateManyInput | FeaturedBidCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeaturedBid createManyAndReturn
   */
  export type FeaturedBidCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * The data used to create many FeaturedBids.
     */
    data: FeaturedBidCreateManyInput | FeaturedBidCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeaturedBid update
   */
  export type FeaturedBidUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidInclude<ExtArgs> | null
    /**
     * The data needed to update a FeaturedBid.
     */
    data: XOR<FeaturedBidUpdateInput, FeaturedBidUncheckedUpdateInput>
    /**
     * Choose, which FeaturedBid to update.
     */
    where: FeaturedBidWhereUniqueInput
  }

  /**
   * FeaturedBid updateMany
   */
  export type FeaturedBidUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeaturedBids.
     */
    data: XOR<FeaturedBidUpdateManyMutationInput, FeaturedBidUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedBids to update
     */
    where?: FeaturedBidWhereInput
    /**
     * Limit how many FeaturedBids to update.
     */
    limit?: number
  }

  /**
   * FeaturedBid updateManyAndReturn
   */
  export type FeaturedBidUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * The data used to update FeaturedBids.
     */
    data: XOR<FeaturedBidUpdateManyMutationInput, FeaturedBidUncheckedUpdateManyInput>
    /**
     * Filter which FeaturedBids to update
     */
    where?: FeaturedBidWhereInput
    /**
     * Limit how many FeaturedBids to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeaturedBid upsert
   */
  export type FeaturedBidUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidInclude<ExtArgs> | null
    /**
     * The filter to search for the FeaturedBid to update in case it exists.
     */
    where: FeaturedBidWhereUniqueInput
    /**
     * In case the FeaturedBid found by the `where` argument doesn't exist, create a new FeaturedBid with this data.
     */
    create: XOR<FeaturedBidCreateInput, FeaturedBidUncheckedCreateInput>
    /**
     * In case the FeaturedBid was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeaturedBidUpdateInput, FeaturedBidUncheckedUpdateInput>
  }

  /**
   * FeaturedBid delete
   */
  export type FeaturedBidDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidInclude<ExtArgs> | null
    /**
     * Filter which FeaturedBid to delete.
     */
    where: FeaturedBidWhereUniqueInput
  }

  /**
   * FeaturedBid deleteMany
   */
  export type FeaturedBidDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeaturedBids to delete
     */
    where?: FeaturedBidWhereInput
    /**
     * Limit how many FeaturedBids to delete.
     */
    limit?: number
  }

  /**
   * FeaturedBid.bidder
   */
  export type FeaturedBid$bidderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FeaturedBid.winnerOf
   */
  export type FeaturedBid$winnerOfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedCycle
     */
    select?: FeaturedCycleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedCycle
     */
    omit?: FeaturedCycleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedCycleInclude<ExtArgs> | null
    where?: FeaturedCycleWhereInput
  }

  /**
   * FeaturedBid without action
   */
  export type FeaturedBidDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeaturedBid
     */
    select?: FeaturedBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeaturedBid
     */
    omit?: FeaturedBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeaturedBidInclude<ExtArgs> | null
  }


  /**
   * Model Currency
   */

  export type AggregateCurrency = {
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyAvgAggregateOutputType = {
    decimals: number | null
  }

  export type CurrencySumAggregateOutputType = {
    decimals: number | null
  }

  export type CurrencyMinAggregateOutputType = {
    id: string | null
    symbol: string | null
    decimals: number | null
    kind: $Enums.CurrencyKind | null
    tokenAddress: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyMaxAggregateOutputType = {
    id: string | null
    symbol: string | null
    decimals: number | null
    kind: $Enums.CurrencyKind | null
    tokenAddress: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrencyCountAggregateOutputType = {
    id: number
    symbol: number
    decimals: number
    kind: number
    tokenAddress: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CurrencyAvgAggregateInputType = {
    decimals?: true
  }

  export type CurrencySumAggregateInputType = {
    decimals?: true
  }

  export type CurrencyMinAggregateInputType = {
    id?: true
    symbol?: true
    decimals?: true
    kind?: true
    tokenAddress?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyMaxAggregateInputType = {
    id?: true
    symbol?: true
    decimals?: true
    kind?: true
    tokenAddress?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrencyCountAggregateInputType = {
    id?: true
    symbol?: true
    decimals?: true
    kind?: true
    tokenAddress?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currency to aggregate.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Currencies
    **/
    _count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }




  export type CurrencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CurrencyWhereInput
    orderBy?: CurrencyOrderByWithAggregationInput | CurrencyOrderByWithAggregationInput[]
    by: CurrencyScalarFieldEnum[] | CurrencyScalarFieldEnum
    having?: CurrencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyCountAggregateInputType | true
    _avg?: CurrencyAvgAggregateInputType
    _sum?: CurrencySumAggregateInputType
    _min?: CurrencyMinAggregateInputType
    _max?: CurrencyMaxAggregateInputType
  }

  export type CurrencyGroupByOutputType = {
    id: string
    symbol: string
    decimals: number
    kind: $Enums.CurrencyKind
    tokenAddress: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends CurrencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
        }
      >
    >


  export type CurrencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    decimals?: boolean
    kind?: boolean
    tokenAddress?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    auctions?: boolean | Currency$auctionsArgs<ExtArgs>
    bids?: boolean | Currency$bidsArgs<ExtArgs>
    holderRewards?: boolean | Currency$holderRewardsArgs<ExtArgs>
    listings?: boolean | Currency$listingsArgs<ExtArgs>
    sales?: boolean | Currency$salesArgs<ExtArgs>
    rewardAccumulators?: boolean | Currency$rewardAccumulatorsArgs<ExtArgs>
    claimLogs?: boolean | Currency$claimLogsArgs<ExtArgs>
    distributionLogs?: boolean | Currency$distributionLogsArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    decimals?: boolean
    kind?: boolean
    tokenAddress?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    symbol?: boolean
    decimals?: boolean
    kind?: boolean
    tokenAddress?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["currency"]>

  export type CurrencySelectScalar = {
    id?: boolean
    symbol?: boolean
    decimals?: boolean
    kind?: boolean
    tokenAddress?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CurrencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "symbol" | "decimals" | "kind" | "tokenAddress" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["currency"]>
  export type CurrencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    auctions?: boolean | Currency$auctionsArgs<ExtArgs>
    bids?: boolean | Currency$bidsArgs<ExtArgs>
    holderRewards?: boolean | Currency$holderRewardsArgs<ExtArgs>
    listings?: boolean | Currency$listingsArgs<ExtArgs>
    sales?: boolean | Currency$salesArgs<ExtArgs>
    rewardAccumulators?: boolean | Currency$rewardAccumulatorsArgs<ExtArgs>
    claimLogs?: boolean | Currency$claimLogsArgs<ExtArgs>
    distributionLogs?: boolean | Currency$distributionLogsArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CurrencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CurrencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CurrencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Currency"
    objects: {
      auctions: Prisma.$AuctionPayload<ExtArgs>[]
      bids: Prisma.$AuctionBidPayload<ExtArgs>[]
      holderRewards: Prisma.$HolderRewardMultiPayload<ExtArgs>[]
      listings: Prisma.$MarketplaceListingPayload<ExtArgs>[]
      sales: Prisma.$MarketplaceSalePayload<ExtArgs>[]
      rewardAccumulators: Prisma.$RewardAccumulatorMultiPayload<ExtArgs> | null
      claimLogs: Prisma.$RewardClaimLogPayload<ExtArgs>[]
      distributionLogs: Prisma.$RewardDistributionLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      symbol: string
      decimals: number
      kind: $Enums.CurrencyKind
      tokenAddress: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["currency"]>
    composites: {}
  }

  type CurrencyGetPayload<S extends boolean | null | undefined | CurrencyDefaultArgs> = $Result.GetResult<Prisma.$CurrencyPayload, S>

  type CurrencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CurrencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrencyCountAggregateInputType | true
    }

  export interface CurrencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Currency'], meta: { name: 'Currency' } }
    /**
     * Find zero or one Currency that matches the filter.
     * @param {CurrencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CurrencyFindUniqueArgs>(args: SelectSubset<T, CurrencyFindUniqueArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Currency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CurrencyFindUniqueOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CurrencyFindUniqueOrThrowArgs>(args: SelectSubset<T, CurrencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CurrencyFindFirstArgs>(args?: SelectSubset<T, CurrencyFindFirstArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindFirstOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CurrencyFindFirstOrThrowArgs>(args?: SelectSubset<T, CurrencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currencyWithIdOnly = await prisma.currency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CurrencyFindManyArgs>(args?: SelectSubset<T, CurrencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Currency.
     * @param {CurrencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
     */
    create<T extends CurrencyCreateArgs>(args: SelectSubset<T, CurrencyCreateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Currencies.
     * @param {CurrencyCreateManyArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CurrencyCreateManyArgs>(args?: SelectSubset<T, CurrencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Currencies and returns the data saved in the database.
     * @param {CurrencyCreateManyAndReturnArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CurrencyCreateManyAndReturnArgs>(args?: SelectSubset<T, CurrencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Currency.
     * @param {CurrencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
     */
    delete<T extends CurrencyDeleteArgs>(args: SelectSubset<T, CurrencyDeleteArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Currency.
     * @param {CurrencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CurrencyUpdateArgs>(args: SelectSubset<T, CurrencyUpdateArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Currencies.
     * @param {CurrencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CurrencyDeleteManyArgs>(args?: SelectSubset<T, CurrencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CurrencyUpdateManyArgs>(args: SelectSubset<T, CurrencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies and returns the data updated in the database.
     * @param {CurrencyUpdateManyAndReturnArgs} args - Arguments to update many Currencies.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Currencies and only return the `id`
     * const currencyWithIdOnly = await prisma.currency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CurrencyUpdateManyAndReturnArgs>(args: SelectSubset<T, CurrencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Currency.
     * @param {CurrencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
     */
    upsert<T extends CurrencyUpsertArgs>(args: SelectSubset<T, CurrencyUpsertArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends CurrencyCountArgs>(
      args?: Subset<T, CurrencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): Prisma.PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrencyGroupByArgs['orderBy'] }
        : { orderBy?: CurrencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Currency model
   */
  readonly fields: CurrencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CurrencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    auctions<T extends Currency$auctionsArgs<ExtArgs> = {}>(args?: Subset<T, Currency$auctionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bids<T extends Currency$bidsArgs<ExtArgs> = {}>(args?: Subset<T, Currency$bidsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuctionBidPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    holderRewards<T extends Currency$holderRewardsArgs<ExtArgs> = {}>(args?: Subset<T, Currency$holderRewardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolderRewardMultiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listings<T extends Currency$listingsArgs<ExtArgs> = {}>(args?: Subset<T, Currency$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends Currency$salesArgs<ExtArgs> = {}>(args?: Subset<T, Currency$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rewardAccumulators<T extends Currency$rewardAccumulatorsArgs<ExtArgs> = {}>(args?: Subset<T, Currency$rewardAccumulatorsArgs<ExtArgs>>): Prisma__RewardAccumulatorMultiClient<$Result.GetResult<Prisma.$RewardAccumulatorMultiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    claimLogs<T extends Currency$claimLogsArgs<ExtArgs> = {}>(args?: Subset<T, Currency$claimLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardClaimLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    distributionLogs<T extends Currency$distributionLogsArgs<ExtArgs> = {}>(args?: Subset<T, Currency$distributionLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardDistributionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Currency model
   */
  interface CurrencyFieldRefs {
    readonly id: FieldRef<"Currency", 'String'>
    readonly symbol: FieldRef<"Currency", 'String'>
    readonly decimals: FieldRef<"Currency", 'Int'>
    readonly kind: FieldRef<"Currency", 'CurrencyKind'>
    readonly tokenAddress: FieldRef<"Currency", 'String'>
    readonly active: FieldRef<"Currency", 'Boolean'>
    readonly createdAt: FieldRef<"Currency", 'DateTime'>
    readonly updatedAt: FieldRef<"Currency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Currency findUnique
   */
  export type CurrencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findUniqueOrThrow
   */
  export type CurrencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency findFirst
   */
  export type CurrencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findFirstOrThrow
   */
  export type CurrencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currency to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency findMany
   */
  export type CurrencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter, which Currencies to fetch.
     */
    where?: CurrencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Currencies to fetch.
     */
    orderBy?: CurrencyOrderByWithRelationInput | CurrencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Currencies.
     */
    cursor?: CurrencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Currencies.
     */
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * Currency create
   */
  export type CurrencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Currency.
     */
    data: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
  }

  /**
   * Currency createMany
   */
  export type CurrencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency createManyAndReturn
   */
  export type CurrencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to create many Currencies.
     */
    data: CurrencyCreateManyInput | CurrencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Currency update
   */
  export type CurrencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Currency.
     */
    data: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
    /**
     * Choose, which Currency to update.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency updateMany
   */
  export type CurrencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency updateManyAndReturn
   */
  export type CurrencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * The data used to update Currencies.
     */
    data: XOR<CurrencyUpdateManyMutationInput, CurrencyUncheckedUpdateManyInput>
    /**
     * Filter which Currencies to update
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to update.
     */
    limit?: number
  }

  /**
   * Currency upsert
   */
  export type CurrencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Currency to update in case it exists.
     */
    where: CurrencyWhereUniqueInput
    /**
     * In case the Currency found by the `where` argument doesn't exist, create a new Currency with this data.
     */
    create: XOR<CurrencyCreateInput, CurrencyUncheckedCreateInput>
    /**
     * In case the Currency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrencyUpdateInput, CurrencyUncheckedUpdateInput>
  }

  /**
   * Currency delete
   */
  export type CurrencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    /**
     * Filter which Currency to delete.
     */
    where: CurrencyWhereUniqueInput
  }

  /**
   * Currency deleteMany
   */
  export type CurrencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Currencies to delete
     */
    where?: CurrencyWhereInput
    /**
     * Limit how many Currencies to delete.
     */
    limit?: number
  }

  /**
   * Currency.auctions
   */
  export type Currency$auctionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Auction
     */
    select?: AuctionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Auction
     */
    omit?: AuctionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionInclude<ExtArgs> | null
    where?: AuctionWhereInput
    orderBy?: AuctionOrderByWithRelationInput | AuctionOrderByWithRelationInput[]
    cursor?: AuctionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionScalarFieldEnum | AuctionScalarFieldEnum[]
  }

  /**
   * Currency.bids
   */
  export type Currency$bidsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuctionBid
     */
    select?: AuctionBidSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuctionBid
     */
    omit?: AuctionBidOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuctionBidInclude<ExtArgs> | null
    where?: AuctionBidWhereInput
    orderBy?: AuctionBidOrderByWithRelationInput | AuctionBidOrderByWithRelationInput[]
    cursor?: AuctionBidWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuctionBidScalarFieldEnum | AuctionBidScalarFieldEnum[]
  }

  /**
   * Currency.holderRewards
   */
  export type Currency$holderRewardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderRewardMulti
     */
    select?: HolderRewardMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderRewardMulti
     */
    omit?: HolderRewardMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolderRewardMultiInclude<ExtArgs> | null
    where?: HolderRewardMultiWhereInput
    orderBy?: HolderRewardMultiOrderByWithRelationInput | HolderRewardMultiOrderByWithRelationInput[]
    cursor?: HolderRewardMultiWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HolderRewardMultiScalarFieldEnum | HolderRewardMultiScalarFieldEnum[]
  }

  /**
   * Currency.listings
   */
  export type Currency$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceListing
     */
    select?: MarketplaceListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceListing
     */
    omit?: MarketplaceListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceListingInclude<ExtArgs> | null
    where?: MarketplaceListingWhereInput
    orderBy?: MarketplaceListingOrderByWithRelationInput | MarketplaceListingOrderByWithRelationInput[]
    cursor?: MarketplaceListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketplaceListingScalarFieldEnum | MarketplaceListingScalarFieldEnum[]
  }

  /**
   * Currency.sales
   */
  export type Currency$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceSale
     */
    select?: MarketplaceSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceSale
     */
    omit?: MarketplaceSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceSaleInclude<ExtArgs> | null
    where?: MarketplaceSaleWhereInput
    orderBy?: MarketplaceSaleOrderByWithRelationInput | MarketplaceSaleOrderByWithRelationInput[]
    cursor?: MarketplaceSaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketplaceSaleScalarFieldEnum | MarketplaceSaleScalarFieldEnum[]
  }

  /**
   * Currency.rewardAccumulators
   */
  export type Currency$rewardAccumulatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulatorMulti
     */
    select?: RewardAccumulatorMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulatorMulti
     */
    omit?: RewardAccumulatorMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccumulatorMultiInclude<ExtArgs> | null
    where?: RewardAccumulatorMultiWhereInput
  }

  /**
   * Currency.claimLogs
   */
  export type Currency$claimLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaimLog
     */
    select?: RewardClaimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaimLog
     */
    omit?: RewardClaimLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimLogInclude<ExtArgs> | null
    where?: RewardClaimLogWhereInput
    orderBy?: RewardClaimLogOrderByWithRelationInput | RewardClaimLogOrderByWithRelationInput[]
    cursor?: RewardClaimLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardClaimLogScalarFieldEnum | RewardClaimLogScalarFieldEnum[]
  }

  /**
   * Currency.distributionLogs
   */
  export type Currency$distributionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDistributionLog
     */
    select?: RewardDistributionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDistributionLog
     */
    omit?: RewardDistributionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDistributionLogInclude<ExtArgs> | null
    where?: RewardDistributionLogWhereInput
    orderBy?: RewardDistributionLogOrderByWithRelationInput | RewardDistributionLogOrderByWithRelationInput[]
    cursor?: RewardDistributionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardDistributionLogScalarFieldEnum | RewardDistributionLogScalarFieldEnum[]
  }

  /**
   * Currency without action
   */
  export type CurrencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
  }


  /**
   * Model MarketplaceSale
   */

  export type AggregateMarketplaceSale = {
    _count: MarketplaceSaleCountAggregateOutputType | null
    _avg: MarketplaceSaleAvgAggregateOutputType | null
    _sum: MarketplaceSaleSumAggregateOutputType | null
    _min: MarketplaceSaleMinAggregateOutputType | null
    _max: MarketplaceSaleMaxAggregateOutputType | null
  }

  export type MarketplaceSaleAvgAggregateOutputType = {
    quantity: number | null
    priceEtnWei: Decimal | null
    royaltyPaidWei: Decimal | null
    marketplaceFeePaidWei: Decimal | null
    priceTokenAmount: Decimal | null
    royaltyPaidTokenAmount: Decimal | null
    feePaidTokenAmount: Decimal | null
    logIndex: number | null
    blockNumber: number | null
  }

  export type MarketplaceSaleSumAggregateOutputType = {
    quantity: number | null
    priceEtnWei: Decimal | null
    royaltyPaidWei: Decimal | null
    marketplaceFeePaidWei: Decimal | null
    priceTokenAmount: Decimal | null
    royaltyPaidTokenAmount: Decimal | null
    feePaidTokenAmount: Decimal | null
    logIndex: number | null
    blockNumber: number | null
  }

  export type MarketplaceSaleMinAggregateOutputType = {
    id: string | null
    nftId: string | null
    buyerAddress: string | null
    sellerAddress: string | null
    quantity: number | null
    priceEtnWei: Decimal | null
    royaltyPaidWei: Decimal | null
    marketplaceFeePaidWei: Decimal | null
    currencyId: string | null
    priceTokenAmount: Decimal | null
    royaltyPaidTokenAmount: Decimal | null
    feePaidTokenAmount: Decimal | null
    royaltyRecipient: string | null
    marketplaceFeeRecipient: string | null
    txHash: string | null
    logIndex: number | null
    blockNumber: number | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type MarketplaceSaleMaxAggregateOutputType = {
    id: string | null
    nftId: string | null
    buyerAddress: string | null
    sellerAddress: string | null
    quantity: number | null
    priceEtnWei: Decimal | null
    royaltyPaidWei: Decimal | null
    marketplaceFeePaidWei: Decimal | null
    currencyId: string | null
    priceTokenAmount: Decimal | null
    royaltyPaidTokenAmount: Decimal | null
    feePaidTokenAmount: Decimal | null
    royaltyRecipient: string | null
    marketplaceFeeRecipient: string | null
    txHash: string | null
    logIndex: number | null
    blockNumber: number | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type MarketplaceSaleCountAggregateOutputType = {
    id: number
    nftId: number
    buyerAddress: number
    sellerAddress: number
    quantity: number
    priceEtnWei: number
    royaltyPaidWei: number
    marketplaceFeePaidWei: number
    currencyId: number
    priceTokenAmount: number
    royaltyPaidTokenAmount: number
    feePaidTokenAmount: number
    royaltyRecipient: number
    marketplaceFeeRecipient: number
    txHash: number
    logIndex: number
    blockNumber: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type MarketplaceSaleAvgAggregateInputType = {
    quantity?: true
    priceEtnWei?: true
    royaltyPaidWei?: true
    marketplaceFeePaidWei?: true
    priceTokenAmount?: true
    royaltyPaidTokenAmount?: true
    feePaidTokenAmount?: true
    logIndex?: true
    blockNumber?: true
  }

  export type MarketplaceSaleSumAggregateInputType = {
    quantity?: true
    priceEtnWei?: true
    royaltyPaidWei?: true
    marketplaceFeePaidWei?: true
    priceTokenAmount?: true
    royaltyPaidTokenAmount?: true
    feePaidTokenAmount?: true
    logIndex?: true
    blockNumber?: true
  }

  export type MarketplaceSaleMinAggregateInputType = {
    id?: true
    nftId?: true
    buyerAddress?: true
    sellerAddress?: true
    quantity?: true
    priceEtnWei?: true
    royaltyPaidWei?: true
    marketplaceFeePaidWei?: true
    currencyId?: true
    priceTokenAmount?: true
    royaltyPaidTokenAmount?: true
    feePaidTokenAmount?: true
    royaltyRecipient?: true
    marketplaceFeeRecipient?: true
    txHash?: true
    logIndex?: true
    blockNumber?: true
    timestamp?: true
    createdAt?: true
  }

  export type MarketplaceSaleMaxAggregateInputType = {
    id?: true
    nftId?: true
    buyerAddress?: true
    sellerAddress?: true
    quantity?: true
    priceEtnWei?: true
    royaltyPaidWei?: true
    marketplaceFeePaidWei?: true
    currencyId?: true
    priceTokenAmount?: true
    royaltyPaidTokenAmount?: true
    feePaidTokenAmount?: true
    royaltyRecipient?: true
    marketplaceFeeRecipient?: true
    txHash?: true
    logIndex?: true
    blockNumber?: true
    timestamp?: true
    createdAt?: true
  }

  export type MarketplaceSaleCountAggregateInputType = {
    id?: true
    nftId?: true
    buyerAddress?: true
    sellerAddress?: true
    quantity?: true
    priceEtnWei?: true
    royaltyPaidWei?: true
    marketplaceFeePaidWei?: true
    currencyId?: true
    priceTokenAmount?: true
    royaltyPaidTokenAmount?: true
    feePaidTokenAmount?: true
    royaltyRecipient?: true
    marketplaceFeeRecipient?: true
    txHash?: true
    logIndex?: true
    blockNumber?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type MarketplaceSaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceSale to aggregate.
     */
    where?: MarketplaceSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceSales to fetch.
     */
    orderBy?: MarketplaceSaleOrderByWithRelationInput | MarketplaceSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketplaceSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketplaceSales
    **/
    _count?: true | MarketplaceSaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketplaceSaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketplaceSaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketplaceSaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketplaceSaleMaxAggregateInputType
  }

  export type GetMarketplaceSaleAggregateType<T extends MarketplaceSaleAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketplaceSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketplaceSale[P]>
      : GetScalarType<T[P], AggregateMarketplaceSale[P]>
  }




  export type MarketplaceSaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceSaleWhereInput
    orderBy?: MarketplaceSaleOrderByWithAggregationInput | MarketplaceSaleOrderByWithAggregationInput[]
    by: MarketplaceSaleScalarFieldEnum[] | MarketplaceSaleScalarFieldEnum
    having?: MarketplaceSaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketplaceSaleCountAggregateInputType | true
    _avg?: MarketplaceSaleAvgAggregateInputType
    _sum?: MarketplaceSaleSumAggregateInputType
    _min?: MarketplaceSaleMinAggregateInputType
    _max?: MarketplaceSaleMaxAggregateInputType
  }

  export type MarketplaceSaleGroupByOutputType = {
    id: string
    nftId: string
    buyerAddress: string
    sellerAddress: string
    quantity: number
    priceEtnWei: Decimal
    royaltyPaidWei: Decimal | null
    marketplaceFeePaidWei: Decimal | null
    currencyId: string | null
    priceTokenAmount: Decimal | null
    royaltyPaidTokenAmount: Decimal | null
    feePaidTokenAmount: Decimal | null
    royaltyRecipient: string | null
    marketplaceFeeRecipient: string | null
    txHash: string
    logIndex: number
    blockNumber: number
    timestamp: Date
    createdAt: Date
    _count: MarketplaceSaleCountAggregateOutputType | null
    _avg: MarketplaceSaleAvgAggregateOutputType | null
    _sum: MarketplaceSaleSumAggregateOutputType | null
    _min: MarketplaceSaleMinAggregateOutputType | null
    _max: MarketplaceSaleMaxAggregateOutputType | null
  }

  type GetMarketplaceSaleGroupByPayload<T extends MarketplaceSaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketplaceSaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketplaceSaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketplaceSaleGroupByOutputType[P]>
            : GetScalarType<T[P], MarketplaceSaleGroupByOutputType[P]>
        }
      >
    >


  export type MarketplaceSaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nftId?: boolean
    buyerAddress?: boolean
    sellerAddress?: boolean
    quantity?: boolean
    priceEtnWei?: boolean
    royaltyPaidWei?: boolean
    marketplaceFeePaidWei?: boolean
    currencyId?: boolean
    priceTokenAmount?: boolean
    royaltyPaidTokenAmount?: boolean
    feePaidTokenAmount?: boolean
    royaltyRecipient?: boolean
    marketplaceFeeRecipient?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    createdAt?: boolean
    currency?: boolean | MarketplaceSale$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceSale"]>

  export type MarketplaceSaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nftId?: boolean
    buyerAddress?: boolean
    sellerAddress?: boolean
    quantity?: boolean
    priceEtnWei?: boolean
    royaltyPaidWei?: boolean
    marketplaceFeePaidWei?: boolean
    currencyId?: boolean
    priceTokenAmount?: boolean
    royaltyPaidTokenAmount?: boolean
    feePaidTokenAmount?: boolean
    royaltyRecipient?: boolean
    marketplaceFeeRecipient?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    createdAt?: boolean
    currency?: boolean | MarketplaceSale$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceSale"]>

  export type MarketplaceSaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nftId?: boolean
    buyerAddress?: boolean
    sellerAddress?: boolean
    quantity?: boolean
    priceEtnWei?: boolean
    royaltyPaidWei?: boolean
    marketplaceFeePaidWei?: boolean
    currencyId?: boolean
    priceTokenAmount?: boolean
    royaltyPaidTokenAmount?: boolean
    feePaidTokenAmount?: boolean
    royaltyRecipient?: boolean
    marketplaceFeeRecipient?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    createdAt?: boolean
    currency?: boolean | MarketplaceSale$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceSale"]>

  export type MarketplaceSaleSelectScalar = {
    id?: boolean
    nftId?: boolean
    buyerAddress?: boolean
    sellerAddress?: boolean
    quantity?: boolean
    priceEtnWei?: boolean
    royaltyPaidWei?: boolean
    marketplaceFeePaidWei?: boolean
    currencyId?: boolean
    priceTokenAmount?: boolean
    royaltyPaidTokenAmount?: boolean
    feePaidTokenAmount?: boolean
    royaltyRecipient?: boolean
    marketplaceFeeRecipient?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }

  export type MarketplaceSaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nftId" | "buyerAddress" | "sellerAddress" | "quantity" | "priceEtnWei" | "royaltyPaidWei" | "marketplaceFeePaidWei" | "currencyId" | "priceTokenAmount" | "royaltyPaidTokenAmount" | "feePaidTokenAmount" | "royaltyRecipient" | "marketplaceFeeRecipient" | "txHash" | "logIndex" | "blockNumber" | "timestamp" | "createdAt", ExtArgs["result"]["marketplaceSale"]>
  export type MarketplaceSaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | MarketplaceSale$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }
  export type MarketplaceSaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | MarketplaceSale$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }
  export type MarketplaceSaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | MarketplaceSale$currencyArgs<ExtArgs>
    nft?: boolean | NFTDefaultArgs<ExtArgs>
  }

  export type $MarketplaceSalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketplaceSale"
    objects: {
      currency: Prisma.$CurrencyPayload<ExtArgs> | null
      nft: Prisma.$NFTPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nftId: string
      buyerAddress: string
      sellerAddress: string
      quantity: number
      priceEtnWei: Prisma.Decimal
      royaltyPaidWei: Prisma.Decimal | null
      marketplaceFeePaidWei: Prisma.Decimal | null
      currencyId: string | null
      priceTokenAmount: Prisma.Decimal | null
      royaltyPaidTokenAmount: Prisma.Decimal | null
      feePaidTokenAmount: Prisma.Decimal | null
      royaltyRecipient: string | null
      marketplaceFeeRecipient: string | null
      txHash: string
      logIndex: number
      blockNumber: number
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["marketplaceSale"]>
    composites: {}
  }

  type MarketplaceSaleGetPayload<S extends boolean | null | undefined | MarketplaceSaleDefaultArgs> = $Result.GetResult<Prisma.$MarketplaceSalePayload, S>

  type MarketplaceSaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketplaceSaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketplaceSaleCountAggregateInputType | true
    }

  export interface MarketplaceSaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketplaceSale'], meta: { name: 'MarketplaceSale' } }
    /**
     * Find zero or one MarketplaceSale that matches the filter.
     * @param {MarketplaceSaleFindUniqueArgs} args - Arguments to find a MarketplaceSale
     * @example
     * // Get one MarketplaceSale
     * const marketplaceSale = await prisma.marketplaceSale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketplaceSaleFindUniqueArgs>(args: SelectSubset<T, MarketplaceSaleFindUniqueArgs<ExtArgs>>): Prisma__MarketplaceSaleClient<$Result.GetResult<Prisma.$MarketplaceSalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketplaceSale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketplaceSaleFindUniqueOrThrowArgs} args - Arguments to find a MarketplaceSale
     * @example
     * // Get one MarketplaceSale
     * const marketplaceSale = await prisma.marketplaceSale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketplaceSaleFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketplaceSaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketplaceSaleClient<$Result.GetResult<Prisma.$MarketplaceSalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketplaceSale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceSaleFindFirstArgs} args - Arguments to find a MarketplaceSale
     * @example
     * // Get one MarketplaceSale
     * const marketplaceSale = await prisma.marketplaceSale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketplaceSaleFindFirstArgs>(args?: SelectSubset<T, MarketplaceSaleFindFirstArgs<ExtArgs>>): Prisma__MarketplaceSaleClient<$Result.GetResult<Prisma.$MarketplaceSalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketplaceSale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceSaleFindFirstOrThrowArgs} args - Arguments to find a MarketplaceSale
     * @example
     * // Get one MarketplaceSale
     * const marketplaceSale = await prisma.marketplaceSale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketplaceSaleFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketplaceSaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketplaceSaleClient<$Result.GetResult<Prisma.$MarketplaceSalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketplaceSales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceSaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketplaceSales
     * const marketplaceSales = await prisma.marketplaceSale.findMany()
     * 
     * // Get first 10 MarketplaceSales
     * const marketplaceSales = await prisma.marketplaceSale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketplaceSaleWithIdOnly = await prisma.marketplaceSale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketplaceSaleFindManyArgs>(args?: SelectSubset<T, MarketplaceSaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceSalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketplaceSale.
     * @param {MarketplaceSaleCreateArgs} args - Arguments to create a MarketplaceSale.
     * @example
     * // Create one MarketplaceSale
     * const MarketplaceSale = await prisma.marketplaceSale.create({
     *   data: {
     *     // ... data to create a MarketplaceSale
     *   }
     * })
     * 
     */
    create<T extends MarketplaceSaleCreateArgs>(args: SelectSubset<T, MarketplaceSaleCreateArgs<ExtArgs>>): Prisma__MarketplaceSaleClient<$Result.GetResult<Prisma.$MarketplaceSalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketplaceSales.
     * @param {MarketplaceSaleCreateManyArgs} args - Arguments to create many MarketplaceSales.
     * @example
     * // Create many MarketplaceSales
     * const marketplaceSale = await prisma.marketplaceSale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketplaceSaleCreateManyArgs>(args?: SelectSubset<T, MarketplaceSaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketplaceSales and returns the data saved in the database.
     * @param {MarketplaceSaleCreateManyAndReturnArgs} args - Arguments to create many MarketplaceSales.
     * @example
     * // Create many MarketplaceSales
     * const marketplaceSale = await prisma.marketplaceSale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketplaceSales and only return the `id`
     * const marketplaceSaleWithIdOnly = await prisma.marketplaceSale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketplaceSaleCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketplaceSaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceSalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketplaceSale.
     * @param {MarketplaceSaleDeleteArgs} args - Arguments to delete one MarketplaceSale.
     * @example
     * // Delete one MarketplaceSale
     * const MarketplaceSale = await prisma.marketplaceSale.delete({
     *   where: {
     *     // ... filter to delete one MarketplaceSale
     *   }
     * })
     * 
     */
    delete<T extends MarketplaceSaleDeleteArgs>(args: SelectSubset<T, MarketplaceSaleDeleteArgs<ExtArgs>>): Prisma__MarketplaceSaleClient<$Result.GetResult<Prisma.$MarketplaceSalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketplaceSale.
     * @param {MarketplaceSaleUpdateArgs} args - Arguments to update one MarketplaceSale.
     * @example
     * // Update one MarketplaceSale
     * const marketplaceSale = await prisma.marketplaceSale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketplaceSaleUpdateArgs>(args: SelectSubset<T, MarketplaceSaleUpdateArgs<ExtArgs>>): Prisma__MarketplaceSaleClient<$Result.GetResult<Prisma.$MarketplaceSalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketplaceSales.
     * @param {MarketplaceSaleDeleteManyArgs} args - Arguments to filter MarketplaceSales to delete.
     * @example
     * // Delete a few MarketplaceSales
     * const { count } = await prisma.marketplaceSale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketplaceSaleDeleteManyArgs>(args?: SelectSubset<T, MarketplaceSaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceSaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketplaceSales
     * const marketplaceSale = await prisma.marketplaceSale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketplaceSaleUpdateManyArgs>(args: SelectSubset<T, MarketplaceSaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceSales and returns the data updated in the database.
     * @param {MarketplaceSaleUpdateManyAndReturnArgs} args - Arguments to update many MarketplaceSales.
     * @example
     * // Update many MarketplaceSales
     * const marketplaceSale = await prisma.marketplaceSale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketplaceSales and only return the `id`
     * const marketplaceSaleWithIdOnly = await prisma.marketplaceSale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketplaceSaleUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketplaceSaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceSalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketplaceSale.
     * @param {MarketplaceSaleUpsertArgs} args - Arguments to update or create a MarketplaceSale.
     * @example
     * // Update or create a MarketplaceSale
     * const marketplaceSale = await prisma.marketplaceSale.upsert({
     *   create: {
     *     // ... data to create a MarketplaceSale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketplaceSale we want to update
     *   }
     * })
     */
    upsert<T extends MarketplaceSaleUpsertArgs>(args: SelectSubset<T, MarketplaceSaleUpsertArgs<ExtArgs>>): Prisma__MarketplaceSaleClient<$Result.GetResult<Prisma.$MarketplaceSalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketplaceSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceSaleCountArgs} args - Arguments to filter MarketplaceSales to count.
     * @example
     * // Count the number of MarketplaceSales
     * const count = await prisma.marketplaceSale.count({
     *   where: {
     *     // ... the filter for the MarketplaceSales we want to count
     *   }
     * })
    **/
    count<T extends MarketplaceSaleCountArgs>(
      args?: Subset<T, MarketplaceSaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketplaceSaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketplaceSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceSaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketplaceSaleAggregateArgs>(args: Subset<T, MarketplaceSaleAggregateArgs>): Prisma.PrismaPromise<GetMarketplaceSaleAggregateType<T>>

    /**
     * Group by MarketplaceSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceSaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketplaceSaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketplaceSaleGroupByArgs['orderBy'] }
        : { orderBy?: MarketplaceSaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketplaceSaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketplaceSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketplaceSale model
   */
  readonly fields: MarketplaceSaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketplaceSale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketplaceSaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currency<T extends MarketplaceSale$currencyArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceSale$currencyArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    nft<T extends NFTDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NFTDefaultArgs<ExtArgs>>): Prisma__NFTClient<$Result.GetResult<Prisma.$NFTPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketplaceSale model
   */
  interface MarketplaceSaleFieldRefs {
    readonly id: FieldRef<"MarketplaceSale", 'String'>
    readonly nftId: FieldRef<"MarketplaceSale", 'String'>
    readonly buyerAddress: FieldRef<"MarketplaceSale", 'String'>
    readonly sellerAddress: FieldRef<"MarketplaceSale", 'String'>
    readonly quantity: FieldRef<"MarketplaceSale", 'Int'>
    readonly priceEtnWei: FieldRef<"MarketplaceSale", 'Decimal'>
    readonly royaltyPaidWei: FieldRef<"MarketplaceSale", 'Decimal'>
    readonly marketplaceFeePaidWei: FieldRef<"MarketplaceSale", 'Decimal'>
    readonly currencyId: FieldRef<"MarketplaceSale", 'String'>
    readonly priceTokenAmount: FieldRef<"MarketplaceSale", 'Decimal'>
    readonly royaltyPaidTokenAmount: FieldRef<"MarketplaceSale", 'Decimal'>
    readonly feePaidTokenAmount: FieldRef<"MarketplaceSale", 'Decimal'>
    readonly royaltyRecipient: FieldRef<"MarketplaceSale", 'String'>
    readonly marketplaceFeeRecipient: FieldRef<"MarketplaceSale", 'String'>
    readonly txHash: FieldRef<"MarketplaceSale", 'String'>
    readonly logIndex: FieldRef<"MarketplaceSale", 'Int'>
    readonly blockNumber: FieldRef<"MarketplaceSale", 'Int'>
    readonly timestamp: FieldRef<"MarketplaceSale", 'DateTime'>
    readonly createdAt: FieldRef<"MarketplaceSale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketplaceSale findUnique
   */
  export type MarketplaceSaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceSale
     */
    select?: MarketplaceSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceSale
     */
    omit?: MarketplaceSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceSaleInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceSale to fetch.
     */
    where: MarketplaceSaleWhereUniqueInput
  }

  /**
   * MarketplaceSale findUniqueOrThrow
   */
  export type MarketplaceSaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceSale
     */
    select?: MarketplaceSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceSale
     */
    omit?: MarketplaceSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceSaleInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceSale to fetch.
     */
    where: MarketplaceSaleWhereUniqueInput
  }

  /**
   * MarketplaceSale findFirst
   */
  export type MarketplaceSaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceSale
     */
    select?: MarketplaceSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceSale
     */
    omit?: MarketplaceSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceSaleInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceSale to fetch.
     */
    where?: MarketplaceSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceSales to fetch.
     */
    orderBy?: MarketplaceSaleOrderByWithRelationInput | MarketplaceSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceSales.
     */
    cursor?: MarketplaceSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceSales.
     */
    distinct?: MarketplaceSaleScalarFieldEnum | MarketplaceSaleScalarFieldEnum[]
  }

  /**
   * MarketplaceSale findFirstOrThrow
   */
  export type MarketplaceSaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceSale
     */
    select?: MarketplaceSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceSale
     */
    omit?: MarketplaceSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceSaleInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceSale to fetch.
     */
    where?: MarketplaceSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceSales to fetch.
     */
    orderBy?: MarketplaceSaleOrderByWithRelationInput | MarketplaceSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceSales.
     */
    cursor?: MarketplaceSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceSales.
     */
    distinct?: MarketplaceSaleScalarFieldEnum | MarketplaceSaleScalarFieldEnum[]
  }

  /**
   * MarketplaceSale findMany
   */
  export type MarketplaceSaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceSale
     */
    select?: MarketplaceSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceSale
     */
    omit?: MarketplaceSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceSaleInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceSales to fetch.
     */
    where?: MarketplaceSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceSales to fetch.
     */
    orderBy?: MarketplaceSaleOrderByWithRelationInput | MarketplaceSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketplaceSales.
     */
    cursor?: MarketplaceSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceSales.
     */
    skip?: number
    distinct?: MarketplaceSaleScalarFieldEnum | MarketplaceSaleScalarFieldEnum[]
  }

  /**
   * MarketplaceSale create
   */
  export type MarketplaceSaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceSale
     */
    select?: MarketplaceSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceSale
     */
    omit?: MarketplaceSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceSaleInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketplaceSale.
     */
    data: XOR<MarketplaceSaleCreateInput, MarketplaceSaleUncheckedCreateInput>
  }

  /**
   * MarketplaceSale createMany
   */
  export type MarketplaceSaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketplaceSales.
     */
    data: MarketplaceSaleCreateManyInput | MarketplaceSaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketplaceSale createManyAndReturn
   */
  export type MarketplaceSaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceSale
     */
    select?: MarketplaceSaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceSale
     */
    omit?: MarketplaceSaleOmit<ExtArgs> | null
    /**
     * The data used to create many MarketplaceSales.
     */
    data: MarketplaceSaleCreateManyInput | MarketplaceSaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceSaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketplaceSale update
   */
  export type MarketplaceSaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceSale
     */
    select?: MarketplaceSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceSale
     */
    omit?: MarketplaceSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceSaleInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketplaceSale.
     */
    data: XOR<MarketplaceSaleUpdateInput, MarketplaceSaleUncheckedUpdateInput>
    /**
     * Choose, which MarketplaceSale to update.
     */
    where: MarketplaceSaleWhereUniqueInput
  }

  /**
   * MarketplaceSale updateMany
   */
  export type MarketplaceSaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketplaceSales.
     */
    data: XOR<MarketplaceSaleUpdateManyMutationInput, MarketplaceSaleUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceSales to update
     */
    where?: MarketplaceSaleWhereInput
    /**
     * Limit how many MarketplaceSales to update.
     */
    limit?: number
  }

  /**
   * MarketplaceSale updateManyAndReturn
   */
  export type MarketplaceSaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceSale
     */
    select?: MarketplaceSaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceSale
     */
    omit?: MarketplaceSaleOmit<ExtArgs> | null
    /**
     * The data used to update MarketplaceSales.
     */
    data: XOR<MarketplaceSaleUpdateManyMutationInput, MarketplaceSaleUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceSales to update
     */
    where?: MarketplaceSaleWhereInput
    /**
     * Limit how many MarketplaceSales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceSaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketplaceSale upsert
   */
  export type MarketplaceSaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceSale
     */
    select?: MarketplaceSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceSale
     */
    omit?: MarketplaceSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceSaleInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketplaceSale to update in case it exists.
     */
    where: MarketplaceSaleWhereUniqueInput
    /**
     * In case the MarketplaceSale found by the `where` argument doesn't exist, create a new MarketplaceSale with this data.
     */
    create: XOR<MarketplaceSaleCreateInput, MarketplaceSaleUncheckedCreateInput>
    /**
     * In case the MarketplaceSale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketplaceSaleUpdateInput, MarketplaceSaleUncheckedUpdateInput>
  }

  /**
   * MarketplaceSale delete
   */
  export type MarketplaceSaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceSale
     */
    select?: MarketplaceSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceSale
     */
    omit?: MarketplaceSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceSaleInclude<ExtArgs> | null
    /**
     * Filter which MarketplaceSale to delete.
     */
    where: MarketplaceSaleWhereUniqueInput
  }

  /**
   * MarketplaceSale deleteMany
   */
  export type MarketplaceSaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceSales to delete
     */
    where?: MarketplaceSaleWhereInput
    /**
     * Limit how many MarketplaceSales to delete.
     */
    limit?: number
  }

  /**
   * MarketplaceSale.currency
   */
  export type MarketplaceSale$currencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Currency
     */
    select?: CurrencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Currency
     */
    omit?: CurrencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CurrencyInclude<ExtArgs> | null
    where?: CurrencyWhereInput
  }

  /**
   * MarketplaceSale without action
   */
  export type MarketplaceSaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceSale
     */
    select?: MarketplaceSaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketplaceSale
     */
    omit?: MarketplaceSaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceSaleInclude<ExtArgs> | null
  }


  /**
   * Model RewardAccumulatorMulti
   */

  export type AggregateRewardAccumulatorMulti = {
    _count: RewardAccumulatorMultiCountAggregateOutputType | null
    _avg: RewardAccumulatorMultiAvgAggregateOutputType | null
    _sum: RewardAccumulatorMultiSumAggregateOutputType | null
    _min: RewardAccumulatorMultiMinAggregateOutputType | null
    _max: RewardAccumulatorMultiMaxAggregateOutputType | null
  }

  export type RewardAccumulatorMultiAvgAggregateOutputType = {
    accPerToken: Decimal | null
  }

  export type RewardAccumulatorMultiSumAggregateOutputType = {
    accPerToken: Decimal | null
  }

  export type RewardAccumulatorMultiMinAggregateOutputType = {
    id: string | null
    currencyId: string | null
    accPerToken: Decimal | null
    updatedAt: Date | null
  }

  export type RewardAccumulatorMultiMaxAggregateOutputType = {
    id: string | null
    currencyId: string | null
    accPerToken: Decimal | null
    updatedAt: Date | null
  }

  export type RewardAccumulatorMultiCountAggregateOutputType = {
    id: number
    currencyId: number
    accPerToken: number
    updatedAt: number
    _all: number
  }


  export type RewardAccumulatorMultiAvgAggregateInputType = {
    accPerToken?: true
  }

  export type RewardAccumulatorMultiSumAggregateInputType = {
    accPerToken?: true
  }

  export type RewardAccumulatorMultiMinAggregateInputType = {
    id?: true
    currencyId?: true
    accPerToken?: true
    updatedAt?: true
  }

  export type RewardAccumulatorMultiMaxAggregateInputType = {
    id?: true
    currencyId?: true
    accPerToken?: true
    updatedAt?: true
  }

  export type RewardAccumulatorMultiCountAggregateInputType = {
    id?: true
    currencyId?: true
    accPerToken?: true
    updatedAt?: true
    _all?: true
  }

  export type RewardAccumulatorMultiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardAccumulatorMulti to aggregate.
     */
    where?: RewardAccumulatorMultiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardAccumulatorMultis to fetch.
     */
    orderBy?: RewardAccumulatorMultiOrderByWithRelationInput | RewardAccumulatorMultiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardAccumulatorMultiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardAccumulatorMultis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardAccumulatorMultis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardAccumulatorMultis
    **/
    _count?: true | RewardAccumulatorMultiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardAccumulatorMultiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardAccumulatorMultiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardAccumulatorMultiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardAccumulatorMultiMaxAggregateInputType
  }

  export type GetRewardAccumulatorMultiAggregateType<T extends RewardAccumulatorMultiAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardAccumulatorMulti]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardAccumulatorMulti[P]>
      : GetScalarType<T[P], AggregateRewardAccumulatorMulti[P]>
  }




  export type RewardAccumulatorMultiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardAccumulatorMultiWhereInput
    orderBy?: RewardAccumulatorMultiOrderByWithAggregationInput | RewardAccumulatorMultiOrderByWithAggregationInput[]
    by: RewardAccumulatorMultiScalarFieldEnum[] | RewardAccumulatorMultiScalarFieldEnum
    having?: RewardAccumulatorMultiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardAccumulatorMultiCountAggregateInputType | true
    _avg?: RewardAccumulatorMultiAvgAggregateInputType
    _sum?: RewardAccumulatorMultiSumAggregateInputType
    _min?: RewardAccumulatorMultiMinAggregateInputType
    _max?: RewardAccumulatorMultiMaxAggregateInputType
  }

  export type RewardAccumulatorMultiGroupByOutputType = {
    id: string
    currencyId: string
    accPerToken: Decimal
    updatedAt: Date
    _count: RewardAccumulatorMultiCountAggregateOutputType | null
    _avg: RewardAccumulatorMultiAvgAggregateOutputType | null
    _sum: RewardAccumulatorMultiSumAggregateOutputType | null
    _min: RewardAccumulatorMultiMinAggregateOutputType | null
    _max: RewardAccumulatorMultiMaxAggregateOutputType | null
  }

  type GetRewardAccumulatorMultiGroupByPayload<T extends RewardAccumulatorMultiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardAccumulatorMultiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardAccumulatorMultiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardAccumulatorMultiGroupByOutputType[P]>
            : GetScalarType<T[P], RewardAccumulatorMultiGroupByOutputType[P]>
        }
      >
    >


  export type RewardAccumulatorMultiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currencyId?: boolean
    accPerToken?: boolean
    updatedAt?: boolean
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardAccumulatorMulti"]>

  export type RewardAccumulatorMultiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currencyId?: boolean
    accPerToken?: boolean
    updatedAt?: boolean
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardAccumulatorMulti"]>

  export type RewardAccumulatorMultiSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currencyId?: boolean
    accPerToken?: boolean
    updatedAt?: boolean
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardAccumulatorMulti"]>

  export type RewardAccumulatorMultiSelectScalar = {
    id?: boolean
    currencyId?: boolean
    accPerToken?: boolean
    updatedAt?: boolean
  }

  export type RewardAccumulatorMultiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "currencyId" | "accPerToken" | "updatedAt", ExtArgs["result"]["rewardAccumulatorMulti"]>
  export type RewardAccumulatorMultiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }
  export type RewardAccumulatorMultiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }
  export type RewardAccumulatorMultiIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }

  export type $RewardAccumulatorMultiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RewardAccumulatorMulti"
    objects: {
      currency: Prisma.$CurrencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      currencyId: string
      accPerToken: Prisma.Decimal
      updatedAt: Date
    }, ExtArgs["result"]["rewardAccumulatorMulti"]>
    composites: {}
  }

  type RewardAccumulatorMultiGetPayload<S extends boolean | null | undefined | RewardAccumulatorMultiDefaultArgs> = $Result.GetResult<Prisma.$RewardAccumulatorMultiPayload, S>

  type RewardAccumulatorMultiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RewardAccumulatorMultiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardAccumulatorMultiCountAggregateInputType | true
    }

  export interface RewardAccumulatorMultiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RewardAccumulatorMulti'], meta: { name: 'RewardAccumulatorMulti' } }
    /**
     * Find zero or one RewardAccumulatorMulti that matches the filter.
     * @param {RewardAccumulatorMultiFindUniqueArgs} args - Arguments to find a RewardAccumulatorMulti
     * @example
     * // Get one RewardAccumulatorMulti
     * const rewardAccumulatorMulti = await prisma.rewardAccumulatorMulti.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardAccumulatorMultiFindUniqueArgs>(args: SelectSubset<T, RewardAccumulatorMultiFindUniqueArgs<ExtArgs>>): Prisma__RewardAccumulatorMultiClient<$Result.GetResult<Prisma.$RewardAccumulatorMultiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RewardAccumulatorMulti that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardAccumulatorMultiFindUniqueOrThrowArgs} args - Arguments to find a RewardAccumulatorMulti
     * @example
     * // Get one RewardAccumulatorMulti
     * const rewardAccumulatorMulti = await prisma.rewardAccumulatorMulti.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardAccumulatorMultiFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardAccumulatorMultiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardAccumulatorMultiClient<$Result.GetResult<Prisma.$RewardAccumulatorMultiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardAccumulatorMulti that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccumulatorMultiFindFirstArgs} args - Arguments to find a RewardAccumulatorMulti
     * @example
     * // Get one RewardAccumulatorMulti
     * const rewardAccumulatorMulti = await prisma.rewardAccumulatorMulti.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardAccumulatorMultiFindFirstArgs>(args?: SelectSubset<T, RewardAccumulatorMultiFindFirstArgs<ExtArgs>>): Prisma__RewardAccumulatorMultiClient<$Result.GetResult<Prisma.$RewardAccumulatorMultiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardAccumulatorMulti that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccumulatorMultiFindFirstOrThrowArgs} args - Arguments to find a RewardAccumulatorMulti
     * @example
     * // Get one RewardAccumulatorMulti
     * const rewardAccumulatorMulti = await prisma.rewardAccumulatorMulti.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardAccumulatorMultiFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardAccumulatorMultiFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardAccumulatorMultiClient<$Result.GetResult<Prisma.$RewardAccumulatorMultiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RewardAccumulatorMultis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccumulatorMultiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardAccumulatorMultis
     * const rewardAccumulatorMultis = await prisma.rewardAccumulatorMulti.findMany()
     * 
     * // Get first 10 RewardAccumulatorMultis
     * const rewardAccumulatorMultis = await prisma.rewardAccumulatorMulti.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardAccumulatorMultiWithIdOnly = await prisma.rewardAccumulatorMulti.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardAccumulatorMultiFindManyArgs>(args?: SelectSubset<T, RewardAccumulatorMultiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardAccumulatorMultiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RewardAccumulatorMulti.
     * @param {RewardAccumulatorMultiCreateArgs} args - Arguments to create a RewardAccumulatorMulti.
     * @example
     * // Create one RewardAccumulatorMulti
     * const RewardAccumulatorMulti = await prisma.rewardAccumulatorMulti.create({
     *   data: {
     *     // ... data to create a RewardAccumulatorMulti
     *   }
     * })
     * 
     */
    create<T extends RewardAccumulatorMultiCreateArgs>(args: SelectSubset<T, RewardAccumulatorMultiCreateArgs<ExtArgs>>): Prisma__RewardAccumulatorMultiClient<$Result.GetResult<Prisma.$RewardAccumulatorMultiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RewardAccumulatorMultis.
     * @param {RewardAccumulatorMultiCreateManyArgs} args - Arguments to create many RewardAccumulatorMultis.
     * @example
     * // Create many RewardAccumulatorMultis
     * const rewardAccumulatorMulti = await prisma.rewardAccumulatorMulti.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardAccumulatorMultiCreateManyArgs>(args?: SelectSubset<T, RewardAccumulatorMultiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RewardAccumulatorMultis and returns the data saved in the database.
     * @param {RewardAccumulatorMultiCreateManyAndReturnArgs} args - Arguments to create many RewardAccumulatorMultis.
     * @example
     * // Create many RewardAccumulatorMultis
     * const rewardAccumulatorMulti = await prisma.rewardAccumulatorMulti.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RewardAccumulatorMultis and only return the `id`
     * const rewardAccumulatorMultiWithIdOnly = await prisma.rewardAccumulatorMulti.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardAccumulatorMultiCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardAccumulatorMultiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardAccumulatorMultiPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RewardAccumulatorMulti.
     * @param {RewardAccumulatorMultiDeleteArgs} args - Arguments to delete one RewardAccumulatorMulti.
     * @example
     * // Delete one RewardAccumulatorMulti
     * const RewardAccumulatorMulti = await prisma.rewardAccumulatorMulti.delete({
     *   where: {
     *     // ... filter to delete one RewardAccumulatorMulti
     *   }
     * })
     * 
     */
    delete<T extends RewardAccumulatorMultiDeleteArgs>(args: SelectSubset<T, RewardAccumulatorMultiDeleteArgs<ExtArgs>>): Prisma__RewardAccumulatorMultiClient<$Result.GetResult<Prisma.$RewardAccumulatorMultiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RewardAccumulatorMulti.
     * @param {RewardAccumulatorMultiUpdateArgs} args - Arguments to update one RewardAccumulatorMulti.
     * @example
     * // Update one RewardAccumulatorMulti
     * const rewardAccumulatorMulti = await prisma.rewardAccumulatorMulti.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardAccumulatorMultiUpdateArgs>(args: SelectSubset<T, RewardAccumulatorMultiUpdateArgs<ExtArgs>>): Prisma__RewardAccumulatorMultiClient<$Result.GetResult<Prisma.$RewardAccumulatorMultiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RewardAccumulatorMultis.
     * @param {RewardAccumulatorMultiDeleteManyArgs} args - Arguments to filter RewardAccumulatorMultis to delete.
     * @example
     * // Delete a few RewardAccumulatorMultis
     * const { count } = await prisma.rewardAccumulatorMulti.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardAccumulatorMultiDeleteManyArgs>(args?: SelectSubset<T, RewardAccumulatorMultiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardAccumulatorMultis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccumulatorMultiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardAccumulatorMultis
     * const rewardAccumulatorMulti = await prisma.rewardAccumulatorMulti.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardAccumulatorMultiUpdateManyArgs>(args: SelectSubset<T, RewardAccumulatorMultiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardAccumulatorMultis and returns the data updated in the database.
     * @param {RewardAccumulatorMultiUpdateManyAndReturnArgs} args - Arguments to update many RewardAccumulatorMultis.
     * @example
     * // Update many RewardAccumulatorMultis
     * const rewardAccumulatorMulti = await prisma.rewardAccumulatorMulti.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RewardAccumulatorMultis and only return the `id`
     * const rewardAccumulatorMultiWithIdOnly = await prisma.rewardAccumulatorMulti.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RewardAccumulatorMultiUpdateManyAndReturnArgs>(args: SelectSubset<T, RewardAccumulatorMultiUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardAccumulatorMultiPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RewardAccumulatorMulti.
     * @param {RewardAccumulatorMultiUpsertArgs} args - Arguments to update or create a RewardAccumulatorMulti.
     * @example
     * // Update or create a RewardAccumulatorMulti
     * const rewardAccumulatorMulti = await prisma.rewardAccumulatorMulti.upsert({
     *   create: {
     *     // ... data to create a RewardAccumulatorMulti
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardAccumulatorMulti we want to update
     *   }
     * })
     */
    upsert<T extends RewardAccumulatorMultiUpsertArgs>(args: SelectSubset<T, RewardAccumulatorMultiUpsertArgs<ExtArgs>>): Prisma__RewardAccumulatorMultiClient<$Result.GetResult<Prisma.$RewardAccumulatorMultiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RewardAccumulatorMultis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccumulatorMultiCountArgs} args - Arguments to filter RewardAccumulatorMultis to count.
     * @example
     * // Count the number of RewardAccumulatorMultis
     * const count = await prisma.rewardAccumulatorMulti.count({
     *   where: {
     *     // ... the filter for the RewardAccumulatorMultis we want to count
     *   }
     * })
    **/
    count<T extends RewardAccumulatorMultiCountArgs>(
      args?: Subset<T, RewardAccumulatorMultiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardAccumulatorMultiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardAccumulatorMulti.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccumulatorMultiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardAccumulatorMultiAggregateArgs>(args: Subset<T, RewardAccumulatorMultiAggregateArgs>): Prisma.PrismaPromise<GetRewardAccumulatorMultiAggregateType<T>>

    /**
     * Group by RewardAccumulatorMulti.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAccumulatorMultiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardAccumulatorMultiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardAccumulatorMultiGroupByArgs['orderBy'] }
        : { orderBy?: RewardAccumulatorMultiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardAccumulatorMultiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardAccumulatorMultiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RewardAccumulatorMulti model
   */
  readonly fields: RewardAccumulatorMultiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardAccumulatorMulti.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardAccumulatorMultiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RewardAccumulatorMulti model
   */
  interface RewardAccumulatorMultiFieldRefs {
    readonly id: FieldRef<"RewardAccumulatorMulti", 'String'>
    readonly currencyId: FieldRef<"RewardAccumulatorMulti", 'String'>
    readonly accPerToken: FieldRef<"RewardAccumulatorMulti", 'Decimal'>
    readonly updatedAt: FieldRef<"RewardAccumulatorMulti", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RewardAccumulatorMulti findUnique
   */
  export type RewardAccumulatorMultiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulatorMulti
     */
    select?: RewardAccumulatorMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulatorMulti
     */
    omit?: RewardAccumulatorMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccumulatorMultiInclude<ExtArgs> | null
    /**
     * Filter, which RewardAccumulatorMulti to fetch.
     */
    where: RewardAccumulatorMultiWhereUniqueInput
  }

  /**
   * RewardAccumulatorMulti findUniqueOrThrow
   */
  export type RewardAccumulatorMultiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulatorMulti
     */
    select?: RewardAccumulatorMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulatorMulti
     */
    omit?: RewardAccumulatorMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccumulatorMultiInclude<ExtArgs> | null
    /**
     * Filter, which RewardAccumulatorMulti to fetch.
     */
    where: RewardAccumulatorMultiWhereUniqueInput
  }

  /**
   * RewardAccumulatorMulti findFirst
   */
  export type RewardAccumulatorMultiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulatorMulti
     */
    select?: RewardAccumulatorMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulatorMulti
     */
    omit?: RewardAccumulatorMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccumulatorMultiInclude<ExtArgs> | null
    /**
     * Filter, which RewardAccumulatorMulti to fetch.
     */
    where?: RewardAccumulatorMultiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardAccumulatorMultis to fetch.
     */
    orderBy?: RewardAccumulatorMultiOrderByWithRelationInput | RewardAccumulatorMultiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardAccumulatorMultis.
     */
    cursor?: RewardAccumulatorMultiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardAccumulatorMultis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardAccumulatorMultis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardAccumulatorMultis.
     */
    distinct?: RewardAccumulatorMultiScalarFieldEnum | RewardAccumulatorMultiScalarFieldEnum[]
  }

  /**
   * RewardAccumulatorMulti findFirstOrThrow
   */
  export type RewardAccumulatorMultiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulatorMulti
     */
    select?: RewardAccumulatorMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulatorMulti
     */
    omit?: RewardAccumulatorMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccumulatorMultiInclude<ExtArgs> | null
    /**
     * Filter, which RewardAccumulatorMulti to fetch.
     */
    where?: RewardAccumulatorMultiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardAccumulatorMultis to fetch.
     */
    orderBy?: RewardAccumulatorMultiOrderByWithRelationInput | RewardAccumulatorMultiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardAccumulatorMultis.
     */
    cursor?: RewardAccumulatorMultiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardAccumulatorMultis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardAccumulatorMultis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardAccumulatorMultis.
     */
    distinct?: RewardAccumulatorMultiScalarFieldEnum | RewardAccumulatorMultiScalarFieldEnum[]
  }

  /**
   * RewardAccumulatorMulti findMany
   */
  export type RewardAccumulatorMultiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulatorMulti
     */
    select?: RewardAccumulatorMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulatorMulti
     */
    omit?: RewardAccumulatorMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccumulatorMultiInclude<ExtArgs> | null
    /**
     * Filter, which RewardAccumulatorMultis to fetch.
     */
    where?: RewardAccumulatorMultiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardAccumulatorMultis to fetch.
     */
    orderBy?: RewardAccumulatorMultiOrderByWithRelationInput | RewardAccumulatorMultiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardAccumulatorMultis.
     */
    cursor?: RewardAccumulatorMultiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardAccumulatorMultis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardAccumulatorMultis.
     */
    skip?: number
    distinct?: RewardAccumulatorMultiScalarFieldEnum | RewardAccumulatorMultiScalarFieldEnum[]
  }

  /**
   * RewardAccumulatorMulti create
   */
  export type RewardAccumulatorMultiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulatorMulti
     */
    select?: RewardAccumulatorMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulatorMulti
     */
    omit?: RewardAccumulatorMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccumulatorMultiInclude<ExtArgs> | null
    /**
     * The data needed to create a RewardAccumulatorMulti.
     */
    data: XOR<RewardAccumulatorMultiCreateInput, RewardAccumulatorMultiUncheckedCreateInput>
  }

  /**
   * RewardAccumulatorMulti createMany
   */
  export type RewardAccumulatorMultiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RewardAccumulatorMultis.
     */
    data: RewardAccumulatorMultiCreateManyInput | RewardAccumulatorMultiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RewardAccumulatorMulti createManyAndReturn
   */
  export type RewardAccumulatorMultiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulatorMulti
     */
    select?: RewardAccumulatorMultiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulatorMulti
     */
    omit?: RewardAccumulatorMultiOmit<ExtArgs> | null
    /**
     * The data used to create many RewardAccumulatorMultis.
     */
    data: RewardAccumulatorMultiCreateManyInput | RewardAccumulatorMultiCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccumulatorMultiIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardAccumulatorMulti update
   */
  export type RewardAccumulatorMultiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulatorMulti
     */
    select?: RewardAccumulatorMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulatorMulti
     */
    omit?: RewardAccumulatorMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccumulatorMultiInclude<ExtArgs> | null
    /**
     * The data needed to update a RewardAccumulatorMulti.
     */
    data: XOR<RewardAccumulatorMultiUpdateInput, RewardAccumulatorMultiUncheckedUpdateInput>
    /**
     * Choose, which RewardAccumulatorMulti to update.
     */
    where: RewardAccumulatorMultiWhereUniqueInput
  }

  /**
   * RewardAccumulatorMulti updateMany
   */
  export type RewardAccumulatorMultiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RewardAccumulatorMultis.
     */
    data: XOR<RewardAccumulatorMultiUpdateManyMutationInput, RewardAccumulatorMultiUncheckedUpdateManyInput>
    /**
     * Filter which RewardAccumulatorMultis to update
     */
    where?: RewardAccumulatorMultiWhereInput
    /**
     * Limit how many RewardAccumulatorMultis to update.
     */
    limit?: number
  }

  /**
   * RewardAccumulatorMulti updateManyAndReturn
   */
  export type RewardAccumulatorMultiUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulatorMulti
     */
    select?: RewardAccumulatorMultiSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulatorMulti
     */
    omit?: RewardAccumulatorMultiOmit<ExtArgs> | null
    /**
     * The data used to update RewardAccumulatorMultis.
     */
    data: XOR<RewardAccumulatorMultiUpdateManyMutationInput, RewardAccumulatorMultiUncheckedUpdateManyInput>
    /**
     * Filter which RewardAccumulatorMultis to update
     */
    where?: RewardAccumulatorMultiWhereInput
    /**
     * Limit how many RewardAccumulatorMultis to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccumulatorMultiIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardAccumulatorMulti upsert
   */
  export type RewardAccumulatorMultiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulatorMulti
     */
    select?: RewardAccumulatorMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulatorMulti
     */
    omit?: RewardAccumulatorMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccumulatorMultiInclude<ExtArgs> | null
    /**
     * The filter to search for the RewardAccumulatorMulti to update in case it exists.
     */
    where: RewardAccumulatorMultiWhereUniqueInput
    /**
     * In case the RewardAccumulatorMulti found by the `where` argument doesn't exist, create a new RewardAccumulatorMulti with this data.
     */
    create: XOR<RewardAccumulatorMultiCreateInput, RewardAccumulatorMultiUncheckedCreateInput>
    /**
     * In case the RewardAccumulatorMulti was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardAccumulatorMultiUpdateInput, RewardAccumulatorMultiUncheckedUpdateInput>
  }

  /**
   * RewardAccumulatorMulti delete
   */
  export type RewardAccumulatorMultiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulatorMulti
     */
    select?: RewardAccumulatorMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulatorMulti
     */
    omit?: RewardAccumulatorMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccumulatorMultiInclude<ExtArgs> | null
    /**
     * Filter which RewardAccumulatorMulti to delete.
     */
    where: RewardAccumulatorMultiWhereUniqueInput
  }

  /**
   * RewardAccumulatorMulti deleteMany
   */
  export type RewardAccumulatorMultiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardAccumulatorMultis to delete
     */
    where?: RewardAccumulatorMultiWhereInput
    /**
     * Limit how many RewardAccumulatorMultis to delete.
     */
    limit?: number
  }

  /**
   * RewardAccumulatorMulti without action
   */
  export type RewardAccumulatorMultiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardAccumulatorMulti
     */
    select?: RewardAccumulatorMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardAccumulatorMulti
     */
    omit?: RewardAccumulatorMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardAccumulatorMultiInclude<ExtArgs> | null
  }


  /**
   * Model HolderRewardMulti
   */

  export type AggregateHolderRewardMulti = {
    _count: HolderRewardMultiCountAggregateOutputType | null
    _avg: HolderRewardMultiAvgAggregateOutputType | null
    _sum: HolderRewardMultiSumAggregateOutputType | null
    _min: HolderRewardMultiMinAggregateOutputType | null
    _max: HolderRewardMultiMaxAggregateOutputType | null
  }

  export type HolderRewardMultiAvgAggregateOutputType = {
    lastAccPerToken: Decimal | null
    claimedAmount: Decimal | null
  }

  export type HolderRewardMultiSumAggregateOutputType = {
    lastAccPerToken: Decimal | null
    claimedAmount: Decimal | null
  }

  export type HolderRewardMultiMinAggregateOutputType = {
    id: string | null
    userId: string | null
    walletAddress: string | null
    currencyId: string | null
    lastAccPerToken: Decimal | null
    claimedAmount: Decimal | null
    updatedAt: Date | null
  }

  export type HolderRewardMultiMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    walletAddress: string | null
    currencyId: string | null
    lastAccPerToken: Decimal | null
    claimedAmount: Decimal | null
    updatedAt: Date | null
  }

  export type HolderRewardMultiCountAggregateOutputType = {
    id: number
    userId: number
    walletAddress: number
    currencyId: number
    lastAccPerToken: number
    claimedAmount: number
    updatedAt: number
    _all: number
  }


  export type HolderRewardMultiAvgAggregateInputType = {
    lastAccPerToken?: true
    claimedAmount?: true
  }

  export type HolderRewardMultiSumAggregateInputType = {
    lastAccPerToken?: true
    claimedAmount?: true
  }

  export type HolderRewardMultiMinAggregateInputType = {
    id?: true
    userId?: true
    walletAddress?: true
    currencyId?: true
    lastAccPerToken?: true
    claimedAmount?: true
    updatedAt?: true
  }

  export type HolderRewardMultiMaxAggregateInputType = {
    id?: true
    userId?: true
    walletAddress?: true
    currencyId?: true
    lastAccPerToken?: true
    claimedAmount?: true
    updatedAt?: true
  }

  export type HolderRewardMultiCountAggregateInputType = {
    id?: true
    userId?: true
    walletAddress?: true
    currencyId?: true
    lastAccPerToken?: true
    claimedAmount?: true
    updatedAt?: true
    _all?: true
  }

  export type HolderRewardMultiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HolderRewardMulti to aggregate.
     */
    where?: HolderRewardMultiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HolderRewardMultis to fetch.
     */
    orderBy?: HolderRewardMultiOrderByWithRelationInput | HolderRewardMultiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HolderRewardMultiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HolderRewardMultis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HolderRewardMultis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HolderRewardMultis
    **/
    _count?: true | HolderRewardMultiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HolderRewardMultiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HolderRewardMultiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HolderRewardMultiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HolderRewardMultiMaxAggregateInputType
  }

  export type GetHolderRewardMultiAggregateType<T extends HolderRewardMultiAggregateArgs> = {
        [P in keyof T & keyof AggregateHolderRewardMulti]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHolderRewardMulti[P]>
      : GetScalarType<T[P], AggregateHolderRewardMulti[P]>
  }




  export type HolderRewardMultiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HolderRewardMultiWhereInput
    orderBy?: HolderRewardMultiOrderByWithAggregationInput | HolderRewardMultiOrderByWithAggregationInput[]
    by: HolderRewardMultiScalarFieldEnum[] | HolderRewardMultiScalarFieldEnum
    having?: HolderRewardMultiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HolderRewardMultiCountAggregateInputType | true
    _avg?: HolderRewardMultiAvgAggregateInputType
    _sum?: HolderRewardMultiSumAggregateInputType
    _min?: HolderRewardMultiMinAggregateInputType
    _max?: HolderRewardMultiMaxAggregateInputType
  }

  export type HolderRewardMultiGroupByOutputType = {
    id: string
    userId: string | null
    walletAddress: string
    currencyId: string
    lastAccPerToken: Decimal
    claimedAmount: Decimal
    updatedAt: Date
    _count: HolderRewardMultiCountAggregateOutputType | null
    _avg: HolderRewardMultiAvgAggregateOutputType | null
    _sum: HolderRewardMultiSumAggregateOutputType | null
    _min: HolderRewardMultiMinAggregateOutputType | null
    _max: HolderRewardMultiMaxAggregateOutputType | null
  }

  type GetHolderRewardMultiGroupByPayload<T extends HolderRewardMultiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HolderRewardMultiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HolderRewardMultiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HolderRewardMultiGroupByOutputType[P]>
            : GetScalarType<T[P], HolderRewardMultiGroupByOutputType[P]>
        }
      >
    >


  export type HolderRewardMultiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    walletAddress?: boolean
    currencyId?: boolean
    lastAccPerToken?: boolean
    claimedAmount?: boolean
    updatedAt?: boolean
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    user?: boolean | HolderRewardMulti$userArgs<ExtArgs>
  }, ExtArgs["result"]["holderRewardMulti"]>

  export type HolderRewardMultiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    walletAddress?: boolean
    currencyId?: boolean
    lastAccPerToken?: boolean
    claimedAmount?: boolean
    updatedAt?: boolean
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    user?: boolean | HolderRewardMulti$userArgs<ExtArgs>
  }, ExtArgs["result"]["holderRewardMulti"]>

  export type HolderRewardMultiSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    walletAddress?: boolean
    currencyId?: boolean
    lastAccPerToken?: boolean
    claimedAmount?: boolean
    updatedAt?: boolean
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    user?: boolean | HolderRewardMulti$userArgs<ExtArgs>
  }, ExtArgs["result"]["holderRewardMulti"]>

  export type HolderRewardMultiSelectScalar = {
    id?: boolean
    userId?: boolean
    walletAddress?: boolean
    currencyId?: boolean
    lastAccPerToken?: boolean
    claimedAmount?: boolean
    updatedAt?: boolean
  }

  export type HolderRewardMultiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "walletAddress" | "currencyId" | "lastAccPerToken" | "claimedAmount" | "updatedAt", ExtArgs["result"]["holderRewardMulti"]>
  export type HolderRewardMultiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    user?: boolean | HolderRewardMulti$userArgs<ExtArgs>
  }
  export type HolderRewardMultiIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    user?: boolean | HolderRewardMulti$userArgs<ExtArgs>
  }
  export type HolderRewardMultiIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    user?: boolean | HolderRewardMulti$userArgs<ExtArgs>
  }

  export type $HolderRewardMultiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HolderRewardMulti"
    objects: {
      currency: Prisma.$CurrencyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      walletAddress: string
      currencyId: string
      lastAccPerToken: Prisma.Decimal
      claimedAmount: Prisma.Decimal
      updatedAt: Date
    }, ExtArgs["result"]["holderRewardMulti"]>
    composites: {}
  }

  type HolderRewardMultiGetPayload<S extends boolean | null | undefined | HolderRewardMultiDefaultArgs> = $Result.GetResult<Prisma.$HolderRewardMultiPayload, S>

  type HolderRewardMultiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HolderRewardMultiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HolderRewardMultiCountAggregateInputType | true
    }

  export interface HolderRewardMultiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HolderRewardMulti'], meta: { name: 'HolderRewardMulti' } }
    /**
     * Find zero or one HolderRewardMulti that matches the filter.
     * @param {HolderRewardMultiFindUniqueArgs} args - Arguments to find a HolderRewardMulti
     * @example
     * // Get one HolderRewardMulti
     * const holderRewardMulti = await prisma.holderRewardMulti.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HolderRewardMultiFindUniqueArgs>(args: SelectSubset<T, HolderRewardMultiFindUniqueArgs<ExtArgs>>): Prisma__HolderRewardMultiClient<$Result.GetResult<Prisma.$HolderRewardMultiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HolderRewardMulti that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HolderRewardMultiFindUniqueOrThrowArgs} args - Arguments to find a HolderRewardMulti
     * @example
     * // Get one HolderRewardMulti
     * const holderRewardMulti = await prisma.holderRewardMulti.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HolderRewardMultiFindUniqueOrThrowArgs>(args: SelectSubset<T, HolderRewardMultiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HolderRewardMultiClient<$Result.GetResult<Prisma.$HolderRewardMultiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HolderRewardMulti that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolderRewardMultiFindFirstArgs} args - Arguments to find a HolderRewardMulti
     * @example
     * // Get one HolderRewardMulti
     * const holderRewardMulti = await prisma.holderRewardMulti.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HolderRewardMultiFindFirstArgs>(args?: SelectSubset<T, HolderRewardMultiFindFirstArgs<ExtArgs>>): Prisma__HolderRewardMultiClient<$Result.GetResult<Prisma.$HolderRewardMultiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HolderRewardMulti that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolderRewardMultiFindFirstOrThrowArgs} args - Arguments to find a HolderRewardMulti
     * @example
     * // Get one HolderRewardMulti
     * const holderRewardMulti = await prisma.holderRewardMulti.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HolderRewardMultiFindFirstOrThrowArgs>(args?: SelectSubset<T, HolderRewardMultiFindFirstOrThrowArgs<ExtArgs>>): Prisma__HolderRewardMultiClient<$Result.GetResult<Prisma.$HolderRewardMultiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HolderRewardMultis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolderRewardMultiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HolderRewardMultis
     * const holderRewardMultis = await prisma.holderRewardMulti.findMany()
     * 
     * // Get first 10 HolderRewardMultis
     * const holderRewardMultis = await prisma.holderRewardMulti.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const holderRewardMultiWithIdOnly = await prisma.holderRewardMulti.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HolderRewardMultiFindManyArgs>(args?: SelectSubset<T, HolderRewardMultiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolderRewardMultiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HolderRewardMulti.
     * @param {HolderRewardMultiCreateArgs} args - Arguments to create a HolderRewardMulti.
     * @example
     * // Create one HolderRewardMulti
     * const HolderRewardMulti = await prisma.holderRewardMulti.create({
     *   data: {
     *     // ... data to create a HolderRewardMulti
     *   }
     * })
     * 
     */
    create<T extends HolderRewardMultiCreateArgs>(args: SelectSubset<T, HolderRewardMultiCreateArgs<ExtArgs>>): Prisma__HolderRewardMultiClient<$Result.GetResult<Prisma.$HolderRewardMultiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HolderRewardMultis.
     * @param {HolderRewardMultiCreateManyArgs} args - Arguments to create many HolderRewardMultis.
     * @example
     * // Create many HolderRewardMultis
     * const holderRewardMulti = await prisma.holderRewardMulti.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HolderRewardMultiCreateManyArgs>(args?: SelectSubset<T, HolderRewardMultiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HolderRewardMultis and returns the data saved in the database.
     * @param {HolderRewardMultiCreateManyAndReturnArgs} args - Arguments to create many HolderRewardMultis.
     * @example
     * // Create many HolderRewardMultis
     * const holderRewardMulti = await prisma.holderRewardMulti.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HolderRewardMultis and only return the `id`
     * const holderRewardMultiWithIdOnly = await prisma.holderRewardMulti.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HolderRewardMultiCreateManyAndReturnArgs>(args?: SelectSubset<T, HolderRewardMultiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolderRewardMultiPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HolderRewardMulti.
     * @param {HolderRewardMultiDeleteArgs} args - Arguments to delete one HolderRewardMulti.
     * @example
     * // Delete one HolderRewardMulti
     * const HolderRewardMulti = await prisma.holderRewardMulti.delete({
     *   where: {
     *     // ... filter to delete one HolderRewardMulti
     *   }
     * })
     * 
     */
    delete<T extends HolderRewardMultiDeleteArgs>(args: SelectSubset<T, HolderRewardMultiDeleteArgs<ExtArgs>>): Prisma__HolderRewardMultiClient<$Result.GetResult<Prisma.$HolderRewardMultiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HolderRewardMulti.
     * @param {HolderRewardMultiUpdateArgs} args - Arguments to update one HolderRewardMulti.
     * @example
     * // Update one HolderRewardMulti
     * const holderRewardMulti = await prisma.holderRewardMulti.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HolderRewardMultiUpdateArgs>(args: SelectSubset<T, HolderRewardMultiUpdateArgs<ExtArgs>>): Prisma__HolderRewardMultiClient<$Result.GetResult<Prisma.$HolderRewardMultiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HolderRewardMultis.
     * @param {HolderRewardMultiDeleteManyArgs} args - Arguments to filter HolderRewardMultis to delete.
     * @example
     * // Delete a few HolderRewardMultis
     * const { count } = await prisma.holderRewardMulti.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HolderRewardMultiDeleteManyArgs>(args?: SelectSubset<T, HolderRewardMultiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HolderRewardMultis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolderRewardMultiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HolderRewardMultis
     * const holderRewardMulti = await prisma.holderRewardMulti.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HolderRewardMultiUpdateManyArgs>(args: SelectSubset<T, HolderRewardMultiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HolderRewardMultis and returns the data updated in the database.
     * @param {HolderRewardMultiUpdateManyAndReturnArgs} args - Arguments to update many HolderRewardMultis.
     * @example
     * // Update many HolderRewardMultis
     * const holderRewardMulti = await prisma.holderRewardMulti.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HolderRewardMultis and only return the `id`
     * const holderRewardMultiWithIdOnly = await prisma.holderRewardMulti.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HolderRewardMultiUpdateManyAndReturnArgs>(args: SelectSubset<T, HolderRewardMultiUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolderRewardMultiPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HolderRewardMulti.
     * @param {HolderRewardMultiUpsertArgs} args - Arguments to update or create a HolderRewardMulti.
     * @example
     * // Update or create a HolderRewardMulti
     * const holderRewardMulti = await prisma.holderRewardMulti.upsert({
     *   create: {
     *     // ... data to create a HolderRewardMulti
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HolderRewardMulti we want to update
     *   }
     * })
     */
    upsert<T extends HolderRewardMultiUpsertArgs>(args: SelectSubset<T, HolderRewardMultiUpsertArgs<ExtArgs>>): Prisma__HolderRewardMultiClient<$Result.GetResult<Prisma.$HolderRewardMultiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HolderRewardMultis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolderRewardMultiCountArgs} args - Arguments to filter HolderRewardMultis to count.
     * @example
     * // Count the number of HolderRewardMultis
     * const count = await prisma.holderRewardMulti.count({
     *   where: {
     *     // ... the filter for the HolderRewardMultis we want to count
     *   }
     * })
    **/
    count<T extends HolderRewardMultiCountArgs>(
      args?: Subset<T, HolderRewardMultiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HolderRewardMultiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HolderRewardMulti.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolderRewardMultiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HolderRewardMultiAggregateArgs>(args: Subset<T, HolderRewardMultiAggregateArgs>): Prisma.PrismaPromise<GetHolderRewardMultiAggregateType<T>>

    /**
     * Group by HolderRewardMulti.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolderRewardMultiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HolderRewardMultiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HolderRewardMultiGroupByArgs['orderBy'] }
        : { orderBy?: HolderRewardMultiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HolderRewardMultiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHolderRewardMultiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HolderRewardMulti model
   */
  readonly fields: HolderRewardMultiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HolderRewardMulti.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HolderRewardMultiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends HolderRewardMulti$userArgs<ExtArgs> = {}>(args?: Subset<T, HolderRewardMulti$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HolderRewardMulti model
   */
  interface HolderRewardMultiFieldRefs {
    readonly id: FieldRef<"HolderRewardMulti", 'String'>
    readonly userId: FieldRef<"HolderRewardMulti", 'String'>
    readonly walletAddress: FieldRef<"HolderRewardMulti", 'String'>
    readonly currencyId: FieldRef<"HolderRewardMulti", 'String'>
    readonly lastAccPerToken: FieldRef<"HolderRewardMulti", 'Decimal'>
    readonly claimedAmount: FieldRef<"HolderRewardMulti", 'Decimal'>
    readonly updatedAt: FieldRef<"HolderRewardMulti", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HolderRewardMulti findUnique
   */
  export type HolderRewardMultiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderRewardMulti
     */
    select?: HolderRewardMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderRewardMulti
     */
    omit?: HolderRewardMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolderRewardMultiInclude<ExtArgs> | null
    /**
     * Filter, which HolderRewardMulti to fetch.
     */
    where: HolderRewardMultiWhereUniqueInput
  }

  /**
   * HolderRewardMulti findUniqueOrThrow
   */
  export type HolderRewardMultiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderRewardMulti
     */
    select?: HolderRewardMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderRewardMulti
     */
    omit?: HolderRewardMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolderRewardMultiInclude<ExtArgs> | null
    /**
     * Filter, which HolderRewardMulti to fetch.
     */
    where: HolderRewardMultiWhereUniqueInput
  }

  /**
   * HolderRewardMulti findFirst
   */
  export type HolderRewardMultiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderRewardMulti
     */
    select?: HolderRewardMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderRewardMulti
     */
    omit?: HolderRewardMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolderRewardMultiInclude<ExtArgs> | null
    /**
     * Filter, which HolderRewardMulti to fetch.
     */
    where?: HolderRewardMultiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HolderRewardMultis to fetch.
     */
    orderBy?: HolderRewardMultiOrderByWithRelationInput | HolderRewardMultiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HolderRewardMultis.
     */
    cursor?: HolderRewardMultiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HolderRewardMultis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HolderRewardMultis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HolderRewardMultis.
     */
    distinct?: HolderRewardMultiScalarFieldEnum | HolderRewardMultiScalarFieldEnum[]
  }

  /**
   * HolderRewardMulti findFirstOrThrow
   */
  export type HolderRewardMultiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderRewardMulti
     */
    select?: HolderRewardMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderRewardMulti
     */
    omit?: HolderRewardMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolderRewardMultiInclude<ExtArgs> | null
    /**
     * Filter, which HolderRewardMulti to fetch.
     */
    where?: HolderRewardMultiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HolderRewardMultis to fetch.
     */
    orderBy?: HolderRewardMultiOrderByWithRelationInput | HolderRewardMultiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HolderRewardMultis.
     */
    cursor?: HolderRewardMultiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HolderRewardMultis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HolderRewardMultis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HolderRewardMultis.
     */
    distinct?: HolderRewardMultiScalarFieldEnum | HolderRewardMultiScalarFieldEnum[]
  }

  /**
   * HolderRewardMulti findMany
   */
  export type HolderRewardMultiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderRewardMulti
     */
    select?: HolderRewardMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderRewardMulti
     */
    omit?: HolderRewardMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolderRewardMultiInclude<ExtArgs> | null
    /**
     * Filter, which HolderRewardMultis to fetch.
     */
    where?: HolderRewardMultiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HolderRewardMultis to fetch.
     */
    orderBy?: HolderRewardMultiOrderByWithRelationInput | HolderRewardMultiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HolderRewardMultis.
     */
    cursor?: HolderRewardMultiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HolderRewardMultis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HolderRewardMultis.
     */
    skip?: number
    distinct?: HolderRewardMultiScalarFieldEnum | HolderRewardMultiScalarFieldEnum[]
  }

  /**
   * HolderRewardMulti create
   */
  export type HolderRewardMultiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderRewardMulti
     */
    select?: HolderRewardMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderRewardMulti
     */
    omit?: HolderRewardMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolderRewardMultiInclude<ExtArgs> | null
    /**
     * The data needed to create a HolderRewardMulti.
     */
    data: XOR<HolderRewardMultiCreateInput, HolderRewardMultiUncheckedCreateInput>
  }

  /**
   * HolderRewardMulti createMany
   */
  export type HolderRewardMultiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HolderRewardMultis.
     */
    data: HolderRewardMultiCreateManyInput | HolderRewardMultiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HolderRewardMulti createManyAndReturn
   */
  export type HolderRewardMultiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderRewardMulti
     */
    select?: HolderRewardMultiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HolderRewardMulti
     */
    omit?: HolderRewardMultiOmit<ExtArgs> | null
    /**
     * The data used to create many HolderRewardMultis.
     */
    data: HolderRewardMultiCreateManyInput | HolderRewardMultiCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolderRewardMultiIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HolderRewardMulti update
   */
  export type HolderRewardMultiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderRewardMulti
     */
    select?: HolderRewardMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderRewardMulti
     */
    omit?: HolderRewardMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolderRewardMultiInclude<ExtArgs> | null
    /**
     * The data needed to update a HolderRewardMulti.
     */
    data: XOR<HolderRewardMultiUpdateInput, HolderRewardMultiUncheckedUpdateInput>
    /**
     * Choose, which HolderRewardMulti to update.
     */
    where: HolderRewardMultiWhereUniqueInput
  }

  /**
   * HolderRewardMulti updateMany
   */
  export type HolderRewardMultiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HolderRewardMultis.
     */
    data: XOR<HolderRewardMultiUpdateManyMutationInput, HolderRewardMultiUncheckedUpdateManyInput>
    /**
     * Filter which HolderRewardMultis to update
     */
    where?: HolderRewardMultiWhereInput
    /**
     * Limit how many HolderRewardMultis to update.
     */
    limit?: number
  }

  /**
   * HolderRewardMulti updateManyAndReturn
   */
  export type HolderRewardMultiUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderRewardMulti
     */
    select?: HolderRewardMultiSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HolderRewardMulti
     */
    omit?: HolderRewardMultiOmit<ExtArgs> | null
    /**
     * The data used to update HolderRewardMultis.
     */
    data: XOR<HolderRewardMultiUpdateManyMutationInput, HolderRewardMultiUncheckedUpdateManyInput>
    /**
     * Filter which HolderRewardMultis to update
     */
    where?: HolderRewardMultiWhereInput
    /**
     * Limit how many HolderRewardMultis to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolderRewardMultiIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HolderRewardMulti upsert
   */
  export type HolderRewardMultiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderRewardMulti
     */
    select?: HolderRewardMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderRewardMulti
     */
    omit?: HolderRewardMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolderRewardMultiInclude<ExtArgs> | null
    /**
     * The filter to search for the HolderRewardMulti to update in case it exists.
     */
    where: HolderRewardMultiWhereUniqueInput
    /**
     * In case the HolderRewardMulti found by the `where` argument doesn't exist, create a new HolderRewardMulti with this data.
     */
    create: XOR<HolderRewardMultiCreateInput, HolderRewardMultiUncheckedCreateInput>
    /**
     * In case the HolderRewardMulti was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HolderRewardMultiUpdateInput, HolderRewardMultiUncheckedUpdateInput>
  }

  /**
   * HolderRewardMulti delete
   */
  export type HolderRewardMultiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderRewardMulti
     */
    select?: HolderRewardMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderRewardMulti
     */
    omit?: HolderRewardMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolderRewardMultiInclude<ExtArgs> | null
    /**
     * Filter which HolderRewardMulti to delete.
     */
    where: HolderRewardMultiWhereUniqueInput
  }

  /**
   * HolderRewardMulti deleteMany
   */
  export type HolderRewardMultiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HolderRewardMultis to delete
     */
    where?: HolderRewardMultiWhereInput
    /**
     * Limit how many HolderRewardMultis to delete.
     */
    limit?: number
  }

  /**
   * HolderRewardMulti.user
   */
  export type HolderRewardMulti$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * HolderRewardMulti without action
   */
  export type HolderRewardMultiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HolderRewardMulti
     */
    select?: HolderRewardMultiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HolderRewardMulti
     */
    omit?: HolderRewardMultiOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HolderRewardMultiInclude<ExtArgs> | null
  }


  /**
   * Model RewardDistributionLog
   */

  export type AggregateRewardDistributionLog = {
    _count: RewardDistributionLogCountAggregateOutputType | null
    _avg: RewardDistributionLogAvgAggregateOutputType | null
    _sum: RewardDistributionLogSumAggregateOutputType | null
    _min: RewardDistributionLogMinAggregateOutputType | null
    _max: RewardDistributionLogMaxAggregateOutputType | null
  }

  export type RewardDistributionLogAvgAggregateOutputType = {
    amount: Decimal | null
    blockNumber: number | null
  }

  export type RewardDistributionLogSumAggregateOutputType = {
    amount: Decimal | null
    blockNumber: number | null
  }

  export type RewardDistributionLogMinAggregateOutputType = {
    id: string | null
    currencyId: string | null
    amount: Decimal | null
    txHash: string | null
    blockNumber: number | null
    timestamp: Date | null
    note: string | null
  }

  export type RewardDistributionLogMaxAggregateOutputType = {
    id: string | null
    currencyId: string | null
    amount: Decimal | null
    txHash: string | null
    blockNumber: number | null
    timestamp: Date | null
    note: string | null
  }

  export type RewardDistributionLogCountAggregateOutputType = {
    id: number
    currencyId: number
    amount: number
    txHash: number
    blockNumber: number
    timestamp: number
    note: number
    _all: number
  }


  export type RewardDistributionLogAvgAggregateInputType = {
    amount?: true
    blockNumber?: true
  }

  export type RewardDistributionLogSumAggregateInputType = {
    amount?: true
    blockNumber?: true
  }

  export type RewardDistributionLogMinAggregateInputType = {
    id?: true
    currencyId?: true
    amount?: true
    txHash?: true
    blockNumber?: true
    timestamp?: true
    note?: true
  }

  export type RewardDistributionLogMaxAggregateInputType = {
    id?: true
    currencyId?: true
    amount?: true
    txHash?: true
    blockNumber?: true
    timestamp?: true
    note?: true
  }

  export type RewardDistributionLogCountAggregateInputType = {
    id?: true
    currencyId?: true
    amount?: true
    txHash?: true
    blockNumber?: true
    timestamp?: true
    note?: true
    _all?: true
  }

  export type RewardDistributionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardDistributionLog to aggregate.
     */
    where?: RewardDistributionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardDistributionLogs to fetch.
     */
    orderBy?: RewardDistributionLogOrderByWithRelationInput | RewardDistributionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardDistributionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardDistributionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardDistributionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardDistributionLogs
    **/
    _count?: true | RewardDistributionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardDistributionLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardDistributionLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardDistributionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardDistributionLogMaxAggregateInputType
  }

  export type GetRewardDistributionLogAggregateType<T extends RewardDistributionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardDistributionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardDistributionLog[P]>
      : GetScalarType<T[P], AggregateRewardDistributionLog[P]>
  }




  export type RewardDistributionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardDistributionLogWhereInput
    orderBy?: RewardDistributionLogOrderByWithAggregationInput | RewardDistributionLogOrderByWithAggregationInput[]
    by: RewardDistributionLogScalarFieldEnum[] | RewardDistributionLogScalarFieldEnum
    having?: RewardDistributionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardDistributionLogCountAggregateInputType | true
    _avg?: RewardDistributionLogAvgAggregateInputType
    _sum?: RewardDistributionLogSumAggregateInputType
    _min?: RewardDistributionLogMinAggregateInputType
    _max?: RewardDistributionLogMaxAggregateInputType
  }

  export type RewardDistributionLogGroupByOutputType = {
    id: string
    currencyId: string
    amount: Decimal
    txHash: string | null
    blockNumber: number | null
    timestamp: Date
    note: string | null
    _count: RewardDistributionLogCountAggregateOutputType | null
    _avg: RewardDistributionLogAvgAggregateOutputType | null
    _sum: RewardDistributionLogSumAggregateOutputType | null
    _min: RewardDistributionLogMinAggregateOutputType | null
    _max: RewardDistributionLogMaxAggregateOutputType | null
  }

  type GetRewardDistributionLogGroupByPayload<T extends RewardDistributionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardDistributionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardDistributionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardDistributionLogGroupByOutputType[P]>
            : GetScalarType<T[P], RewardDistributionLogGroupByOutputType[P]>
        }
      >
    >


  export type RewardDistributionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currencyId?: boolean
    amount?: boolean
    txHash?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    note?: boolean
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardDistributionLog"]>

  export type RewardDistributionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currencyId?: boolean
    amount?: boolean
    txHash?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    note?: boolean
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardDistributionLog"]>

  export type RewardDistributionLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currencyId?: boolean
    amount?: boolean
    txHash?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    note?: boolean
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rewardDistributionLog"]>

  export type RewardDistributionLogSelectScalar = {
    id?: boolean
    currencyId?: boolean
    amount?: boolean
    txHash?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    note?: boolean
  }

  export type RewardDistributionLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "currencyId" | "amount" | "txHash" | "blockNumber" | "timestamp" | "note", ExtArgs["result"]["rewardDistributionLog"]>
  export type RewardDistributionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }
  export type RewardDistributionLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }
  export type RewardDistributionLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
  }

  export type $RewardDistributionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RewardDistributionLog"
    objects: {
      currency: Prisma.$CurrencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      currencyId: string
      amount: Prisma.Decimal
      txHash: string | null
      blockNumber: number | null
      timestamp: Date
      note: string | null
    }, ExtArgs["result"]["rewardDistributionLog"]>
    composites: {}
  }

  type RewardDistributionLogGetPayload<S extends boolean | null | undefined | RewardDistributionLogDefaultArgs> = $Result.GetResult<Prisma.$RewardDistributionLogPayload, S>

  type RewardDistributionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RewardDistributionLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardDistributionLogCountAggregateInputType | true
    }

  export interface RewardDistributionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RewardDistributionLog'], meta: { name: 'RewardDistributionLog' } }
    /**
     * Find zero or one RewardDistributionLog that matches the filter.
     * @param {RewardDistributionLogFindUniqueArgs} args - Arguments to find a RewardDistributionLog
     * @example
     * // Get one RewardDistributionLog
     * const rewardDistributionLog = await prisma.rewardDistributionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardDistributionLogFindUniqueArgs>(args: SelectSubset<T, RewardDistributionLogFindUniqueArgs<ExtArgs>>): Prisma__RewardDistributionLogClient<$Result.GetResult<Prisma.$RewardDistributionLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RewardDistributionLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardDistributionLogFindUniqueOrThrowArgs} args - Arguments to find a RewardDistributionLog
     * @example
     * // Get one RewardDistributionLog
     * const rewardDistributionLog = await prisma.rewardDistributionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardDistributionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardDistributionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardDistributionLogClient<$Result.GetResult<Prisma.$RewardDistributionLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardDistributionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardDistributionLogFindFirstArgs} args - Arguments to find a RewardDistributionLog
     * @example
     * // Get one RewardDistributionLog
     * const rewardDistributionLog = await prisma.rewardDistributionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardDistributionLogFindFirstArgs>(args?: SelectSubset<T, RewardDistributionLogFindFirstArgs<ExtArgs>>): Prisma__RewardDistributionLogClient<$Result.GetResult<Prisma.$RewardDistributionLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardDistributionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardDistributionLogFindFirstOrThrowArgs} args - Arguments to find a RewardDistributionLog
     * @example
     * // Get one RewardDistributionLog
     * const rewardDistributionLog = await prisma.rewardDistributionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardDistributionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardDistributionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardDistributionLogClient<$Result.GetResult<Prisma.$RewardDistributionLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RewardDistributionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardDistributionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardDistributionLogs
     * const rewardDistributionLogs = await prisma.rewardDistributionLog.findMany()
     * 
     * // Get first 10 RewardDistributionLogs
     * const rewardDistributionLogs = await prisma.rewardDistributionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardDistributionLogWithIdOnly = await prisma.rewardDistributionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardDistributionLogFindManyArgs>(args?: SelectSubset<T, RewardDistributionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardDistributionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RewardDistributionLog.
     * @param {RewardDistributionLogCreateArgs} args - Arguments to create a RewardDistributionLog.
     * @example
     * // Create one RewardDistributionLog
     * const RewardDistributionLog = await prisma.rewardDistributionLog.create({
     *   data: {
     *     // ... data to create a RewardDistributionLog
     *   }
     * })
     * 
     */
    create<T extends RewardDistributionLogCreateArgs>(args: SelectSubset<T, RewardDistributionLogCreateArgs<ExtArgs>>): Prisma__RewardDistributionLogClient<$Result.GetResult<Prisma.$RewardDistributionLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RewardDistributionLogs.
     * @param {RewardDistributionLogCreateManyArgs} args - Arguments to create many RewardDistributionLogs.
     * @example
     * // Create many RewardDistributionLogs
     * const rewardDistributionLog = await prisma.rewardDistributionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardDistributionLogCreateManyArgs>(args?: SelectSubset<T, RewardDistributionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RewardDistributionLogs and returns the data saved in the database.
     * @param {RewardDistributionLogCreateManyAndReturnArgs} args - Arguments to create many RewardDistributionLogs.
     * @example
     * // Create many RewardDistributionLogs
     * const rewardDistributionLog = await prisma.rewardDistributionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RewardDistributionLogs and only return the `id`
     * const rewardDistributionLogWithIdOnly = await prisma.rewardDistributionLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardDistributionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardDistributionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardDistributionLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RewardDistributionLog.
     * @param {RewardDistributionLogDeleteArgs} args - Arguments to delete one RewardDistributionLog.
     * @example
     * // Delete one RewardDistributionLog
     * const RewardDistributionLog = await prisma.rewardDistributionLog.delete({
     *   where: {
     *     // ... filter to delete one RewardDistributionLog
     *   }
     * })
     * 
     */
    delete<T extends RewardDistributionLogDeleteArgs>(args: SelectSubset<T, RewardDistributionLogDeleteArgs<ExtArgs>>): Prisma__RewardDistributionLogClient<$Result.GetResult<Prisma.$RewardDistributionLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RewardDistributionLog.
     * @param {RewardDistributionLogUpdateArgs} args - Arguments to update one RewardDistributionLog.
     * @example
     * // Update one RewardDistributionLog
     * const rewardDistributionLog = await prisma.rewardDistributionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardDistributionLogUpdateArgs>(args: SelectSubset<T, RewardDistributionLogUpdateArgs<ExtArgs>>): Prisma__RewardDistributionLogClient<$Result.GetResult<Prisma.$RewardDistributionLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RewardDistributionLogs.
     * @param {RewardDistributionLogDeleteManyArgs} args - Arguments to filter RewardDistributionLogs to delete.
     * @example
     * // Delete a few RewardDistributionLogs
     * const { count } = await prisma.rewardDistributionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardDistributionLogDeleteManyArgs>(args?: SelectSubset<T, RewardDistributionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardDistributionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardDistributionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardDistributionLogs
     * const rewardDistributionLog = await prisma.rewardDistributionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardDistributionLogUpdateManyArgs>(args: SelectSubset<T, RewardDistributionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardDistributionLogs and returns the data updated in the database.
     * @param {RewardDistributionLogUpdateManyAndReturnArgs} args - Arguments to update many RewardDistributionLogs.
     * @example
     * // Update many RewardDistributionLogs
     * const rewardDistributionLog = await prisma.rewardDistributionLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RewardDistributionLogs and only return the `id`
     * const rewardDistributionLogWithIdOnly = await prisma.rewardDistributionLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RewardDistributionLogUpdateManyAndReturnArgs>(args: SelectSubset<T, RewardDistributionLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardDistributionLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RewardDistributionLog.
     * @param {RewardDistributionLogUpsertArgs} args - Arguments to update or create a RewardDistributionLog.
     * @example
     * // Update or create a RewardDistributionLog
     * const rewardDistributionLog = await prisma.rewardDistributionLog.upsert({
     *   create: {
     *     // ... data to create a RewardDistributionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardDistributionLog we want to update
     *   }
     * })
     */
    upsert<T extends RewardDistributionLogUpsertArgs>(args: SelectSubset<T, RewardDistributionLogUpsertArgs<ExtArgs>>): Prisma__RewardDistributionLogClient<$Result.GetResult<Prisma.$RewardDistributionLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RewardDistributionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardDistributionLogCountArgs} args - Arguments to filter RewardDistributionLogs to count.
     * @example
     * // Count the number of RewardDistributionLogs
     * const count = await prisma.rewardDistributionLog.count({
     *   where: {
     *     // ... the filter for the RewardDistributionLogs we want to count
     *   }
     * })
    **/
    count<T extends RewardDistributionLogCountArgs>(
      args?: Subset<T, RewardDistributionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardDistributionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardDistributionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardDistributionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardDistributionLogAggregateArgs>(args: Subset<T, RewardDistributionLogAggregateArgs>): Prisma.PrismaPromise<GetRewardDistributionLogAggregateType<T>>

    /**
     * Group by RewardDistributionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardDistributionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardDistributionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardDistributionLogGroupByArgs['orderBy'] }
        : { orderBy?: RewardDistributionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardDistributionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardDistributionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RewardDistributionLog model
   */
  readonly fields: RewardDistributionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardDistributionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardDistributionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RewardDistributionLog model
   */
  interface RewardDistributionLogFieldRefs {
    readonly id: FieldRef<"RewardDistributionLog", 'String'>
    readonly currencyId: FieldRef<"RewardDistributionLog", 'String'>
    readonly amount: FieldRef<"RewardDistributionLog", 'Decimal'>
    readonly txHash: FieldRef<"RewardDistributionLog", 'String'>
    readonly blockNumber: FieldRef<"RewardDistributionLog", 'Int'>
    readonly timestamp: FieldRef<"RewardDistributionLog", 'DateTime'>
    readonly note: FieldRef<"RewardDistributionLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RewardDistributionLog findUnique
   */
  export type RewardDistributionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDistributionLog
     */
    select?: RewardDistributionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDistributionLog
     */
    omit?: RewardDistributionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDistributionLogInclude<ExtArgs> | null
    /**
     * Filter, which RewardDistributionLog to fetch.
     */
    where: RewardDistributionLogWhereUniqueInput
  }

  /**
   * RewardDistributionLog findUniqueOrThrow
   */
  export type RewardDistributionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDistributionLog
     */
    select?: RewardDistributionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDistributionLog
     */
    omit?: RewardDistributionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDistributionLogInclude<ExtArgs> | null
    /**
     * Filter, which RewardDistributionLog to fetch.
     */
    where: RewardDistributionLogWhereUniqueInput
  }

  /**
   * RewardDistributionLog findFirst
   */
  export type RewardDistributionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDistributionLog
     */
    select?: RewardDistributionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDistributionLog
     */
    omit?: RewardDistributionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDistributionLogInclude<ExtArgs> | null
    /**
     * Filter, which RewardDistributionLog to fetch.
     */
    where?: RewardDistributionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardDistributionLogs to fetch.
     */
    orderBy?: RewardDistributionLogOrderByWithRelationInput | RewardDistributionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardDistributionLogs.
     */
    cursor?: RewardDistributionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardDistributionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardDistributionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardDistributionLogs.
     */
    distinct?: RewardDistributionLogScalarFieldEnum | RewardDistributionLogScalarFieldEnum[]
  }

  /**
   * RewardDistributionLog findFirstOrThrow
   */
  export type RewardDistributionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDistributionLog
     */
    select?: RewardDistributionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDistributionLog
     */
    omit?: RewardDistributionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDistributionLogInclude<ExtArgs> | null
    /**
     * Filter, which RewardDistributionLog to fetch.
     */
    where?: RewardDistributionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardDistributionLogs to fetch.
     */
    orderBy?: RewardDistributionLogOrderByWithRelationInput | RewardDistributionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardDistributionLogs.
     */
    cursor?: RewardDistributionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardDistributionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardDistributionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardDistributionLogs.
     */
    distinct?: RewardDistributionLogScalarFieldEnum | RewardDistributionLogScalarFieldEnum[]
  }

  /**
   * RewardDistributionLog findMany
   */
  export type RewardDistributionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDistributionLog
     */
    select?: RewardDistributionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDistributionLog
     */
    omit?: RewardDistributionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDistributionLogInclude<ExtArgs> | null
    /**
     * Filter, which RewardDistributionLogs to fetch.
     */
    where?: RewardDistributionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardDistributionLogs to fetch.
     */
    orderBy?: RewardDistributionLogOrderByWithRelationInput | RewardDistributionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardDistributionLogs.
     */
    cursor?: RewardDistributionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardDistributionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardDistributionLogs.
     */
    skip?: number
    distinct?: RewardDistributionLogScalarFieldEnum | RewardDistributionLogScalarFieldEnum[]
  }

  /**
   * RewardDistributionLog create
   */
  export type RewardDistributionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDistributionLog
     */
    select?: RewardDistributionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDistributionLog
     */
    omit?: RewardDistributionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDistributionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a RewardDistributionLog.
     */
    data: XOR<RewardDistributionLogCreateInput, RewardDistributionLogUncheckedCreateInput>
  }

  /**
   * RewardDistributionLog createMany
   */
  export type RewardDistributionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RewardDistributionLogs.
     */
    data: RewardDistributionLogCreateManyInput | RewardDistributionLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RewardDistributionLog createManyAndReturn
   */
  export type RewardDistributionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDistributionLog
     */
    select?: RewardDistributionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDistributionLog
     */
    omit?: RewardDistributionLogOmit<ExtArgs> | null
    /**
     * The data used to create many RewardDistributionLogs.
     */
    data: RewardDistributionLogCreateManyInput | RewardDistributionLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDistributionLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardDistributionLog update
   */
  export type RewardDistributionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDistributionLog
     */
    select?: RewardDistributionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDistributionLog
     */
    omit?: RewardDistributionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDistributionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a RewardDistributionLog.
     */
    data: XOR<RewardDistributionLogUpdateInput, RewardDistributionLogUncheckedUpdateInput>
    /**
     * Choose, which RewardDistributionLog to update.
     */
    where: RewardDistributionLogWhereUniqueInput
  }

  /**
   * RewardDistributionLog updateMany
   */
  export type RewardDistributionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RewardDistributionLogs.
     */
    data: XOR<RewardDistributionLogUpdateManyMutationInput, RewardDistributionLogUncheckedUpdateManyInput>
    /**
     * Filter which RewardDistributionLogs to update
     */
    where?: RewardDistributionLogWhereInput
    /**
     * Limit how many RewardDistributionLogs to update.
     */
    limit?: number
  }

  /**
   * RewardDistributionLog updateManyAndReturn
   */
  export type RewardDistributionLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDistributionLog
     */
    select?: RewardDistributionLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDistributionLog
     */
    omit?: RewardDistributionLogOmit<ExtArgs> | null
    /**
     * The data used to update RewardDistributionLogs.
     */
    data: XOR<RewardDistributionLogUpdateManyMutationInput, RewardDistributionLogUncheckedUpdateManyInput>
    /**
     * Filter which RewardDistributionLogs to update
     */
    where?: RewardDistributionLogWhereInput
    /**
     * Limit how many RewardDistributionLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDistributionLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardDistributionLog upsert
   */
  export type RewardDistributionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDistributionLog
     */
    select?: RewardDistributionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDistributionLog
     */
    omit?: RewardDistributionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDistributionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the RewardDistributionLog to update in case it exists.
     */
    where: RewardDistributionLogWhereUniqueInput
    /**
     * In case the RewardDistributionLog found by the `where` argument doesn't exist, create a new RewardDistributionLog with this data.
     */
    create: XOR<RewardDistributionLogCreateInput, RewardDistributionLogUncheckedCreateInput>
    /**
     * In case the RewardDistributionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardDistributionLogUpdateInput, RewardDistributionLogUncheckedUpdateInput>
  }

  /**
   * RewardDistributionLog delete
   */
  export type RewardDistributionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDistributionLog
     */
    select?: RewardDistributionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDistributionLog
     */
    omit?: RewardDistributionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDistributionLogInclude<ExtArgs> | null
    /**
     * Filter which RewardDistributionLog to delete.
     */
    where: RewardDistributionLogWhereUniqueInput
  }

  /**
   * RewardDistributionLog deleteMany
   */
  export type RewardDistributionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardDistributionLogs to delete
     */
    where?: RewardDistributionLogWhereInput
    /**
     * Limit how many RewardDistributionLogs to delete.
     */
    limit?: number
  }

  /**
   * RewardDistributionLog without action
   */
  export type RewardDistributionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardDistributionLog
     */
    select?: RewardDistributionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardDistributionLog
     */
    omit?: RewardDistributionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardDistributionLogInclude<ExtArgs> | null
  }


  /**
   * Model RewardClaimLog
   */

  export type AggregateRewardClaimLog = {
    _count: RewardClaimLogCountAggregateOutputType | null
    _avg: RewardClaimLogAvgAggregateOutputType | null
    _sum: RewardClaimLogSumAggregateOutputType | null
    _min: RewardClaimLogMinAggregateOutputType | null
    _max: RewardClaimLogMaxAggregateOutputType | null
  }

  export type RewardClaimLogAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type RewardClaimLogSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type RewardClaimLogMinAggregateOutputType = {
    id: string | null
    walletAddress: string | null
    userId: string | null
    currencyId: string | null
    amount: Decimal | null
    txHash: string | null
    timestamp: Date | null
  }

  export type RewardClaimLogMaxAggregateOutputType = {
    id: string | null
    walletAddress: string | null
    userId: string | null
    currencyId: string | null
    amount: Decimal | null
    txHash: string | null
    timestamp: Date | null
  }

  export type RewardClaimLogCountAggregateOutputType = {
    id: number
    walletAddress: number
    userId: number
    currencyId: number
    amount: number
    txHash: number
    timestamp: number
    _all: number
  }


  export type RewardClaimLogAvgAggregateInputType = {
    amount?: true
  }

  export type RewardClaimLogSumAggregateInputType = {
    amount?: true
  }

  export type RewardClaimLogMinAggregateInputType = {
    id?: true
    walletAddress?: true
    userId?: true
    currencyId?: true
    amount?: true
    txHash?: true
    timestamp?: true
  }

  export type RewardClaimLogMaxAggregateInputType = {
    id?: true
    walletAddress?: true
    userId?: true
    currencyId?: true
    amount?: true
    txHash?: true
    timestamp?: true
  }

  export type RewardClaimLogCountAggregateInputType = {
    id?: true
    walletAddress?: true
    userId?: true
    currencyId?: true
    amount?: true
    txHash?: true
    timestamp?: true
    _all?: true
  }

  export type RewardClaimLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardClaimLog to aggregate.
     */
    where?: RewardClaimLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardClaimLogs to fetch.
     */
    orderBy?: RewardClaimLogOrderByWithRelationInput | RewardClaimLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RewardClaimLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardClaimLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardClaimLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RewardClaimLogs
    **/
    _count?: true | RewardClaimLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardClaimLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardClaimLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardClaimLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardClaimLogMaxAggregateInputType
  }

  export type GetRewardClaimLogAggregateType<T extends RewardClaimLogAggregateArgs> = {
        [P in keyof T & keyof AggregateRewardClaimLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRewardClaimLog[P]>
      : GetScalarType<T[P], AggregateRewardClaimLog[P]>
  }




  export type RewardClaimLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RewardClaimLogWhereInput
    orderBy?: RewardClaimLogOrderByWithAggregationInput | RewardClaimLogOrderByWithAggregationInput[]
    by: RewardClaimLogScalarFieldEnum[] | RewardClaimLogScalarFieldEnum
    having?: RewardClaimLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardClaimLogCountAggregateInputType | true
    _avg?: RewardClaimLogAvgAggregateInputType
    _sum?: RewardClaimLogSumAggregateInputType
    _min?: RewardClaimLogMinAggregateInputType
    _max?: RewardClaimLogMaxAggregateInputType
  }

  export type RewardClaimLogGroupByOutputType = {
    id: string
    walletAddress: string
    userId: string | null
    currencyId: string
    amount: Decimal
    txHash: string | null
    timestamp: Date
    _count: RewardClaimLogCountAggregateOutputType | null
    _avg: RewardClaimLogAvgAggregateOutputType | null
    _sum: RewardClaimLogSumAggregateOutputType | null
    _min: RewardClaimLogMinAggregateOutputType | null
    _max: RewardClaimLogMaxAggregateOutputType | null
  }

  type GetRewardClaimLogGroupByPayload<T extends RewardClaimLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardClaimLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardClaimLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardClaimLogGroupByOutputType[P]>
            : GetScalarType<T[P], RewardClaimLogGroupByOutputType[P]>
        }
      >
    >


  export type RewardClaimLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletAddress?: boolean
    userId?: boolean
    currencyId?: boolean
    amount?: boolean
    txHash?: boolean
    timestamp?: boolean
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    user?: boolean | RewardClaimLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["rewardClaimLog"]>

  export type RewardClaimLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletAddress?: boolean
    userId?: boolean
    currencyId?: boolean
    amount?: boolean
    txHash?: boolean
    timestamp?: boolean
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    user?: boolean | RewardClaimLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["rewardClaimLog"]>

  export type RewardClaimLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletAddress?: boolean
    userId?: boolean
    currencyId?: boolean
    amount?: boolean
    txHash?: boolean
    timestamp?: boolean
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    user?: boolean | RewardClaimLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["rewardClaimLog"]>

  export type RewardClaimLogSelectScalar = {
    id?: boolean
    walletAddress?: boolean
    userId?: boolean
    currencyId?: boolean
    amount?: boolean
    txHash?: boolean
    timestamp?: boolean
  }

  export type RewardClaimLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletAddress" | "userId" | "currencyId" | "amount" | "txHash" | "timestamp", ExtArgs["result"]["rewardClaimLog"]>
  export type RewardClaimLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    user?: boolean | RewardClaimLog$userArgs<ExtArgs>
  }
  export type RewardClaimLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    user?: boolean | RewardClaimLog$userArgs<ExtArgs>
  }
  export type RewardClaimLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | CurrencyDefaultArgs<ExtArgs>
    user?: boolean | RewardClaimLog$userArgs<ExtArgs>
  }

  export type $RewardClaimLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RewardClaimLog"
    objects: {
      currency: Prisma.$CurrencyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletAddress: string
      userId: string | null
      currencyId: string
      amount: Prisma.Decimal
      txHash: string | null
      timestamp: Date
    }, ExtArgs["result"]["rewardClaimLog"]>
    composites: {}
  }

  type RewardClaimLogGetPayload<S extends boolean | null | undefined | RewardClaimLogDefaultArgs> = $Result.GetResult<Prisma.$RewardClaimLogPayload, S>

  type RewardClaimLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RewardClaimLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardClaimLogCountAggregateInputType | true
    }

  export interface RewardClaimLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RewardClaimLog'], meta: { name: 'RewardClaimLog' } }
    /**
     * Find zero or one RewardClaimLog that matches the filter.
     * @param {RewardClaimLogFindUniqueArgs} args - Arguments to find a RewardClaimLog
     * @example
     * // Get one RewardClaimLog
     * const rewardClaimLog = await prisma.rewardClaimLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RewardClaimLogFindUniqueArgs>(args: SelectSubset<T, RewardClaimLogFindUniqueArgs<ExtArgs>>): Prisma__RewardClaimLogClient<$Result.GetResult<Prisma.$RewardClaimLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RewardClaimLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RewardClaimLogFindUniqueOrThrowArgs} args - Arguments to find a RewardClaimLog
     * @example
     * // Get one RewardClaimLog
     * const rewardClaimLog = await prisma.rewardClaimLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RewardClaimLogFindUniqueOrThrowArgs>(args: SelectSubset<T, RewardClaimLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RewardClaimLogClient<$Result.GetResult<Prisma.$RewardClaimLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardClaimLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardClaimLogFindFirstArgs} args - Arguments to find a RewardClaimLog
     * @example
     * // Get one RewardClaimLog
     * const rewardClaimLog = await prisma.rewardClaimLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RewardClaimLogFindFirstArgs>(args?: SelectSubset<T, RewardClaimLogFindFirstArgs<ExtArgs>>): Prisma__RewardClaimLogClient<$Result.GetResult<Prisma.$RewardClaimLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RewardClaimLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardClaimLogFindFirstOrThrowArgs} args - Arguments to find a RewardClaimLog
     * @example
     * // Get one RewardClaimLog
     * const rewardClaimLog = await prisma.rewardClaimLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RewardClaimLogFindFirstOrThrowArgs>(args?: SelectSubset<T, RewardClaimLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__RewardClaimLogClient<$Result.GetResult<Prisma.$RewardClaimLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RewardClaimLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardClaimLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RewardClaimLogs
     * const rewardClaimLogs = await prisma.rewardClaimLog.findMany()
     * 
     * // Get first 10 RewardClaimLogs
     * const rewardClaimLogs = await prisma.rewardClaimLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardClaimLogWithIdOnly = await prisma.rewardClaimLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RewardClaimLogFindManyArgs>(args?: SelectSubset<T, RewardClaimLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardClaimLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RewardClaimLog.
     * @param {RewardClaimLogCreateArgs} args - Arguments to create a RewardClaimLog.
     * @example
     * // Create one RewardClaimLog
     * const RewardClaimLog = await prisma.rewardClaimLog.create({
     *   data: {
     *     // ... data to create a RewardClaimLog
     *   }
     * })
     * 
     */
    create<T extends RewardClaimLogCreateArgs>(args: SelectSubset<T, RewardClaimLogCreateArgs<ExtArgs>>): Prisma__RewardClaimLogClient<$Result.GetResult<Prisma.$RewardClaimLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RewardClaimLogs.
     * @param {RewardClaimLogCreateManyArgs} args - Arguments to create many RewardClaimLogs.
     * @example
     * // Create many RewardClaimLogs
     * const rewardClaimLog = await prisma.rewardClaimLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RewardClaimLogCreateManyArgs>(args?: SelectSubset<T, RewardClaimLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RewardClaimLogs and returns the data saved in the database.
     * @param {RewardClaimLogCreateManyAndReturnArgs} args - Arguments to create many RewardClaimLogs.
     * @example
     * // Create many RewardClaimLogs
     * const rewardClaimLog = await prisma.rewardClaimLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RewardClaimLogs and only return the `id`
     * const rewardClaimLogWithIdOnly = await prisma.rewardClaimLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RewardClaimLogCreateManyAndReturnArgs>(args?: SelectSubset<T, RewardClaimLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardClaimLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RewardClaimLog.
     * @param {RewardClaimLogDeleteArgs} args - Arguments to delete one RewardClaimLog.
     * @example
     * // Delete one RewardClaimLog
     * const RewardClaimLog = await prisma.rewardClaimLog.delete({
     *   where: {
     *     // ... filter to delete one RewardClaimLog
     *   }
     * })
     * 
     */
    delete<T extends RewardClaimLogDeleteArgs>(args: SelectSubset<T, RewardClaimLogDeleteArgs<ExtArgs>>): Prisma__RewardClaimLogClient<$Result.GetResult<Prisma.$RewardClaimLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RewardClaimLog.
     * @param {RewardClaimLogUpdateArgs} args - Arguments to update one RewardClaimLog.
     * @example
     * // Update one RewardClaimLog
     * const rewardClaimLog = await prisma.rewardClaimLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RewardClaimLogUpdateArgs>(args: SelectSubset<T, RewardClaimLogUpdateArgs<ExtArgs>>): Prisma__RewardClaimLogClient<$Result.GetResult<Prisma.$RewardClaimLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RewardClaimLogs.
     * @param {RewardClaimLogDeleteManyArgs} args - Arguments to filter RewardClaimLogs to delete.
     * @example
     * // Delete a few RewardClaimLogs
     * const { count } = await prisma.rewardClaimLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RewardClaimLogDeleteManyArgs>(args?: SelectSubset<T, RewardClaimLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardClaimLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardClaimLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RewardClaimLogs
     * const rewardClaimLog = await prisma.rewardClaimLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RewardClaimLogUpdateManyArgs>(args: SelectSubset<T, RewardClaimLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RewardClaimLogs and returns the data updated in the database.
     * @param {RewardClaimLogUpdateManyAndReturnArgs} args - Arguments to update many RewardClaimLogs.
     * @example
     * // Update many RewardClaimLogs
     * const rewardClaimLog = await prisma.rewardClaimLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RewardClaimLogs and only return the `id`
     * const rewardClaimLogWithIdOnly = await prisma.rewardClaimLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RewardClaimLogUpdateManyAndReturnArgs>(args: SelectSubset<T, RewardClaimLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RewardClaimLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RewardClaimLog.
     * @param {RewardClaimLogUpsertArgs} args - Arguments to update or create a RewardClaimLog.
     * @example
     * // Update or create a RewardClaimLog
     * const rewardClaimLog = await prisma.rewardClaimLog.upsert({
     *   create: {
     *     // ... data to create a RewardClaimLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RewardClaimLog we want to update
     *   }
     * })
     */
    upsert<T extends RewardClaimLogUpsertArgs>(args: SelectSubset<T, RewardClaimLogUpsertArgs<ExtArgs>>): Prisma__RewardClaimLogClient<$Result.GetResult<Prisma.$RewardClaimLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RewardClaimLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardClaimLogCountArgs} args - Arguments to filter RewardClaimLogs to count.
     * @example
     * // Count the number of RewardClaimLogs
     * const count = await prisma.rewardClaimLog.count({
     *   where: {
     *     // ... the filter for the RewardClaimLogs we want to count
     *   }
     * })
    **/
    count<T extends RewardClaimLogCountArgs>(
      args?: Subset<T, RewardClaimLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardClaimLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RewardClaimLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardClaimLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardClaimLogAggregateArgs>(args: Subset<T, RewardClaimLogAggregateArgs>): Prisma.PrismaPromise<GetRewardClaimLogAggregateType<T>>

    /**
     * Group by RewardClaimLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardClaimLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RewardClaimLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RewardClaimLogGroupByArgs['orderBy'] }
        : { orderBy?: RewardClaimLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RewardClaimLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardClaimLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RewardClaimLog model
   */
  readonly fields: RewardClaimLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RewardClaimLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RewardClaimLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currency<T extends CurrencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CurrencyDefaultArgs<ExtArgs>>): Prisma__CurrencyClient<$Result.GetResult<Prisma.$CurrencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends RewardClaimLog$userArgs<ExtArgs> = {}>(args?: Subset<T, RewardClaimLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RewardClaimLog model
   */
  interface RewardClaimLogFieldRefs {
    readonly id: FieldRef<"RewardClaimLog", 'String'>
    readonly walletAddress: FieldRef<"RewardClaimLog", 'String'>
    readonly userId: FieldRef<"RewardClaimLog", 'String'>
    readonly currencyId: FieldRef<"RewardClaimLog", 'String'>
    readonly amount: FieldRef<"RewardClaimLog", 'Decimal'>
    readonly txHash: FieldRef<"RewardClaimLog", 'String'>
    readonly timestamp: FieldRef<"RewardClaimLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RewardClaimLog findUnique
   */
  export type RewardClaimLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaimLog
     */
    select?: RewardClaimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaimLog
     */
    omit?: RewardClaimLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimLogInclude<ExtArgs> | null
    /**
     * Filter, which RewardClaimLog to fetch.
     */
    where: RewardClaimLogWhereUniqueInput
  }

  /**
   * RewardClaimLog findUniqueOrThrow
   */
  export type RewardClaimLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaimLog
     */
    select?: RewardClaimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaimLog
     */
    omit?: RewardClaimLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimLogInclude<ExtArgs> | null
    /**
     * Filter, which RewardClaimLog to fetch.
     */
    where: RewardClaimLogWhereUniqueInput
  }

  /**
   * RewardClaimLog findFirst
   */
  export type RewardClaimLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaimLog
     */
    select?: RewardClaimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaimLog
     */
    omit?: RewardClaimLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimLogInclude<ExtArgs> | null
    /**
     * Filter, which RewardClaimLog to fetch.
     */
    where?: RewardClaimLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardClaimLogs to fetch.
     */
    orderBy?: RewardClaimLogOrderByWithRelationInput | RewardClaimLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardClaimLogs.
     */
    cursor?: RewardClaimLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardClaimLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardClaimLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardClaimLogs.
     */
    distinct?: RewardClaimLogScalarFieldEnum | RewardClaimLogScalarFieldEnum[]
  }

  /**
   * RewardClaimLog findFirstOrThrow
   */
  export type RewardClaimLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaimLog
     */
    select?: RewardClaimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaimLog
     */
    omit?: RewardClaimLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimLogInclude<ExtArgs> | null
    /**
     * Filter, which RewardClaimLog to fetch.
     */
    where?: RewardClaimLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardClaimLogs to fetch.
     */
    orderBy?: RewardClaimLogOrderByWithRelationInput | RewardClaimLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RewardClaimLogs.
     */
    cursor?: RewardClaimLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardClaimLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardClaimLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RewardClaimLogs.
     */
    distinct?: RewardClaimLogScalarFieldEnum | RewardClaimLogScalarFieldEnum[]
  }

  /**
   * RewardClaimLog findMany
   */
  export type RewardClaimLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaimLog
     */
    select?: RewardClaimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaimLog
     */
    omit?: RewardClaimLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimLogInclude<ExtArgs> | null
    /**
     * Filter, which RewardClaimLogs to fetch.
     */
    where?: RewardClaimLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RewardClaimLogs to fetch.
     */
    orderBy?: RewardClaimLogOrderByWithRelationInput | RewardClaimLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RewardClaimLogs.
     */
    cursor?: RewardClaimLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RewardClaimLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RewardClaimLogs.
     */
    skip?: number
    distinct?: RewardClaimLogScalarFieldEnum | RewardClaimLogScalarFieldEnum[]
  }

  /**
   * RewardClaimLog create
   */
  export type RewardClaimLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaimLog
     */
    select?: RewardClaimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaimLog
     */
    omit?: RewardClaimLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimLogInclude<ExtArgs> | null
    /**
     * The data needed to create a RewardClaimLog.
     */
    data: XOR<RewardClaimLogCreateInput, RewardClaimLogUncheckedCreateInput>
  }

  /**
   * RewardClaimLog createMany
   */
  export type RewardClaimLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RewardClaimLogs.
     */
    data: RewardClaimLogCreateManyInput | RewardClaimLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RewardClaimLog createManyAndReturn
   */
  export type RewardClaimLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaimLog
     */
    select?: RewardClaimLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaimLog
     */
    omit?: RewardClaimLogOmit<ExtArgs> | null
    /**
     * The data used to create many RewardClaimLogs.
     */
    data: RewardClaimLogCreateManyInput | RewardClaimLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardClaimLog update
   */
  export type RewardClaimLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaimLog
     */
    select?: RewardClaimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaimLog
     */
    omit?: RewardClaimLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimLogInclude<ExtArgs> | null
    /**
     * The data needed to update a RewardClaimLog.
     */
    data: XOR<RewardClaimLogUpdateInput, RewardClaimLogUncheckedUpdateInput>
    /**
     * Choose, which RewardClaimLog to update.
     */
    where: RewardClaimLogWhereUniqueInput
  }

  /**
   * RewardClaimLog updateMany
   */
  export type RewardClaimLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RewardClaimLogs.
     */
    data: XOR<RewardClaimLogUpdateManyMutationInput, RewardClaimLogUncheckedUpdateManyInput>
    /**
     * Filter which RewardClaimLogs to update
     */
    where?: RewardClaimLogWhereInput
    /**
     * Limit how many RewardClaimLogs to update.
     */
    limit?: number
  }

  /**
   * RewardClaimLog updateManyAndReturn
   */
  export type RewardClaimLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaimLog
     */
    select?: RewardClaimLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaimLog
     */
    omit?: RewardClaimLogOmit<ExtArgs> | null
    /**
     * The data used to update RewardClaimLogs.
     */
    data: XOR<RewardClaimLogUpdateManyMutationInput, RewardClaimLogUncheckedUpdateManyInput>
    /**
     * Filter which RewardClaimLogs to update
     */
    where?: RewardClaimLogWhereInput
    /**
     * Limit how many RewardClaimLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RewardClaimLog upsert
   */
  export type RewardClaimLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaimLog
     */
    select?: RewardClaimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaimLog
     */
    omit?: RewardClaimLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimLogInclude<ExtArgs> | null
    /**
     * The filter to search for the RewardClaimLog to update in case it exists.
     */
    where: RewardClaimLogWhereUniqueInput
    /**
     * In case the RewardClaimLog found by the `where` argument doesn't exist, create a new RewardClaimLog with this data.
     */
    create: XOR<RewardClaimLogCreateInput, RewardClaimLogUncheckedCreateInput>
    /**
     * In case the RewardClaimLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RewardClaimLogUpdateInput, RewardClaimLogUncheckedUpdateInput>
  }

  /**
   * RewardClaimLog delete
   */
  export type RewardClaimLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaimLog
     */
    select?: RewardClaimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaimLog
     */
    omit?: RewardClaimLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimLogInclude<ExtArgs> | null
    /**
     * Filter which RewardClaimLog to delete.
     */
    where: RewardClaimLogWhereUniqueInput
  }

  /**
   * RewardClaimLog deleteMany
   */
  export type RewardClaimLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RewardClaimLogs to delete
     */
    where?: RewardClaimLogWhereInput
    /**
     * Limit how many RewardClaimLogs to delete.
     */
    limit?: number
  }

  /**
   * RewardClaimLog.user
   */
  export type RewardClaimLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RewardClaimLog without action
   */
  export type RewardClaimLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RewardClaimLog
     */
    select?: RewardClaimLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RewardClaimLog
     */
    omit?: RewardClaimLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RewardClaimLogInclude<ExtArgs> | null
  }


  /**
   * Model StolenItem
   */

  export type AggregateStolenItem = {
    _count: StolenItemCountAggregateOutputType | null
    _min: StolenItemMinAggregateOutputType | null
    _max: StolenItemMaxAggregateOutputType | null
  }

  export type StolenItemMinAggregateOutputType = {
    id: string | null
    contract: string | null
    tokenId: string | null
    status: $Enums.StolenStatus | null
    source: $Enums.StolenSource | null
    reporterAddress: string | null
    reporterUserId: string | null
    evidenceUrl: string | null
    notes: string | null
    disputed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StolenItemMaxAggregateOutputType = {
    id: string | null
    contract: string | null
    tokenId: string | null
    status: $Enums.StolenStatus | null
    source: $Enums.StolenSource | null
    reporterAddress: string | null
    reporterUserId: string | null
    evidenceUrl: string | null
    notes: string | null
    disputed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StolenItemCountAggregateOutputType = {
    id: number
    contract: number
    tokenId: number
    status: number
    source: number
    reporterAddress: number
    reporterUserId: number
    evidenceUrl: number
    notes: number
    disputed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StolenItemMinAggregateInputType = {
    id?: true
    contract?: true
    tokenId?: true
    status?: true
    source?: true
    reporterAddress?: true
    reporterUserId?: true
    evidenceUrl?: true
    notes?: true
    disputed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StolenItemMaxAggregateInputType = {
    id?: true
    contract?: true
    tokenId?: true
    status?: true
    source?: true
    reporterAddress?: true
    reporterUserId?: true
    evidenceUrl?: true
    notes?: true
    disputed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StolenItemCountAggregateInputType = {
    id?: true
    contract?: true
    tokenId?: true
    status?: true
    source?: true
    reporterAddress?: true
    reporterUserId?: true
    evidenceUrl?: true
    notes?: true
    disputed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StolenItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StolenItem to aggregate.
     */
    where?: StolenItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StolenItems to fetch.
     */
    orderBy?: StolenItemOrderByWithRelationInput | StolenItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StolenItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StolenItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StolenItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StolenItems
    **/
    _count?: true | StolenItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StolenItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StolenItemMaxAggregateInputType
  }

  export type GetStolenItemAggregateType<T extends StolenItemAggregateArgs> = {
        [P in keyof T & keyof AggregateStolenItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStolenItem[P]>
      : GetScalarType<T[P], AggregateStolenItem[P]>
  }




  export type StolenItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StolenItemWhereInput
    orderBy?: StolenItemOrderByWithAggregationInput | StolenItemOrderByWithAggregationInput[]
    by: StolenItemScalarFieldEnum[] | StolenItemScalarFieldEnum
    having?: StolenItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StolenItemCountAggregateInputType | true
    _min?: StolenItemMinAggregateInputType
    _max?: StolenItemMaxAggregateInputType
  }

  export type StolenItemGroupByOutputType = {
    id: string
    contract: string
    tokenId: string
    status: $Enums.StolenStatus
    source: $Enums.StolenSource
    reporterAddress: string | null
    reporterUserId: string | null
    evidenceUrl: string | null
    notes: string | null
    disputed: boolean
    createdAt: Date
    updatedAt: Date
    _count: StolenItemCountAggregateOutputType | null
    _min: StolenItemMinAggregateOutputType | null
    _max: StolenItemMaxAggregateOutputType | null
  }

  type GetStolenItemGroupByPayload<T extends StolenItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StolenItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StolenItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StolenItemGroupByOutputType[P]>
            : GetScalarType<T[P], StolenItemGroupByOutputType[P]>
        }
      >
    >


  export type StolenItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    status?: boolean
    source?: boolean
    reporterAddress?: boolean
    reporterUserId?: boolean
    evidenceUrl?: boolean
    notes?: boolean
    disputed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reporter?: boolean | StolenItem$reporterArgs<ExtArgs>
  }, ExtArgs["result"]["stolenItem"]>

  export type StolenItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    status?: boolean
    source?: boolean
    reporterAddress?: boolean
    reporterUserId?: boolean
    evidenceUrl?: boolean
    notes?: boolean
    disputed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reporter?: boolean | StolenItem$reporterArgs<ExtArgs>
  }, ExtArgs["result"]["stolenItem"]>

  export type StolenItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    status?: boolean
    source?: boolean
    reporterAddress?: boolean
    reporterUserId?: boolean
    evidenceUrl?: boolean
    notes?: boolean
    disputed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reporter?: boolean | StolenItem$reporterArgs<ExtArgs>
  }, ExtArgs["result"]["stolenItem"]>

  export type StolenItemSelectScalar = {
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    status?: boolean
    source?: boolean
    reporterAddress?: boolean
    reporterUserId?: boolean
    evidenceUrl?: boolean
    notes?: boolean
    disputed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StolenItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contract" | "tokenId" | "status" | "source" | "reporterAddress" | "reporterUserId" | "evidenceUrl" | "notes" | "disputed" | "createdAt" | "updatedAt", ExtArgs["result"]["stolenItem"]>
  export type StolenItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | StolenItem$reporterArgs<ExtArgs>
  }
  export type StolenItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | StolenItem$reporterArgs<ExtArgs>
  }
  export type StolenItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | StolenItem$reporterArgs<ExtArgs>
  }

  export type $StolenItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StolenItem"
    objects: {
      reporter: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contract: string
      tokenId: string
      status: $Enums.StolenStatus
      source: $Enums.StolenSource
      reporterAddress: string | null
      reporterUserId: string | null
      evidenceUrl: string | null
      notes: string | null
      disputed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stolenItem"]>
    composites: {}
  }

  type StolenItemGetPayload<S extends boolean | null | undefined | StolenItemDefaultArgs> = $Result.GetResult<Prisma.$StolenItemPayload, S>

  type StolenItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StolenItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StolenItemCountAggregateInputType | true
    }

  export interface StolenItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StolenItem'], meta: { name: 'StolenItem' } }
    /**
     * Find zero or one StolenItem that matches the filter.
     * @param {StolenItemFindUniqueArgs} args - Arguments to find a StolenItem
     * @example
     * // Get one StolenItem
     * const stolenItem = await prisma.stolenItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StolenItemFindUniqueArgs>(args: SelectSubset<T, StolenItemFindUniqueArgs<ExtArgs>>): Prisma__StolenItemClient<$Result.GetResult<Prisma.$StolenItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StolenItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StolenItemFindUniqueOrThrowArgs} args - Arguments to find a StolenItem
     * @example
     * // Get one StolenItem
     * const stolenItem = await prisma.stolenItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StolenItemFindUniqueOrThrowArgs>(args: SelectSubset<T, StolenItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StolenItemClient<$Result.GetResult<Prisma.$StolenItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StolenItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenItemFindFirstArgs} args - Arguments to find a StolenItem
     * @example
     * // Get one StolenItem
     * const stolenItem = await prisma.stolenItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StolenItemFindFirstArgs>(args?: SelectSubset<T, StolenItemFindFirstArgs<ExtArgs>>): Prisma__StolenItemClient<$Result.GetResult<Prisma.$StolenItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StolenItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenItemFindFirstOrThrowArgs} args - Arguments to find a StolenItem
     * @example
     * // Get one StolenItem
     * const stolenItem = await prisma.stolenItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StolenItemFindFirstOrThrowArgs>(args?: SelectSubset<T, StolenItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__StolenItemClient<$Result.GetResult<Prisma.$StolenItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StolenItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StolenItems
     * const stolenItems = await prisma.stolenItem.findMany()
     * 
     * // Get first 10 StolenItems
     * const stolenItems = await prisma.stolenItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stolenItemWithIdOnly = await prisma.stolenItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StolenItemFindManyArgs>(args?: SelectSubset<T, StolenItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StolenItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StolenItem.
     * @param {StolenItemCreateArgs} args - Arguments to create a StolenItem.
     * @example
     * // Create one StolenItem
     * const StolenItem = await prisma.stolenItem.create({
     *   data: {
     *     // ... data to create a StolenItem
     *   }
     * })
     * 
     */
    create<T extends StolenItemCreateArgs>(args: SelectSubset<T, StolenItemCreateArgs<ExtArgs>>): Prisma__StolenItemClient<$Result.GetResult<Prisma.$StolenItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StolenItems.
     * @param {StolenItemCreateManyArgs} args - Arguments to create many StolenItems.
     * @example
     * // Create many StolenItems
     * const stolenItem = await prisma.stolenItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StolenItemCreateManyArgs>(args?: SelectSubset<T, StolenItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StolenItems and returns the data saved in the database.
     * @param {StolenItemCreateManyAndReturnArgs} args - Arguments to create many StolenItems.
     * @example
     * // Create many StolenItems
     * const stolenItem = await prisma.stolenItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StolenItems and only return the `id`
     * const stolenItemWithIdOnly = await prisma.stolenItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StolenItemCreateManyAndReturnArgs>(args?: SelectSubset<T, StolenItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StolenItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StolenItem.
     * @param {StolenItemDeleteArgs} args - Arguments to delete one StolenItem.
     * @example
     * // Delete one StolenItem
     * const StolenItem = await prisma.stolenItem.delete({
     *   where: {
     *     // ... filter to delete one StolenItem
     *   }
     * })
     * 
     */
    delete<T extends StolenItemDeleteArgs>(args: SelectSubset<T, StolenItemDeleteArgs<ExtArgs>>): Prisma__StolenItemClient<$Result.GetResult<Prisma.$StolenItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StolenItem.
     * @param {StolenItemUpdateArgs} args - Arguments to update one StolenItem.
     * @example
     * // Update one StolenItem
     * const stolenItem = await prisma.stolenItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StolenItemUpdateArgs>(args: SelectSubset<T, StolenItemUpdateArgs<ExtArgs>>): Prisma__StolenItemClient<$Result.GetResult<Prisma.$StolenItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StolenItems.
     * @param {StolenItemDeleteManyArgs} args - Arguments to filter StolenItems to delete.
     * @example
     * // Delete a few StolenItems
     * const { count } = await prisma.stolenItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StolenItemDeleteManyArgs>(args?: SelectSubset<T, StolenItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StolenItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StolenItems
     * const stolenItem = await prisma.stolenItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StolenItemUpdateManyArgs>(args: SelectSubset<T, StolenItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StolenItems and returns the data updated in the database.
     * @param {StolenItemUpdateManyAndReturnArgs} args - Arguments to update many StolenItems.
     * @example
     * // Update many StolenItems
     * const stolenItem = await prisma.stolenItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StolenItems and only return the `id`
     * const stolenItemWithIdOnly = await prisma.stolenItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StolenItemUpdateManyAndReturnArgs>(args: SelectSubset<T, StolenItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StolenItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StolenItem.
     * @param {StolenItemUpsertArgs} args - Arguments to update or create a StolenItem.
     * @example
     * // Update or create a StolenItem
     * const stolenItem = await prisma.stolenItem.upsert({
     *   create: {
     *     // ... data to create a StolenItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StolenItem we want to update
     *   }
     * })
     */
    upsert<T extends StolenItemUpsertArgs>(args: SelectSubset<T, StolenItemUpsertArgs<ExtArgs>>): Prisma__StolenItemClient<$Result.GetResult<Prisma.$StolenItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StolenItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenItemCountArgs} args - Arguments to filter StolenItems to count.
     * @example
     * // Count the number of StolenItems
     * const count = await prisma.stolenItem.count({
     *   where: {
     *     // ... the filter for the StolenItems we want to count
     *   }
     * })
    **/
    count<T extends StolenItemCountArgs>(
      args?: Subset<T, StolenItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StolenItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StolenItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StolenItemAggregateArgs>(args: Subset<T, StolenItemAggregateArgs>): Prisma.PrismaPromise<GetStolenItemAggregateType<T>>

    /**
     * Group by StolenItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StolenItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StolenItemGroupByArgs['orderBy'] }
        : { orderBy?: StolenItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StolenItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStolenItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StolenItem model
   */
  readonly fields: StolenItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StolenItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StolenItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reporter<T extends StolenItem$reporterArgs<ExtArgs> = {}>(args?: Subset<T, StolenItem$reporterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StolenItem model
   */
  interface StolenItemFieldRefs {
    readonly id: FieldRef<"StolenItem", 'String'>
    readonly contract: FieldRef<"StolenItem", 'String'>
    readonly tokenId: FieldRef<"StolenItem", 'String'>
    readonly status: FieldRef<"StolenItem", 'StolenStatus'>
    readonly source: FieldRef<"StolenItem", 'StolenSource'>
    readonly reporterAddress: FieldRef<"StolenItem", 'String'>
    readonly reporterUserId: FieldRef<"StolenItem", 'String'>
    readonly evidenceUrl: FieldRef<"StolenItem", 'String'>
    readonly notes: FieldRef<"StolenItem", 'String'>
    readonly disputed: FieldRef<"StolenItem", 'Boolean'>
    readonly createdAt: FieldRef<"StolenItem", 'DateTime'>
    readonly updatedAt: FieldRef<"StolenItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StolenItem findUnique
   */
  export type StolenItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenItem
     */
    select?: StolenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenItem
     */
    omit?: StolenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StolenItemInclude<ExtArgs> | null
    /**
     * Filter, which StolenItem to fetch.
     */
    where: StolenItemWhereUniqueInput
  }

  /**
   * StolenItem findUniqueOrThrow
   */
  export type StolenItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenItem
     */
    select?: StolenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenItem
     */
    omit?: StolenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StolenItemInclude<ExtArgs> | null
    /**
     * Filter, which StolenItem to fetch.
     */
    where: StolenItemWhereUniqueInput
  }

  /**
   * StolenItem findFirst
   */
  export type StolenItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenItem
     */
    select?: StolenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenItem
     */
    omit?: StolenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StolenItemInclude<ExtArgs> | null
    /**
     * Filter, which StolenItem to fetch.
     */
    where?: StolenItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StolenItems to fetch.
     */
    orderBy?: StolenItemOrderByWithRelationInput | StolenItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StolenItems.
     */
    cursor?: StolenItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StolenItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StolenItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StolenItems.
     */
    distinct?: StolenItemScalarFieldEnum | StolenItemScalarFieldEnum[]
  }

  /**
   * StolenItem findFirstOrThrow
   */
  export type StolenItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenItem
     */
    select?: StolenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenItem
     */
    omit?: StolenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StolenItemInclude<ExtArgs> | null
    /**
     * Filter, which StolenItem to fetch.
     */
    where?: StolenItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StolenItems to fetch.
     */
    orderBy?: StolenItemOrderByWithRelationInput | StolenItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StolenItems.
     */
    cursor?: StolenItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StolenItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StolenItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StolenItems.
     */
    distinct?: StolenItemScalarFieldEnum | StolenItemScalarFieldEnum[]
  }

  /**
   * StolenItem findMany
   */
  export type StolenItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenItem
     */
    select?: StolenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenItem
     */
    omit?: StolenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StolenItemInclude<ExtArgs> | null
    /**
     * Filter, which StolenItems to fetch.
     */
    where?: StolenItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StolenItems to fetch.
     */
    orderBy?: StolenItemOrderByWithRelationInput | StolenItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StolenItems.
     */
    cursor?: StolenItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StolenItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StolenItems.
     */
    skip?: number
    distinct?: StolenItemScalarFieldEnum | StolenItemScalarFieldEnum[]
  }

  /**
   * StolenItem create
   */
  export type StolenItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenItem
     */
    select?: StolenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenItem
     */
    omit?: StolenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StolenItemInclude<ExtArgs> | null
    /**
     * The data needed to create a StolenItem.
     */
    data: XOR<StolenItemCreateInput, StolenItemUncheckedCreateInput>
  }

  /**
   * StolenItem createMany
   */
  export type StolenItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StolenItems.
     */
    data: StolenItemCreateManyInput | StolenItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StolenItem createManyAndReturn
   */
  export type StolenItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenItem
     */
    select?: StolenItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StolenItem
     */
    omit?: StolenItemOmit<ExtArgs> | null
    /**
     * The data used to create many StolenItems.
     */
    data: StolenItemCreateManyInput | StolenItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StolenItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StolenItem update
   */
  export type StolenItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenItem
     */
    select?: StolenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenItem
     */
    omit?: StolenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StolenItemInclude<ExtArgs> | null
    /**
     * The data needed to update a StolenItem.
     */
    data: XOR<StolenItemUpdateInput, StolenItemUncheckedUpdateInput>
    /**
     * Choose, which StolenItem to update.
     */
    where: StolenItemWhereUniqueInput
  }

  /**
   * StolenItem updateMany
   */
  export type StolenItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StolenItems.
     */
    data: XOR<StolenItemUpdateManyMutationInput, StolenItemUncheckedUpdateManyInput>
    /**
     * Filter which StolenItems to update
     */
    where?: StolenItemWhereInput
    /**
     * Limit how many StolenItems to update.
     */
    limit?: number
  }

  /**
   * StolenItem updateManyAndReturn
   */
  export type StolenItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenItem
     */
    select?: StolenItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StolenItem
     */
    omit?: StolenItemOmit<ExtArgs> | null
    /**
     * The data used to update StolenItems.
     */
    data: XOR<StolenItemUpdateManyMutationInput, StolenItemUncheckedUpdateManyInput>
    /**
     * Filter which StolenItems to update
     */
    where?: StolenItemWhereInput
    /**
     * Limit how many StolenItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StolenItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StolenItem upsert
   */
  export type StolenItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenItem
     */
    select?: StolenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenItem
     */
    omit?: StolenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StolenItemInclude<ExtArgs> | null
    /**
     * The filter to search for the StolenItem to update in case it exists.
     */
    where: StolenItemWhereUniqueInput
    /**
     * In case the StolenItem found by the `where` argument doesn't exist, create a new StolenItem with this data.
     */
    create: XOR<StolenItemCreateInput, StolenItemUncheckedCreateInput>
    /**
     * In case the StolenItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StolenItemUpdateInput, StolenItemUncheckedUpdateInput>
  }

  /**
   * StolenItem delete
   */
  export type StolenItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenItem
     */
    select?: StolenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenItem
     */
    omit?: StolenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StolenItemInclude<ExtArgs> | null
    /**
     * Filter which StolenItem to delete.
     */
    where: StolenItemWhereUniqueInput
  }

  /**
   * StolenItem deleteMany
   */
  export type StolenItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StolenItems to delete
     */
    where?: StolenItemWhereInput
    /**
     * Limit how many StolenItems to delete.
     */
    limit?: number
  }

  /**
   * StolenItem.reporter
   */
  export type StolenItem$reporterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StolenItem without action
   */
  export type StolenItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenItem
     */
    select?: StolenItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenItem
     */
    omit?: StolenItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StolenItemInclude<ExtArgs> | null
  }


  /**
   * Model StolenEvent
   */

  export type AggregateStolenEvent = {
    _count: StolenEventCountAggregateOutputType | null
    _avg: StolenEventAvgAggregateOutputType | null
    _sum: StolenEventSumAggregateOutputType | null
    _min: StolenEventMinAggregateOutputType | null
    _max: StolenEventMaxAggregateOutputType | null
  }

  export type StolenEventAvgAggregateOutputType = {
    logIndex: number | null
    blockNumber: number | null
  }

  export type StolenEventSumAggregateOutputType = {
    logIndex: number | null
    blockNumber: number | null
  }

  export type StolenEventMinAggregateOutputType = {
    id: string | null
    contract: string | null
    tokenId: string | null
    action: string | null
    actorAddress: string | null
    txHash: string | null
    logIndex: number | null
    blockNumber: number | null
    timestamp: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type StolenEventMaxAggregateOutputType = {
    id: string | null
    contract: string | null
    tokenId: string | null
    action: string | null
    actorAddress: string | null
    txHash: string | null
    logIndex: number | null
    blockNumber: number | null
    timestamp: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type StolenEventCountAggregateOutputType = {
    id: number
    contract: number
    tokenId: number
    action: number
    actorAddress: number
    txHash: number
    logIndex: number
    blockNumber: number
    timestamp: number
    notes: number
    createdAt: number
    _all: number
  }


  export type StolenEventAvgAggregateInputType = {
    logIndex?: true
    blockNumber?: true
  }

  export type StolenEventSumAggregateInputType = {
    logIndex?: true
    blockNumber?: true
  }

  export type StolenEventMinAggregateInputType = {
    id?: true
    contract?: true
    tokenId?: true
    action?: true
    actorAddress?: true
    txHash?: true
    logIndex?: true
    blockNumber?: true
    timestamp?: true
    notes?: true
    createdAt?: true
  }

  export type StolenEventMaxAggregateInputType = {
    id?: true
    contract?: true
    tokenId?: true
    action?: true
    actorAddress?: true
    txHash?: true
    logIndex?: true
    blockNumber?: true
    timestamp?: true
    notes?: true
    createdAt?: true
  }

  export type StolenEventCountAggregateInputType = {
    id?: true
    contract?: true
    tokenId?: true
    action?: true
    actorAddress?: true
    txHash?: true
    logIndex?: true
    blockNumber?: true
    timestamp?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type StolenEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StolenEvent to aggregate.
     */
    where?: StolenEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StolenEvents to fetch.
     */
    orderBy?: StolenEventOrderByWithRelationInput | StolenEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StolenEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StolenEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StolenEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StolenEvents
    **/
    _count?: true | StolenEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StolenEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StolenEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StolenEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StolenEventMaxAggregateInputType
  }

  export type GetStolenEventAggregateType<T extends StolenEventAggregateArgs> = {
        [P in keyof T & keyof AggregateStolenEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStolenEvent[P]>
      : GetScalarType<T[P], AggregateStolenEvent[P]>
  }




  export type StolenEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StolenEventWhereInput
    orderBy?: StolenEventOrderByWithAggregationInput | StolenEventOrderByWithAggregationInput[]
    by: StolenEventScalarFieldEnum[] | StolenEventScalarFieldEnum
    having?: StolenEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StolenEventCountAggregateInputType | true
    _avg?: StolenEventAvgAggregateInputType
    _sum?: StolenEventSumAggregateInputType
    _min?: StolenEventMinAggregateInputType
    _max?: StolenEventMaxAggregateInputType
  }

  export type StolenEventGroupByOutputType = {
    id: string
    contract: string
    tokenId: string
    action: string
    actorAddress: string | null
    txHash: string | null
    logIndex: number | null
    blockNumber: number | null
    timestamp: Date
    notes: string | null
    createdAt: Date
    _count: StolenEventCountAggregateOutputType | null
    _avg: StolenEventAvgAggregateOutputType | null
    _sum: StolenEventSumAggregateOutputType | null
    _min: StolenEventMinAggregateOutputType | null
    _max: StolenEventMaxAggregateOutputType | null
  }

  type GetStolenEventGroupByPayload<T extends StolenEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StolenEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StolenEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StolenEventGroupByOutputType[P]>
            : GetScalarType<T[P], StolenEventGroupByOutputType[P]>
        }
      >
    >


  export type StolenEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    action?: boolean
    actorAddress?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    notes?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["stolenEvent"]>

  export type StolenEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    action?: boolean
    actorAddress?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    notes?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["stolenEvent"]>

  export type StolenEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    action?: boolean
    actorAddress?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    notes?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["stolenEvent"]>

  export type StolenEventSelectScalar = {
    id?: boolean
    contract?: boolean
    tokenId?: boolean
    action?: boolean
    actorAddress?: boolean
    txHash?: boolean
    logIndex?: boolean
    blockNumber?: boolean
    timestamp?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type StolenEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contract" | "tokenId" | "action" | "actorAddress" | "txHash" | "logIndex" | "blockNumber" | "timestamp" | "notes" | "createdAt", ExtArgs["result"]["stolenEvent"]>

  export type $StolenEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StolenEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contract: string
      tokenId: string
      action: string
      actorAddress: string | null
      txHash: string | null
      logIndex: number | null
      blockNumber: number | null
      timestamp: Date
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["stolenEvent"]>
    composites: {}
  }

  type StolenEventGetPayload<S extends boolean | null | undefined | StolenEventDefaultArgs> = $Result.GetResult<Prisma.$StolenEventPayload, S>

  type StolenEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StolenEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StolenEventCountAggregateInputType | true
    }

  export interface StolenEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StolenEvent'], meta: { name: 'StolenEvent' } }
    /**
     * Find zero or one StolenEvent that matches the filter.
     * @param {StolenEventFindUniqueArgs} args - Arguments to find a StolenEvent
     * @example
     * // Get one StolenEvent
     * const stolenEvent = await prisma.stolenEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StolenEventFindUniqueArgs>(args: SelectSubset<T, StolenEventFindUniqueArgs<ExtArgs>>): Prisma__StolenEventClient<$Result.GetResult<Prisma.$StolenEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StolenEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StolenEventFindUniqueOrThrowArgs} args - Arguments to find a StolenEvent
     * @example
     * // Get one StolenEvent
     * const stolenEvent = await prisma.stolenEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StolenEventFindUniqueOrThrowArgs>(args: SelectSubset<T, StolenEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StolenEventClient<$Result.GetResult<Prisma.$StolenEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StolenEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenEventFindFirstArgs} args - Arguments to find a StolenEvent
     * @example
     * // Get one StolenEvent
     * const stolenEvent = await prisma.stolenEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StolenEventFindFirstArgs>(args?: SelectSubset<T, StolenEventFindFirstArgs<ExtArgs>>): Prisma__StolenEventClient<$Result.GetResult<Prisma.$StolenEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StolenEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenEventFindFirstOrThrowArgs} args - Arguments to find a StolenEvent
     * @example
     * // Get one StolenEvent
     * const stolenEvent = await prisma.stolenEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StolenEventFindFirstOrThrowArgs>(args?: SelectSubset<T, StolenEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__StolenEventClient<$Result.GetResult<Prisma.$StolenEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StolenEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StolenEvents
     * const stolenEvents = await prisma.stolenEvent.findMany()
     * 
     * // Get first 10 StolenEvents
     * const stolenEvents = await prisma.stolenEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stolenEventWithIdOnly = await prisma.stolenEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StolenEventFindManyArgs>(args?: SelectSubset<T, StolenEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StolenEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StolenEvent.
     * @param {StolenEventCreateArgs} args - Arguments to create a StolenEvent.
     * @example
     * // Create one StolenEvent
     * const StolenEvent = await prisma.stolenEvent.create({
     *   data: {
     *     // ... data to create a StolenEvent
     *   }
     * })
     * 
     */
    create<T extends StolenEventCreateArgs>(args: SelectSubset<T, StolenEventCreateArgs<ExtArgs>>): Prisma__StolenEventClient<$Result.GetResult<Prisma.$StolenEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StolenEvents.
     * @param {StolenEventCreateManyArgs} args - Arguments to create many StolenEvents.
     * @example
     * // Create many StolenEvents
     * const stolenEvent = await prisma.stolenEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StolenEventCreateManyArgs>(args?: SelectSubset<T, StolenEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StolenEvents and returns the data saved in the database.
     * @param {StolenEventCreateManyAndReturnArgs} args - Arguments to create many StolenEvents.
     * @example
     * // Create many StolenEvents
     * const stolenEvent = await prisma.stolenEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StolenEvents and only return the `id`
     * const stolenEventWithIdOnly = await prisma.stolenEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StolenEventCreateManyAndReturnArgs>(args?: SelectSubset<T, StolenEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StolenEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StolenEvent.
     * @param {StolenEventDeleteArgs} args - Arguments to delete one StolenEvent.
     * @example
     * // Delete one StolenEvent
     * const StolenEvent = await prisma.stolenEvent.delete({
     *   where: {
     *     // ... filter to delete one StolenEvent
     *   }
     * })
     * 
     */
    delete<T extends StolenEventDeleteArgs>(args: SelectSubset<T, StolenEventDeleteArgs<ExtArgs>>): Prisma__StolenEventClient<$Result.GetResult<Prisma.$StolenEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StolenEvent.
     * @param {StolenEventUpdateArgs} args - Arguments to update one StolenEvent.
     * @example
     * // Update one StolenEvent
     * const stolenEvent = await prisma.stolenEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StolenEventUpdateArgs>(args: SelectSubset<T, StolenEventUpdateArgs<ExtArgs>>): Prisma__StolenEventClient<$Result.GetResult<Prisma.$StolenEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StolenEvents.
     * @param {StolenEventDeleteManyArgs} args - Arguments to filter StolenEvents to delete.
     * @example
     * // Delete a few StolenEvents
     * const { count } = await prisma.stolenEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StolenEventDeleteManyArgs>(args?: SelectSubset<T, StolenEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StolenEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StolenEvents
     * const stolenEvent = await prisma.stolenEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StolenEventUpdateManyArgs>(args: SelectSubset<T, StolenEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StolenEvents and returns the data updated in the database.
     * @param {StolenEventUpdateManyAndReturnArgs} args - Arguments to update many StolenEvents.
     * @example
     * // Update many StolenEvents
     * const stolenEvent = await prisma.stolenEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StolenEvents and only return the `id`
     * const stolenEventWithIdOnly = await prisma.stolenEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StolenEventUpdateManyAndReturnArgs>(args: SelectSubset<T, StolenEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StolenEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StolenEvent.
     * @param {StolenEventUpsertArgs} args - Arguments to update or create a StolenEvent.
     * @example
     * // Update or create a StolenEvent
     * const stolenEvent = await prisma.stolenEvent.upsert({
     *   create: {
     *     // ... data to create a StolenEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StolenEvent we want to update
     *   }
     * })
     */
    upsert<T extends StolenEventUpsertArgs>(args: SelectSubset<T, StolenEventUpsertArgs<ExtArgs>>): Prisma__StolenEventClient<$Result.GetResult<Prisma.$StolenEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StolenEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenEventCountArgs} args - Arguments to filter StolenEvents to count.
     * @example
     * // Count the number of StolenEvents
     * const count = await prisma.stolenEvent.count({
     *   where: {
     *     // ... the filter for the StolenEvents we want to count
     *   }
     * })
    **/
    count<T extends StolenEventCountArgs>(
      args?: Subset<T, StolenEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StolenEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StolenEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StolenEventAggregateArgs>(args: Subset<T, StolenEventAggregateArgs>): Prisma.PrismaPromise<GetStolenEventAggregateType<T>>

    /**
     * Group by StolenEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StolenEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StolenEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StolenEventGroupByArgs['orderBy'] }
        : { orderBy?: StolenEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StolenEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStolenEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StolenEvent model
   */
  readonly fields: StolenEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StolenEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StolenEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StolenEvent model
   */
  interface StolenEventFieldRefs {
    readonly id: FieldRef<"StolenEvent", 'String'>
    readonly contract: FieldRef<"StolenEvent", 'String'>
    readonly tokenId: FieldRef<"StolenEvent", 'String'>
    readonly action: FieldRef<"StolenEvent", 'String'>
    readonly actorAddress: FieldRef<"StolenEvent", 'String'>
    readonly txHash: FieldRef<"StolenEvent", 'String'>
    readonly logIndex: FieldRef<"StolenEvent", 'Int'>
    readonly blockNumber: FieldRef<"StolenEvent", 'Int'>
    readonly timestamp: FieldRef<"StolenEvent", 'DateTime'>
    readonly notes: FieldRef<"StolenEvent", 'String'>
    readonly createdAt: FieldRef<"StolenEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StolenEvent findUnique
   */
  export type StolenEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenEvent
     */
    select?: StolenEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenEvent
     */
    omit?: StolenEventOmit<ExtArgs> | null
    /**
     * Filter, which StolenEvent to fetch.
     */
    where: StolenEventWhereUniqueInput
  }

  /**
   * StolenEvent findUniqueOrThrow
   */
  export type StolenEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenEvent
     */
    select?: StolenEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenEvent
     */
    omit?: StolenEventOmit<ExtArgs> | null
    /**
     * Filter, which StolenEvent to fetch.
     */
    where: StolenEventWhereUniqueInput
  }

  /**
   * StolenEvent findFirst
   */
  export type StolenEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenEvent
     */
    select?: StolenEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenEvent
     */
    omit?: StolenEventOmit<ExtArgs> | null
    /**
     * Filter, which StolenEvent to fetch.
     */
    where?: StolenEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StolenEvents to fetch.
     */
    orderBy?: StolenEventOrderByWithRelationInput | StolenEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StolenEvents.
     */
    cursor?: StolenEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StolenEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StolenEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StolenEvents.
     */
    distinct?: StolenEventScalarFieldEnum | StolenEventScalarFieldEnum[]
  }

  /**
   * StolenEvent findFirstOrThrow
   */
  export type StolenEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenEvent
     */
    select?: StolenEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenEvent
     */
    omit?: StolenEventOmit<ExtArgs> | null
    /**
     * Filter, which StolenEvent to fetch.
     */
    where?: StolenEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StolenEvents to fetch.
     */
    orderBy?: StolenEventOrderByWithRelationInput | StolenEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StolenEvents.
     */
    cursor?: StolenEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StolenEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StolenEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StolenEvents.
     */
    distinct?: StolenEventScalarFieldEnum | StolenEventScalarFieldEnum[]
  }

  /**
   * StolenEvent findMany
   */
  export type StolenEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenEvent
     */
    select?: StolenEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenEvent
     */
    omit?: StolenEventOmit<ExtArgs> | null
    /**
     * Filter, which StolenEvents to fetch.
     */
    where?: StolenEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StolenEvents to fetch.
     */
    orderBy?: StolenEventOrderByWithRelationInput | StolenEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StolenEvents.
     */
    cursor?: StolenEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StolenEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StolenEvents.
     */
    skip?: number
    distinct?: StolenEventScalarFieldEnum | StolenEventScalarFieldEnum[]
  }

  /**
   * StolenEvent create
   */
  export type StolenEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenEvent
     */
    select?: StolenEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenEvent
     */
    omit?: StolenEventOmit<ExtArgs> | null
    /**
     * The data needed to create a StolenEvent.
     */
    data: XOR<StolenEventCreateInput, StolenEventUncheckedCreateInput>
  }

  /**
   * StolenEvent createMany
   */
  export type StolenEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StolenEvents.
     */
    data: StolenEventCreateManyInput | StolenEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StolenEvent createManyAndReturn
   */
  export type StolenEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenEvent
     */
    select?: StolenEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StolenEvent
     */
    omit?: StolenEventOmit<ExtArgs> | null
    /**
     * The data used to create many StolenEvents.
     */
    data: StolenEventCreateManyInput | StolenEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StolenEvent update
   */
  export type StolenEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenEvent
     */
    select?: StolenEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenEvent
     */
    omit?: StolenEventOmit<ExtArgs> | null
    /**
     * The data needed to update a StolenEvent.
     */
    data: XOR<StolenEventUpdateInput, StolenEventUncheckedUpdateInput>
    /**
     * Choose, which StolenEvent to update.
     */
    where: StolenEventWhereUniqueInput
  }

  /**
   * StolenEvent updateMany
   */
  export type StolenEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StolenEvents.
     */
    data: XOR<StolenEventUpdateManyMutationInput, StolenEventUncheckedUpdateManyInput>
    /**
     * Filter which StolenEvents to update
     */
    where?: StolenEventWhereInput
    /**
     * Limit how many StolenEvents to update.
     */
    limit?: number
  }

  /**
   * StolenEvent updateManyAndReturn
   */
  export type StolenEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenEvent
     */
    select?: StolenEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StolenEvent
     */
    omit?: StolenEventOmit<ExtArgs> | null
    /**
     * The data used to update StolenEvents.
     */
    data: XOR<StolenEventUpdateManyMutationInput, StolenEventUncheckedUpdateManyInput>
    /**
     * Filter which StolenEvents to update
     */
    where?: StolenEventWhereInput
    /**
     * Limit how many StolenEvents to update.
     */
    limit?: number
  }

  /**
   * StolenEvent upsert
   */
  export type StolenEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenEvent
     */
    select?: StolenEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenEvent
     */
    omit?: StolenEventOmit<ExtArgs> | null
    /**
     * The filter to search for the StolenEvent to update in case it exists.
     */
    where: StolenEventWhereUniqueInput
    /**
     * In case the StolenEvent found by the `where` argument doesn't exist, create a new StolenEvent with this data.
     */
    create: XOR<StolenEventCreateInput, StolenEventUncheckedCreateInput>
    /**
     * In case the StolenEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StolenEventUpdateInput, StolenEventUncheckedUpdateInput>
  }

  /**
   * StolenEvent delete
   */
  export type StolenEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenEvent
     */
    select?: StolenEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenEvent
     */
    omit?: StolenEventOmit<ExtArgs> | null
    /**
     * Filter which StolenEvent to delete.
     */
    where: StolenEventWhereUniqueInput
  }

  /**
   * StolenEvent deleteMany
   */
  export type StolenEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StolenEvents to delete
     */
    where?: StolenEventWhereInput
    /**
     * Limit how many StolenEvents to delete.
     */
    limit?: number
  }

  /**
   * StolenEvent without action
   */
  export type StolenEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StolenEvent
     */
    select?: StolenEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StolenEvent
     */
    omit?: StolenEventOmit<ExtArgs> | null
  }


  /**
   * Model MultisigSafe
   */

  export type AggregateMultisigSafe = {
    _count: MultisigSafeCountAggregateOutputType | null
    _avg: MultisigSafeAvgAggregateOutputType | null
    _sum: MultisigSafeSumAggregateOutputType | null
    _min: MultisigSafeMinAggregateOutputType | null
    _max: MultisigSafeMaxAggregateOutputType | null
  }

  export type MultisigSafeAvgAggregateOutputType = {
    threshold: number | null
  }

  export type MultisigSafeSumAggregateOutputType = {
    threshold: number | null
  }

  export type MultisigSafeMinAggregateOutputType = {
    id: string | null
    contract: string | null
    name: string | null
    threshold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MultisigSafeMaxAggregateOutputType = {
    id: string | null
    contract: string | null
    name: string | null
    threshold: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MultisigSafeCountAggregateOutputType = {
    id: number
    contract: number
    name: number
    threshold: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MultisigSafeAvgAggregateInputType = {
    threshold?: true
  }

  export type MultisigSafeSumAggregateInputType = {
    threshold?: true
  }

  export type MultisigSafeMinAggregateInputType = {
    id?: true
    contract?: true
    name?: true
    threshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MultisigSafeMaxAggregateInputType = {
    id?: true
    contract?: true
    name?: true
    threshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MultisigSafeCountAggregateInputType = {
    id?: true
    contract?: true
    name?: true
    threshold?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MultisigSafeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultisigSafe to aggregate.
     */
    where?: MultisigSafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigSafes to fetch.
     */
    orderBy?: MultisigSafeOrderByWithRelationInput | MultisigSafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MultisigSafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigSafes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigSafes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MultisigSafes
    **/
    _count?: true | MultisigSafeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MultisigSafeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MultisigSafeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MultisigSafeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MultisigSafeMaxAggregateInputType
  }

  export type GetMultisigSafeAggregateType<T extends MultisigSafeAggregateArgs> = {
        [P in keyof T & keyof AggregateMultisigSafe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMultisigSafe[P]>
      : GetScalarType<T[P], AggregateMultisigSafe[P]>
  }




  export type MultisigSafeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultisigSafeWhereInput
    orderBy?: MultisigSafeOrderByWithAggregationInput | MultisigSafeOrderByWithAggregationInput[]
    by: MultisigSafeScalarFieldEnum[] | MultisigSafeScalarFieldEnum
    having?: MultisigSafeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MultisigSafeCountAggregateInputType | true
    _avg?: MultisigSafeAvgAggregateInputType
    _sum?: MultisigSafeSumAggregateInputType
    _min?: MultisigSafeMinAggregateInputType
    _max?: MultisigSafeMaxAggregateInputType
  }

  export type MultisigSafeGroupByOutputType = {
    id: string
    contract: string
    name: string | null
    threshold: number
    createdAt: Date
    updatedAt: Date
    _count: MultisigSafeCountAggregateOutputType | null
    _avg: MultisigSafeAvgAggregateOutputType | null
    _sum: MultisigSafeSumAggregateOutputType | null
    _min: MultisigSafeMinAggregateOutputType | null
    _max: MultisigSafeMaxAggregateOutputType | null
  }

  type GetMultisigSafeGroupByPayload<T extends MultisigSafeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MultisigSafeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MultisigSafeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MultisigSafeGroupByOutputType[P]>
            : GetScalarType<T[P], MultisigSafeGroupByOutputType[P]>
        }
      >
    >


  export type MultisigSafeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    name?: boolean
    threshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owners?: boolean | MultisigSafe$ownersArgs<ExtArgs>
    txs?: boolean | MultisigSafe$txsArgs<ExtArgs>
    _count?: boolean | MultisigSafeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multisigSafe"]>

  export type MultisigSafeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    name?: boolean
    threshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["multisigSafe"]>

  export type MultisigSafeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contract?: boolean
    name?: boolean
    threshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["multisigSafe"]>

  export type MultisigSafeSelectScalar = {
    id?: boolean
    contract?: boolean
    name?: boolean
    threshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MultisigSafeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contract" | "name" | "threshold" | "createdAt" | "updatedAt", ExtArgs["result"]["multisigSafe"]>
  export type MultisigSafeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owners?: boolean | MultisigSafe$ownersArgs<ExtArgs>
    txs?: boolean | MultisigSafe$txsArgs<ExtArgs>
    _count?: boolean | MultisigSafeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MultisigSafeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MultisigSafeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MultisigSafePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MultisigSafe"
    objects: {
      owners: Prisma.$MultisigOwnerPayload<ExtArgs>[]
      txs: Prisma.$MultisigTxPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contract: string
      name: string | null
      threshold: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["multisigSafe"]>
    composites: {}
  }

  type MultisigSafeGetPayload<S extends boolean | null | undefined | MultisigSafeDefaultArgs> = $Result.GetResult<Prisma.$MultisigSafePayload, S>

  type MultisigSafeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MultisigSafeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MultisigSafeCountAggregateInputType | true
    }

  export interface MultisigSafeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MultisigSafe'], meta: { name: 'MultisigSafe' } }
    /**
     * Find zero or one MultisigSafe that matches the filter.
     * @param {MultisigSafeFindUniqueArgs} args - Arguments to find a MultisigSafe
     * @example
     * // Get one MultisigSafe
     * const multisigSafe = await prisma.multisigSafe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MultisigSafeFindUniqueArgs>(args: SelectSubset<T, MultisigSafeFindUniqueArgs<ExtArgs>>): Prisma__MultisigSafeClient<$Result.GetResult<Prisma.$MultisigSafePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MultisigSafe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MultisigSafeFindUniqueOrThrowArgs} args - Arguments to find a MultisigSafe
     * @example
     * // Get one MultisigSafe
     * const multisigSafe = await prisma.multisigSafe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MultisigSafeFindUniqueOrThrowArgs>(args: SelectSubset<T, MultisigSafeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MultisigSafeClient<$Result.GetResult<Prisma.$MultisigSafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultisigSafe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigSafeFindFirstArgs} args - Arguments to find a MultisigSafe
     * @example
     * // Get one MultisigSafe
     * const multisigSafe = await prisma.multisigSafe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MultisigSafeFindFirstArgs>(args?: SelectSubset<T, MultisigSafeFindFirstArgs<ExtArgs>>): Prisma__MultisigSafeClient<$Result.GetResult<Prisma.$MultisigSafePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultisigSafe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigSafeFindFirstOrThrowArgs} args - Arguments to find a MultisigSafe
     * @example
     * // Get one MultisigSafe
     * const multisigSafe = await prisma.multisigSafe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MultisigSafeFindFirstOrThrowArgs>(args?: SelectSubset<T, MultisigSafeFindFirstOrThrowArgs<ExtArgs>>): Prisma__MultisigSafeClient<$Result.GetResult<Prisma.$MultisigSafePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MultisigSafes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigSafeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MultisigSafes
     * const multisigSafes = await prisma.multisigSafe.findMany()
     * 
     * // Get first 10 MultisigSafes
     * const multisigSafes = await prisma.multisigSafe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const multisigSafeWithIdOnly = await prisma.multisigSafe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MultisigSafeFindManyArgs>(args?: SelectSubset<T, MultisigSafeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigSafePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MultisigSafe.
     * @param {MultisigSafeCreateArgs} args - Arguments to create a MultisigSafe.
     * @example
     * // Create one MultisigSafe
     * const MultisigSafe = await prisma.multisigSafe.create({
     *   data: {
     *     // ... data to create a MultisigSafe
     *   }
     * })
     * 
     */
    create<T extends MultisigSafeCreateArgs>(args: SelectSubset<T, MultisigSafeCreateArgs<ExtArgs>>): Prisma__MultisigSafeClient<$Result.GetResult<Prisma.$MultisigSafePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MultisigSafes.
     * @param {MultisigSafeCreateManyArgs} args - Arguments to create many MultisigSafes.
     * @example
     * // Create many MultisigSafes
     * const multisigSafe = await prisma.multisigSafe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MultisigSafeCreateManyArgs>(args?: SelectSubset<T, MultisigSafeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MultisigSafes and returns the data saved in the database.
     * @param {MultisigSafeCreateManyAndReturnArgs} args - Arguments to create many MultisigSafes.
     * @example
     * // Create many MultisigSafes
     * const multisigSafe = await prisma.multisigSafe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MultisigSafes and only return the `id`
     * const multisigSafeWithIdOnly = await prisma.multisigSafe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MultisigSafeCreateManyAndReturnArgs>(args?: SelectSubset<T, MultisigSafeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigSafePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MultisigSafe.
     * @param {MultisigSafeDeleteArgs} args - Arguments to delete one MultisigSafe.
     * @example
     * // Delete one MultisigSafe
     * const MultisigSafe = await prisma.multisigSafe.delete({
     *   where: {
     *     // ... filter to delete one MultisigSafe
     *   }
     * })
     * 
     */
    delete<T extends MultisigSafeDeleteArgs>(args: SelectSubset<T, MultisigSafeDeleteArgs<ExtArgs>>): Prisma__MultisigSafeClient<$Result.GetResult<Prisma.$MultisigSafePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MultisigSafe.
     * @param {MultisigSafeUpdateArgs} args - Arguments to update one MultisigSafe.
     * @example
     * // Update one MultisigSafe
     * const multisigSafe = await prisma.multisigSafe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MultisigSafeUpdateArgs>(args: SelectSubset<T, MultisigSafeUpdateArgs<ExtArgs>>): Prisma__MultisigSafeClient<$Result.GetResult<Prisma.$MultisigSafePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MultisigSafes.
     * @param {MultisigSafeDeleteManyArgs} args - Arguments to filter MultisigSafes to delete.
     * @example
     * // Delete a few MultisigSafes
     * const { count } = await prisma.multisigSafe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MultisigSafeDeleteManyArgs>(args?: SelectSubset<T, MultisigSafeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultisigSafes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigSafeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MultisigSafes
     * const multisigSafe = await prisma.multisigSafe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MultisigSafeUpdateManyArgs>(args: SelectSubset<T, MultisigSafeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultisigSafes and returns the data updated in the database.
     * @param {MultisigSafeUpdateManyAndReturnArgs} args - Arguments to update many MultisigSafes.
     * @example
     * // Update many MultisigSafes
     * const multisigSafe = await prisma.multisigSafe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MultisigSafes and only return the `id`
     * const multisigSafeWithIdOnly = await prisma.multisigSafe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MultisigSafeUpdateManyAndReturnArgs>(args: SelectSubset<T, MultisigSafeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigSafePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MultisigSafe.
     * @param {MultisigSafeUpsertArgs} args - Arguments to update or create a MultisigSafe.
     * @example
     * // Update or create a MultisigSafe
     * const multisigSafe = await prisma.multisigSafe.upsert({
     *   create: {
     *     // ... data to create a MultisigSafe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MultisigSafe we want to update
     *   }
     * })
     */
    upsert<T extends MultisigSafeUpsertArgs>(args: SelectSubset<T, MultisigSafeUpsertArgs<ExtArgs>>): Prisma__MultisigSafeClient<$Result.GetResult<Prisma.$MultisigSafePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MultisigSafes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigSafeCountArgs} args - Arguments to filter MultisigSafes to count.
     * @example
     * // Count the number of MultisigSafes
     * const count = await prisma.multisigSafe.count({
     *   where: {
     *     // ... the filter for the MultisigSafes we want to count
     *   }
     * })
    **/
    count<T extends MultisigSafeCountArgs>(
      args?: Subset<T, MultisigSafeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MultisigSafeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MultisigSafe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigSafeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MultisigSafeAggregateArgs>(args: Subset<T, MultisigSafeAggregateArgs>): Prisma.PrismaPromise<GetMultisigSafeAggregateType<T>>

    /**
     * Group by MultisigSafe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigSafeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MultisigSafeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MultisigSafeGroupByArgs['orderBy'] }
        : { orderBy?: MultisigSafeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MultisigSafeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMultisigSafeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MultisigSafe model
   */
  readonly fields: MultisigSafeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MultisigSafe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MultisigSafeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owners<T extends MultisigSafe$ownersArgs<ExtArgs> = {}>(args?: Subset<T, MultisigSafe$ownersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigOwnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    txs<T extends MultisigSafe$txsArgs<ExtArgs> = {}>(args?: Subset<T, MultisigSafe$txsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigTxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MultisigSafe model
   */
  interface MultisigSafeFieldRefs {
    readonly id: FieldRef<"MultisigSafe", 'String'>
    readonly contract: FieldRef<"MultisigSafe", 'String'>
    readonly name: FieldRef<"MultisigSafe", 'String'>
    readonly threshold: FieldRef<"MultisigSafe", 'Int'>
    readonly createdAt: FieldRef<"MultisigSafe", 'DateTime'>
    readonly updatedAt: FieldRef<"MultisigSafe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MultisigSafe findUnique
   */
  export type MultisigSafeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigSafe
     */
    select?: MultisigSafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigSafe
     */
    omit?: MultisigSafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigSafeInclude<ExtArgs> | null
    /**
     * Filter, which MultisigSafe to fetch.
     */
    where: MultisigSafeWhereUniqueInput
  }

  /**
   * MultisigSafe findUniqueOrThrow
   */
  export type MultisigSafeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigSafe
     */
    select?: MultisigSafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigSafe
     */
    omit?: MultisigSafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigSafeInclude<ExtArgs> | null
    /**
     * Filter, which MultisigSafe to fetch.
     */
    where: MultisigSafeWhereUniqueInput
  }

  /**
   * MultisigSafe findFirst
   */
  export type MultisigSafeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigSafe
     */
    select?: MultisigSafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigSafe
     */
    omit?: MultisigSafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigSafeInclude<ExtArgs> | null
    /**
     * Filter, which MultisigSafe to fetch.
     */
    where?: MultisigSafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigSafes to fetch.
     */
    orderBy?: MultisigSafeOrderByWithRelationInput | MultisigSafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultisigSafes.
     */
    cursor?: MultisigSafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigSafes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigSafes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultisigSafes.
     */
    distinct?: MultisigSafeScalarFieldEnum | MultisigSafeScalarFieldEnum[]
  }

  /**
   * MultisigSafe findFirstOrThrow
   */
  export type MultisigSafeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigSafe
     */
    select?: MultisigSafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigSafe
     */
    omit?: MultisigSafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigSafeInclude<ExtArgs> | null
    /**
     * Filter, which MultisigSafe to fetch.
     */
    where?: MultisigSafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigSafes to fetch.
     */
    orderBy?: MultisigSafeOrderByWithRelationInput | MultisigSafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultisigSafes.
     */
    cursor?: MultisigSafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigSafes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigSafes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultisigSafes.
     */
    distinct?: MultisigSafeScalarFieldEnum | MultisigSafeScalarFieldEnum[]
  }

  /**
   * MultisigSafe findMany
   */
  export type MultisigSafeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigSafe
     */
    select?: MultisigSafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigSafe
     */
    omit?: MultisigSafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigSafeInclude<ExtArgs> | null
    /**
     * Filter, which MultisigSafes to fetch.
     */
    where?: MultisigSafeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigSafes to fetch.
     */
    orderBy?: MultisigSafeOrderByWithRelationInput | MultisigSafeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MultisigSafes.
     */
    cursor?: MultisigSafeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigSafes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigSafes.
     */
    skip?: number
    distinct?: MultisigSafeScalarFieldEnum | MultisigSafeScalarFieldEnum[]
  }

  /**
   * MultisigSafe create
   */
  export type MultisigSafeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigSafe
     */
    select?: MultisigSafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigSafe
     */
    omit?: MultisigSafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigSafeInclude<ExtArgs> | null
    /**
     * The data needed to create a MultisigSafe.
     */
    data: XOR<MultisigSafeCreateInput, MultisigSafeUncheckedCreateInput>
  }

  /**
   * MultisigSafe createMany
   */
  export type MultisigSafeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MultisigSafes.
     */
    data: MultisigSafeCreateManyInput | MultisigSafeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MultisigSafe createManyAndReturn
   */
  export type MultisigSafeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigSafe
     */
    select?: MultisigSafeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigSafe
     */
    omit?: MultisigSafeOmit<ExtArgs> | null
    /**
     * The data used to create many MultisigSafes.
     */
    data: MultisigSafeCreateManyInput | MultisigSafeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MultisigSafe update
   */
  export type MultisigSafeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigSafe
     */
    select?: MultisigSafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigSafe
     */
    omit?: MultisigSafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigSafeInclude<ExtArgs> | null
    /**
     * The data needed to update a MultisigSafe.
     */
    data: XOR<MultisigSafeUpdateInput, MultisigSafeUncheckedUpdateInput>
    /**
     * Choose, which MultisigSafe to update.
     */
    where: MultisigSafeWhereUniqueInput
  }

  /**
   * MultisigSafe updateMany
   */
  export type MultisigSafeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MultisigSafes.
     */
    data: XOR<MultisigSafeUpdateManyMutationInput, MultisigSafeUncheckedUpdateManyInput>
    /**
     * Filter which MultisigSafes to update
     */
    where?: MultisigSafeWhereInput
    /**
     * Limit how many MultisigSafes to update.
     */
    limit?: number
  }

  /**
   * MultisigSafe updateManyAndReturn
   */
  export type MultisigSafeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigSafe
     */
    select?: MultisigSafeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigSafe
     */
    omit?: MultisigSafeOmit<ExtArgs> | null
    /**
     * The data used to update MultisigSafes.
     */
    data: XOR<MultisigSafeUpdateManyMutationInput, MultisigSafeUncheckedUpdateManyInput>
    /**
     * Filter which MultisigSafes to update
     */
    where?: MultisigSafeWhereInput
    /**
     * Limit how many MultisigSafes to update.
     */
    limit?: number
  }

  /**
   * MultisigSafe upsert
   */
  export type MultisigSafeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigSafe
     */
    select?: MultisigSafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigSafe
     */
    omit?: MultisigSafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigSafeInclude<ExtArgs> | null
    /**
     * The filter to search for the MultisigSafe to update in case it exists.
     */
    where: MultisigSafeWhereUniqueInput
    /**
     * In case the MultisigSafe found by the `where` argument doesn't exist, create a new MultisigSafe with this data.
     */
    create: XOR<MultisigSafeCreateInput, MultisigSafeUncheckedCreateInput>
    /**
     * In case the MultisigSafe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MultisigSafeUpdateInput, MultisigSafeUncheckedUpdateInput>
  }

  /**
   * MultisigSafe delete
   */
  export type MultisigSafeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigSafe
     */
    select?: MultisigSafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigSafe
     */
    omit?: MultisigSafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigSafeInclude<ExtArgs> | null
    /**
     * Filter which MultisigSafe to delete.
     */
    where: MultisigSafeWhereUniqueInput
  }

  /**
   * MultisigSafe deleteMany
   */
  export type MultisigSafeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultisigSafes to delete
     */
    where?: MultisigSafeWhereInput
    /**
     * Limit how many MultisigSafes to delete.
     */
    limit?: number
  }

  /**
   * MultisigSafe.owners
   */
  export type MultisigSafe$ownersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigOwner
     */
    select?: MultisigOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigOwner
     */
    omit?: MultisigOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigOwnerInclude<ExtArgs> | null
    where?: MultisigOwnerWhereInput
    orderBy?: MultisigOwnerOrderByWithRelationInput | MultisigOwnerOrderByWithRelationInput[]
    cursor?: MultisigOwnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MultisigOwnerScalarFieldEnum | MultisigOwnerScalarFieldEnum[]
  }

  /**
   * MultisigSafe.txs
   */
  export type MultisigSafe$txsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigTx
     */
    select?: MultisigTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigTx
     */
    omit?: MultisigTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigTxInclude<ExtArgs> | null
    where?: MultisigTxWhereInput
    orderBy?: MultisigTxOrderByWithRelationInput | MultisigTxOrderByWithRelationInput[]
    cursor?: MultisigTxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MultisigTxScalarFieldEnum | MultisigTxScalarFieldEnum[]
  }

  /**
   * MultisigSafe without action
   */
  export type MultisigSafeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigSafe
     */
    select?: MultisigSafeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigSafe
     */
    omit?: MultisigSafeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigSafeInclude<ExtArgs> | null
  }


  /**
   * Model MultisigOwner
   */

  export type AggregateMultisigOwner = {
    _count: MultisigOwnerCountAggregateOutputType | null
    _min: MultisigOwnerMinAggregateOutputType | null
    _max: MultisigOwnerMaxAggregateOutputType | null
  }

  export type MultisigOwnerMinAggregateOutputType = {
    id: string | null
    safeId: string | null
    ownerAddress: string | null
    addedAt: Date | null
    removedAt: Date | null
  }

  export type MultisigOwnerMaxAggregateOutputType = {
    id: string | null
    safeId: string | null
    ownerAddress: string | null
    addedAt: Date | null
    removedAt: Date | null
  }

  export type MultisigOwnerCountAggregateOutputType = {
    id: number
    safeId: number
    ownerAddress: number
    addedAt: number
    removedAt: number
    _all: number
  }


  export type MultisigOwnerMinAggregateInputType = {
    id?: true
    safeId?: true
    ownerAddress?: true
    addedAt?: true
    removedAt?: true
  }

  export type MultisigOwnerMaxAggregateInputType = {
    id?: true
    safeId?: true
    ownerAddress?: true
    addedAt?: true
    removedAt?: true
  }

  export type MultisigOwnerCountAggregateInputType = {
    id?: true
    safeId?: true
    ownerAddress?: true
    addedAt?: true
    removedAt?: true
    _all?: true
  }

  export type MultisigOwnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultisigOwner to aggregate.
     */
    where?: MultisigOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigOwners to fetch.
     */
    orderBy?: MultisigOwnerOrderByWithRelationInput | MultisigOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MultisigOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MultisigOwners
    **/
    _count?: true | MultisigOwnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MultisigOwnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MultisigOwnerMaxAggregateInputType
  }

  export type GetMultisigOwnerAggregateType<T extends MultisigOwnerAggregateArgs> = {
        [P in keyof T & keyof AggregateMultisigOwner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMultisigOwner[P]>
      : GetScalarType<T[P], AggregateMultisigOwner[P]>
  }




  export type MultisigOwnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultisigOwnerWhereInput
    orderBy?: MultisigOwnerOrderByWithAggregationInput | MultisigOwnerOrderByWithAggregationInput[]
    by: MultisigOwnerScalarFieldEnum[] | MultisigOwnerScalarFieldEnum
    having?: MultisigOwnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MultisigOwnerCountAggregateInputType | true
    _min?: MultisigOwnerMinAggregateInputType
    _max?: MultisigOwnerMaxAggregateInputType
  }

  export type MultisigOwnerGroupByOutputType = {
    id: string
    safeId: string
    ownerAddress: string
    addedAt: Date
    removedAt: Date | null
    _count: MultisigOwnerCountAggregateOutputType | null
    _min: MultisigOwnerMinAggregateOutputType | null
    _max: MultisigOwnerMaxAggregateOutputType | null
  }

  type GetMultisigOwnerGroupByPayload<T extends MultisigOwnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MultisigOwnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MultisigOwnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MultisigOwnerGroupByOutputType[P]>
            : GetScalarType<T[P], MultisigOwnerGroupByOutputType[P]>
        }
      >
    >


  export type MultisigOwnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    safeId?: boolean
    ownerAddress?: boolean
    addedAt?: boolean
    removedAt?: boolean
    safe?: boolean | MultisigSafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multisigOwner"]>

  export type MultisigOwnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    safeId?: boolean
    ownerAddress?: boolean
    addedAt?: boolean
    removedAt?: boolean
    safe?: boolean | MultisigSafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multisigOwner"]>

  export type MultisigOwnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    safeId?: boolean
    ownerAddress?: boolean
    addedAt?: boolean
    removedAt?: boolean
    safe?: boolean | MultisigSafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multisigOwner"]>

  export type MultisigOwnerSelectScalar = {
    id?: boolean
    safeId?: boolean
    ownerAddress?: boolean
    addedAt?: boolean
    removedAt?: boolean
  }

  export type MultisigOwnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "safeId" | "ownerAddress" | "addedAt" | "removedAt", ExtArgs["result"]["multisigOwner"]>
  export type MultisigOwnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    safe?: boolean | MultisigSafeDefaultArgs<ExtArgs>
  }
  export type MultisigOwnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    safe?: boolean | MultisigSafeDefaultArgs<ExtArgs>
  }
  export type MultisigOwnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    safe?: boolean | MultisigSafeDefaultArgs<ExtArgs>
  }

  export type $MultisigOwnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MultisigOwner"
    objects: {
      safe: Prisma.$MultisigSafePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      safeId: string
      ownerAddress: string
      addedAt: Date
      removedAt: Date | null
    }, ExtArgs["result"]["multisigOwner"]>
    composites: {}
  }

  type MultisigOwnerGetPayload<S extends boolean | null | undefined | MultisigOwnerDefaultArgs> = $Result.GetResult<Prisma.$MultisigOwnerPayload, S>

  type MultisigOwnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MultisigOwnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MultisigOwnerCountAggregateInputType | true
    }

  export interface MultisigOwnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MultisigOwner'], meta: { name: 'MultisigOwner' } }
    /**
     * Find zero or one MultisigOwner that matches the filter.
     * @param {MultisigOwnerFindUniqueArgs} args - Arguments to find a MultisigOwner
     * @example
     * // Get one MultisigOwner
     * const multisigOwner = await prisma.multisigOwner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MultisigOwnerFindUniqueArgs>(args: SelectSubset<T, MultisigOwnerFindUniqueArgs<ExtArgs>>): Prisma__MultisigOwnerClient<$Result.GetResult<Prisma.$MultisigOwnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MultisigOwner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MultisigOwnerFindUniqueOrThrowArgs} args - Arguments to find a MultisigOwner
     * @example
     * // Get one MultisigOwner
     * const multisigOwner = await prisma.multisigOwner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MultisigOwnerFindUniqueOrThrowArgs>(args: SelectSubset<T, MultisigOwnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MultisigOwnerClient<$Result.GetResult<Prisma.$MultisigOwnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultisigOwner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigOwnerFindFirstArgs} args - Arguments to find a MultisigOwner
     * @example
     * // Get one MultisigOwner
     * const multisigOwner = await prisma.multisigOwner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MultisigOwnerFindFirstArgs>(args?: SelectSubset<T, MultisigOwnerFindFirstArgs<ExtArgs>>): Prisma__MultisigOwnerClient<$Result.GetResult<Prisma.$MultisigOwnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultisigOwner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigOwnerFindFirstOrThrowArgs} args - Arguments to find a MultisigOwner
     * @example
     * // Get one MultisigOwner
     * const multisigOwner = await prisma.multisigOwner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MultisigOwnerFindFirstOrThrowArgs>(args?: SelectSubset<T, MultisigOwnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__MultisigOwnerClient<$Result.GetResult<Prisma.$MultisigOwnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MultisigOwners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigOwnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MultisigOwners
     * const multisigOwners = await prisma.multisigOwner.findMany()
     * 
     * // Get first 10 MultisigOwners
     * const multisigOwners = await prisma.multisigOwner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const multisigOwnerWithIdOnly = await prisma.multisigOwner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MultisigOwnerFindManyArgs>(args?: SelectSubset<T, MultisigOwnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigOwnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MultisigOwner.
     * @param {MultisigOwnerCreateArgs} args - Arguments to create a MultisigOwner.
     * @example
     * // Create one MultisigOwner
     * const MultisigOwner = await prisma.multisigOwner.create({
     *   data: {
     *     // ... data to create a MultisigOwner
     *   }
     * })
     * 
     */
    create<T extends MultisigOwnerCreateArgs>(args: SelectSubset<T, MultisigOwnerCreateArgs<ExtArgs>>): Prisma__MultisigOwnerClient<$Result.GetResult<Prisma.$MultisigOwnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MultisigOwners.
     * @param {MultisigOwnerCreateManyArgs} args - Arguments to create many MultisigOwners.
     * @example
     * // Create many MultisigOwners
     * const multisigOwner = await prisma.multisigOwner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MultisigOwnerCreateManyArgs>(args?: SelectSubset<T, MultisigOwnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MultisigOwners and returns the data saved in the database.
     * @param {MultisigOwnerCreateManyAndReturnArgs} args - Arguments to create many MultisigOwners.
     * @example
     * // Create many MultisigOwners
     * const multisigOwner = await prisma.multisigOwner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MultisigOwners and only return the `id`
     * const multisigOwnerWithIdOnly = await prisma.multisigOwner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MultisigOwnerCreateManyAndReturnArgs>(args?: SelectSubset<T, MultisigOwnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigOwnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MultisigOwner.
     * @param {MultisigOwnerDeleteArgs} args - Arguments to delete one MultisigOwner.
     * @example
     * // Delete one MultisigOwner
     * const MultisigOwner = await prisma.multisigOwner.delete({
     *   where: {
     *     // ... filter to delete one MultisigOwner
     *   }
     * })
     * 
     */
    delete<T extends MultisigOwnerDeleteArgs>(args: SelectSubset<T, MultisigOwnerDeleteArgs<ExtArgs>>): Prisma__MultisigOwnerClient<$Result.GetResult<Prisma.$MultisigOwnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MultisigOwner.
     * @param {MultisigOwnerUpdateArgs} args - Arguments to update one MultisigOwner.
     * @example
     * // Update one MultisigOwner
     * const multisigOwner = await prisma.multisigOwner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MultisigOwnerUpdateArgs>(args: SelectSubset<T, MultisigOwnerUpdateArgs<ExtArgs>>): Prisma__MultisigOwnerClient<$Result.GetResult<Prisma.$MultisigOwnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MultisigOwners.
     * @param {MultisigOwnerDeleteManyArgs} args - Arguments to filter MultisigOwners to delete.
     * @example
     * // Delete a few MultisigOwners
     * const { count } = await prisma.multisigOwner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MultisigOwnerDeleteManyArgs>(args?: SelectSubset<T, MultisigOwnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultisigOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigOwnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MultisigOwners
     * const multisigOwner = await prisma.multisigOwner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MultisigOwnerUpdateManyArgs>(args: SelectSubset<T, MultisigOwnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultisigOwners and returns the data updated in the database.
     * @param {MultisigOwnerUpdateManyAndReturnArgs} args - Arguments to update many MultisigOwners.
     * @example
     * // Update many MultisigOwners
     * const multisigOwner = await prisma.multisigOwner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MultisigOwners and only return the `id`
     * const multisigOwnerWithIdOnly = await prisma.multisigOwner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MultisigOwnerUpdateManyAndReturnArgs>(args: SelectSubset<T, MultisigOwnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigOwnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MultisigOwner.
     * @param {MultisigOwnerUpsertArgs} args - Arguments to update or create a MultisigOwner.
     * @example
     * // Update or create a MultisigOwner
     * const multisigOwner = await prisma.multisigOwner.upsert({
     *   create: {
     *     // ... data to create a MultisigOwner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MultisigOwner we want to update
     *   }
     * })
     */
    upsert<T extends MultisigOwnerUpsertArgs>(args: SelectSubset<T, MultisigOwnerUpsertArgs<ExtArgs>>): Prisma__MultisigOwnerClient<$Result.GetResult<Prisma.$MultisigOwnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MultisigOwners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigOwnerCountArgs} args - Arguments to filter MultisigOwners to count.
     * @example
     * // Count the number of MultisigOwners
     * const count = await prisma.multisigOwner.count({
     *   where: {
     *     // ... the filter for the MultisigOwners we want to count
     *   }
     * })
    **/
    count<T extends MultisigOwnerCountArgs>(
      args?: Subset<T, MultisigOwnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MultisigOwnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MultisigOwner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigOwnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MultisigOwnerAggregateArgs>(args: Subset<T, MultisigOwnerAggregateArgs>): Prisma.PrismaPromise<GetMultisigOwnerAggregateType<T>>

    /**
     * Group by MultisigOwner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigOwnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MultisigOwnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MultisigOwnerGroupByArgs['orderBy'] }
        : { orderBy?: MultisigOwnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MultisigOwnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMultisigOwnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MultisigOwner model
   */
  readonly fields: MultisigOwnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MultisigOwner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MultisigOwnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    safe<T extends MultisigSafeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MultisigSafeDefaultArgs<ExtArgs>>): Prisma__MultisigSafeClient<$Result.GetResult<Prisma.$MultisigSafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MultisigOwner model
   */
  interface MultisigOwnerFieldRefs {
    readonly id: FieldRef<"MultisigOwner", 'String'>
    readonly safeId: FieldRef<"MultisigOwner", 'String'>
    readonly ownerAddress: FieldRef<"MultisigOwner", 'String'>
    readonly addedAt: FieldRef<"MultisigOwner", 'DateTime'>
    readonly removedAt: FieldRef<"MultisigOwner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MultisigOwner findUnique
   */
  export type MultisigOwnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigOwner
     */
    select?: MultisigOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigOwner
     */
    omit?: MultisigOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigOwnerInclude<ExtArgs> | null
    /**
     * Filter, which MultisigOwner to fetch.
     */
    where: MultisigOwnerWhereUniqueInput
  }

  /**
   * MultisigOwner findUniqueOrThrow
   */
  export type MultisigOwnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigOwner
     */
    select?: MultisigOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigOwner
     */
    omit?: MultisigOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigOwnerInclude<ExtArgs> | null
    /**
     * Filter, which MultisigOwner to fetch.
     */
    where: MultisigOwnerWhereUniqueInput
  }

  /**
   * MultisigOwner findFirst
   */
  export type MultisigOwnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigOwner
     */
    select?: MultisigOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigOwner
     */
    omit?: MultisigOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigOwnerInclude<ExtArgs> | null
    /**
     * Filter, which MultisigOwner to fetch.
     */
    where?: MultisigOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigOwners to fetch.
     */
    orderBy?: MultisigOwnerOrderByWithRelationInput | MultisigOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultisigOwners.
     */
    cursor?: MultisigOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultisigOwners.
     */
    distinct?: MultisigOwnerScalarFieldEnum | MultisigOwnerScalarFieldEnum[]
  }

  /**
   * MultisigOwner findFirstOrThrow
   */
  export type MultisigOwnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigOwner
     */
    select?: MultisigOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigOwner
     */
    omit?: MultisigOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigOwnerInclude<ExtArgs> | null
    /**
     * Filter, which MultisigOwner to fetch.
     */
    where?: MultisigOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigOwners to fetch.
     */
    orderBy?: MultisigOwnerOrderByWithRelationInput | MultisigOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultisigOwners.
     */
    cursor?: MultisigOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigOwners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultisigOwners.
     */
    distinct?: MultisigOwnerScalarFieldEnum | MultisigOwnerScalarFieldEnum[]
  }

  /**
   * MultisigOwner findMany
   */
  export type MultisigOwnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigOwner
     */
    select?: MultisigOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigOwner
     */
    omit?: MultisigOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigOwnerInclude<ExtArgs> | null
    /**
     * Filter, which MultisigOwners to fetch.
     */
    where?: MultisigOwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigOwners to fetch.
     */
    orderBy?: MultisigOwnerOrderByWithRelationInput | MultisigOwnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MultisigOwners.
     */
    cursor?: MultisigOwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigOwners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigOwners.
     */
    skip?: number
    distinct?: MultisigOwnerScalarFieldEnum | MultisigOwnerScalarFieldEnum[]
  }

  /**
   * MultisigOwner create
   */
  export type MultisigOwnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigOwner
     */
    select?: MultisigOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigOwner
     */
    omit?: MultisigOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigOwnerInclude<ExtArgs> | null
    /**
     * The data needed to create a MultisigOwner.
     */
    data: XOR<MultisigOwnerCreateInput, MultisigOwnerUncheckedCreateInput>
  }

  /**
   * MultisigOwner createMany
   */
  export type MultisigOwnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MultisigOwners.
     */
    data: MultisigOwnerCreateManyInput | MultisigOwnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MultisigOwner createManyAndReturn
   */
  export type MultisigOwnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigOwner
     */
    select?: MultisigOwnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigOwner
     */
    omit?: MultisigOwnerOmit<ExtArgs> | null
    /**
     * The data used to create many MultisigOwners.
     */
    data: MultisigOwnerCreateManyInput | MultisigOwnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigOwnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MultisigOwner update
   */
  export type MultisigOwnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigOwner
     */
    select?: MultisigOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigOwner
     */
    omit?: MultisigOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigOwnerInclude<ExtArgs> | null
    /**
     * The data needed to update a MultisigOwner.
     */
    data: XOR<MultisigOwnerUpdateInput, MultisigOwnerUncheckedUpdateInput>
    /**
     * Choose, which MultisigOwner to update.
     */
    where: MultisigOwnerWhereUniqueInput
  }

  /**
   * MultisigOwner updateMany
   */
  export type MultisigOwnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MultisigOwners.
     */
    data: XOR<MultisigOwnerUpdateManyMutationInput, MultisigOwnerUncheckedUpdateManyInput>
    /**
     * Filter which MultisigOwners to update
     */
    where?: MultisigOwnerWhereInput
    /**
     * Limit how many MultisigOwners to update.
     */
    limit?: number
  }

  /**
   * MultisigOwner updateManyAndReturn
   */
  export type MultisigOwnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigOwner
     */
    select?: MultisigOwnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigOwner
     */
    omit?: MultisigOwnerOmit<ExtArgs> | null
    /**
     * The data used to update MultisigOwners.
     */
    data: XOR<MultisigOwnerUpdateManyMutationInput, MultisigOwnerUncheckedUpdateManyInput>
    /**
     * Filter which MultisigOwners to update
     */
    where?: MultisigOwnerWhereInput
    /**
     * Limit how many MultisigOwners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigOwnerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MultisigOwner upsert
   */
  export type MultisigOwnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigOwner
     */
    select?: MultisigOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigOwner
     */
    omit?: MultisigOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigOwnerInclude<ExtArgs> | null
    /**
     * The filter to search for the MultisigOwner to update in case it exists.
     */
    where: MultisigOwnerWhereUniqueInput
    /**
     * In case the MultisigOwner found by the `where` argument doesn't exist, create a new MultisigOwner with this data.
     */
    create: XOR<MultisigOwnerCreateInput, MultisigOwnerUncheckedCreateInput>
    /**
     * In case the MultisigOwner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MultisigOwnerUpdateInput, MultisigOwnerUncheckedUpdateInput>
  }

  /**
   * MultisigOwner delete
   */
  export type MultisigOwnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigOwner
     */
    select?: MultisigOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigOwner
     */
    omit?: MultisigOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigOwnerInclude<ExtArgs> | null
    /**
     * Filter which MultisigOwner to delete.
     */
    where: MultisigOwnerWhereUniqueInput
  }

  /**
   * MultisigOwner deleteMany
   */
  export type MultisigOwnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultisigOwners to delete
     */
    where?: MultisigOwnerWhereInput
    /**
     * Limit how many MultisigOwners to delete.
     */
    limit?: number
  }

  /**
   * MultisigOwner without action
   */
  export type MultisigOwnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigOwner
     */
    select?: MultisigOwnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigOwner
     */
    omit?: MultisigOwnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigOwnerInclude<ExtArgs> | null
  }


  /**
   * Model MultisigTx
   */

  export type AggregateMultisigTx = {
    _count: MultisigTxCountAggregateOutputType | null
    _avg: MultisigTxAvgAggregateOutputType | null
    _sum: MultisigTxSumAggregateOutputType | null
    _min: MultisigTxMinAggregateOutputType | null
    _max: MultisigTxMaxAggregateOutputType | null
  }

  export type MultisigTxAvgAggregateOutputType = {
    nonce: number | null
    valueWei: Decimal | null
    operation: number | null
  }

  export type MultisigTxSumAggregateOutputType = {
    nonce: number | null
    valueWei: Decimal | null
    operation: number | null
  }

  export type MultisigTxMinAggregateOutputType = {
    id: string | null
    safeId: string | null
    nonce: number | null
    to: string | null
    valueWei: Decimal | null
    dataHex: string | null
    operation: number | null
    submittedBy: string | null
    status: $Enums.MultisigTxStatus | null
    executedTxHash: string | null
    createdAt: Date | null
    executedAt: Date | null
  }

  export type MultisigTxMaxAggregateOutputType = {
    id: string | null
    safeId: string | null
    nonce: number | null
    to: string | null
    valueWei: Decimal | null
    dataHex: string | null
    operation: number | null
    submittedBy: string | null
    status: $Enums.MultisigTxStatus | null
    executedTxHash: string | null
    createdAt: Date | null
    executedAt: Date | null
  }

  export type MultisigTxCountAggregateOutputType = {
    id: number
    safeId: number
    nonce: number
    to: number
    valueWei: number
    dataHex: number
    operation: number
    submittedBy: number
    status: number
    executedTxHash: number
    createdAt: number
    executedAt: number
    _all: number
  }


  export type MultisigTxAvgAggregateInputType = {
    nonce?: true
    valueWei?: true
    operation?: true
  }

  export type MultisigTxSumAggregateInputType = {
    nonce?: true
    valueWei?: true
    operation?: true
  }

  export type MultisigTxMinAggregateInputType = {
    id?: true
    safeId?: true
    nonce?: true
    to?: true
    valueWei?: true
    dataHex?: true
    operation?: true
    submittedBy?: true
    status?: true
    executedTxHash?: true
    createdAt?: true
    executedAt?: true
  }

  export type MultisigTxMaxAggregateInputType = {
    id?: true
    safeId?: true
    nonce?: true
    to?: true
    valueWei?: true
    dataHex?: true
    operation?: true
    submittedBy?: true
    status?: true
    executedTxHash?: true
    createdAt?: true
    executedAt?: true
  }

  export type MultisigTxCountAggregateInputType = {
    id?: true
    safeId?: true
    nonce?: true
    to?: true
    valueWei?: true
    dataHex?: true
    operation?: true
    submittedBy?: true
    status?: true
    executedTxHash?: true
    createdAt?: true
    executedAt?: true
    _all?: true
  }

  export type MultisigTxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultisigTx to aggregate.
     */
    where?: MultisigTxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigTxes to fetch.
     */
    orderBy?: MultisigTxOrderByWithRelationInput | MultisigTxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MultisigTxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigTxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigTxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MultisigTxes
    **/
    _count?: true | MultisigTxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MultisigTxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MultisigTxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MultisigTxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MultisigTxMaxAggregateInputType
  }

  export type GetMultisigTxAggregateType<T extends MultisigTxAggregateArgs> = {
        [P in keyof T & keyof AggregateMultisigTx]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMultisigTx[P]>
      : GetScalarType<T[P], AggregateMultisigTx[P]>
  }




  export type MultisigTxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultisigTxWhereInput
    orderBy?: MultisigTxOrderByWithAggregationInput | MultisigTxOrderByWithAggregationInput[]
    by: MultisigTxScalarFieldEnum[] | MultisigTxScalarFieldEnum
    having?: MultisigTxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MultisigTxCountAggregateInputType | true
    _avg?: MultisigTxAvgAggregateInputType
    _sum?: MultisigTxSumAggregateInputType
    _min?: MultisigTxMinAggregateInputType
    _max?: MultisigTxMaxAggregateInputType
  }

  export type MultisigTxGroupByOutputType = {
    id: string
    safeId: string
    nonce: number
    to: string
    valueWei: Decimal
    dataHex: string | null
    operation: number | null
    submittedBy: string | null
    status: $Enums.MultisigTxStatus
    executedTxHash: string | null
    createdAt: Date
    executedAt: Date | null
    _count: MultisigTxCountAggregateOutputType | null
    _avg: MultisigTxAvgAggregateOutputType | null
    _sum: MultisigTxSumAggregateOutputType | null
    _min: MultisigTxMinAggregateOutputType | null
    _max: MultisigTxMaxAggregateOutputType | null
  }

  type GetMultisigTxGroupByPayload<T extends MultisigTxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MultisigTxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MultisigTxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MultisigTxGroupByOutputType[P]>
            : GetScalarType<T[P], MultisigTxGroupByOutputType[P]>
        }
      >
    >


  export type MultisigTxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    safeId?: boolean
    nonce?: boolean
    to?: boolean
    valueWei?: boolean
    dataHex?: boolean
    operation?: boolean
    submittedBy?: boolean
    status?: boolean
    executedTxHash?: boolean
    createdAt?: boolean
    executedAt?: boolean
    approvals?: boolean | MultisigTx$approvalsArgs<ExtArgs>
    safe?: boolean | MultisigSafeDefaultArgs<ExtArgs>
    _count?: boolean | MultisigTxCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multisigTx"]>

  export type MultisigTxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    safeId?: boolean
    nonce?: boolean
    to?: boolean
    valueWei?: boolean
    dataHex?: boolean
    operation?: boolean
    submittedBy?: boolean
    status?: boolean
    executedTxHash?: boolean
    createdAt?: boolean
    executedAt?: boolean
    safe?: boolean | MultisigSafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multisigTx"]>

  export type MultisigTxSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    safeId?: boolean
    nonce?: boolean
    to?: boolean
    valueWei?: boolean
    dataHex?: boolean
    operation?: boolean
    submittedBy?: boolean
    status?: boolean
    executedTxHash?: boolean
    createdAt?: boolean
    executedAt?: boolean
    safe?: boolean | MultisigSafeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multisigTx"]>

  export type MultisigTxSelectScalar = {
    id?: boolean
    safeId?: boolean
    nonce?: boolean
    to?: boolean
    valueWei?: boolean
    dataHex?: boolean
    operation?: boolean
    submittedBy?: boolean
    status?: boolean
    executedTxHash?: boolean
    createdAt?: boolean
    executedAt?: boolean
  }

  export type MultisigTxOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "safeId" | "nonce" | "to" | "valueWei" | "dataHex" | "operation" | "submittedBy" | "status" | "executedTxHash" | "createdAt" | "executedAt", ExtArgs["result"]["multisigTx"]>
  export type MultisigTxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvals?: boolean | MultisigTx$approvalsArgs<ExtArgs>
    safe?: boolean | MultisigSafeDefaultArgs<ExtArgs>
    _count?: boolean | MultisigTxCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MultisigTxIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    safe?: boolean | MultisigSafeDefaultArgs<ExtArgs>
  }
  export type MultisigTxIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    safe?: boolean | MultisigSafeDefaultArgs<ExtArgs>
  }

  export type $MultisigTxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MultisigTx"
    objects: {
      approvals: Prisma.$MultisigApprovalPayload<ExtArgs>[]
      safe: Prisma.$MultisigSafePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      safeId: string
      nonce: number
      to: string
      valueWei: Prisma.Decimal
      dataHex: string | null
      operation: number | null
      submittedBy: string | null
      status: $Enums.MultisigTxStatus
      executedTxHash: string | null
      createdAt: Date
      executedAt: Date | null
    }, ExtArgs["result"]["multisigTx"]>
    composites: {}
  }

  type MultisigTxGetPayload<S extends boolean | null | undefined | MultisigTxDefaultArgs> = $Result.GetResult<Prisma.$MultisigTxPayload, S>

  type MultisigTxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MultisigTxFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MultisigTxCountAggregateInputType | true
    }

  export interface MultisigTxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MultisigTx'], meta: { name: 'MultisigTx' } }
    /**
     * Find zero or one MultisigTx that matches the filter.
     * @param {MultisigTxFindUniqueArgs} args - Arguments to find a MultisigTx
     * @example
     * // Get one MultisigTx
     * const multisigTx = await prisma.multisigTx.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MultisigTxFindUniqueArgs>(args: SelectSubset<T, MultisigTxFindUniqueArgs<ExtArgs>>): Prisma__MultisigTxClient<$Result.GetResult<Prisma.$MultisigTxPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MultisigTx that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MultisigTxFindUniqueOrThrowArgs} args - Arguments to find a MultisigTx
     * @example
     * // Get one MultisigTx
     * const multisigTx = await prisma.multisigTx.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MultisigTxFindUniqueOrThrowArgs>(args: SelectSubset<T, MultisigTxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MultisigTxClient<$Result.GetResult<Prisma.$MultisigTxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultisigTx that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigTxFindFirstArgs} args - Arguments to find a MultisigTx
     * @example
     * // Get one MultisigTx
     * const multisigTx = await prisma.multisigTx.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MultisigTxFindFirstArgs>(args?: SelectSubset<T, MultisigTxFindFirstArgs<ExtArgs>>): Prisma__MultisigTxClient<$Result.GetResult<Prisma.$MultisigTxPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultisigTx that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigTxFindFirstOrThrowArgs} args - Arguments to find a MultisigTx
     * @example
     * // Get one MultisigTx
     * const multisigTx = await prisma.multisigTx.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MultisigTxFindFirstOrThrowArgs>(args?: SelectSubset<T, MultisigTxFindFirstOrThrowArgs<ExtArgs>>): Prisma__MultisigTxClient<$Result.GetResult<Prisma.$MultisigTxPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MultisigTxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigTxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MultisigTxes
     * const multisigTxes = await prisma.multisigTx.findMany()
     * 
     * // Get first 10 MultisigTxes
     * const multisigTxes = await prisma.multisigTx.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const multisigTxWithIdOnly = await prisma.multisigTx.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MultisigTxFindManyArgs>(args?: SelectSubset<T, MultisigTxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigTxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MultisigTx.
     * @param {MultisigTxCreateArgs} args - Arguments to create a MultisigTx.
     * @example
     * // Create one MultisigTx
     * const MultisigTx = await prisma.multisigTx.create({
     *   data: {
     *     // ... data to create a MultisigTx
     *   }
     * })
     * 
     */
    create<T extends MultisigTxCreateArgs>(args: SelectSubset<T, MultisigTxCreateArgs<ExtArgs>>): Prisma__MultisigTxClient<$Result.GetResult<Prisma.$MultisigTxPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MultisigTxes.
     * @param {MultisigTxCreateManyArgs} args - Arguments to create many MultisigTxes.
     * @example
     * // Create many MultisigTxes
     * const multisigTx = await prisma.multisigTx.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MultisigTxCreateManyArgs>(args?: SelectSubset<T, MultisigTxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MultisigTxes and returns the data saved in the database.
     * @param {MultisigTxCreateManyAndReturnArgs} args - Arguments to create many MultisigTxes.
     * @example
     * // Create many MultisigTxes
     * const multisigTx = await prisma.multisigTx.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MultisigTxes and only return the `id`
     * const multisigTxWithIdOnly = await prisma.multisigTx.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MultisigTxCreateManyAndReturnArgs>(args?: SelectSubset<T, MultisigTxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigTxPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MultisigTx.
     * @param {MultisigTxDeleteArgs} args - Arguments to delete one MultisigTx.
     * @example
     * // Delete one MultisigTx
     * const MultisigTx = await prisma.multisigTx.delete({
     *   where: {
     *     // ... filter to delete one MultisigTx
     *   }
     * })
     * 
     */
    delete<T extends MultisigTxDeleteArgs>(args: SelectSubset<T, MultisigTxDeleteArgs<ExtArgs>>): Prisma__MultisigTxClient<$Result.GetResult<Prisma.$MultisigTxPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MultisigTx.
     * @param {MultisigTxUpdateArgs} args - Arguments to update one MultisigTx.
     * @example
     * // Update one MultisigTx
     * const multisigTx = await prisma.multisigTx.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MultisigTxUpdateArgs>(args: SelectSubset<T, MultisigTxUpdateArgs<ExtArgs>>): Prisma__MultisigTxClient<$Result.GetResult<Prisma.$MultisigTxPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MultisigTxes.
     * @param {MultisigTxDeleteManyArgs} args - Arguments to filter MultisigTxes to delete.
     * @example
     * // Delete a few MultisigTxes
     * const { count } = await prisma.multisigTx.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MultisigTxDeleteManyArgs>(args?: SelectSubset<T, MultisigTxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultisigTxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigTxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MultisigTxes
     * const multisigTx = await prisma.multisigTx.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MultisigTxUpdateManyArgs>(args: SelectSubset<T, MultisigTxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultisigTxes and returns the data updated in the database.
     * @param {MultisigTxUpdateManyAndReturnArgs} args - Arguments to update many MultisigTxes.
     * @example
     * // Update many MultisigTxes
     * const multisigTx = await prisma.multisigTx.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MultisigTxes and only return the `id`
     * const multisigTxWithIdOnly = await prisma.multisigTx.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MultisigTxUpdateManyAndReturnArgs>(args: SelectSubset<T, MultisigTxUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigTxPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MultisigTx.
     * @param {MultisigTxUpsertArgs} args - Arguments to update or create a MultisigTx.
     * @example
     * // Update or create a MultisigTx
     * const multisigTx = await prisma.multisigTx.upsert({
     *   create: {
     *     // ... data to create a MultisigTx
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MultisigTx we want to update
     *   }
     * })
     */
    upsert<T extends MultisigTxUpsertArgs>(args: SelectSubset<T, MultisigTxUpsertArgs<ExtArgs>>): Prisma__MultisigTxClient<$Result.GetResult<Prisma.$MultisigTxPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MultisigTxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigTxCountArgs} args - Arguments to filter MultisigTxes to count.
     * @example
     * // Count the number of MultisigTxes
     * const count = await prisma.multisigTx.count({
     *   where: {
     *     // ... the filter for the MultisigTxes we want to count
     *   }
     * })
    **/
    count<T extends MultisigTxCountArgs>(
      args?: Subset<T, MultisigTxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MultisigTxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MultisigTx.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigTxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MultisigTxAggregateArgs>(args: Subset<T, MultisigTxAggregateArgs>): Prisma.PrismaPromise<GetMultisigTxAggregateType<T>>

    /**
     * Group by MultisigTx.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigTxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MultisigTxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MultisigTxGroupByArgs['orderBy'] }
        : { orderBy?: MultisigTxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MultisigTxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMultisigTxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MultisigTx model
   */
  readonly fields: MultisigTxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MultisigTx.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MultisigTxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approvals<T extends MultisigTx$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, MultisigTx$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    safe<T extends MultisigSafeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MultisigSafeDefaultArgs<ExtArgs>>): Prisma__MultisigSafeClient<$Result.GetResult<Prisma.$MultisigSafePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MultisigTx model
   */
  interface MultisigTxFieldRefs {
    readonly id: FieldRef<"MultisigTx", 'String'>
    readonly safeId: FieldRef<"MultisigTx", 'String'>
    readonly nonce: FieldRef<"MultisigTx", 'Int'>
    readonly to: FieldRef<"MultisigTx", 'String'>
    readonly valueWei: FieldRef<"MultisigTx", 'Decimal'>
    readonly dataHex: FieldRef<"MultisigTx", 'String'>
    readonly operation: FieldRef<"MultisigTx", 'Int'>
    readonly submittedBy: FieldRef<"MultisigTx", 'String'>
    readonly status: FieldRef<"MultisigTx", 'MultisigTxStatus'>
    readonly executedTxHash: FieldRef<"MultisigTx", 'String'>
    readonly createdAt: FieldRef<"MultisigTx", 'DateTime'>
    readonly executedAt: FieldRef<"MultisigTx", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MultisigTx findUnique
   */
  export type MultisigTxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigTx
     */
    select?: MultisigTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigTx
     */
    omit?: MultisigTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigTxInclude<ExtArgs> | null
    /**
     * Filter, which MultisigTx to fetch.
     */
    where: MultisigTxWhereUniqueInput
  }

  /**
   * MultisigTx findUniqueOrThrow
   */
  export type MultisigTxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigTx
     */
    select?: MultisigTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigTx
     */
    omit?: MultisigTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigTxInclude<ExtArgs> | null
    /**
     * Filter, which MultisigTx to fetch.
     */
    where: MultisigTxWhereUniqueInput
  }

  /**
   * MultisigTx findFirst
   */
  export type MultisigTxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigTx
     */
    select?: MultisigTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigTx
     */
    omit?: MultisigTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigTxInclude<ExtArgs> | null
    /**
     * Filter, which MultisigTx to fetch.
     */
    where?: MultisigTxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigTxes to fetch.
     */
    orderBy?: MultisigTxOrderByWithRelationInput | MultisigTxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultisigTxes.
     */
    cursor?: MultisigTxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigTxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigTxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultisigTxes.
     */
    distinct?: MultisigTxScalarFieldEnum | MultisigTxScalarFieldEnum[]
  }

  /**
   * MultisigTx findFirstOrThrow
   */
  export type MultisigTxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigTx
     */
    select?: MultisigTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigTx
     */
    omit?: MultisigTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigTxInclude<ExtArgs> | null
    /**
     * Filter, which MultisigTx to fetch.
     */
    where?: MultisigTxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigTxes to fetch.
     */
    orderBy?: MultisigTxOrderByWithRelationInput | MultisigTxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultisigTxes.
     */
    cursor?: MultisigTxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigTxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigTxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultisigTxes.
     */
    distinct?: MultisigTxScalarFieldEnum | MultisigTxScalarFieldEnum[]
  }

  /**
   * MultisigTx findMany
   */
  export type MultisigTxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigTx
     */
    select?: MultisigTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigTx
     */
    omit?: MultisigTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigTxInclude<ExtArgs> | null
    /**
     * Filter, which MultisigTxes to fetch.
     */
    where?: MultisigTxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigTxes to fetch.
     */
    orderBy?: MultisigTxOrderByWithRelationInput | MultisigTxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MultisigTxes.
     */
    cursor?: MultisigTxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigTxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigTxes.
     */
    skip?: number
    distinct?: MultisigTxScalarFieldEnum | MultisigTxScalarFieldEnum[]
  }

  /**
   * MultisigTx create
   */
  export type MultisigTxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigTx
     */
    select?: MultisigTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigTx
     */
    omit?: MultisigTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigTxInclude<ExtArgs> | null
    /**
     * The data needed to create a MultisigTx.
     */
    data: XOR<MultisigTxCreateInput, MultisigTxUncheckedCreateInput>
  }

  /**
   * MultisigTx createMany
   */
  export type MultisigTxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MultisigTxes.
     */
    data: MultisigTxCreateManyInput | MultisigTxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MultisigTx createManyAndReturn
   */
  export type MultisigTxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigTx
     */
    select?: MultisigTxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigTx
     */
    omit?: MultisigTxOmit<ExtArgs> | null
    /**
     * The data used to create many MultisigTxes.
     */
    data: MultisigTxCreateManyInput | MultisigTxCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigTxIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MultisigTx update
   */
  export type MultisigTxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigTx
     */
    select?: MultisigTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigTx
     */
    omit?: MultisigTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigTxInclude<ExtArgs> | null
    /**
     * The data needed to update a MultisigTx.
     */
    data: XOR<MultisigTxUpdateInput, MultisigTxUncheckedUpdateInput>
    /**
     * Choose, which MultisigTx to update.
     */
    where: MultisigTxWhereUniqueInput
  }

  /**
   * MultisigTx updateMany
   */
  export type MultisigTxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MultisigTxes.
     */
    data: XOR<MultisigTxUpdateManyMutationInput, MultisigTxUncheckedUpdateManyInput>
    /**
     * Filter which MultisigTxes to update
     */
    where?: MultisigTxWhereInput
    /**
     * Limit how many MultisigTxes to update.
     */
    limit?: number
  }

  /**
   * MultisigTx updateManyAndReturn
   */
  export type MultisigTxUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigTx
     */
    select?: MultisigTxSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigTx
     */
    omit?: MultisigTxOmit<ExtArgs> | null
    /**
     * The data used to update MultisigTxes.
     */
    data: XOR<MultisigTxUpdateManyMutationInput, MultisigTxUncheckedUpdateManyInput>
    /**
     * Filter which MultisigTxes to update
     */
    where?: MultisigTxWhereInput
    /**
     * Limit how many MultisigTxes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigTxIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MultisigTx upsert
   */
  export type MultisigTxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigTx
     */
    select?: MultisigTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigTx
     */
    omit?: MultisigTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigTxInclude<ExtArgs> | null
    /**
     * The filter to search for the MultisigTx to update in case it exists.
     */
    where: MultisigTxWhereUniqueInput
    /**
     * In case the MultisigTx found by the `where` argument doesn't exist, create a new MultisigTx with this data.
     */
    create: XOR<MultisigTxCreateInput, MultisigTxUncheckedCreateInput>
    /**
     * In case the MultisigTx was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MultisigTxUpdateInput, MultisigTxUncheckedUpdateInput>
  }

  /**
   * MultisigTx delete
   */
  export type MultisigTxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigTx
     */
    select?: MultisigTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigTx
     */
    omit?: MultisigTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigTxInclude<ExtArgs> | null
    /**
     * Filter which MultisigTx to delete.
     */
    where: MultisigTxWhereUniqueInput
  }

  /**
   * MultisigTx deleteMany
   */
  export type MultisigTxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultisigTxes to delete
     */
    where?: MultisigTxWhereInput
    /**
     * Limit how many MultisigTxes to delete.
     */
    limit?: number
  }

  /**
   * MultisigTx.approvals
   */
  export type MultisigTx$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigApproval
     */
    select?: MultisigApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigApproval
     */
    omit?: MultisigApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigApprovalInclude<ExtArgs> | null
    where?: MultisigApprovalWhereInput
    orderBy?: MultisigApprovalOrderByWithRelationInput | MultisigApprovalOrderByWithRelationInput[]
    cursor?: MultisigApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MultisigApprovalScalarFieldEnum | MultisigApprovalScalarFieldEnum[]
  }

  /**
   * MultisigTx without action
   */
  export type MultisigTxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigTx
     */
    select?: MultisigTxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigTx
     */
    omit?: MultisigTxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigTxInclude<ExtArgs> | null
  }


  /**
   * Model MultisigApproval
   */

  export type AggregateMultisigApproval = {
    _count: MultisigApprovalCountAggregateOutputType | null
    _min: MultisigApprovalMinAggregateOutputType | null
    _max: MultisigApprovalMaxAggregateOutputType | null
  }

  export type MultisigApprovalMinAggregateOutputType = {
    id: string | null
    txId: string | null
    ownerAddress: string | null
    signature: string | null
    createdAt: Date | null
  }

  export type MultisigApprovalMaxAggregateOutputType = {
    id: string | null
    txId: string | null
    ownerAddress: string | null
    signature: string | null
    createdAt: Date | null
  }

  export type MultisigApprovalCountAggregateOutputType = {
    id: number
    txId: number
    ownerAddress: number
    signature: number
    createdAt: number
    _all: number
  }


  export type MultisigApprovalMinAggregateInputType = {
    id?: true
    txId?: true
    ownerAddress?: true
    signature?: true
    createdAt?: true
  }

  export type MultisigApprovalMaxAggregateInputType = {
    id?: true
    txId?: true
    ownerAddress?: true
    signature?: true
    createdAt?: true
  }

  export type MultisigApprovalCountAggregateInputType = {
    id?: true
    txId?: true
    ownerAddress?: true
    signature?: true
    createdAt?: true
    _all?: true
  }

  export type MultisigApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultisigApproval to aggregate.
     */
    where?: MultisigApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigApprovals to fetch.
     */
    orderBy?: MultisigApprovalOrderByWithRelationInput | MultisigApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MultisigApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MultisigApprovals
    **/
    _count?: true | MultisigApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MultisigApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MultisigApprovalMaxAggregateInputType
  }

  export type GetMultisigApprovalAggregateType<T extends MultisigApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateMultisigApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMultisigApproval[P]>
      : GetScalarType<T[P], AggregateMultisigApproval[P]>
  }




  export type MultisigApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MultisigApprovalWhereInput
    orderBy?: MultisigApprovalOrderByWithAggregationInput | MultisigApprovalOrderByWithAggregationInput[]
    by: MultisigApprovalScalarFieldEnum[] | MultisigApprovalScalarFieldEnum
    having?: MultisigApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MultisigApprovalCountAggregateInputType | true
    _min?: MultisigApprovalMinAggregateInputType
    _max?: MultisigApprovalMaxAggregateInputType
  }

  export type MultisigApprovalGroupByOutputType = {
    id: string
    txId: string
    ownerAddress: string
    signature: string | null
    createdAt: Date
    _count: MultisigApprovalCountAggregateOutputType | null
    _min: MultisigApprovalMinAggregateOutputType | null
    _max: MultisigApprovalMaxAggregateOutputType | null
  }

  type GetMultisigApprovalGroupByPayload<T extends MultisigApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MultisigApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MultisigApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MultisigApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], MultisigApprovalGroupByOutputType[P]>
        }
      >
    >


  export type MultisigApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    txId?: boolean
    ownerAddress?: boolean
    signature?: boolean
    createdAt?: boolean
    tx?: boolean | MultisigTxDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multisigApproval"]>

  export type MultisigApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    txId?: boolean
    ownerAddress?: boolean
    signature?: boolean
    createdAt?: boolean
    tx?: boolean | MultisigTxDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multisigApproval"]>

  export type MultisigApprovalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    txId?: boolean
    ownerAddress?: boolean
    signature?: boolean
    createdAt?: boolean
    tx?: boolean | MultisigTxDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["multisigApproval"]>

  export type MultisigApprovalSelectScalar = {
    id?: boolean
    txId?: boolean
    ownerAddress?: boolean
    signature?: boolean
    createdAt?: boolean
  }

  export type MultisigApprovalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "txId" | "ownerAddress" | "signature" | "createdAt", ExtArgs["result"]["multisigApproval"]>
  export type MultisigApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tx?: boolean | MultisigTxDefaultArgs<ExtArgs>
  }
  export type MultisigApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tx?: boolean | MultisigTxDefaultArgs<ExtArgs>
  }
  export type MultisigApprovalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tx?: boolean | MultisigTxDefaultArgs<ExtArgs>
  }

  export type $MultisigApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MultisigApproval"
    objects: {
      tx: Prisma.$MultisigTxPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      txId: string
      ownerAddress: string
      signature: string | null
      createdAt: Date
    }, ExtArgs["result"]["multisigApproval"]>
    composites: {}
  }

  type MultisigApprovalGetPayload<S extends boolean | null | undefined | MultisigApprovalDefaultArgs> = $Result.GetResult<Prisma.$MultisigApprovalPayload, S>

  type MultisigApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MultisigApprovalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MultisigApprovalCountAggregateInputType | true
    }

  export interface MultisigApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MultisigApproval'], meta: { name: 'MultisigApproval' } }
    /**
     * Find zero or one MultisigApproval that matches the filter.
     * @param {MultisigApprovalFindUniqueArgs} args - Arguments to find a MultisigApproval
     * @example
     * // Get one MultisigApproval
     * const multisigApproval = await prisma.multisigApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MultisigApprovalFindUniqueArgs>(args: SelectSubset<T, MultisigApprovalFindUniqueArgs<ExtArgs>>): Prisma__MultisigApprovalClient<$Result.GetResult<Prisma.$MultisigApprovalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MultisigApproval that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MultisigApprovalFindUniqueOrThrowArgs} args - Arguments to find a MultisigApproval
     * @example
     * // Get one MultisigApproval
     * const multisigApproval = await prisma.multisigApproval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MultisigApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, MultisigApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MultisigApprovalClient<$Result.GetResult<Prisma.$MultisigApprovalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultisigApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigApprovalFindFirstArgs} args - Arguments to find a MultisigApproval
     * @example
     * // Get one MultisigApproval
     * const multisigApproval = await prisma.multisigApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MultisigApprovalFindFirstArgs>(args?: SelectSubset<T, MultisigApprovalFindFirstArgs<ExtArgs>>): Prisma__MultisigApprovalClient<$Result.GetResult<Prisma.$MultisigApprovalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MultisigApproval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigApprovalFindFirstOrThrowArgs} args - Arguments to find a MultisigApproval
     * @example
     * // Get one MultisigApproval
     * const multisigApproval = await prisma.multisigApproval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MultisigApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, MultisigApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__MultisigApprovalClient<$Result.GetResult<Prisma.$MultisigApprovalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MultisigApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MultisigApprovals
     * const multisigApprovals = await prisma.multisigApproval.findMany()
     * 
     * // Get first 10 MultisigApprovals
     * const multisigApprovals = await prisma.multisigApproval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const multisigApprovalWithIdOnly = await prisma.multisigApproval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MultisigApprovalFindManyArgs>(args?: SelectSubset<T, MultisigApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MultisigApproval.
     * @param {MultisigApprovalCreateArgs} args - Arguments to create a MultisigApproval.
     * @example
     * // Create one MultisigApproval
     * const MultisigApproval = await prisma.multisigApproval.create({
     *   data: {
     *     // ... data to create a MultisigApproval
     *   }
     * })
     * 
     */
    create<T extends MultisigApprovalCreateArgs>(args: SelectSubset<T, MultisigApprovalCreateArgs<ExtArgs>>): Prisma__MultisigApprovalClient<$Result.GetResult<Prisma.$MultisigApprovalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MultisigApprovals.
     * @param {MultisigApprovalCreateManyArgs} args - Arguments to create many MultisigApprovals.
     * @example
     * // Create many MultisigApprovals
     * const multisigApproval = await prisma.multisigApproval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MultisigApprovalCreateManyArgs>(args?: SelectSubset<T, MultisigApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MultisigApprovals and returns the data saved in the database.
     * @param {MultisigApprovalCreateManyAndReturnArgs} args - Arguments to create many MultisigApprovals.
     * @example
     * // Create many MultisigApprovals
     * const multisigApproval = await prisma.multisigApproval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MultisigApprovals and only return the `id`
     * const multisigApprovalWithIdOnly = await prisma.multisigApproval.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MultisigApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, MultisigApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigApprovalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MultisigApproval.
     * @param {MultisigApprovalDeleteArgs} args - Arguments to delete one MultisigApproval.
     * @example
     * // Delete one MultisigApproval
     * const MultisigApproval = await prisma.multisigApproval.delete({
     *   where: {
     *     // ... filter to delete one MultisigApproval
     *   }
     * })
     * 
     */
    delete<T extends MultisigApprovalDeleteArgs>(args: SelectSubset<T, MultisigApprovalDeleteArgs<ExtArgs>>): Prisma__MultisigApprovalClient<$Result.GetResult<Prisma.$MultisigApprovalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MultisigApproval.
     * @param {MultisigApprovalUpdateArgs} args - Arguments to update one MultisigApproval.
     * @example
     * // Update one MultisigApproval
     * const multisigApproval = await prisma.multisigApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MultisigApprovalUpdateArgs>(args: SelectSubset<T, MultisigApprovalUpdateArgs<ExtArgs>>): Prisma__MultisigApprovalClient<$Result.GetResult<Prisma.$MultisigApprovalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MultisigApprovals.
     * @param {MultisigApprovalDeleteManyArgs} args - Arguments to filter MultisigApprovals to delete.
     * @example
     * // Delete a few MultisigApprovals
     * const { count } = await prisma.multisigApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MultisigApprovalDeleteManyArgs>(args?: SelectSubset<T, MultisigApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultisigApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MultisigApprovals
     * const multisigApproval = await prisma.multisigApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MultisigApprovalUpdateManyArgs>(args: SelectSubset<T, MultisigApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MultisigApprovals and returns the data updated in the database.
     * @param {MultisigApprovalUpdateManyAndReturnArgs} args - Arguments to update many MultisigApprovals.
     * @example
     * // Update many MultisigApprovals
     * const multisigApproval = await prisma.multisigApproval.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MultisigApprovals and only return the `id`
     * const multisigApprovalWithIdOnly = await prisma.multisigApproval.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MultisigApprovalUpdateManyAndReturnArgs>(args: SelectSubset<T, MultisigApprovalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MultisigApprovalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MultisigApproval.
     * @param {MultisigApprovalUpsertArgs} args - Arguments to update or create a MultisigApproval.
     * @example
     * // Update or create a MultisigApproval
     * const multisigApproval = await prisma.multisigApproval.upsert({
     *   create: {
     *     // ... data to create a MultisigApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MultisigApproval we want to update
     *   }
     * })
     */
    upsert<T extends MultisigApprovalUpsertArgs>(args: SelectSubset<T, MultisigApprovalUpsertArgs<ExtArgs>>): Prisma__MultisigApprovalClient<$Result.GetResult<Prisma.$MultisigApprovalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MultisigApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigApprovalCountArgs} args - Arguments to filter MultisigApprovals to count.
     * @example
     * // Count the number of MultisigApprovals
     * const count = await prisma.multisigApproval.count({
     *   where: {
     *     // ... the filter for the MultisigApprovals we want to count
     *   }
     * })
    **/
    count<T extends MultisigApprovalCountArgs>(
      args?: Subset<T, MultisigApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MultisigApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MultisigApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MultisigApprovalAggregateArgs>(args: Subset<T, MultisigApprovalAggregateArgs>): Prisma.PrismaPromise<GetMultisigApprovalAggregateType<T>>

    /**
     * Group by MultisigApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MultisigApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MultisigApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MultisigApprovalGroupByArgs['orderBy'] }
        : { orderBy?: MultisigApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MultisigApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMultisigApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MultisigApproval model
   */
  readonly fields: MultisigApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MultisigApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MultisigApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tx<T extends MultisigTxDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MultisigTxDefaultArgs<ExtArgs>>): Prisma__MultisigTxClient<$Result.GetResult<Prisma.$MultisigTxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MultisigApproval model
   */
  interface MultisigApprovalFieldRefs {
    readonly id: FieldRef<"MultisigApproval", 'String'>
    readonly txId: FieldRef<"MultisigApproval", 'String'>
    readonly ownerAddress: FieldRef<"MultisigApproval", 'String'>
    readonly signature: FieldRef<"MultisigApproval", 'String'>
    readonly createdAt: FieldRef<"MultisigApproval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MultisigApproval findUnique
   */
  export type MultisigApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigApproval
     */
    select?: MultisigApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigApproval
     */
    omit?: MultisigApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MultisigApproval to fetch.
     */
    where: MultisigApprovalWhereUniqueInput
  }

  /**
   * MultisigApproval findUniqueOrThrow
   */
  export type MultisigApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigApproval
     */
    select?: MultisigApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigApproval
     */
    omit?: MultisigApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MultisigApproval to fetch.
     */
    where: MultisigApprovalWhereUniqueInput
  }

  /**
   * MultisigApproval findFirst
   */
  export type MultisigApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigApproval
     */
    select?: MultisigApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigApproval
     */
    omit?: MultisigApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MultisigApproval to fetch.
     */
    where?: MultisigApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigApprovals to fetch.
     */
    orderBy?: MultisigApprovalOrderByWithRelationInput | MultisigApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultisigApprovals.
     */
    cursor?: MultisigApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultisigApprovals.
     */
    distinct?: MultisigApprovalScalarFieldEnum | MultisigApprovalScalarFieldEnum[]
  }

  /**
   * MultisigApproval findFirstOrThrow
   */
  export type MultisigApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigApproval
     */
    select?: MultisigApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigApproval
     */
    omit?: MultisigApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MultisigApproval to fetch.
     */
    where?: MultisigApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigApprovals to fetch.
     */
    orderBy?: MultisigApprovalOrderByWithRelationInput | MultisigApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MultisigApprovals.
     */
    cursor?: MultisigApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MultisigApprovals.
     */
    distinct?: MultisigApprovalScalarFieldEnum | MultisigApprovalScalarFieldEnum[]
  }

  /**
   * MultisigApproval findMany
   */
  export type MultisigApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigApproval
     */
    select?: MultisigApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigApproval
     */
    omit?: MultisigApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigApprovalInclude<ExtArgs> | null
    /**
     * Filter, which MultisigApprovals to fetch.
     */
    where?: MultisigApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MultisigApprovals to fetch.
     */
    orderBy?: MultisigApprovalOrderByWithRelationInput | MultisigApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MultisigApprovals.
     */
    cursor?: MultisigApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MultisigApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MultisigApprovals.
     */
    skip?: number
    distinct?: MultisigApprovalScalarFieldEnum | MultisigApprovalScalarFieldEnum[]
  }

  /**
   * MultisigApproval create
   */
  export type MultisigApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigApproval
     */
    select?: MultisigApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigApproval
     */
    omit?: MultisigApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a MultisigApproval.
     */
    data: XOR<MultisigApprovalCreateInput, MultisigApprovalUncheckedCreateInput>
  }

  /**
   * MultisigApproval createMany
   */
  export type MultisigApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MultisigApprovals.
     */
    data: MultisigApprovalCreateManyInput | MultisigApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MultisigApproval createManyAndReturn
   */
  export type MultisigApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigApproval
     */
    select?: MultisigApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigApproval
     */
    omit?: MultisigApprovalOmit<ExtArgs> | null
    /**
     * The data used to create many MultisigApprovals.
     */
    data: MultisigApprovalCreateManyInput | MultisigApprovalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MultisigApproval update
   */
  export type MultisigApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigApproval
     */
    select?: MultisigApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigApproval
     */
    omit?: MultisigApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a MultisigApproval.
     */
    data: XOR<MultisigApprovalUpdateInput, MultisigApprovalUncheckedUpdateInput>
    /**
     * Choose, which MultisigApproval to update.
     */
    where: MultisigApprovalWhereUniqueInput
  }

  /**
   * MultisigApproval updateMany
   */
  export type MultisigApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MultisigApprovals.
     */
    data: XOR<MultisigApprovalUpdateManyMutationInput, MultisigApprovalUncheckedUpdateManyInput>
    /**
     * Filter which MultisigApprovals to update
     */
    where?: MultisigApprovalWhereInput
    /**
     * Limit how many MultisigApprovals to update.
     */
    limit?: number
  }

  /**
   * MultisigApproval updateManyAndReturn
   */
  export type MultisigApprovalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigApproval
     */
    select?: MultisigApprovalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigApproval
     */
    omit?: MultisigApprovalOmit<ExtArgs> | null
    /**
     * The data used to update MultisigApprovals.
     */
    data: XOR<MultisigApprovalUpdateManyMutationInput, MultisigApprovalUncheckedUpdateManyInput>
    /**
     * Filter which MultisigApprovals to update
     */
    where?: MultisigApprovalWhereInput
    /**
     * Limit how many MultisigApprovals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigApprovalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MultisigApproval upsert
   */
  export type MultisigApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigApproval
     */
    select?: MultisigApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigApproval
     */
    omit?: MultisigApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the MultisigApproval to update in case it exists.
     */
    where: MultisigApprovalWhereUniqueInput
    /**
     * In case the MultisigApproval found by the `where` argument doesn't exist, create a new MultisigApproval with this data.
     */
    create: XOR<MultisigApprovalCreateInput, MultisigApprovalUncheckedCreateInput>
    /**
     * In case the MultisigApproval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MultisigApprovalUpdateInput, MultisigApprovalUncheckedUpdateInput>
  }

  /**
   * MultisigApproval delete
   */
  export type MultisigApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigApproval
     */
    select?: MultisigApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigApproval
     */
    omit?: MultisigApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigApprovalInclude<ExtArgs> | null
    /**
     * Filter which MultisigApproval to delete.
     */
    where: MultisigApprovalWhereUniqueInput
  }

  /**
   * MultisigApproval deleteMany
   */
  export type MultisigApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MultisigApprovals to delete
     */
    where?: MultisigApprovalWhereInput
    /**
     * Limit how many MultisigApprovals to delete.
     */
    limit?: number
  }

  /**
   * MultisigApproval without action
   */
  export type MultisigApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MultisigApproval
     */
    select?: MultisigApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MultisigApproval
     */
    omit?: MultisigApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MultisigApprovalInclude<ExtArgs> | null
  }


  /**
   * Model PendingChainAction
   */

  export type AggregatePendingChainAction = {
    _count: PendingChainActionCountAggregateOutputType | null
    _avg: PendingChainActionAvgAggregateOutputType | null
    _sum: PendingChainActionSumAggregateOutputType | null
    _min: PendingChainActionMinAggregateOutputType | null
    _max: PendingChainActionMaxAggregateOutputType | null
  }

  export type PendingChainActionAvgAggregateOutputType = {
    chainId: number | null
  }

  export type PendingChainActionSumAggregateOutputType = {
    chainId: number | null
  }

  export type PendingChainActionMinAggregateOutputType = {
    id: string | null
    type: $Enums.PendingChainActionType | null
    txHash: string | null
    from: string | null
    chainId: number | null
    relatedId: string | null
    status: $Enums.PendingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PendingChainActionMaxAggregateOutputType = {
    id: string | null
    type: $Enums.PendingChainActionType | null
    txHash: string | null
    from: string | null
    chainId: number | null
    relatedId: string | null
    status: $Enums.PendingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PendingChainActionCountAggregateOutputType = {
    id: number
    type: number
    txHash: number
    from: number
    chainId: number
    payload: number
    relatedId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PendingChainActionAvgAggregateInputType = {
    chainId?: true
  }

  export type PendingChainActionSumAggregateInputType = {
    chainId?: true
  }

  export type PendingChainActionMinAggregateInputType = {
    id?: true
    type?: true
    txHash?: true
    from?: true
    chainId?: true
    relatedId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PendingChainActionMaxAggregateInputType = {
    id?: true
    type?: true
    txHash?: true
    from?: true
    chainId?: true
    relatedId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PendingChainActionCountAggregateInputType = {
    id?: true
    type?: true
    txHash?: true
    from?: true
    chainId?: true
    payload?: true
    relatedId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PendingChainActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingChainAction to aggregate.
     */
    where?: PendingChainActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingChainActions to fetch.
     */
    orderBy?: PendingChainActionOrderByWithRelationInput | PendingChainActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingChainActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingChainActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingChainActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingChainActions
    **/
    _count?: true | PendingChainActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingChainActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingChainActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingChainActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingChainActionMaxAggregateInputType
  }

  export type GetPendingChainActionAggregateType<T extends PendingChainActionAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingChainAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingChainAction[P]>
      : GetScalarType<T[P], AggregatePendingChainAction[P]>
  }




  export type PendingChainActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingChainActionWhereInput
    orderBy?: PendingChainActionOrderByWithAggregationInput | PendingChainActionOrderByWithAggregationInput[]
    by: PendingChainActionScalarFieldEnum[] | PendingChainActionScalarFieldEnum
    having?: PendingChainActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingChainActionCountAggregateInputType | true
    _avg?: PendingChainActionAvgAggregateInputType
    _sum?: PendingChainActionSumAggregateInputType
    _min?: PendingChainActionMinAggregateInputType
    _max?: PendingChainActionMaxAggregateInputType
  }

  export type PendingChainActionGroupByOutputType = {
    id: string
    type: $Enums.PendingChainActionType
    txHash: string
    from: string
    chainId: number
    payload: JsonValue
    relatedId: string | null
    status: $Enums.PendingStatus
    createdAt: Date
    updatedAt: Date
    _count: PendingChainActionCountAggregateOutputType | null
    _avg: PendingChainActionAvgAggregateOutputType | null
    _sum: PendingChainActionSumAggregateOutputType | null
    _min: PendingChainActionMinAggregateOutputType | null
    _max: PendingChainActionMaxAggregateOutputType | null
  }

  type GetPendingChainActionGroupByPayload<T extends PendingChainActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingChainActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingChainActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingChainActionGroupByOutputType[P]>
            : GetScalarType<T[P], PendingChainActionGroupByOutputType[P]>
        }
      >
    >


  export type PendingChainActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    txHash?: boolean
    from?: boolean
    chainId?: boolean
    payload?: boolean
    relatedId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pendingChainAction"]>

  export type PendingChainActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    txHash?: boolean
    from?: boolean
    chainId?: boolean
    payload?: boolean
    relatedId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pendingChainAction"]>

  export type PendingChainActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    txHash?: boolean
    from?: boolean
    chainId?: boolean
    payload?: boolean
    relatedId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["pendingChainAction"]>

  export type PendingChainActionSelectScalar = {
    id?: boolean
    type?: boolean
    txHash?: boolean
    from?: boolean
    chainId?: boolean
    payload?: boolean
    relatedId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PendingChainActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "txHash" | "from" | "chainId" | "payload" | "relatedId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["pendingChainAction"]>

  export type $PendingChainActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingChainAction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.PendingChainActionType
      txHash: string
      from: string
      chainId: number
      payload: Prisma.JsonValue
      relatedId: string | null
      status: $Enums.PendingStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pendingChainAction"]>
    composites: {}
  }

  type PendingChainActionGetPayload<S extends boolean | null | undefined | PendingChainActionDefaultArgs> = $Result.GetResult<Prisma.$PendingChainActionPayload, S>

  type PendingChainActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PendingChainActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendingChainActionCountAggregateInputType | true
    }

  export interface PendingChainActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingChainAction'], meta: { name: 'PendingChainAction' } }
    /**
     * Find zero or one PendingChainAction that matches the filter.
     * @param {PendingChainActionFindUniqueArgs} args - Arguments to find a PendingChainAction
     * @example
     * // Get one PendingChainAction
     * const pendingChainAction = await prisma.pendingChainAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendingChainActionFindUniqueArgs>(args: SelectSubset<T, PendingChainActionFindUniqueArgs<ExtArgs>>): Prisma__PendingChainActionClient<$Result.GetResult<Prisma.$PendingChainActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PendingChainAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PendingChainActionFindUniqueOrThrowArgs} args - Arguments to find a PendingChainAction
     * @example
     * // Get one PendingChainAction
     * const pendingChainAction = await prisma.pendingChainAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendingChainActionFindUniqueOrThrowArgs>(args: SelectSubset<T, PendingChainActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendingChainActionClient<$Result.GetResult<Prisma.$PendingChainActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingChainAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingChainActionFindFirstArgs} args - Arguments to find a PendingChainAction
     * @example
     * // Get one PendingChainAction
     * const pendingChainAction = await prisma.pendingChainAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendingChainActionFindFirstArgs>(args?: SelectSubset<T, PendingChainActionFindFirstArgs<ExtArgs>>): Prisma__PendingChainActionClient<$Result.GetResult<Prisma.$PendingChainActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingChainAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingChainActionFindFirstOrThrowArgs} args - Arguments to find a PendingChainAction
     * @example
     * // Get one PendingChainAction
     * const pendingChainAction = await prisma.pendingChainAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendingChainActionFindFirstOrThrowArgs>(args?: SelectSubset<T, PendingChainActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendingChainActionClient<$Result.GetResult<Prisma.$PendingChainActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PendingChainActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingChainActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingChainActions
     * const pendingChainActions = await prisma.pendingChainAction.findMany()
     * 
     * // Get first 10 PendingChainActions
     * const pendingChainActions = await prisma.pendingChainAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingChainActionWithIdOnly = await prisma.pendingChainAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PendingChainActionFindManyArgs>(args?: SelectSubset<T, PendingChainActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingChainActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PendingChainAction.
     * @param {PendingChainActionCreateArgs} args - Arguments to create a PendingChainAction.
     * @example
     * // Create one PendingChainAction
     * const PendingChainAction = await prisma.pendingChainAction.create({
     *   data: {
     *     // ... data to create a PendingChainAction
     *   }
     * })
     * 
     */
    create<T extends PendingChainActionCreateArgs>(args: SelectSubset<T, PendingChainActionCreateArgs<ExtArgs>>): Prisma__PendingChainActionClient<$Result.GetResult<Prisma.$PendingChainActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PendingChainActions.
     * @param {PendingChainActionCreateManyArgs} args - Arguments to create many PendingChainActions.
     * @example
     * // Create many PendingChainActions
     * const pendingChainAction = await prisma.pendingChainAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendingChainActionCreateManyArgs>(args?: SelectSubset<T, PendingChainActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendingChainActions and returns the data saved in the database.
     * @param {PendingChainActionCreateManyAndReturnArgs} args - Arguments to create many PendingChainActions.
     * @example
     * // Create many PendingChainActions
     * const pendingChainAction = await prisma.pendingChainAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendingChainActions and only return the `id`
     * const pendingChainActionWithIdOnly = await prisma.pendingChainAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendingChainActionCreateManyAndReturnArgs>(args?: SelectSubset<T, PendingChainActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingChainActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PendingChainAction.
     * @param {PendingChainActionDeleteArgs} args - Arguments to delete one PendingChainAction.
     * @example
     * // Delete one PendingChainAction
     * const PendingChainAction = await prisma.pendingChainAction.delete({
     *   where: {
     *     // ... filter to delete one PendingChainAction
     *   }
     * })
     * 
     */
    delete<T extends PendingChainActionDeleteArgs>(args: SelectSubset<T, PendingChainActionDeleteArgs<ExtArgs>>): Prisma__PendingChainActionClient<$Result.GetResult<Prisma.$PendingChainActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PendingChainAction.
     * @param {PendingChainActionUpdateArgs} args - Arguments to update one PendingChainAction.
     * @example
     * // Update one PendingChainAction
     * const pendingChainAction = await prisma.pendingChainAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendingChainActionUpdateArgs>(args: SelectSubset<T, PendingChainActionUpdateArgs<ExtArgs>>): Prisma__PendingChainActionClient<$Result.GetResult<Prisma.$PendingChainActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PendingChainActions.
     * @param {PendingChainActionDeleteManyArgs} args - Arguments to filter PendingChainActions to delete.
     * @example
     * // Delete a few PendingChainActions
     * const { count } = await prisma.pendingChainAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendingChainActionDeleteManyArgs>(args?: SelectSubset<T, PendingChainActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingChainActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingChainActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingChainActions
     * const pendingChainAction = await prisma.pendingChainAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendingChainActionUpdateManyArgs>(args: SelectSubset<T, PendingChainActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingChainActions and returns the data updated in the database.
     * @param {PendingChainActionUpdateManyAndReturnArgs} args - Arguments to update many PendingChainActions.
     * @example
     * // Update many PendingChainActions
     * const pendingChainAction = await prisma.pendingChainAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PendingChainActions and only return the `id`
     * const pendingChainActionWithIdOnly = await prisma.pendingChainAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PendingChainActionUpdateManyAndReturnArgs>(args: SelectSubset<T, PendingChainActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingChainActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PendingChainAction.
     * @param {PendingChainActionUpsertArgs} args - Arguments to update or create a PendingChainAction.
     * @example
     * // Update or create a PendingChainAction
     * const pendingChainAction = await prisma.pendingChainAction.upsert({
     *   create: {
     *     // ... data to create a PendingChainAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingChainAction we want to update
     *   }
     * })
     */
    upsert<T extends PendingChainActionUpsertArgs>(args: SelectSubset<T, PendingChainActionUpsertArgs<ExtArgs>>): Prisma__PendingChainActionClient<$Result.GetResult<Prisma.$PendingChainActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PendingChainActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingChainActionCountArgs} args - Arguments to filter PendingChainActions to count.
     * @example
     * // Count the number of PendingChainActions
     * const count = await prisma.pendingChainAction.count({
     *   where: {
     *     // ... the filter for the PendingChainActions we want to count
     *   }
     * })
    **/
    count<T extends PendingChainActionCountArgs>(
      args?: Subset<T, PendingChainActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingChainActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingChainAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingChainActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingChainActionAggregateArgs>(args: Subset<T, PendingChainActionAggregateArgs>): Prisma.PrismaPromise<GetPendingChainActionAggregateType<T>>

    /**
     * Group by PendingChainAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingChainActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingChainActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingChainActionGroupByArgs['orderBy'] }
        : { orderBy?: PendingChainActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingChainActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingChainActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingChainAction model
   */
  readonly fields: PendingChainActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingChainAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingChainActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendingChainAction model
   */
  interface PendingChainActionFieldRefs {
    readonly id: FieldRef<"PendingChainAction", 'String'>
    readonly type: FieldRef<"PendingChainAction", 'PendingChainActionType'>
    readonly txHash: FieldRef<"PendingChainAction", 'String'>
    readonly from: FieldRef<"PendingChainAction", 'String'>
    readonly chainId: FieldRef<"PendingChainAction", 'Int'>
    readonly payload: FieldRef<"PendingChainAction", 'Json'>
    readonly relatedId: FieldRef<"PendingChainAction", 'String'>
    readonly status: FieldRef<"PendingChainAction", 'PendingStatus'>
    readonly createdAt: FieldRef<"PendingChainAction", 'DateTime'>
    readonly updatedAt: FieldRef<"PendingChainAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PendingChainAction findUnique
   */
  export type PendingChainActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingChainAction
     */
    select?: PendingChainActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingChainAction
     */
    omit?: PendingChainActionOmit<ExtArgs> | null
    /**
     * Filter, which PendingChainAction to fetch.
     */
    where: PendingChainActionWhereUniqueInput
  }

  /**
   * PendingChainAction findUniqueOrThrow
   */
  export type PendingChainActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingChainAction
     */
    select?: PendingChainActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingChainAction
     */
    omit?: PendingChainActionOmit<ExtArgs> | null
    /**
     * Filter, which PendingChainAction to fetch.
     */
    where: PendingChainActionWhereUniqueInput
  }

  /**
   * PendingChainAction findFirst
   */
  export type PendingChainActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingChainAction
     */
    select?: PendingChainActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingChainAction
     */
    omit?: PendingChainActionOmit<ExtArgs> | null
    /**
     * Filter, which PendingChainAction to fetch.
     */
    where?: PendingChainActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingChainActions to fetch.
     */
    orderBy?: PendingChainActionOrderByWithRelationInput | PendingChainActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingChainActions.
     */
    cursor?: PendingChainActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingChainActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingChainActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingChainActions.
     */
    distinct?: PendingChainActionScalarFieldEnum | PendingChainActionScalarFieldEnum[]
  }

  /**
   * PendingChainAction findFirstOrThrow
   */
  export type PendingChainActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingChainAction
     */
    select?: PendingChainActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingChainAction
     */
    omit?: PendingChainActionOmit<ExtArgs> | null
    /**
     * Filter, which PendingChainAction to fetch.
     */
    where?: PendingChainActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingChainActions to fetch.
     */
    orderBy?: PendingChainActionOrderByWithRelationInput | PendingChainActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingChainActions.
     */
    cursor?: PendingChainActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingChainActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingChainActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingChainActions.
     */
    distinct?: PendingChainActionScalarFieldEnum | PendingChainActionScalarFieldEnum[]
  }

  /**
   * PendingChainAction findMany
   */
  export type PendingChainActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingChainAction
     */
    select?: PendingChainActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingChainAction
     */
    omit?: PendingChainActionOmit<ExtArgs> | null
    /**
     * Filter, which PendingChainActions to fetch.
     */
    where?: PendingChainActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingChainActions to fetch.
     */
    orderBy?: PendingChainActionOrderByWithRelationInput | PendingChainActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingChainActions.
     */
    cursor?: PendingChainActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingChainActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingChainActions.
     */
    skip?: number
    distinct?: PendingChainActionScalarFieldEnum | PendingChainActionScalarFieldEnum[]
  }

  /**
   * PendingChainAction create
   */
  export type PendingChainActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingChainAction
     */
    select?: PendingChainActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingChainAction
     */
    omit?: PendingChainActionOmit<ExtArgs> | null
    /**
     * The data needed to create a PendingChainAction.
     */
    data: XOR<PendingChainActionCreateInput, PendingChainActionUncheckedCreateInput>
  }

  /**
   * PendingChainAction createMany
   */
  export type PendingChainActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingChainActions.
     */
    data: PendingChainActionCreateManyInput | PendingChainActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingChainAction createManyAndReturn
   */
  export type PendingChainActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingChainAction
     */
    select?: PendingChainActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingChainAction
     */
    omit?: PendingChainActionOmit<ExtArgs> | null
    /**
     * The data used to create many PendingChainActions.
     */
    data: PendingChainActionCreateManyInput | PendingChainActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingChainAction update
   */
  export type PendingChainActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingChainAction
     */
    select?: PendingChainActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingChainAction
     */
    omit?: PendingChainActionOmit<ExtArgs> | null
    /**
     * The data needed to update a PendingChainAction.
     */
    data: XOR<PendingChainActionUpdateInput, PendingChainActionUncheckedUpdateInput>
    /**
     * Choose, which PendingChainAction to update.
     */
    where: PendingChainActionWhereUniqueInput
  }

  /**
   * PendingChainAction updateMany
   */
  export type PendingChainActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingChainActions.
     */
    data: XOR<PendingChainActionUpdateManyMutationInput, PendingChainActionUncheckedUpdateManyInput>
    /**
     * Filter which PendingChainActions to update
     */
    where?: PendingChainActionWhereInput
    /**
     * Limit how many PendingChainActions to update.
     */
    limit?: number
  }

  /**
   * PendingChainAction updateManyAndReturn
   */
  export type PendingChainActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingChainAction
     */
    select?: PendingChainActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingChainAction
     */
    omit?: PendingChainActionOmit<ExtArgs> | null
    /**
     * The data used to update PendingChainActions.
     */
    data: XOR<PendingChainActionUpdateManyMutationInput, PendingChainActionUncheckedUpdateManyInput>
    /**
     * Filter which PendingChainActions to update
     */
    where?: PendingChainActionWhereInput
    /**
     * Limit how many PendingChainActions to update.
     */
    limit?: number
  }

  /**
   * PendingChainAction upsert
   */
  export type PendingChainActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingChainAction
     */
    select?: PendingChainActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingChainAction
     */
    omit?: PendingChainActionOmit<ExtArgs> | null
    /**
     * The filter to search for the PendingChainAction to update in case it exists.
     */
    where: PendingChainActionWhereUniqueInput
    /**
     * In case the PendingChainAction found by the `where` argument doesn't exist, create a new PendingChainAction with this data.
     */
    create: XOR<PendingChainActionCreateInput, PendingChainActionUncheckedCreateInput>
    /**
     * In case the PendingChainAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingChainActionUpdateInput, PendingChainActionUncheckedUpdateInput>
  }

  /**
   * PendingChainAction delete
   */
  export type PendingChainActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingChainAction
     */
    select?: PendingChainActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingChainAction
     */
    omit?: PendingChainActionOmit<ExtArgs> | null
    /**
     * Filter which PendingChainAction to delete.
     */
    where: PendingChainActionWhereUniqueInput
  }

  /**
   * PendingChainAction deleteMany
   */
  export type PendingChainActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingChainActions to delete
     */
    where?: PendingChainActionWhereInput
    /**
     * Limit how many PendingChainActions to delete.
     */
    limit?: number
  }

  /**
   * PendingChainAction without action
   */
  export type PendingChainActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingChainAction
     */
    select?: PendingChainActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingChainAction
     */
    omit?: PendingChainActionOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ChainStateScalarFieldEnum: {
    id: 'id',
    userAddress: 'userAddress',
    contract: 'contract',
    lastBlockNumber: 'lastBlockNumber'
  };

  export type ChainStateScalarFieldEnum = (typeof ChainStateScalarFieldEnum)[keyof typeof ChainStateScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    walletAddress: 'walletAddress',
    username: 'username',
    bio: 'bio',
    profileBanner: 'profileBanner',
    profileAvatar: 'profileAvatar',
    x: 'x',
    instagram: 'instagram',
    website: 'website',
    telegram: 'telegram',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CollectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    symbol: 'symbol',
    contract: 'contract',
    description: 'description',
    logoUrl: 'logoUrl',
    coverUrl: 'coverUrl',
    standard: 'standard',
    supply: 'supply',
    baseUri: 'baseUri',
    gatewayPref: 'gatewayPref',
    indexStatus: 'indexStatus',
    x: 'x',
    instagram: 'instagram',
    website: 'website',
    discord: 'discord',
    telegram: 'telegram',
    floorPrice: 'floorPrice',
    volume: 'volume',
    itemsCount: 'itemsCount',
    ownersCount: 'ownersCount',
    change24h: 'change24h',
    creatorId: 'creatorId',
    ownerAddress: 'ownerAddress',
    isOrphan: 'isOrphan',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CollectionScalarFieldEnum = (typeof CollectionScalarFieldEnum)[keyof typeof CollectionScalarFieldEnum]


  export const NFTScalarFieldEnum: {
    id: 'id',
    tokenId: 'tokenId',
    name: 'name',
    imageUrl: 'imageUrl',
    description: 'description',
    traits: 'traits',
    attributes: 'attributes',
    tokenUri: 'tokenUri',
    contract: 'contract',
    standard: 'standard',
    rawMetadata: 'rawMetadata',
    royaltyBps: 'royaltyBps',
    royaltyRecipient: 'royaltyRecipient',
    ownerId: 'ownerId',
    collectionId: 'collectionId',
    single721Id: 'single721Id',
    single1155Id: 'single1155Id',
    status: 'status',
    retryCount: 'retryCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    rarityScore: 'rarityScore'
  };

  export type NFTScalarFieldEnum = (typeof NFTScalarFieldEnum)[keyof typeof NFTScalarFieldEnum]


  export const TraitStatScalarFieldEnum: {
    id: 'id',
    contract: 'contract',
    trait_type: 'trait_type',
    value: 'value',
    count: 'count',
    frequency: 'frequency',
    createdAt: 'createdAt'
  };

  export type TraitStatScalarFieldEnum = (typeof TraitStatScalarFieldEnum)[keyof typeof TraitStatScalarFieldEnum]


  export const NFTActivityScalarFieldEnum: {
    id: 'id',
    nftId: 'nftId',
    contract: 'contract',
    tokenId: 'tokenId',
    type: 'type',
    fromAddress: 'fromAddress',
    toAddress: 'toAddress',
    priceEtnWei: 'priceEtnWei',
    txHash: 'txHash',
    logIndex: 'logIndex',
    blockNumber: 'blockNumber',
    timestamp: 'timestamp',
    marketplace: 'marketplace',
    rawData: 'rawData',
    createdAt: 'createdAt'
  };

  export type NFTActivityScalarFieldEnum = (typeof NFTActivityScalarFieldEnum)[keyof typeof NFTActivityScalarFieldEnum]


  export const Single721ScalarFieldEnum: {
    id: 'id',
    name: 'name',
    symbol: 'symbol',
    contract: 'contract',
    tokenUri: 'tokenUri',
    royaltyRecipient: 'royaltyRecipient',
    royaltyBps: 'royaltyBps',
    creatorId: 'creatorId',
    ownerAddress: 'ownerAddress',
    description: 'description',
    imageUrl: 'imageUrl',
    indexStatus: 'indexStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Single721ScalarFieldEnum = (typeof Single721ScalarFieldEnum)[keyof typeof Single721ScalarFieldEnum]


  export const Single1155ScalarFieldEnum: {
    id: 'id',
    name: 'name',
    symbol: 'symbol',
    contract: 'contract',
    baseUri: 'baseUri',
    maxSupply: 'maxSupply',
    mintPriceEtnWei: 'mintPriceEtnWei',
    maxPerWallet: 'maxPerWallet',
    royaltyRecipient: 'royaltyRecipient',
    royaltyBps: 'royaltyBps',
    creatorId: 'creatorId',
    ownerAddress: 'ownerAddress',
    description: 'description',
    imageUrl: 'imageUrl',
    indexStatus: 'indexStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Single1155ScalarFieldEnum = (typeof Single1155ScalarFieldEnum)[keyof typeof Single1155ScalarFieldEnum]


  export const Erc1155BalanceScalarFieldEnum: {
    id: 'id',
    single1155Id: 'single1155Id',
    ownerAddress: 'ownerAddress',
    balance: 'balance',
    updatedAt: 'updatedAt'
  };

  export type Erc1155BalanceScalarFieldEnum = (typeof Erc1155BalanceScalarFieldEnum)[keyof typeof Erc1155BalanceScalarFieldEnum]


  export const Erc1155HoldingScalarFieldEnum: {
    id: 'id',
    contract: 'contract',
    tokenId: 'tokenId',
    ownerAddress: 'ownerAddress',
    balance: 'balance',
    updatedAt: 'updatedAt'
  };

  export type Erc1155HoldingScalarFieldEnum = (typeof Erc1155HoldingScalarFieldEnum)[keyof typeof Erc1155HoldingScalarFieldEnum]


  export const MarketplaceListingScalarFieldEnum: {
    id: 'id',
    nftId: 'nftId',
    sellerAddress: 'sellerAddress',
    quantity: 'quantity',
    priceEtnWei: 'priceEtnWei',
    currencyId: 'currencyId',
    priceTokenAmount: 'priceTokenAmount',
    status: 'status',
    startTime: 'startTime',
    endTime: 'endTime',
    txHashCreated: 'txHashCreated',
    txHashFilled: 'txHashFilled',
    txHashCancelled: 'txHashCancelled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketplaceListingScalarFieldEnum = (typeof MarketplaceListingScalarFieldEnum)[keyof typeof MarketplaceListingScalarFieldEnum]


  export const AuctionScalarFieldEnum: {
    id: 'id',
    nftId: 'nftId',
    sellerAddress: 'sellerAddress',
    quantity: 'quantity',
    startPriceEtnWei: 'startPriceEtnWei',
    highestBidEtnWei: 'highestBidEtnWei',
    minIncrementEtnWei: 'minIncrementEtnWei',
    currencyId: 'currencyId',
    startPriceTokenAmount: 'startPriceTokenAmount',
    highestBidTokenAmount: 'highestBidTokenAmount',
    minIncrementTokenAmount: 'minIncrementTokenAmount',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    txHashCreated: 'txHashCreated',
    txHashFinalized: 'txHashFinalized',
    txHashCancelled: 'txHashCancelled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    highestBidder: 'highestBidder'
  };

  export type AuctionScalarFieldEnum = (typeof AuctionScalarFieldEnum)[keyof typeof AuctionScalarFieldEnum]


  export const AuctionBidScalarFieldEnum: {
    id: 'id',
    auctionId: 'auctionId',
    bidderAddress: 'bidderAddress',
    amountWei: 'amountWei',
    currencyId: 'currencyId',
    txHash: 'txHash',
    logIndex: 'logIndex',
    blockNumber: 'blockNumber',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type AuctionBidScalarFieldEnum = (typeof AuctionBidScalarFieldEnum)[keyof typeof AuctionBidScalarFieldEnum]


  export const DeployedContractScalarFieldEnum: {
    id: 'id',
    contractType: 'contractType',
    cloneAddress: 'cloneAddress',
    implementationAddr: 'implementationAddr',
    factoryAddress: 'factoryAddress',
    deployerAddress: 'deployerAddress',
    txHash: 'txHash',
    blockNumber: 'blockNumber',
    metadataOption: 'metadataOption',
    feeRecipient: 'feeRecipient',
    feeAmountEtnWei: 'feeAmountEtnWei',
    royaltyRecipient: 'royaltyRecipient',
    royaltyBps: 'royaltyBps',
    baseURI: 'baseURI',
    maxSupply: 'maxSupply',
    rawInit: 'rawInit',
    createdAt: 'createdAt',
    collectionId: 'collectionId',
    single721Id: 'single721Id',
    single1155Id: 'single1155Id'
  };

  export type DeployedContractScalarFieldEnum = (typeof DeployedContractScalarFieldEnum)[keyof typeof DeployedContractScalarFieldEnum]


  export const FeeConfigScalarFieldEnum: {
    id: 'id',
    contractType: 'contractType',
    metadataOption: 'metadataOption',
    feeRecipient: 'feeRecipient',
    feeAmountEtnWei: 'feeAmountEtnWei',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    updatedByUserId: 'updatedByUserId',
    targetUsdCents: 'targetUsdCents',
    pricingSource: 'pricingSource',
    pricingPair: 'pricingPair',
    lastPriceUsd: 'lastPriceUsd',
    lastPriceAt: 'lastPriceAt'
  };

  export type FeeConfigScalarFieldEnum = (typeof FeeConfigScalarFieldEnum)[keyof typeof FeeConfigScalarFieldEnum]


  export const FeeConfigLogScalarFieldEnum: {
    id: 'id',
    feeConfigId: 'feeConfigId',
    previousRecipient: 'previousRecipient',
    newRecipient: 'newRecipient',
    previousAmountEtnWei: 'previousAmountEtnWei',
    newAmountEtnWei: 'newAmountEtnWei',
    changedByUserId: 'changedByUserId',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type FeeConfigLogScalarFieldEnum = (typeof FeeConfigLogScalarFieldEnum)[keyof typeof FeeConfigLogScalarFieldEnum]


  export const PublicSaleScalarFieldEnum: {
    id: 'id',
    collectionId: 'collectionId',
    startTime: 'startTime',
    priceEtnWei: 'priceEtnWei',
    maxPerWallet: 'maxPerWallet',
    maxPerTx: 'maxPerTx',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PublicSaleScalarFieldEnum = (typeof PublicSaleScalarFieldEnum)[keyof typeof PublicSaleScalarFieldEnum]


  export const PresaleScalarFieldEnum: {
    id: 'id',
    collectionId: 'collectionId',
    startTime: 'startTime',
    endTime: 'endTime',
    priceEtnWei: 'priceEtnWei',
    maxSupply: 'maxSupply',
    merkleRoot: 'merkleRoot',
    whitelistCount: 'whitelistCount',
    allowlistCommit: 'allowlistCommit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PresaleScalarFieldEnum = (typeof PresaleScalarFieldEnum)[keyof typeof PresaleScalarFieldEnum]


  export const PresaleWhitelistAddressScalarFieldEnum: {
    id: 'id',
    presaleId: 'presaleId',
    address: 'address',
    maxAllocation: 'maxAllocation'
  };

  export type PresaleWhitelistAddressScalarFieldEnum = (typeof PresaleWhitelistAddressScalarFieldEnum)[keyof typeof PresaleWhitelistAddressScalarFieldEnum]


  export const PresaleDraftScalarFieldEnum: {
    id: 'id',
    creatorUserId: 'creatorUserId',
    addresses: 'addresses',
    count: 'count',
    merkleRoot: 'merkleRoot',
    sha256Commit: 'sha256Commit',
    status: 'status',
    consumedAt: 'consumedAt',
    consumedByPresaleId: 'consumedByPresaleId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type PresaleDraftScalarFieldEnum = (typeof PresaleDraftScalarFieldEnum)[keyof typeof PresaleDraftScalarFieldEnum]


  export const AssetUploadScalarFieldEnum: {
    id: 'id',
    uploaderUserId: 'uploaderUserId',
    collectionId: 'collectionId',
    single721Id: 'single721Id',
    single1155Id: 'single1155Id',
    provider: 'provider',
    cid: 'cid',
    url: 'url',
    bytes: 'bytes',
    sha256: 'sha256',
    contentType: 'contentType',
    originalName: 'originalName',
    createdAt: 'createdAt'
  };

  export type AssetUploadScalarFieldEnum = (typeof AssetUploadScalarFieldEnum)[keyof typeof AssetUploadScalarFieldEnum]


  export const CollectionSubmissionScalarFieldEnum: {
    id: 'id',
    submittedByUserId: 'submittedByUserId',
    contract: 'contract',
    ownerAddress: 'ownerAddress',
    name: 'name',
    symbol: 'symbol',
    logoUrl: 'logoUrl',
    coverUrl: 'coverUrl',
    baseUri: 'baseUri',
    supply: 'supply',
    description: 'description',
    website: 'website',
    x: 'x',
    instagram: 'instagram',
    telegram: 'telegram',
    feeTxHash: 'feeTxHash',
    feePaidWei: 'feePaidWei',
    feeVerifiedAt: 'feeVerifiedAt',
    ownershipVerified: 'ownershipVerified',
    status: 'status',
    statusReason: 'statusReason',
    reviewedByUserId: 'reviewedByUserId',
    reviewedAt: 'reviewedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CollectionSubmissionScalarFieldEnum = (typeof CollectionSubmissionScalarFieldEnum)[keyof typeof CollectionSubmissionScalarFieldEnum]


  export const NFTRarityScalarFieldEnum: {
    contract: 'contract',
    tokenId: 'tokenId',
    score: 'score',
    rank: 'rank',
    updatedAt: 'updatedAt'
  };

  export type NFTRarityScalarFieldEnum = (typeof NFTRarityScalarFieldEnum)[keyof typeof NFTRarityScalarFieldEnum]


  export const HolderRewardScalarFieldEnum: {
    user_id: 'user_id',
    wallet_address: 'wallet_address',
    last_acc_per_token: 'last_acc_per_token',
    claimed_etn: 'claimed_etn',
    updated_at: 'updated_at'
  };

  export type HolderRewardScalarFieldEnum = (typeof HolderRewardScalarFieldEnum)[keyof typeof HolderRewardScalarFieldEnum]


  export const RewardAccumulatorScalarFieldEnum: {
    id: 'id',
    acc_per_token: 'acc_per_token',
    updated_at: 'updated_at'
  };

  export type RewardAccumulatorScalarFieldEnum = (typeof RewardAccumulatorScalarFieldEnum)[keyof typeof RewardAccumulatorScalarFieldEnum]


  export const FeaturedCycleScalarFieldEnum: {
    id: 'id',
    cycleId: 'cycleId',
    startAt: 'startAt',
    endAt: 'endAt',
    status: 'status',
    minBidWei: 'minBidWei',
    winnerBidId: 'winnerBidId',
    winnerCollectionContract: 'winnerCollectionContract',
    winnerAmountWei: 'winnerAmountWei',
    finalizedAt: 'finalizedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeaturedCycleScalarFieldEnum = (typeof FeaturedCycleScalarFieldEnum)[keyof typeof FeaturedCycleScalarFieldEnum]


  export const FeaturedBidScalarFieldEnum: {
    id: 'id',
    cycleId: 'cycleId',
    bidderAddress: 'bidderAddress',
    bidderUserId: 'bidderUserId',
    collectionContract: 'collectionContract',
    totalBidWei: 'totalBidWei',
    txCount: 'txCount',
    lastTxHash: 'lastTxHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeaturedBidScalarFieldEnum = (typeof FeaturedBidScalarFieldEnum)[keyof typeof FeaturedBidScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    id: 'id',
    symbol: 'symbol',
    decimals: 'decimals',
    kind: 'kind',
    tokenAddress: 'tokenAddress',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const MarketplaceSaleScalarFieldEnum: {
    id: 'id',
    nftId: 'nftId',
    buyerAddress: 'buyerAddress',
    sellerAddress: 'sellerAddress',
    quantity: 'quantity',
    priceEtnWei: 'priceEtnWei',
    royaltyPaidWei: 'royaltyPaidWei',
    marketplaceFeePaidWei: 'marketplaceFeePaidWei',
    currencyId: 'currencyId',
    priceTokenAmount: 'priceTokenAmount',
    royaltyPaidTokenAmount: 'royaltyPaidTokenAmount',
    feePaidTokenAmount: 'feePaidTokenAmount',
    royaltyRecipient: 'royaltyRecipient',
    marketplaceFeeRecipient: 'marketplaceFeeRecipient',
    txHash: 'txHash',
    logIndex: 'logIndex',
    blockNumber: 'blockNumber',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type MarketplaceSaleScalarFieldEnum = (typeof MarketplaceSaleScalarFieldEnum)[keyof typeof MarketplaceSaleScalarFieldEnum]


  export const RewardAccumulatorMultiScalarFieldEnum: {
    id: 'id',
    currencyId: 'currencyId',
    accPerToken: 'accPerToken',
    updatedAt: 'updatedAt'
  };

  export type RewardAccumulatorMultiScalarFieldEnum = (typeof RewardAccumulatorMultiScalarFieldEnum)[keyof typeof RewardAccumulatorMultiScalarFieldEnum]


  export const HolderRewardMultiScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    walletAddress: 'walletAddress',
    currencyId: 'currencyId',
    lastAccPerToken: 'lastAccPerToken',
    claimedAmount: 'claimedAmount',
    updatedAt: 'updatedAt'
  };

  export type HolderRewardMultiScalarFieldEnum = (typeof HolderRewardMultiScalarFieldEnum)[keyof typeof HolderRewardMultiScalarFieldEnum]


  export const RewardDistributionLogScalarFieldEnum: {
    id: 'id',
    currencyId: 'currencyId',
    amount: 'amount',
    txHash: 'txHash',
    blockNumber: 'blockNumber',
    timestamp: 'timestamp',
    note: 'note'
  };

  export type RewardDistributionLogScalarFieldEnum = (typeof RewardDistributionLogScalarFieldEnum)[keyof typeof RewardDistributionLogScalarFieldEnum]


  export const RewardClaimLogScalarFieldEnum: {
    id: 'id',
    walletAddress: 'walletAddress',
    userId: 'userId',
    currencyId: 'currencyId',
    amount: 'amount',
    txHash: 'txHash',
    timestamp: 'timestamp'
  };

  export type RewardClaimLogScalarFieldEnum = (typeof RewardClaimLogScalarFieldEnum)[keyof typeof RewardClaimLogScalarFieldEnum]


  export const StolenItemScalarFieldEnum: {
    id: 'id',
    contract: 'contract',
    tokenId: 'tokenId',
    status: 'status',
    source: 'source',
    reporterAddress: 'reporterAddress',
    reporterUserId: 'reporterUserId',
    evidenceUrl: 'evidenceUrl',
    notes: 'notes',
    disputed: 'disputed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StolenItemScalarFieldEnum = (typeof StolenItemScalarFieldEnum)[keyof typeof StolenItemScalarFieldEnum]


  export const StolenEventScalarFieldEnum: {
    id: 'id',
    contract: 'contract',
    tokenId: 'tokenId',
    action: 'action',
    actorAddress: 'actorAddress',
    txHash: 'txHash',
    logIndex: 'logIndex',
    blockNumber: 'blockNumber',
    timestamp: 'timestamp',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type StolenEventScalarFieldEnum = (typeof StolenEventScalarFieldEnum)[keyof typeof StolenEventScalarFieldEnum]


  export const MultisigSafeScalarFieldEnum: {
    id: 'id',
    contract: 'contract',
    name: 'name',
    threshold: 'threshold',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MultisigSafeScalarFieldEnum = (typeof MultisigSafeScalarFieldEnum)[keyof typeof MultisigSafeScalarFieldEnum]


  export const MultisigOwnerScalarFieldEnum: {
    id: 'id',
    safeId: 'safeId',
    ownerAddress: 'ownerAddress',
    addedAt: 'addedAt',
    removedAt: 'removedAt'
  };

  export type MultisigOwnerScalarFieldEnum = (typeof MultisigOwnerScalarFieldEnum)[keyof typeof MultisigOwnerScalarFieldEnum]


  export const MultisigTxScalarFieldEnum: {
    id: 'id',
    safeId: 'safeId',
    nonce: 'nonce',
    to: 'to',
    valueWei: 'valueWei',
    dataHex: 'dataHex',
    operation: 'operation',
    submittedBy: 'submittedBy',
    status: 'status',
    executedTxHash: 'executedTxHash',
    createdAt: 'createdAt',
    executedAt: 'executedAt'
  };

  export type MultisigTxScalarFieldEnum = (typeof MultisigTxScalarFieldEnum)[keyof typeof MultisigTxScalarFieldEnum]


  export const MultisigApprovalScalarFieldEnum: {
    id: 'id',
    txId: 'txId',
    ownerAddress: 'ownerAddress',
    signature: 'signature',
    createdAt: 'createdAt'
  };

  export type MultisigApprovalScalarFieldEnum = (typeof MultisigApprovalScalarFieldEnum)[keyof typeof MultisigApprovalScalarFieldEnum]


  export const PendingChainActionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    txHash: 'txHash',
    from: 'from',
    chainId: 'chainId',
    payload: 'payload',
    relatedId: 'relatedId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PendingChainActionScalarFieldEnum = (typeof PendingChainActionScalarFieldEnum)[keyof typeof PendingChainActionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'GatewayPref'
   */
  export type EnumGatewayPrefFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GatewayPref'>
    


  /**
   * Reference to a field of type 'GatewayPref[]'
   */
  export type ListEnumGatewayPrefFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GatewayPref[]'>
    


  /**
   * Reference to a field of type 'IndexStatus'
   */
  export type EnumIndexStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IndexStatus'>
    


  /**
   * Reference to a field of type 'IndexStatus[]'
   */
  export type ListEnumIndexStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IndexStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'NftStatus'
   */
  export type EnumNftStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NftStatus'>
    


  /**
   * Reference to a field of type 'NftStatus[]'
   */
  export type ListEnumNftStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NftStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ListingStatus'
   */
  export type EnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus'>
    


  /**
   * Reference to a field of type 'ListingStatus[]'
   */
  export type ListEnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus[]'>
    


  /**
   * Reference to a field of type 'AuctionStatus'
   */
  export type EnumAuctionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuctionStatus'>
    


  /**
   * Reference to a field of type 'AuctionStatus[]'
   */
  export type ListEnumAuctionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuctionStatus[]'>
    


  /**
   * Reference to a field of type 'ContractType'
   */
  export type EnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType'>
    


  /**
   * Reference to a field of type 'ContractType[]'
   */
  export type ListEnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType[]'>
    


  /**
   * Reference to a field of type 'MetadataOption'
   */
  export type EnumMetadataOptionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetadataOption'>
    


  /**
   * Reference to a field of type 'MetadataOption[]'
   */
  export type ListEnumMetadataOptionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MetadataOption[]'>
    


  /**
   * Reference to a field of type 'DraftStatus'
   */
  export type EnumDraftStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DraftStatus'>
    


  /**
   * Reference to a field of type 'DraftStatus[]'
   */
  export type ListEnumDraftStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DraftStatus[]'>
    


  /**
   * Reference to a field of type 'SubmissionStatus'
   */
  export type EnumSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmissionStatus'>
    


  /**
   * Reference to a field of type 'SubmissionStatus[]'
   */
  export type ListEnumSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmissionStatus[]'>
    


  /**
   * Reference to a field of type 'FeaturedCycleStatus'
   */
  export type EnumFeaturedCycleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeaturedCycleStatus'>
    


  /**
   * Reference to a field of type 'FeaturedCycleStatus[]'
   */
  export type ListEnumFeaturedCycleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeaturedCycleStatus[]'>
    


  /**
   * Reference to a field of type 'CurrencyKind'
   */
  export type EnumCurrencyKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CurrencyKind'>
    


  /**
   * Reference to a field of type 'CurrencyKind[]'
   */
  export type ListEnumCurrencyKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CurrencyKind[]'>
    


  /**
   * Reference to a field of type 'StolenStatus'
   */
  export type EnumStolenStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StolenStatus'>
    


  /**
   * Reference to a field of type 'StolenStatus[]'
   */
  export type ListEnumStolenStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StolenStatus[]'>
    


  /**
   * Reference to a field of type 'StolenSource'
   */
  export type EnumStolenSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StolenSource'>
    


  /**
   * Reference to a field of type 'StolenSource[]'
   */
  export type ListEnumStolenSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StolenSource[]'>
    


  /**
   * Reference to a field of type 'MultisigTxStatus'
   */
  export type EnumMultisigTxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MultisigTxStatus'>
    


  /**
   * Reference to a field of type 'MultisigTxStatus[]'
   */
  export type ListEnumMultisigTxStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MultisigTxStatus[]'>
    


  /**
   * Reference to a field of type 'PendingChainActionType'
   */
  export type EnumPendingChainActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PendingChainActionType'>
    


  /**
   * Reference to a field of type 'PendingChainActionType[]'
   */
  export type ListEnumPendingChainActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PendingChainActionType[]'>
    


  /**
   * Reference to a field of type 'PendingStatus'
   */
  export type EnumPendingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PendingStatus'>
    


  /**
   * Reference to a field of type 'PendingStatus[]'
   */
  export type ListEnumPendingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PendingStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type ChainStateWhereInput = {
    AND?: ChainStateWhereInput | ChainStateWhereInput[]
    OR?: ChainStateWhereInput[]
    NOT?: ChainStateWhereInput | ChainStateWhereInput[]
    id?: StringFilter<"ChainState"> | string
    userAddress?: StringFilter<"ChainState"> | string
    contract?: StringFilter<"ChainState"> | string
    lastBlockNumber?: IntFilter<"ChainState"> | number
  }

  export type ChainStateOrderByWithRelationInput = {
    id?: SortOrder
    userAddress?: SortOrder
    contract?: SortOrder
    lastBlockNumber?: SortOrder
  }

  export type ChainStateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contract_userAddress?: ChainStateContract_userAddressCompoundUniqueInput
    AND?: ChainStateWhereInput | ChainStateWhereInput[]
    OR?: ChainStateWhereInput[]
    NOT?: ChainStateWhereInput | ChainStateWhereInput[]
    userAddress?: StringFilter<"ChainState"> | string
    contract?: StringFilter<"ChainState"> | string
    lastBlockNumber?: IntFilter<"ChainState"> | number
  }, "id" | "contract_userAddress">

  export type ChainStateOrderByWithAggregationInput = {
    id?: SortOrder
    userAddress?: SortOrder
    contract?: SortOrder
    lastBlockNumber?: SortOrder
    _count?: ChainStateCountOrderByAggregateInput
    _avg?: ChainStateAvgOrderByAggregateInput
    _max?: ChainStateMaxOrderByAggregateInput
    _min?: ChainStateMinOrderByAggregateInput
    _sum?: ChainStateSumOrderByAggregateInput
  }

  export type ChainStateScalarWhereWithAggregatesInput = {
    AND?: ChainStateScalarWhereWithAggregatesInput | ChainStateScalarWhereWithAggregatesInput[]
    OR?: ChainStateScalarWhereWithAggregatesInput[]
    NOT?: ChainStateScalarWhereWithAggregatesInput | ChainStateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChainState"> | string
    userAddress?: StringWithAggregatesFilter<"ChainState"> | string
    contract?: StringWithAggregatesFilter<"ChainState"> | string
    lastBlockNumber?: IntWithAggregatesFilter<"ChainState"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    walletAddress?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    bio?: StringNullableFilter<"User"> | string | null
    profileBanner?: StringNullableFilter<"User"> | string | null
    profileAvatar?: StringFilter<"User"> | string
    x?: StringNullableFilter<"User"> | string | null
    instagram?: StringNullableFilter<"User"> | string | null
    website?: StringNullableFilter<"User"> | string | null
    telegram?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    collections?: CollectionListRelationFilter
    submissions?: CollectionSubmissionListRelationFilter
    featuredBids?: FeaturedBidListRelationFilter
    holderRewardsMulti?: HolderRewardMultiListRelationFilter
    ownedNFTs?: NFTListRelationFilter
    rewardClaimLogs?: RewardClaimLogListRelationFilter
    stolenReports?: StolenItemListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    username?: SortOrder
    bio?: SortOrderInput | SortOrder
    profileBanner?: SortOrderInput | SortOrder
    profileAvatar?: SortOrder
    x?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collections?: CollectionOrderByRelationAggregateInput
    submissions?: CollectionSubmissionOrderByRelationAggregateInput
    featuredBids?: FeaturedBidOrderByRelationAggregateInput
    holderRewardsMulti?: HolderRewardMultiOrderByRelationAggregateInput
    ownedNFTs?: NFTOrderByRelationAggregateInput
    rewardClaimLogs?: RewardClaimLogOrderByRelationAggregateInput
    stolenReports?: StolenItemOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    walletAddress?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringFilter<"User"> | string
    bio?: StringNullableFilter<"User"> | string | null
    profileBanner?: StringNullableFilter<"User"> | string | null
    profileAvatar?: StringFilter<"User"> | string
    x?: StringNullableFilter<"User"> | string | null
    instagram?: StringNullableFilter<"User"> | string | null
    website?: StringNullableFilter<"User"> | string | null
    telegram?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    collections?: CollectionListRelationFilter
    submissions?: CollectionSubmissionListRelationFilter
    featuredBids?: FeaturedBidListRelationFilter
    holderRewardsMulti?: HolderRewardMultiListRelationFilter
    ownedNFTs?: NFTListRelationFilter
    rewardClaimLogs?: RewardClaimLogListRelationFilter
    stolenReports?: StolenItemListRelationFilter
  }, "id" | "walletAddress">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    username?: SortOrder
    bio?: SortOrderInput | SortOrder
    profileBanner?: SortOrderInput | SortOrder
    profileAvatar?: SortOrder
    x?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    walletAddress?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileBanner?: StringNullableWithAggregatesFilter<"User"> | string | null
    profileAvatar?: StringWithAggregatesFilter<"User"> | string
    x?: StringNullableWithAggregatesFilter<"User"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"User"> | string | null
    website?: StringNullableWithAggregatesFilter<"User"> | string | null
    telegram?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CollectionWhereInput = {
    AND?: CollectionWhereInput | CollectionWhereInput[]
    OR?: CollectionWhereInput[]
    NOT?: CollectionWhereInput | CollectionWhereInput[]
    id?: StringFilter<"Collection"> | string
    name?: StringFilter<"Collection"> | string
    symbol?: StringFilter<"Collection"> | string
    contract?: StringFilter<"Collection"> | string
    description?: StringNullableFilter<"Collection"> | string | null
    logoUrl?: StringNullableFilter<"Collection"> | string | null
    coverUrl?: StringNullableFilter<"Collection"> | string | null
    standard?: StringFilter<"Collection"> | string
    supply?: IntNullableFilter<"Collection"> | number | null
    baseUri?: StringNullableFilter<"Collection"> | string | null
    gatewayPref?: EnumGatewayPrefFilter<"Collection"> | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFilter<"Collection"> | $Enums.IndexStatus
    x?: StringNullableFilter<"Collection"> | string | null
    instagram?: StringNullableFilter<"Collection"> | string | null
    website?: StringNullableFilter<"Collection"> | string | null
    discord?: StringNullableFilter<"Collection"> | string | null
    telegram?: StringNullableFilter<"Collection"> | string | null
    floorPrice?: FloatFilter<"Collection"> | number
    volume?: FloatFilter<"Collection"> | number
    itemsCount?: IntFilter<"Collection"> | number
    ownersCount?: IntFilter<"Collection"> | number
    change24h?: FloatFilter<"Collection"> | number
    creatorId?: StringFilter<"Collection"> | string
    ownerAddress?: StringFilter<"Collection"> | string
    isOrphan?: BoolFilter<"Collection"> | boolean
    createdAt?: DateTimeFilter<"Collection"> | Date | string
    updatedAt?: DateTimeFilter<"Collection"> | Date | string
    assetUploads?: AssetUploadListRelationFilter
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    deployment?: XOR<DeployedContractNullableScalarRelationFilter, DeployedContractWhereInput> | null
    featuredBidEntries?: FeaturedBidListRelationFilter
    featuredAsWinner?: FeaturedCycleListRelationFilter
    nfts?: NFTListRelationFilter
    presale?: XOR<PresaleNullableScalarRelationFilter, PresaleWhereInput> | null
    publicSale?: XOR<PublicSaleNullableScalarRelationFilter, PublicSaleWhereInput> | null
  }

  export type CollectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    standard?: SortOrder
    supply?: SortOrderInput | SortOrder
    baseUri?: SortOrderInput | SortOrder
    gatewayPref?: SortOrder
    indexStatus?: SortOrder
    x?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    discord?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    floorPrice?: SortOrder
    volume?: SortOrder
    itemsCount?: SortOrder
    ownersCount?: SortOrder
    change24h?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    isOrphan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assetUploads?: AssetUploadOrderByRelationAggregateInput
    creator?: UserOrderByWithRelationInput
    deployment?: DeployedContractOrderByWithRelationInput
    featuredBidEntries?: FeaturedBidOrderByRelationAggregateInput
    featuredAsWinner?: FeaturedCycleOrderByRelationAggregateInput
    nfts?: NFTOrderByRelationAggregateInput
    presale?: PresaleOrderByWithRelationInput
    publicSale?: PublicSaleOrderByWithRelationInput
  }

  export type CollectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contract?: string
    AND?: CollectionWhereInput | CollectionWhereInput[]
    OR?: CollectionWhereInput[]
    NOT?: CollectionWhereInput | CollectionWhereInput[]
    name?: StringFilter<"Collection"> | string
    symbol?: StringFilter<"Collection"> | string
    description?: StringNullableFilter<"Collection"> | string | null
    logoUrl?: StringNullableFilter<"Collection"> | string | null
    coverUrl?: StringNullableFilter<"Collection"> | string | null
    standard?: StringFilter<"Collection"> | string
    supply?: IntNullableFilter<"Collection"> | number | null
    baseUri?: StringNullableFilter<"Collection"> | string | null
    gatewayPref?: EnumGatewayPrefFilter<"Collection"> | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFilter<"Collection"> | $Enums.IndexStatus
    x?: StringNullableFilter<"Collection"> | string | null
    instagram?: StringNullableFilter<"Collection"> | string | null
    website?: StringNullableFilter<"Collection"> | string | null
    discord?: StringNullableFilter<"Collection"> | string | null
    telegram?: StringNullableFilter<"Collection"> | string | null
    floorPrice?: FloatFilter<"Collection"> | number
    volume?: FloatFilter<"Collection"> | number
    itemsCount?: IntFilter<"Collection"> | number
    ownersCount?: IntFilter<"Collection"> | number
    change24h?: FloatFilter<"Collection"> | number
    creatorId?: StringFilter<"Collection"> | string
    ownerAddress?: StringFilter<"Collection"> | string
    isOrphan?: BoolFilter<"Collection"> | boolean
    createdAt?: DateTimeFilter<"Collection"> | Date | string
    updatedAt?: DateTimeFilter<"Collection"> | Date | string
    assetUploads?: AssetUploadListRelationFilter
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    deployment?: XOR<DeployedContractNullableScalarRelationFilter, DeployedContractWhereInput> | null
    featuredBidEntries?: FeaturedBidListRelationFilter
    featuredAsWinner?: FeaturedCycleListRelationFilter
    nfts?: NFTListRelationFilter
    presale?: XOR<PresaleNullableScalarRelationFilter, PresaleWhereInput> | null
    publicSale?: XOR<PublicSaleNullableScalarRelationFilter, PublicSaleWhereInput> | null
  }, "id" | "contract">

  export type CollectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    standard?: SortOrder
    supply?: SortOrderInput | SortOrder
    baseUri?: SortOrderInput | SortOrder
    gatewayPref?: SortOrder
    indexStatus?: SortOrder
    x?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    discord?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    floorPrice?: SortOrder
    volume?: SortOrder
    itemsCount?: SortOrder
    ownersCount?: SortOrder
    change24h?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    isOrphan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CollectionCountOrderByAggregateInput
    _avg?: CollectionAvgOrderByAggregateInput
    _max?: CollectionMaxOrderByAggregateInput
    _min?: CollectionMinOrderByAggregateInput
    _sum?: CollectionSumOrderByAggregateInput
  }

  export type CollectionScalarWhereWithAggregatesInput = {
    AND?: CollectionScalarWhereWithAggregatesInput | CollectionScalarWhereWithAggregatesInput[]
    OR?: CollectionScalarWhereWithAggregatesInput[]
    NOT?: CollectionScalarWhereWithAggregatesInput | CollectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Collection"> | string
    name?: StringWithAggregatesFilter<"Collection"> | string
    symbol?: StringWithAggregatesFilter<"Collection"> | string
    contract?: StringWithAggregatesFilter<"Collection"> | string
    description?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    coverUrl?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    standard?: StringWithAggregatesFilter<"Collection"> | string
    supply?: IntNullableWithAggregatesFilter<"Collection"> | number | null
    baseUri?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    gatewayPref?: EnumGatewayPrefWithAggregatesFilter<"Collection"> | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusWithAggregatesFilter<"Collection"> | $Enums.IndexStatus
    x?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    website?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    discord?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    telegram?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    floorPrice?: FloatWithAggregatesFilter<"Collection"> | number
    volume?: FloatWithAggregatesFilter<"Collection"> | number
    itemsCount?: IntWithAggregatesFilter<"Collection"> | number
    ownersCount?: IntWithAggregatesFilter<"Collection"> | number
    change24h?: FloatWithAggregatesFilter<"Collection"> | number
    creatorId?: StringWithAggregatesFilter<"Collection"> | string
    ownerAddress?: StringWithAggregatesFilter<"Collection"> | string
    isOrphan?: BoolWithAggregatesFilter<"Collection"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Collection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Collection"> | Date | string
  }

  export type NFTWhereInput = {
    AND?: NFTWhereInput | NFTWhereInput[]
    OR?: NFTWhereInput[]
    NOT?: NFTWhereInput | NFTWhereInput[]
    id?: StringFilter<"NFT"> | string
    tokenId?: StringFilter<"NFT"> | string
    name?: StringNullableFilter<"NFT"> | string | null
    imageUrl?: StringNullableFilter<"NFT"> | string | null
    description?: StringNullableFilter<"NFT"> | string | null
    traits?: JsonNullableFilter<"NFT">
    attributes?: JsonNullableFilter<"NFT">
    tokenUri?: StringNullableFilter<"NFT"> | string | null
    contract?: StringFilter<"NFT"> | string
    standard?: StringNullableFilter<"NFT"> | string | null
    rawMetadata?: JsonNullableFilter<"NFT">
    royaltyBps?: IntNullableFilter<"NFT"> | number | null
    royaltyRecipient?: StringNullableFilter<"NFT"> | string | null
    ownerId?: StringNullableFilter<"NFT"> | string | null
    collectionId?: StringNullableFilter<"NFT"> | string | null
    single721Id?: StringNullableFilter<"NFT"> | string | null
    single1155Id?: StringNullableFilter<"NFT"> | string | null
    status?: EnumNftStatusFilter<"NFT"> | $Enums.NftStatus
    retryCount?: IntFilter<"NFT"> | number
    createdAt?: DateTimeFilter<"NFT"> | Date | string
    updatedAt?: DateTimeFilter<"NFT"> | Date | string
    rarityScore?: DecimalNullableFilter<"NFT"> | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionListRelationFilter
    listingEntries?: MarketplaceListingListRelationFilter
    sales?: MarketplaceSaleListRelationFilter
    collection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    single1155?: XOR<Single1155NullableScalarRelationFilter, Single1155WhereInput> | null
    single721?: XOR<Single721NullableScalarRelationFilter, Single721WhereInput> | null
    activities?: NFTActivityListRelationFilter
  }

  export type NFTOrderByWithRelationInput = {
    id?: SortOrder
    tokenId?: SortOrder
    name?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    traits?: SortOrderInput | SortOrder
    attributes?: SortOrderInput | SortOrder
    tokenUri?: SortOrderInput | SortOrder
    contract?: SortOrder
    standard?: SortOrderInput | SortOrder
    rawMetadata?: SortOrderInput | SortOrder
    royaltyBps?: SortOrderInput | SortOrder
    royaltyRecipient?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    collectionId?: SortOrderInput | SortOrder
    single721Id?: SortOrderInput | SortOrder
    single1155Id?: SortOrderInput | SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rarityScore?: SortOrderInput | SortOrder
    auctionEntries?: AuctionOrderByRelationAggregateInput
    listingEntries?: MarketplaceListingOrderByRelationAggregateInput
    sales?: MarketplaceSaleOrderByRelationAggregateInput
    collection?: CollectionOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    single1155?: Single1155OrderByWithRelationInput
    single721?: Single721OrderByWithRelationInput
    activities?: NFTActivityOrderByRelationAggregateInput
  }

  export type NFTWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contract_tokenId?: NFTContractTokenIdCompoundUniqueInput
    tokenId_contract_collectionId?: NFTTokenIdContractCollectionIdCompoundUniqueInput
    AND?: NFTWhereInput | NFTWhereInput[]
    OR?: NFTWhereInput[]
    NOT?: NFTWhereInput | NFTWhereInput[]
    tokenId?: StringFilter<"NFT"> | string
    name?: StringNullableFilter<"NFT"> | string | null
    imageUrl?: StringNullableFilter<"NFT"> | string | null
    description?: StringNullableFilter<"NFT"> | string | null
    traits?: JsonNullableFilter<"NFT">
    attributes?: JsonNullableFilter<"NFT">
    tokenUri?: StringNullableFilter<"NFT"> | string | null
    contract?: StringFilter<"NFT"> | string
    standard?: StringNullableFilter<"NFT"> | string | null
    rawMetadata?: JsonNullableFilter<"NFT">
    royaltyBps?: IntNullableFilter<"NFT"> | number | null
    royaltyRecipient?: StringNullableFilter<"NFT"> | string | null
    ownerId?: StringNullableFilter<"NFT"> | string | null
    collectionId?: StringNullableFilter<"NFT"> | string | null
    single721Id?: StringNullableFilter<"NFT"> | string | null
    single1155Id?: StringNullableFilter<"NFT"> | string | null
    status?: EnumNftStatusFilter<"NFT"> | $Enums.NftStatus
    retryCount?: IntFilter<"NFT"> | number
    createdAt?: DateTimeFilter<"NFT"> | Date | string
    updatedAt?: DateTimeFilter<"NFT"> | Date | string
    rarityScore?: DecimalNullableFilter<"NFT"> | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionListRelationFilter
    listingEntries?: MarketplaceListingListRelationFilter
    sales?: MarketplaceSaleListRelationFilter
    collection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    single1155?: XOR<Single1155NullableScalarRelationFilter, Single1155WhereInput> | null
    single721?: XOR<Single721NullableScalarRelationFilter, Single721WhereInput> | null
    activities?: NFTActivityListRelationFilter
  }, "id" | "contract_tokenId" | "tokenId_contract_collectionId">

  export type NFTOrderByWithAggregationInput = {
    id?: SortOrder
    tokenId?: SortOrder
    name?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    traits?: SortOrderInput | SortOrder
    attributes?: SortOrderInput | SortOrder
    tokenUri?: SortOrderInput | SortOrder
    contract?: SortOrder
    standard?: SortOrderInput | SortOrder
    rawMetadata?: SortOrderInput | SortOrder
    royaltyBps?: SortOrderInput | SortOrder
    royaltyRecipient?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    collectionId?: SortOrderInput | SortOrder
    single721Id?: SortOrderInput | SortOrder
    single1155Id?: SortOrderInput | SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rarityScore?: SortOrderInput | SortOrder
    _count?: NFTCountOrderByAggregateInput
    _avg?: NFTAvgOrderByAggregateInput
    _max?: NFTMaxOrderByAggregateInput
    _min?: NFTMinOrderByAggregateInput
    _sum?: NFTSumOrderByAggregateInput
  }

  export type NFTScalarWhereWithAggregatesInput = {
    AND?: NFTScalarWhereWithAggregatesInput | NFTScalarWhereWithAggregatesInput[]
    OR?: NFTScalarWhereWithAggregatesInput[]
    NOT?: NFTScalarWhereWithAggregatesInput | NFTScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NFT"> | string
    tokenId?: StringWithAggregatesFilter<"NFT"> | string
    name?: StringNullableWithAggregatesFilter<"NFT"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"NFT"> | string | null
    description?: StringNullableWithAggregatesFilter<"NFT"> | string | null
    traits?: JsonNullableWithAggregatesFilter<"NFT">
    attributes?: JsonNullableWithAggregatesFilter<"NFT">
    tokenUri?: StringNullableWithAggregatesFilter<"NFT"> | string | null
    contract?: StringWithAggregatesFilter<"NFT"> | string
    standard?: StringNullableWithAggregatesFilter<"NFT"> | string | null
    rawMetadata?: JsonNullableWithAggregatesFilter<"NFT">
    royaltyBps?: IntNullableWithAggregatesFilter<"NFT"> | number | null
    royaltyRecipient?: StringNullableWithAggregatesFilter<"NFT"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"NFT"> | string | null
    collectionId?: StringNullableWithAggregatesFilter<"NFT"> | string | null
    single721Id?: StringNullableWithAggregatesFilter<"NFT"> | string | null
    single1155Id?: StringNullableWithAggregatesFilter<"NFT"> | string | null
    status?: EnumNftStatusWithAggregatesFilter<"NFT"> | $Enums.NftStatus
    retryCount?: IntWithAggregatesFilter<"NFT"> | number
    createdAt?: DateTimeWithAggregatesFilter<"NFT"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NFT"> | Date | string
    rarityScore?: DecimalNullableWithAggregatesFilter<"NFT"> | Decimal | DecimalJsLike | number | string | null
  }

  export type TraitStatWhereInput = {
    AND?: TraitStatWhereInput | TraitStatWhereInput[]
    OR?: TraitStatWhereInput[]
    NOT?: TraitStatWhereInput | TraitStatWhereInput[]
    id?: StringFilter<"TraitStat"> | string
    contract?: StringFilter<"TraitStat"> | string
    trait_type?: StringFilter<"TraitStat"> | string
    value?: JsonFilter<"TraitStat">
    count?: IntFilter<"TraitStat"> | number
    frequency?: FloatFilter<"TraitStat"> | number
    createdAt?: DateTimeFilter<"TraitStat"> | Date | string
  }

  export type TraitStatOrderByWithRelationInput = {
    id?: SortOrder
    contract?: SortOrder
    trait_type?: SortOrder
    value?: SortOrder
    count?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
  }

  export type TraitStatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contract_trait_type_value?: TraitStatContractTrait_typeValueCompoundUniqueInput
    AND?: TraitStatWhereInput | TraitStatWhereInput[]
    OR?: TraitStatWhereInput[]
    NOT?: TraitStatWhereInput | TraitStatWhereInput[]
    contract?: StringFilter<"TraitStat"> | string
    trait_type?: StringFilter<"TraitStat"> | string
    value?: JsonFilter<"TraitStat">
    count?: IntFilter<"TraitStat"> | number
    frequency?: FloatFilter<"TraitStat"> | number
    createdAt?: DateTimeFilter<"TraitStat"> | Date | string
  }, "id" | "contract_trait_type_value">

  export type TraitStatOrderByWithAggregationInput = {
    id?: SortOrder
    contract?: SortOrder
    trait_type?: SortOrder
    value?: SortOrder
    count?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
    _count?: TraitStatCountOrderByAggregateInput
    _avg?: TraitStatAvgOrderByAggregateInput
    _max?: TraitStatMaxOrderByAggregateInput
    _min?: TraitStatMinOrderByAggregateInput
    _sum?: TraitStatSumOrderByAggregateInput
  }

  export type TraitStatScalarWhereWithAggregatesInput = {
    AND?: TraitStatScalarWhereWithAggregatesInput | TraitStatScalarWhereWithAggregatesInput[]
    OR?: TraitStatScalarWhereWithAggregatesInput[]
    NOT?: TraitStatScalarWhereWithAggregatesInput | TraitStatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TraitStat"> | string
    contract?: StringWithAggregatesFilter<"TraitStat"> | string
    trait_type?: StringWithAggregatesFilter<"TraitStat"> | string
    value?: JsonWithAggregatesFilter<"TraitStat">
    count?: IntWithAggregatesFilter<"TraitStat"> | number
    frequency?: FloatWithAggregatesFilter<"TraitStat"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TraitStat"> | Date | string
  }

  export type NFTActivityWhereInput = {
    AND?: NFTActivityWhereInput | NFTActivityWhereInput[]
    OR?: NFTActivityWhereInput[]
    NOT?: NFTActivityWhereInput | NFTActivityWhereInput[]
    id?: StringFilter<"NFTActivity"> | string
    nftId?: StringFilter<"NFTActivity"> | string
    contract?: StringFilter<"NFTActivity"> | string
    tokenId?: StringFilter<"NFTActivity"> | string
    type?: StringFilter<"NFTActivity"> | string
    fromAddress?: StringFilter<"NFTActivity"> | string
    toAddress?: StringFilter<"NFTActivity"> | string
    priceEtnWei?: DecimalNullableFilter<"NFTActivity"> | Decimal | DecimalJsLike | number | string | null
    txHash?: StringFilter<"NFTActivity"> | string
    logIndex?: IntFilter<"NFTActivity"> | number
    blockNumber?: IntFilter<"NFTActivity"> | number
    timestamp?: DateTimeFilter<"NFTActivity"> | Date | string
    marketplace?: StringNullableFilter<"NFTActivity"> | string | null
    rawData?: JsonNullableFilter<"NFTActivity">
    createdAt?: DateTimeFilter<"NFTActivity"> | Date | string
    nft?: XOR<NFTScalarRelationFilter, NFTWhereInput>
  }

  export type NFTActivityOrderByWithRelationInput = {
    id?: SortOrder
    nftId?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    priceEtnWei?: SortOrderInput | SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    marketplace?: SortOrderInput | SortOrder
    rawData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    nft?: NFTOrderByWithRelationInput
  }

  export type NFTActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    txHash_logIndex?: NFTActivityTxHashLogIndexCompoundUniqueInput
    AND?: NFTActivityWhereInput | NFTActivityWhereInput[]
    OR?: NFTActivityWhereInput[]
    NOT?: NFTActivityWhereInput | NFTActivityWhereInput[]
    nftId?: StringFilter<"NFTActivity"> | string
    contract?: StringFilter<"NFTActivity"> | string
    tokenId?: StringFilter<"NFTActivity"> | string
    type?: StringFilter<"NFTActivity"> | string
    fromAddress?: StringFilter<"NFTActivity"> | string
    toAddress?: StringFilter<"NFTActivity"> | string
    priceEtnWei?: DecimalNullableFilter<"NFTActivity"> | Decimal | DecimalJsLike | number | string | null
    txHash?: StringFilter<"NFTActivity"> | string
    logIndex?: IntFilter<"NFTActivity"> | number
    blockNumber?: IntFilter<"NFTActivity"> | number
    timestamp?: DateTimeFilter<"NFTActivity"> | Date | string
    marketplace?: StringNullableFilter<"NFTActivity"> | string | null
    rawData?: JsonNullableFilter<"NFTActivity">
    createdAt?: DateTimeFilter<"NFTActivity"> | Date | string
    nft?: XOR<NFTScalarRelationFilter, NFTWhereInput>
  }, "id" | "txHash_logIndex">

  export type NFTActivityOrderByWithAggregationInput = {
    id?: SortOrder
    nftId?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    priceEtnWei?: SortOrderInput | SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    marketplace?: SortOrderInput | SortOrder
    rawData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NFTActivityCountOrderByAggregateInput
    _avg?: NFTActivityAvgOrderByAggregateInput
    _max?: NFTActivityMaxOrderByAggregateInput
    _min?: NFTActivityMinOrderByAggregateInput
    _sum?: NFTActivitySumOrderByAggregateInput
  }

  export type NFTActivityScalarWhereWithAggregatesInput = {
    AND?: NFTActivityScalarWhereWithAggregatesInput | NFTActivityScalarWhereWithAggregatesInput[]
    OR?: NFTActivityScalarWhereWithAggregatesInput[]
    NOT?: NFTActivityScalarWhereWithAggregatesInput | NFTActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NFTActivity"> | string
    nftId?: StringWithAggregatesFilter<"NFTActivity"> | string
    contract?: StringWithAggregatesFilter<"NFTActivity"> | string
    tokenId?: StringWithAggregatesFilter<"NFTActivity"> | string
    type?: StringWithAggregatesFilter<"NFTActivity"> | string
    fromAddress?: StringWithAggregatesFilter<"NFTActivity"> | string
    toAddress?: StringWithAggregatesFilter<"NFTActivity"> | string
    priceEtnWei?: DecimalNullableWithAggregatesFilter<"NFTActivity"> | Decimal | DecimalJsLike | number | string | null
    txHash?: StringWithAggregatesFilter<"NFTActivity"> | string
    logIndex?: IntWithAggregatesFilter<"NFTActivity"> | number
    blockNumber?: IntWithAggregatesFilter<"NFTActivity"> | number
    timestamp?: DateTimeWithAggregatesFilter<"NFTActivity"> | Date | string
    marketplace?: StringNullableWithAggregatesFilter<"NFTActivity"> | string | null
    rawData?: JsonNullableWithAggregatesFilter<"NFTActivity">
    createdAt?: DateTimeWithAggregatesFilter<"NFTActivity"> | Date | string
  }

  export type Single721WhereInput = {
    AND?: Single721WhereInput | Single721WhereInput[]
    OR?: Single721WhereInput[]
    NOT?: Single721WhereInput | Single721WhereInput[]
    id?: StringFilter<"Single721"> | string
    name?: StringFilter<"Single721"> | string
    symbol?: StringFilter<"Single721"> | string
    contract?: StringFilter<"Single721"> | string
    tokenUri?: StringFilter<"Single721"> | string
    royaltyRecipient?: StringFilter<"Single721"> | string
    royaltyBps?: IntFilter<"Single721"> | number
    creatorId?: StringFilter<"Single721"> | string
    ownerAddress?: StringFilter<"Single721"> | string
    description?: StringNullableFilter<"Single721"> | string | null
    imageUrl?: StringNullableFilter<"Single721"> | string | null
    indexStatus?: EnumIndexStatusFilter<"Single721"> | $Enums.IndexStatus
    createdAt?: DateTimeFilter<"Single721"> | Date | string
    updatedAt?: DateTimeFilter<"Single721"> | Date | string
    assetUploads?: AssetUploadListRelationFilter
    deployment?: XOR<DeployedContractNullableScalarRelationFilter, DeployedContractWhereInput> | null
    nfts?: NFTListRelationFilter
  }

  export type Single721OrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    tokenUri?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    indexStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assetUploads?: AssetUploadOrderByRelationAggregateInput
    deployment?: DeployedContractOrderByWithRelationInput
    nfts?: NFTOrderByRelationAggregateInput
  }

  export type Single721WhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contract?: string
    AND?: Single721WhereInput | Single721WhereInput[]
    OR?: Single721WhereInput[]
    NOT?: Single721WhereInput | Single721WhereInput[]
    name?: StringFilter<"Single721"> | string
    symbol?: StringFilter<"Single721"> | string
    tokenUri?: StringFilter<"Single721"> | string
    royaltyRecipient?: StringFilter<"Single721"> | string
    royaltyBps?: IntFilter<"Single721"> | number
    creatorId?: StringFilter<"Single721"> | string
    ownerAddress?: StringFilter<"Single721"> | string
    description?: StringNullableFilter<"Single721"> | string | null
    imageUrl?: StringNullableFilter<"Single721"> | string | null
    indexStatus?: EnumIndexStatusFilter<"Single721"> | $Enums.IndexStatus
    createdAt?: DateTimeFilter<"Single721"> | Date | string
    updatedAt?: DateTimeFilter<"Single721"> | Date | string
    assetUploads?: AssetUploadListRelationFilter
    deployment?: XOR<DeployedContractNullableScalarRelationFilter, DeployedContractWhereInput> | null
    nfts?: NFTListRelationFilter
  }, "id" | "contract">

  export type Single721OrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    tokenUri?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    indexStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: Single721CountOrderByAggregateInput
    _avg?: Single721AvgOrderByAggregateInput
    _max?: Single721MaxOrderByAggregateInput
    _min?: Single721MinOrderByAggregateInput
    _sum?: Single721SumOrderByAggregateInput
  }

  export type Single721ScalarWhereWithAggregatesInput = {
    AND?: Single721ScalarWhereWithAggregatesInput | Single721ScalarWhereWithAggregatesInput[]
    OR?: Single721ScalarWhereWithAggregatesInput[]
    NOT?: Single721ScalarWhereWithAggregatesInput | Single721ScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Single721"> | string
    name?: StringWithAggregatesFilter<"Single721"> | string
    symbol?: StringWithAggregatesFilter<"Single721"> | string
    contract?: StringWithAggregatesFilter<"Single721"> | string
    tokenUri?: StringWithAggregatesFilter<"Single721"> | string
    royaltyRecipient?: StringWithAggregatesFilter<"Single721"> | string
    royaltyBps?: IntWithAggregatesFilter<"Single721"> | number
    creatorId?: StringWithAggregatesFilter<"Single721"> | string
    ownerAddress?: StringWithAggregatesFilter<"Single721"> | string
    description?: StringNullableWithAggregatesFilter<"Single721"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Single721"> | string | null
    indexStatus?: EnumIndexStatusWithAggregatesFilter<"Single721"> | $Enums.IndexStatus
    createdAt?: DateTimeWithAggregatesFilter<"Single721"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Single721"> | Date | string
  }

  export type Single1155WhereInput = {
    AND?: Single1155WhereInput | Single1155WhereInput[]
    OR?: Single1155WhereInput[]
    NOT?: Single1155WhereInput | Single1155WhereInput[]
    id?: StringFilter<"Single1155"> | string
    name?: StringFilter<"Single1155"> | string
    symbol?: StringFilter<"Single1155"> | string
    contract?: StringFilter<"Single1155"> | string
    baseUri?: StringFilter<"Single1155"> | string
    maxSupply?: IntFilter<"Single1155"> | number
    mintPriceEtnWei?: DecimalFilter<"Single1155"> | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFilter<"Single1155"> | number
    royaltyRecipient?: StringFilter<"Single1155"> | string
    royaltyBps?: IntFilter<"Single1155"> | number
    creatorId?: StringFilter<"Single1155"> | string
    ownerAddress?: StringFilter<"Single1155"> | string
    description?: StringNullableFilter<"Single1155"> | string | null
    imageUrl?: StringNullableFilter<"Single1155"> | string | null
    indexStatus?: EnumIndexStatusFilter<"Single1155"> | $Enums.IndexStatus
    createdAt?: DateTimeFilter<"Single1155"> | Date | string
    updatedAt?: DateTimeFilter<"Single1155"> | Date | string
    assetUploads?: AssetUploadListRelationFilter
    deployment?: XOR<DeployedContractNullableScalarRelationFilter, DeployedContractWhereInput> | null
    balances?: Erc1155BalanceListRelationFilter
    nfts?: NFTListRelationFilter
  }

  export type Single1155OrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    baseUri?: SortOrder
    maxSupply?: SortOrder
    mintPriceEtnWei?: SortOrder
    maxPerWallet?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    indexStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assetUploads?: AssetUploadOrderByRelationAggregateInput
    deployment?: DeployedContractOrderByWithRelationInput
    balances?: Erc1155BalanceOrderByRelationAggregateInput
    nfts?: NFTOrderByRelationAggregateInput
  }

  export type Single1155WhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contract?: string
    AND?: Single1155WhereInput | Single1155WhereInput[]
    OR?: Single1155WhereInput[]
    NOT?: Single1155WhereInput | Single1155WhereInput[]
    name?: StringFilter<"Single1155"> | string
    symbol?: StringFilter<"Single1155"> | string
    baseUri?: StringFilter<"Single1155"> | string
    maxSupply?: IntFilter<"Single1155"> | number
    mintPriceEtnWei?: DecimalFilter<"Single1155"> | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFilter<"Single1155"> | number
    royaltyRecipient?: StringFilter<"Single1155"> | string
    royaltyBps?: IntFilter<"Single1155"> | number
    creatorId?: StringFilter<"Single1155"> | string
    ownerAddress?: StringFilter<"Single1155"> | string
    description?: StringNullableFilter<"Single1155"> | string | null
    imageUrl?: StringNullableFilter<"Single1155"> | string | null
    indexStatus?: EnumIndexStatusFilter<"Single1155"> | $Enums.IndexStatus
    createdAt?: DateTimeFilter<"Single1155"> | Date | string
    updatedAt?: DateTimeFilter<"Single1155"> | Date | string
    assetUploads?: AssetUploadListRelationFilter
    deployment?: XOR<DeployedContractNullableScalarRelationFilter, DeployedContractWhereInput> | null
    balances?: Erc1155BalanceListRelationFilter
    nfts?: NFTListRelationFilter
  }, "id" | "contract">

  export type Single1155OrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    baseUri?: SortOrder
    maxSupply?: SortOrder
    mintPriceEtnWei?: SortOrder
    maxPerWallet?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    indexStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: Single1155CountOrderByAggregateInput
    _avg?: Single1155AvgOrderByAggregateInput
    _max?: Single1155MaxOrderByAggregateInput
    _min?: Single1155MinOrderByAggregateInput
    _sum?: Single1155SumOrderByAggregateInput
  }

  export type Single1155ScalarWhereWithAggregatesInput = {
    AND?: Single1155ScalarWhereWithAggregatesInput | Single1155ScalarWhereWithAggregatesInput[]
    OR?: Single1155ScalarWhereWithAggregatesInput[]
    NOT?: Single1155ScalarWhereWithAggregatesInput | Single1155ScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Single1155"> | string
    name?: StringWithAggregatesFilter<"Single1155"> | string
    symbol?: StringWithAggregatesFilter<"Single1155"> | string
    contract?: StringWithAggregatesFilter<"Single1155"> | string
    baseUri?: StringWithAggregatesFilter<"Single1155"> | string
    maxSupply?: IntWithAggregatesFilter<"Single1155"> | number
    mintPriceEtnWei?: DecimalWithAggregatesFilter<"Single1155"> | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntWithAggregatesFilter<"Single1155"> | number
    royaltyRecipient?: StringWithAggregatesFilter<"Single1155"> | string
    royaltyBps?: IntWithAggregatesFilter<"Single1155"> | number
    creatorId?: StringWithAggregatesFilter<"Single1155"> | string
    ownerAddress?: StringWithAggregatesFilter<"Single1155"> | string
    description?: StringNullableWithAggregatesFilter<"Single1155"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Single1155"> | string | null
    indexStatus?: EnumIndexStatusWithAggregatesFilter<"Single1155"> | $Enums.IndexStatus
    createdAt?: DateTimeWithAggregatesFilter<"Single1155"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Single1155"> | Date | string
  }

  export type Erc1155BalanceWhereInput = {
    AND?: Erc1155BalanceWhereInput | Erc1155BalanceWhereInput[]
    OR?: Erc1155BalanceWhereInput[]
    NOT?: Erc1155BalanceWhereInput | Erc1155BalanceWhereInput[]
    id?: StringFilter<"Erc1155Balance"> | string
    single1155Id?: StringFilter<"Erc1155Balance"> | string
    ownerAddress?: StringFilter<"Erc1155Balance"> | string
    balance?: IntFilter<"Erc1155Balance"> | number
    updatedAt?: DateTimeFilter<"Erc1155Balance"> | Date | string
    single1155?: XOR<Single1155ScalarRelationFilter, Single1155WhereInput>
  }

  export type Erc1155BalanceOrderByWithRelationInput = {
    id?: SortOrder
    single1155Id?: SortOrder
    ownerAddress?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
    single1155?: Single1155OrderByWithRelationInput
  }

  export type Erc1155BalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    single1155Id_ownerAddress?: Erc1155BalanceSingle1155IdOwnerAddressCompoundUniqueInput
    AND?: Erc1155BalanceWhereInput | Erc1155BalanceWhereInput[]
    OR?: Erc1155BalanceWhereInput[]
    NOT?: Erc1155BalanceWhereInput | Erc1155BalanceWhereInput[]
    single1155Id?: StringFilter<"Erc1155Balance"> | string
    ownerAddress?: StringFilter<"Erc1155Balance"> | string
    balance?: IntFilter<"Erc1155Balance"> | number
    updatedAt?: DateTimeFilter<"Erc1155Balance"> | Date | string
    single1155?: XOR<Single1155ScalarRelationFilter, Single1155WhereInput>
  }, "id" | "single1155Id_ownerAddress">

  export type Erc1155BalanceOrderByWithAggregationInput = {
    id?: SortOrder
    single1155Id?: SortOrder
    ownerAddress?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
    _count?: Erc1155BalanceCountOrderByAggregateInput
    _avg?: Erc1155BalanceAvgOrderByAggregateInput
    _max?: Erc1155BalanceMaxOrderByAggregateInput
    _min?: Erc1155BalanceMinOrderByAggregateInput
    _sum?: Erc1155BalanceSumOrderByAggregateInput
  }

  export type Erc1155BalanceScalarWhereWithAggregatesInput = {
    AND?: Erc1155BalanceScalarWhereWithAggregatesInput | Erc1155BalanceScalarWhereWithAggregatesInput[]
    OR?: Erc1155BalanceScalarWhereWithAggregatesInput[]
    NOT?: Erc1155BalanceScalarWhereWithAggregatesInput | Erc1155BalanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Erc1155Balance"> | string
    single1155Id?: StringWithAggregatesFilter<"Erc1155Balance"> | string
    ownerAddress?: StringWithAggregatesFilter<"Erc1155Balance"> | string
    balance?: IntWithAggregatesFilter<"Erc1155Balance"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Erc1155Balance"> | Date | string
  }

  export type Erc1155HoldingWhereInput = {
    AND?: Erc1155HoldingWhereInput | Erc1155HoldingWhereInput[]
    OR?: Erc1155HoldingWhereInput[]
    NOT?: Erc1155HoldingWhereInput | Erc1155HoldingWhereInput[]
    id?: StringFilter<"Erc1155Holding"> | string
    contract?: StringFilter<"Erc1155Holding"> | string
    tokenId?: StringFilter<"Erc1155Holding"> | string
    ownerAddress?: StringFilter<"Erc1155Holding"> | string
    balance?: IntFilter<"Erc1155Holding"> | number
    updatedAt?: DateTimeFilter<"Erc1155Holding"> | Date | string
  }

  export type Erc1155HoldingOrderByWithRelationInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    ownerAddress?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
  }

  export type Erc1155HoldingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contract_tokenId_ownerAddress?: Erc1155HoldingContractTokenIdOwnerAddressCompoundUniqueInput
    AND?: Erc1155HoldingWhereInput | Erc1155HoldingWhereInput[]
    OR?: Erc1155HoldingWhereInput[]
    NOT?: Erc1155HoldingWhereInput | Erc1155HoldingWhereInput[]
    contract?: StringFilter<"Erc1155Holding"> | string
    tokenId?: StringFilter<"Erc1155Holding"> | string
    ownerAddress?: StringFilter<"Erc1155Holding"> | string
    balance?: IntFilter<"Erc1155Holding"> | number
    updatedAt?: DateTimeFilter<"Erc1155Holding"> | Date | string
  }, "id" | "contract_tokenId_ownerAddress">

  export type Erc1155HoldingOrderByWithAggregationInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    ownerAddress?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
    _count?: Erc1155HoldingCountOrderByAggregateInput
    _avg?: Erc1155HoldingAvgOrderByAggregateInput
    _max?: Erc1155HoldingMaxOrderByAggregateInput
    _min?: Erc1155HoldingMinOrderByAggregateInput
    _sum?: Erc1155HoldingSumOrderByAggregateInput
  }

  export type Erc1155HoldingScalarWhereWithAggregatesInput = {
    AND?: Erc1155HoldingScalarWhereWithAggregatesInput | Erc1155HoldingScalarWhereWithAggregatesInput[]
    OR?: Erc1155HoldingScalarWhereWithAggregatesInput[]
    NOT?: Erc1155HoldingScalarWhereWithAggregatesInput | Erc1155HoldingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Erc1155Holding"> | string
    contract?: StringWithAggregatesFilter<"Erc1155Holding"> | string
    tokenId?: StringWithAggregatesFilter<"Erc1155Holding"> | string
    ownerAddress?: StringWithAggregatesFilter<"Erc1155Holding"> | string
    balance?: IntWithAggregatesFilter<"Erc1155Holding"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Erc1155Holding"> | Date | string
  }

  export type MarketplaceListingWhereInput = {
    AND?: MarketplaceListingWhereInput | MarketplaceListingWhereInput[]
    OR?: MarketplaceListingWhereInput[]
    NOT?: MarketplaceListingWhereInput | MarketplaceListingWhereInput[]
    id?: StringFilter<"MarketplaceListing"> | string
    nftId?: StringFilter<"MarketplaceListing"> | string
    sellerAddress?: StringFilter<"MarketplaceListing"> | string
    quantity?: IntFilter<"MarketplaceListing"> | number
    priceEtnWei?: DecimalFilter<"MarketplaceListing"> | Decimal | DecimalJsLike | number | string
    currencyId?: StringNullableFilter<"MarketplaceListing"> | string | null
    priceTokenAmount?: DecimalNullableFilter<"MarketplaceListing"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumListingStatusFilter<"MarketplaceListing"> | $Enums.ListingStatus
    startTime?: DateTimeFilter<"MarketplaceListing"> | Date | string
    endTime?: DateTimeNullableFilter<"MarketplaceListing"> | Date | string | null
    txHashCreated?: StringNullableFilter<"MarketplaceListing"> | string | null
    txHashFilled?: StringNullableFilter<"MarketplaceListing"> | string | null
    txHashCancelled?: StringNullableFilter<"MarketplaceListing"> | string | null
    createdAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    currency?: XOR<CurrencyNullableScalarRelationFilter, CurrencyWhereInput> | null
    nft?: XOR<NFTScalarRelationFilter, NFTWhereInput>
  }

  export type MarketplaceListingOrderByWithRelationInput = {
    id?: SortOrder
    nftId?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    priceEtnWei?: SortOrder
    currencyId?: SortOrderInput | SortOrder
    priceTokenAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    txHashCreated?: SortOrderInput | SortOrder
    txHashFilled?: SortOrderInput | SortOrder
    txHashCancelled?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: CurrencyOrderByWithRelationInput
    nft?: NFTOrderByWithRelationInput
  }

  export type MarketplaceListingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketplaceListingWhereInput | MarketplaceListingWhereInput[]
    OR?: MarketplaceListingWhereInput[]
    NOT?: MarketplaceListingWhereInput | MarketplaceListingWhereInput[]
    nftId?: StringFilter<"MarketplaceListing"> | string
    sellerAddress?: StringFilter<"MarketplaceListing"> | string
    quantity?: IntFilter<"MarketplaceListing"> | number
    priceEtnWei?: DecimalFilter<"MarketplaceListing"> | Decimal | DecimalJsLike | number | string
    currencyId?: StringNullableFilter<"MarketplaceListing"> | string | null
    priceTokenAmount?: DecimalNullableFilter<"MarketplaceListing"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumListingStatusFilter<"MarketplaceListing"> | $Enums.ListingStatus
    startTime?: DateTimeFilter<"MarketplaceListing"> | Date | string
    endTime?: DateTimeNullableFilter<"MarketplaceListing"> | Date | string | null
    txHashCreated?: StringNullableFilter<"MarketplaceListing"> | string | null
    txHashFilled?: StringNullableFilter<"MarketplaceListing"> | string | null
    txHashCancelled?: StringNullableFilter<"MarketplaceListing"> | string | null
    createdAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    currency?: XOR<CurrencyNullableScalarRelationFilter, CurrencyWhereInput> | null
    nft?: XOR<NFTScalarRelationFilter, NFTWhereInput>
  }, "id">

  export type MarketplaceListingOrderByWithAggregationInput = {
    id?: SortOrder
    nftId?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    priceEtnWei?: SortOrder
    currencyId?: SortOrderInput | SortOrder
    priceTokenAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    txHashCreated?: SortOrderInput | SortOrder
    txHashFilled?: SortOrderInput | SortOrder
    txHashCancelled?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketplaceListingCountOrderByAggregateInput
    _avg?: MarketplaceListingAvgOrderByAggregateInput
    _max?: MarketplaceListingMaxOrderByAggregateInput
    _min?: MarketplaceListingMinOrderByAggregateInput
    _sum?: MarketplaceListingSumOrderByAggregateInput
  }

  export type MarketplaceListingScalarWhereWithAggregatesInput = {
    AND?: MarketplaceListingScalarWhereWithAggregatesInput | MarketplaceListingScalarWhereWithAggregatesInput[]
    OR?: MarketplaceListingScalarWhereWithAggregatesInput[]
    NOT?: MarketplaceListingScalarWhereWithAggregatesInput | MarketplaceListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketplaceListing"> | string
    nftId?: StringWithAggregatesFilter<"MarketplaceListing"> | string
    sellerAddress?: StringWithAggregatesFilter<"MarketplaceListing"> | string
    quantity?: IntWithAggregatesFilter<"MarketplaceListing"> | number
    priceEtnWei?: DecimalWithAggregatesFilter<"MarketplaceListing"> | Decimal | DecimalJsLike | number | string
    currencyId?: StringNullableWithAggregatesFilter<"MarketplaceListing"> | string | null
    priceTokenAmount?: DecimalNullableWithAggregatesFilter<"MarketplaceListing"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumListingStatusWithAggregatesFilter<"MarketplaceListing"> | $Enums.ListingStatus
    startTime?: DateTimeWithAggregatesFilter<"MarketplaceListing"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"MarketplaceListing"> | Date | string | null
    txHashCreated?: StringNullableWithAggregatesFilter<"MarketplaceListing"> | string | null
    txHashFilled?: StringNullableWithAggregatesFilter<"MarketplaceListing"> | string | null
    txHashCancelled?: StringNullableWithAggregatesFilter<"MarketplaceListing"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MarketplaceListing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketplaceListing"> | Date | string
  }

  export type AuctionWhereInput = {
    AND?: AuctionWhereInput | AuctionWhereInput[]
    OR?: AuctionWhereInput[]
    NOT?: AuctionWhereInput | AuctionWhereInput[]
    id?: StringFilter<"Auction"> | string
    nftId?: StringFilter<"Auction"> | string
    sellerAddress?: StringFilter<"Auction"> | string
    quantity?: IntFilter<"Auction"> | number
    startPriceEtnWei?: DecimalFilter<"Auction"> | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: StringNullableFilter<"Auction"> | string | null
    startPriceTokenAmount?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFilter<"Auction"> | Date | string
    endTime?: DateTimeFilter<"Auction"> | Date | string
    status?: EnumAuctionStatusFilter<"Auction"> | $Enums.AuctionStatus
    txHashCreated?: StringNullableFilter<"Auction"> | string | null
    txHashFinalized?: StringNullableFilter<"Auction"> | string | null
    txHashCancelled?: StringNullableFilter<"Auction"> | string | null
    createdAt?: DateTimeFilter<"Auction"> | Date | string
    updatedAt?: DateTimeFilter<"Auction"> | Date | string
    highestBidder?: StringNullableFilter<"Auction"> | string | null
    currency?: XOR<CurrencyNullableScalarRelationFilter, CurrencyWhereInput> | null
    nft?: XOR<NFTScalarRelationFilter, NFTWhereInput>
    bids?: AuctionBidListRelationFilter
  }

  export type AuctionOrderByWithRelationInput = {
    id?: SortOrder
    nftId?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    startPriceEtnWei?: SortOrder
    highestBidEtnWei?: SortOrderInput | SortOrder
    minIncrementEtnWei?: SortOrderInput | SortOrder
    currencyId?: SortOrderInput | SortOrder
    startPriceTokenAmount?: SortOrderInput | SortOrder
    highestBidTokenAmount?: SortOrderInput | SortOrder
    minIncrementTokenAmount?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    txHashCreated?: SortOrderInput | SortOrder
    txHashFinalized?: SortOrderInput | SortOrder
    txHashCancelled?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highestBidder?: SortOrderInput | SortOrder
    currency?: CurrencyOrderByWithRelationInput
    nft?: NFTOrderByWithRelationInput
    bids?: AuctionBidOrderByRelationAggregateInput
  }

  export type AuctionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuctionWhereInput | AuctionWhereInput[]
    OR?: AuctionWhereInput[]
    NOT?: AuctionWhereInput | AuctionWhereInput[]
    nftId?: StringFilter<"Auction"> | string
    sellerAddress?: StringFilter<"Auction"> | string
    quantity?: IntFilter<"Auction"> | number
    startPriceEtnWei?: DecimalFilter<"Auction"> | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: StringNullableFilter<"Auction"> | string | null
    startPriceTokenAmount?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFilter<"Auction"> | Date | string
    endTime?: DateTimeFilter<"Auction"> | Date | string
    status?: EnumAuctionStatusFilter<"Auction"> | $Enums.AuctionStatus
    txHashCreated?: StringNullableFilter<"Auction"> | string | null
    txHashFinalized?: StringNullableFilter<"Auction"> | string | null
    txHashCancelled?: StringNullableFilter<"Auction"> | string | null
    createdAt?: DateTimeFilter<"Auction"> | Date | string
    updatedAt?: DateTimeFilter<"Auction"> | Date | string
    highestBidder?: StringNullableFilter<"Auction"> | string | null
    currency?: XOR<CurrencyNullableScalarRelationFilter, CurrencyWhereInput> | null
    nft?: XOR<NFTScalarRelationFilter, NFTWhereInput>
    bids?: AuctionBidListRelationFilter
  }, "id">

  export type AuctionOrderByWithAggregationInput = {
    id?: SortOrder
    nftId?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    startPriceEtnWei?: SortOrder
    highestBidEtnWei?: SortOrderInput | SortOrder
    minIncrementEtnWei?: SortOrderInput | SortOrder
    currencyId?: SortOrderInput | SortOrder
    startPriceTokenAmount?: SortOrderInput | SortOrder
    highestBidTokenAmount?: SortOrderInput | SortOrder
    minIncrementTokenAmount?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    txHashCreated?: SortOrderInput | SortOrder
    txHashFinalized?: SortOrderInput | SortOrder
    txHashCancelled?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highestBidder?: SortOrderInput | SortOrder
    _count?: AuctionCountOrderByAggregateInput
    _avg?: AuctionAvgOrderByAggregateInput
    _max?: AuctionMaxOrderByAggregateInput
    _min?: AuctionMinOrderByAggregateInput
    _sum?: AuctionSumOrderByAggregateInput
  }

  export type AuctionScalarWhereWithAggregatesInput = {
    AND?: AuctionScalarWhereWithAggregatesInput | AuctionScalarWhereWithAggregatesInput[]
    OR?: AuctionScalarWhereWithAggregatesInput[]
    NOT?: AuctionScalarWhereWithAggregatesInput | AuctionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Auction"> | string
    nftId?: StringWithAggregatesFilter<"Auction"> | string
    sellerAddress?: StringWithAggregatesFilter<"Auction"> | string
    quantity?: IntWithAggregatesFilter<"Auction"> | number
    startPriceEtnWei?: DecimalWithAggregatesFilter<"Auction"> | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: DecimalNullableWithAggregatesFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: DecimalNullableWithAggregatesFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: StringNullableWithAggregatesFilter<"Auction"> | string | null
    startPriceTokenAmount?: DecimalNullableWithAggregatesFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: DecimalNullableWithAggregatesFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: DecimalNullableWithAggregatesFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeWithAggregatesFilter<"Auction"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Auction"> | Date | string
    status?: EnumAuctionStatusWithAggregatesFilter<"Auction"> | $Enums.AuctionStatus
    txHashCreated?: StringNullableWithAggregatesFilter<"Auction"> | string | null
    txHashFinalized?: StringNullableWithAggregatesFilter<"Auction"> | string | null
    txHashCancelled?: StringNullableWithAggregatesFilter<"Auction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Auction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Auction"> | Date | string
    highestBidder?: StringNullableWithAggregatesFilter<"Auction"> | string | null
  }

  export type AuctionBidWhereInput = {
    AND?: AuctionBidWhereInput | AuctionBidWhereInput[]
    OR?: AuctionBidWhereInput[]
    NOT?: AuctionBidWhereInput | AuctionBidWhereInput[]
    id?: StringFilter<"AuctionBid"> | string
    auctionId?: StringFilter<"AuctionBid"> | string
    bidderAddress?: StringFilter<"AuctionBid"> | string
    amountWei?: DecimalFilter<"AuctionBid"> | Decimal | DecimalJsLike | number | string
    currencyId?: StringNullableFilter<"AuctionBid"> | string | null
    txHash?: StringFilter<"AuctionBid"> | string
    logIndex?: IntFilter<"AuctionBid"> | number
    blockNumber?: IntFilter<"AuctionBid"> | number
    timestamp?: DateTimeFilter<"AuctionBid"> | Date | string
    createdAt?: DateTimeFilter<"AuctionBid"> | Date | string
    auction?: XOR<AuctionScalarRelationFilter, AuctionWhereInput>
    currency?: XOR<CurrencyNullableScalarRelationFilter, CurrencyWhereInput> | null
  }

  export type AuctionBidOrderByWithRelationInput = {
    id?: SortOrder
    auctionId?: SortOrder
    bidderAddress?: SortOrder
    amountWei?: SortOrder
    currencyId?: SortOrderInput | SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    auction?: AuctionOrderByWithRelationInput
    currency?: CurrencyOrderByWithRelationInput
  }

  export type AuctionBidWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    txHash_logIndex?: AuctionBidTxHashLogIndexCompoundUniqueInput
    AND?: AuctionBidWhereInput | AuctionBidWhereInput[]
    OR?: AuctionBidWhereInput[]
    NOT?: AuctionBidWhereInput | AuctionBidWhereInput[]
    auctionId?: StringFilter<"AuctionBid"> | string
    bidderAddress?: StringFilter<"AuctionBid"> | string
    amountWei?: DecimalFilter<"AuctionBid"> | Decimal | DecimalJsLike | number | string
    currencyId?: StringNullableFilter<"AuctionBid"> | string | null
    txHash?: StringFilter<"AuctionBid"> | string
    logIndex?: IntFilter<"AuctionBid"> | number
    blockNumber?: IntFilter<"AuctionBid"> | number
    timestamp?: DateTimeFilter<"AuctionBid"> | Date | string
    createdAt?: DateTimeFilter<"AuctionBid"> | Date | string
    auction?: XOR<AuctionScalarRelationFilter, AuctionWhereInput>
    currency?: XOR<CurrencyNullableScalarRelationFilter, CurrencyWhereInput> | null
  }, "id" | "txHash_logIndex">

  export type AuctionBidOrderByWithAggregationInput = {
    id?: SortOrder
    auctionId?: SortOrder
    bidderAddress?: SortOrder
    amountWei?: SortOrder
    currencyId?: SortOrderInput | SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: AuctionBidCountOrderByAggregateInput
    _avg?: AuctionBidAvgOrderByAggregateInput
    _max?: AuctionBidMaxOrderByAggregateInput
    _min?: AuctionBidMinOrderByAggregateInput
    _sum?: AuctionBidSumOrderByAggregateInput
  }

  export type AuctionBidScalarWhereWithAggregatesInput = {
    AND?: AuctionBidScalarWhereWithAggregatesInput | AuctionBidScalarWhereWithAggregatesInput[]
    OR?: AuctionBidScalarWhereWithAggregatesInput[]
    NOT?: AuctionBidScalarWhereWithAggregatesInput | AuctionBidScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuctionBid"> | string
    auctionId?: StringWithAggregatesFilter<"AuctionBid"> | string
    bidderAddress?: StringWithAggregatesFilter<"AuctionBid"> | string
    amountWei?: DecimalWithAggregatesFilter<"AuctionBid"> | Decimal | DecimalJsLike | number | string
    currencyId?: StringNullableWithAggregatesFilter<"AuctionBid"> | string | null
    txHash?: StringWithAggregatesFilter<"AuctionBid"> | string
    logIndex?: IntWithAggregatesFilter<"AuctionBid"> | number
    blockNumber?: IntWithAggregatesFilter<"AuctionBid"> | number
    timestamp?: DateTimeWithAggregatesFilter<"AuctionBid"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AuctionBid"> | Date | string
  }

  export type DeployedContractWhereInput = {
    AND?: DeployedContractWhereInput | DeployedContractWhereInput[]
    OR?: DeployedContractWhereInput[]
    NOT?: DeployedContractWhereInput | DeployedContractWhereInput[]
    id?: StringFilter<"DeployedContract"> | string
    contractType?: EnumContractTypeFilter<"DeployedContract"> | $Enums.ContractType
    cloneAddress?: StringFilter<"DeployedContract"> | string
    implementationAddr?: StringFilter<"DeployedContract"> | string
    factoryAddress?: StringFilter<"DeployedContract"> | string
    deployerAddress?: StringFilter<"DeployedContract"> | string
    txHash?: StringFilter<"DeployedContract"> | string
    blockNumber?: IntFilter<"DeployedContract"> | number
    metadataOption?: EnumMetadataOptionFilter<"DeployedContract"> | $Enums.MetadataOption
    feeRecipient?: StringFilter<"DeployedContract"> | string
    feeAmountEtnWei?: DecimalFilter<"DeployedContract"> | Decimal | DecimalJsLike | number | string
    royaltyRecipient?: StringFilter<"DeployedContract"> | string
    royaltyBps?: IntFilter<"DeployedContract"> | number
    baseURI?: StringNullableFilter<"DeployedContract"> | string | null
    maxSupply?: IntNullableFilter<"DeployedContract"> | number | null
    rawInit?: JsonNullableFilter<"DeployedContract">
    createdAt?: DateTimeFilter<"DeployedContract"> | Date | string
    collectionId?: StringNullableFilter<"DeployedContract"> | string | null
    single721Id?: StringNullableFilter<"DeployedContract"> | string | null
    single1155Id?: StringNullableFilter<"DeployedContract"> | string | null
    collection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null
    single1155?: XOR<Single1155NullableScalarRelationFilter, Single1155WhereInput> | null
    single721?: XOR<Single721NullableScalarRelationFilter, Single721WhereInput> | null
  }

  export type DeployedContractOrderByWithRelationInput = {
    id?: SortOrder
    contractType?: SortOrder
    cloneAddress?: SortOrder
    implementationAddr?: SortOrder
    factoryAddress?: SortOrder
    deployerAddress?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    metadataOption?: SortOrder
    feeRecipient?: SortOrder
    feeAmountEtnWei?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    baseURI?: SortOrderInput | SortOrder
    maxSupply?: SortOrderInput | SortOrder
    rawInit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    collectionId?: SortOrderInput | SortOrder
    single721Id?: SortOrderInput | SortOrder
    single1155Id?: SortOrderInput | SortOrder
    collection?: CollectionOrderByWithRelationInput
    single1155?: Single1155OrderByWithRelationInput
    single721?: Single721OrderByWithRelationInput
  }

  export type DeployedContractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cloneAddress?: string
    txHash?: string
    collectionId?: string
    single721Id?: string
    single1155Id?: string
    AND?: DeployedContractWhereInput | DeployedContractWhereInput[]
    OR?: DeployedContractWhereInput[]
    NOT?: DeployedContractWhereInput | DeployedContractWhereInput[]
    contractType?: EnumContractTypeFilter<"DeployedContract"> | $Enums.ContractType
    implementationAddr?: StringFilter<"DeployedContract"> | string
    factoryAddress?: StringFilter<"DeployedContract"> | string
    deployerAddress?: StringFilter<"DeployedContract"> | string
    blockNumber?: IntFilter<"DeployedContract"> | number
    metadataOption?: EnumMetadataOptionFilter<"DeployedContract"> | $Enums.MetadataOption
    feeRecipient?: StringFilter<"DeployedContract"> | string
    feeAmountEtnWei?: DecimalFilter<"DeployedContract"> | Decimal | DecimalJsLike | number | string
    royaltyRecipient?: StringFilter<"DeployedContract"> | string
    royaltyBps?: IntFilter<"DeployedContract"> | number
    baseURI?: StringNullableFilter<"DeployedContract"> | string | null
    maxSupply?: IntNullableFilter<"DeployedContract"> | number | null
    rawInit?: JsonNullableFilter<"DeployedContract">
    createdAt?: DateTimeFilter<"DeployedContract"> | Date | string
    collection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null
    single1155?: XOR<Single1155NullableScalarRelationFilter, Single1155WhereInput> | null
    single721?: XOR<Single721NullableScalarRelationFilter, Single721WhereInput> | null
  }, "id" | "cloneAddress" | "txHash" | "collectionId" | "single721Id" | "single1155Id">

  export type DeployedContractOrderByWithAggregationInput = {
    id?: SortOrder
    contractType?: SortOrder
    cloneAddress?: SortOrder
    implementationAddr?: SortOrder
    factoryAddress?: SortOrder
    deployerAddress?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    metadataOption?: SortOrder
    feeRecipient?: SortOrder
    feeAmountEtnWei?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    baseURI?: SortOrderInput | SortOrder
    maxSupply?: SortOrderInput | SortOrder
    rawInit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    collectionId?: SortOrderInput | SortOrder
    single721Id?: SortOrderInput | SortOrder
    single1155Id?: SortOrderInput | SortOrder
    _count?: DeployedContractCountOrderByAggregateInput
    _avg?: DeployedContractAvgOrderByAggregateInput
    _max?: DeployedContractMaxOrderByAggregateInput
    _min?: DeployedContractMinOrderByAggregateInput
    _sum?: DeployedContractSumOrderByAggregateInput
  }

  export type DeployedContractScalarWhereWithAggregatesInput = {
    AND?: DeployedContractScalarWhereWithAggregatesInput | DeployedContractScalarWhereWithAggregatesInput[]
    OR?: DeployedContractScalarWhereWithAggregatesInput[]
    NOT?: DeployedContractScalarWhereWithAggregatesInput | DeployedContractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeployedContract"> | string
    contractType?: EnumContractTypeWithAggregatesFilter<"DeployedContract"> | $Enums.ContractType
    cloneAddress?: StringWithAggregatesFilter<"DeployedContract"> | string
    implementationAddr?: StringWithAggregatesFilter<"DeployedContract"> | string
    factoryAddress?: StringWithAggregatesFilter<"DeployedContract"> | string
    deployerAddress?: StringWithAggregatesFilter<"DeployedContract"> | string
    txHash?: StringWithAggregatesFilter<"DeployedContract"> | string
    blockNumber?: IntWithAggregatesFilter<"DeployedContract"> | number
    metadataOption?: EnumMetadataOptionWithAggregatesFilter<"DeployedContract"> | $Enums.MetadataOption
    feeRecipient?: StringWithAggregatesFilter<"DeployedContract"> | string
    feeAmountEtnWei?: DecimalWithAggregatesFilter<"DeployedContract"> | Decimal | DecimalJsLike | number | string
    royaltyRecipient?: StringWithAggregatesFilter<"DeployedContract"> | string
    royaltyBps?: IntWithAggregatesFilter<"DeployedContract"> | number
    baseURI?: StringNullableWithAggregatesFilter<"DeployedContract"> | string | null
    maxSupply?: IntNullableWithAggregatesFilter<"DeployedContract"> | number | null
    rawInit?: JsonNullableWithAggregatesFilter<"DeployedContract">
    createdAt?: DateTimeWithAggregatesFilter<"DeployedContract"> | Date | string
    collectionId?: StringNullableWithAggregatesFilter<"DeployedContract"> | string | null
    single721Id?: StringNullableWithAggregatesFilter<"DeployedContract"> | string | null
    single1155Id?: StringNullableWithAggregatesFilter<"DeployedContract"> | string | null
  }

  export type FeeConfigWhereInput = {
    AND?: FeeConfigWhereInput | FeeConfigWhereInput[]
    OR?: FeeConfigWhereInput[]
    NOT?: FeeConfigWhereInput | FeeConfigWhereInput[]
    id?: StringFilter<"FeeConfig"> | string
    contractType?: EnumContractTypeFilter<"FeeConfig"> | $Enums.ContractType
    metadataOption?: EnumMetadataOptionFilter<"FeeConfig"> | $Enums.MetadataOption
    feeRecipient?: StringFilter<"FeeConfig"> | string
    feeAmountEtnWei?: DecimalFilter<"FeeConfig"> | Decimal | DecimalJsLike | number | string
    active?: BoolFilter<"FeeConfig"> | boolean
    createdAt?: DateTimeFilter<"FeeConfig"> | Date | string
    updatedAt?: DateTimeFilter<"FeeConfig"> | Date | string
    updatedByUserId?: StringNullableFilter<"FeeConfig"> | string | null
    targetUsdCents?: IntNullableFilter<"FeeConfig"> | number | null
    pricingSource?: StringFilter<"FeeConfig"> | string
    pricingPair?: StringFilter<"FeeConfig"> | string
    lastPriceUsd?: DecimalNullableFilter<"FeeConfig"> | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: DateTimeNullableFilter<"FeeConfig"> | Date | string | null
    logs?: FeeConfigLogListRelationFilter
  }

  export type FeeConfigOrderByWithRelationInput = {
    id?: SortOrder
    contractType?: SortOrder
    metadataOption?: SortOrder
    feeRecipient?: SortOrder
    feeAmountEtnWei?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    targetUsdCents?: SortOrderInput | SortOrder
    pricingSource?: SortOrder
    pricingPair?: SortOrder
    lastPriceUsd?: SortOrderInput | SortOrder
    lastPriceAt?: SortOrderInput | SortOrder
    logs?: FeeConfigLogOrderByRelationAggregateInput
  }

  export type FeeConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contractType_metadataOption?: FeeConfigContractTypeMetadataOptionCompoundUniqueInput
    AND?: FeeConfigWhereInput | FeeConfigWhereInput[]
    OR?: FeeConfigWhereInput[]
    NOT?: FeeConfigWhereInput | FeeConfigWhereInput[]
    contractType?: EnumContractTypeFilter<"FeeConfig"> | $Enums.ContractType
    metadataOption?: EnumMetadataOptionFilter<"FeeConfig"> | $Enums.MetadataOption
    feeRecipient?: StringFilter<"FeeConfig"> | string
    feeAmountEtnWei?: DecimalFilter<"FeeConfig"> | Decimal | DecimalJsLike | number | string
    active?: BoolFilter<"FeeConfig"> | boolean
    createdAt?: DateTimeFilter<"FeeConfig"> | Date | string
    updatedAt?: DateTimeFilter<"FeeConfig"> | Date | string
    updatedByUserId?: StringNullableFilter<"FeeConfig"> | string | null
    targetUsdCents?: IntNullableFilter<"FeeConfig"> | number | null
    pricingSource?: StringFilter<"FeeConfig"> | string
    pricingPair?: StringFilter<"FeeConfig"> | string
    lastPriceUsd?: DecimalNullableFilter<"FeeConfig"> | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: DateTimeNullableFilter<"FeeConfig"> | Date | string | null
    logs?: FeeConfigLogListRelationFilter
  }, "id" | "contractType_metadataOption">

  export type FeeConfigOrderByWithAggregationInput = {
    id?: SortOrder
    contractType?: SortOrder
    metadataOption?: SortOrder
    feeRecipient?: SortOrder
    feeAmountEtnWei?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    targetUsdCents?: SortOrderInput | SortOrder
    pricingSource?: SortOrder
    pricingPair?: SortOrder
    lastPriceUsd?: SortOrderInput | SortOrder
    lastPriceAt?: SortOrderInput | SortOrder
    _count?: FeeConfigCountOrderByAggregateInput
    _avg?: FeeConfigAvgOrderByAggregateInput
    _max?: FeeConfigMaxOrderByAggregateInput
    _min?: FeeConfigMinOrderByAggregateInput
    _sum?: FeeConfigSumOrderByAggregateInput
  }

  export type FeeConfigScalarWhereWithAggregatesInput = {
    AND?: FeeConfigScalarWhereWithAggregatesInput | FeeConfigScalarWhereWithAggregatesInput[]
    OR?: FeeConfigScalarWhereWithAggregatesInput[]
    NOT?: FeeConfigScalarWhereWithAggregatesInput | FeeConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeeConfig"> | string
    contractType?: EnumContractTypeWithAggregatesFilter<"FeeConfig"> | $Enums.ContractType
    metadataOption?: EnumMetadataOptionWithAggregatesFilter<"FeeConfig"> | $Enums.MetadataOption
    feeRecipient?: StringWithAggregatesFilter<"FeeConfig"> | string
    feeAmountEtnWei?: DecimalWithAggregatesFilter<"FeeConfig"> | Decimal | DecimalJsLike | number | string
    active?: BoolWithAggregatesFilter<"FeeConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FeeConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeeConfig"> | Date | string
    updatedByUserId?: StringNullableWithAggregatesFilter<"FeeConfig"> | string | null
    targetUsdCents?: IntNullableWithAggregatesFilter<"FeeConfig"> | number | null
    pricingSource?: StringWithAggregatesFilter<"FeeConfig"> | string
    pricingPair?: StringWithAggregatesFilter<"FeeConfig"> | string
    lastPriceUsd?: DecimalNullableWithAggregatesFilter<"FeeConfig"> | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: DateTimeNullableWithAggregatesFilter<"FeeConfig"> | Date | string | null
  }

  export type FeeConfigLogWhereInput = {
    AND?: FeeConfigLogWhereInput | FeeConfigLogWhereInput[]
    OR?: FeeConfigLogWhereInput[]
    NOT?: FeeConfigLogWhereInput | FeeConfigLogWhereInput[]
    id?: StringFilter<"FeeConfigLog"> | string
    feeConfigId?: StringFilter<"FeeConfigLog"> | string
    previousRecipient?: StringNullableFilter<"FeeConfigLog"> | string | null
    newRecipient?: StringNullableFilter<"FeeConfigLog"> | string | null
    previousAmountEtnWei?: DecimalNullableFilter<"FeeConfigLog"> | Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: DecimalNullableFilter<"FeeConfigLog"> | Decimal | DecimalJsLike | number | string | null
    changedByUserId?: StringNullableFilter<"FeeConfigLog"> | string | null
    reason?: StringNullableFilter<"FeeConfigLog"> | string | null
    createdAt?: DateTimeFilter<"FeeConfigLog"> | Date | string
    feeConfig?: XOR<FeeConfigScalarRelationFilter, FeeConfigWhereInput>
  }

  export type FeeConfigLogOrderByWithRelationInput = {
    id?: SortOrder
    feeConfigId?: SortOrder
    previousRecipient?: SortOrderInput | SortOrder
    newRecipient?: SortOrderInput | SortOrder
    previousAmountEtnWei?: SortOrderInput | SortOrder
    newAmountEtnWei?: SortOrderInput | SortOrder
    changedByUserId?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    feeConfig?: FeeConfigOrderByWithRelationInput
  }

  export type FeeConfigLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeeConfigLogWhereInput | FeeConfigLogWhereInput[]
    OR?: FeeConfigLogWhereInput[]
    NOT?: FeeConfigLogWhereInput | FeeConfigLogWhereInput[]
    feeConfigId?: StringFilter<"FeeConfigLog"> | string
    previousRecipient?: StringNullableFilter<"FeeConfigLog"> | string | null
    newRecipient?: StringNullableFilter<"FeeConfigLog"> | string | null
    previousAmountEtnWei?: DecimalNullableFilter<"FeeConfigLog"> | Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: DecimalNullableFilter<"FeeConfigLog"> | Decimal | DecimalJsLike | number | string | null
    changedByUserId?: StringNullableFilter<"FeeConfigLog"> | string | null
    reason?: StringNullableFilter<"FeeConfigLog"> | string | null
    createdAt?: DateTimeFilter<"FeeConfigLog"> | Date | string
    feeConfig?: XOR<FeeConfigScalarRelationFilter, FeeConfigWhereInput>
  }, "id">

  export type FeeConfigLogOrderByWithAggregationInput = {
    id?: SortOrder
    feeConfigId?: SortOrder
    previousRecipient?: SortOrderInput | SortOrder
    newRecipient?: SortOrderInput | SortOrder
    previousAmountEtnWei?: SortOrderInput | SortOrder
    newAmountEtnWei?: SortOrderInput | SortOrder
    changedByUserId?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FeeConfigLogCountOrderByAggregateInput
    _avg?: FeeConfigLogAvgOrderByAggregateInput
    _max?: FeeConfigLogMaxOrderByAggregateInput
    _min?: FeeConfigLogMinOrderByAggregateInput
    _sum?: FeeConfigLogSumOrderByAggregateInput
  }

  export type FeeConfigLogScalarWhereWithAggregatesInput = {
    AND?: FeeConfigLogScalarWhereWithAggregatesInput | FeeConfigLogScalarWhereWithAggregatesInput[]
    OR?: FeeConfigLogScalarWhereWithAggregatesInput[]
    NOT?: FeeConfigLogScalarWhereWithAggregatesInput | FeeConfigLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeeConfigLog"> | string
    feeConfigId?: StringWithAggregatesFilter<"FeeConfigLog"> | string
    previousRecipient?: StringNullableWithAggregatesFilter<"FeeConfigLog"> | string | null
    newRecipient?: StringNullableWithAggregatesFilter<"FeeConfigLog"> | string | null
    previousAmountEtnWei?: DecimalNullableWithAggregatesFilter<"FeeConfigLog"> | Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: DecimalNullableWithAggregatesFilter<"FeeConfigLog"> | Decimal | DecimalJsLike | number | string | null
    changedByUserId?: StringNullableWithAggregatesFilter<"FeeConfigLog"> | string | null
    reason?: StringNullableWithAggregatesFilter<"FeeConfigLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FeeConfigLog"> | Date | string
  }

  export type PublicSaleWhereInput = {
    AND?: PublicSaleWhereInput | PublicSaleWhereInput[]
    OR?: PublicSaleWhereInput[]
    NOT?: PublicSaleWhereInput | PublicSaleWhereInput[]
    id?: StringFilter<"PublicSale"> | string
    collectionId?: StringFilter<"PublicSale"> | string
    startTime?: DateTimeFilter<"PublicSale"> | Date | string
    priceEtnWei?: DecimalFilter<"PublicSale"> | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFilter<"PublicSale"> | number
    maxPerTx?: IntFilter<"PublicSale"> | number
    createdAt?: DateTimeFilter<"PublicSale"> | Date | string
    updatedAt?: DateTimeFilter<"PublicSale"> | Date | string
    collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>
  }

  export type PublicSaleOrderByWithRelationInput = {
    id?: SortOrder
    collectionId?: SortOrder
    startTime?: SortOrder
    priceEtnWei?: SortOrder
    maxPerWallet?: SortOrder
    maxPerTx?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collection?: CollectionOrderByWithRelationInput
  }

  export type PublicSaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    collectionId?: string
    AND?: PublicSaleWhereInput | PublicSaleWhereInput[]
    OR?: PublicSaleWhereInput[]
    NOT?: PublicSaleWhereInput | PublicSaleWhereInput[]
    startTime?: DateTimeFilter<"PublicSale"> | Date | string
    priceEtnWei?: DecimalFilter<"PublicSale"> | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFilter<"PublicSale"> | number
    maxPerTx?: IntFilter<"PublicSale"> | number
    createdAt?: DateTimeFilter<"PublicSale"> | Date | string
    updatedAt?: DateTimeFilter<"PublicSale"> | Date | string
    collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>
  }, "id" | "collectionId">

  export type PublicSaleOrderByWithAggregationInput = {
    id?: SortOrder
    collectionId?: SortOrder
    startTime?: SortOrder
    priceEtnWei?: SortOrder
    maxPerWallet?: SortOrder
    maxPerTx?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PublicSaleCountOrderByAggregateInput
    _avg?: PublicSaleAvgOrderByAggregateInput
    _max?: PublicSaleMaxOrderByAggregateInput
    _min?: PublicSaleMinOrderByAggregateInput
    _sum?: PublicSaleSumOrderByAggregateInput
  }

  export type PublicSaleScalarWhereWithAggregatesInput = {
    AND?: PublicSaleScalarWhereWithAggregatesInput | PublicSaleScalarWhereWithAggregatesInput[]
    OR?: PublicSaleScalarWhereWithAggregatesInput[]
    NOT?: PublicSaleScalarWhereWithAggregatesInput | PublicSaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PublicSale"> | string
    collectionId?: StringWithAggregatesFilter<"PublicSale"> | string
    startTime?: DateTimeWithAggregatesFilter<"PublicSale"> | Date | string
    priceEtnWei?: DecimalWithAggregatesFilter<"PublicSale"> | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntWithAggregatesFilter<"PublicSale"> | number
    maxPerTx?: IntWithAggregatesFilter<"PublicSale"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PublicSale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PublicSale"> | Date | string
  }

  export type PresaleWhereInput = {
    AND?: PresaleWhereInput | PresaleWhereInput[]
    OR?: PresaleWhereInput[]
    NOT?: PresaleWhereInput | PresaleWhereInput[]
    id?: StringFilter<"Presale"> | string
    collectionId?: StringFilter<"Presale"> | string
    startTime?: DateTimeFilter<"Presale"> | Date | string
    endTime?: DateTimeFilter<"Presale"> | Date | string
    priceEtnWei?: DecimalFilter<"Presale"> | Decimal | DecimalJsLike | number | string
    maxSupply?: IntFilter<"Presale"> | number
    merkleRoot?: StringFilter<"Presale"> | string
    whitelistCount?: IntNullableFilter<"Presale"> | number | null
    allowlistCommit?: StringNullableFilter<"Presale"> | string | null
    createdAt?: DateTimeFilter<"Presale"> | Date | string
    updatedAt?: DateTimeFilter<"Presale"> | Date | string
    collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>
    whitelist?: PresaleWhitelistAddressListRelationFilter
  }

  export type PresaleOrderByWithRelationInput = {
    id?: SortOrder
    collectionId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    priceEtnWei?: SortOrder
    maxSupply?: SortOrder
    merkleRoot?: SortOrder
    whitelistCount?: SortOrderInput | SortOrder
    allowlistCommit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collection?: CollectionOrderByWithRelationInput
    whitelist?: PresaleWhitelistAddressOrderByRelationAggregateInput
  }

  export type PresaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    collectionId?: string
    AND?: PresaleWhereInput | PresaleWhereInput[]
    OR?: PresaleWhereInput[]
    NOT?: PresaleWhereInput | PresaleWhereInput[]
    startTime?: DateTimeFilter<"Presale"> | Date | string
    endTime?: DateTimeFilter<"Presale"> | Date | string
    priceEtnWei?: DecimalFilter<"Presale"> | Decimal | DecimalJsLike | number | string
    maxSupply?: IntFilter<"Presale"> | number
    merkleRoot?: StringFilter<"Presale"> | string
    whitelistCount?: IntNullableFilter<"Presale"> | number | null
    allowlistCommit?: StringNullableFilter<"Presale"> | string | null
    createdAt?: DateTimeFilter<"Presale"> | Date | string
    updatedAt?: DateTimeFilter<"Presale"> | Date | string
    collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>
    whitelist?: PresaleWhitelistAddressListRelationFilter
  }, "id" | "collectionId">

  export type PresaleOrderByWithAggregationInput = {
    id?: SortOrder
    collectionId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    priceEtnWei?: SortOrder
    maxSupply?: SortOrder
    merkleRoot?: SortOrder
    whitelistCount?: SortOrderInput | SortOrder
    allowlistCommit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PresaleCountOrderByAggregateInput
    _avg?: PresaleAvgOrderByAggregateInput
    _max?: PresaleMaxOrderByAggregateInput
    _min?: PresaleMinOrderByAggregateInput
    _sum?: PresaleSumOrderByAggregateInput
  }

  export type PresaleScalarWhereWithAggregatesInput = {
    AND?: PresaleScalarWhereWithAggregatesInput | PresaleScalarWhereWithAggregatesInput[]
    OR?: PresaleScalarWhereWithAggregatesInput[]
    NOT?: PresaleScalarWhereWithAggregatesInput | PresaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Presale"> | string
    collectionId?: StringWithAggregatesFilter<"Presale"> | string
    startTime?: DateTimeWithAggregatesFilter<"Presale"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Presale"> | Date | string
    priceEtnWei?: DecimalWithAggregatesFilter<"Presale"> | Decimal | DecimalJsLike | number | string
    maxSupply?: IntWithAggregatesFilter<"Presale"> | number
    merkleRoot?: StringWithAggregatesFilter<"Presale"> | string
    whitelistCount?: IntNullableWithAggregatesFilter<"Presale"> | number | null
    allowlistCommit?: StringNullableWithAggregatesFilter<"Presale"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Presale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Presale"> | Date | string
  }

  export type PresaleWhitelistAddressWhereInput = {
    AND?: PresaleWhitelistAddressWhereInput | PresaleWhitelistAddressWhereInput[]
    OR?: PresaleWhitelistAddressWhereInput[]
    NOT?: PresaleWhitelistAddressWhereInput | PresaleWhitelistAddressWhereInput[]
    id?: StringFilter<"PresaleWhitelistAddress"> | string
    presaleId?: StringFilter<"PresaleWhitelistAddress"> | string
    address?: StringFilter<"PresaleWhitelistAddress"> | string
    maxAllocation?: IntNullableFilter<"PresaleWhitelistAddress"> | number | null
    presale?: XOR<PresaleScalarRelationFilter, PresaleWhereInput>
  }

  export type PresaleWhitelistAddressOrderByWithRelationInput = {
    id?: SortOrder
    presaleId?: SortOrder
    address?: SortOrder
    maxAllocation?: SortOrderInput | SortOrder
    presale?: PresaleOrderByWithRelationInput
  }

  export type PresaleWhitelistAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    presaleId_address?: PresaleWhitelistAddressPresaleIdAddressCompoundUniqueInput
    AND?: PresaleWhitelistAddressWhereInput | PresaleWhitelistAddressWhereInput[]
    OR?: PresaleWhitelistAddressWhereInput[]
    NOT?: PresaleWhitelistAddressWhereInput | PresaleWhitelistAddressWhereInput[]
    presaleId?: StringFilter<"PresaleWhitelistAddress"> | string
    address?: StringFilter<"PresaleWhitelistAddress"> | string
    maxAllocation?: IntNullableFilter<"PresaleWhitelistAddress"> | number | null
    presale?: XOR<PresaleScalarRelationFilter, PresaleWhereInput>
  }, "id" | "presaleId_address">

  export type PresaleWhitelistAddressOrderByWithAggregationInput = {
    id?: SortOrder
    presaleId?: SortOrder
    address?: SortOrder
    maxAllocation?: SortOrderInput | SortOrder
    _count?: PresaleWhitelistAddressCountOrderByAggregateInput
    _avg?: PresaleWhitelistAddressAvgOrderByAggregateInput
    _max?: PresaleWhitelistAddressMaxOrderByAggregateInput
    _min?: PresaleWhitelistAddressMinOrderByAggregateInput
    _sum?: PresaleWhitelistAddressSumOrderByAggregateInput
  }

  export type PresaleWhitelistAddressScalarWhereWithAggregatesInput = {
    AND?: PresaleWhitelistAddressScalarWhereWithAggregatesInput | PresaleWhitelistAddressScalarWhereWithAggregatesInput[]
    OR?: PresaleWhitelistAddressScalarWhereWithAggregatesInput[]
    NOT?: PresaleWhitelistAddressScalarWhereWithAggregatesInput | PresaleWhitelistAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PresaleWhitelistAddress"> | string
    presaleId?: StringWithAggregatesFilter<"PresaleWhitelistAddress"> | string
    address?: StringWithAggregatesFilter<"PresaleWhitelistAddress"> | string
    maxAllocation?: IntNullableWithAggregatesFilter<"PresaleWhitelistAddress"> | number | null
  }

  export type PresaleDraftWhereInput = {
    AND?: PresaleDraftWhereInput | PresaleDraftWhereInput[]
    OR?: PresaleDraftWhereInput[]
    NOT?: PresaleDraftWhereInput | PresaleDraftWhereInput[]
    id?: StringFilter<"PresaleDraft"> | string
    creatorUserId?: StringFilter<"PresaleDraft"> | string
    addresses?: JsonFilter<"PresaleDraft">
    count?: IntFilter<"PresaleDraft"> | number
    merkleRoot?: StringFilter<"PresaleDraft"> | string
    sha256Commit?: StringFilter<"PresaleDraft"> | string
    status?: EnumDraftStatusFilter<"PresaleDraft"> | $Enums.DraftStatus
    consumedAt?: DateTimeNullableFilter<"PresaleDraft"> | Date | string | null
    consumedByPresaleId?: StringNullableFilter<"PresaleDraft"> | string | null
    createdAt?: DateTimeFilter<"PresaleDraft"> | Date | string
    expiresAt?: DateTimeNullableFilter<"PresaleDraft"> | Date | string | null
  }

  export type PresaleDraftOrderByWithRelationInput = {
    id?: SortOrder
    creatorUserId?: SortOrder
    addresses?: SortOrder
    count?: SortOrder
    merkleRoot?: SortOrder
    sha256Commit?: SortOrder
    status?: SortOrder
    consumedAt?: SortOrderInput | SortOrder
    consumedByPresaleId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
  }

  export type PresaleDraftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sha256Commit?: string
    AND?: PresaleDraftWhereInput | PresaleDraftWhereInput[]
    OR?: PresaleDraftWhereInput[]
    NOT?: PresaleDraftWhereInput | PresaleDraftWhereInput[]
    creatorUserId?: StringFilter<"PresaleDraft"> | string
    addresses?: JsonFilter<"PresaleDraft">
    count?: IntFilter<"PresaleDraft"> | number
    merkleRoot?: StringFilter<"PresaleDraft"> | string
    status?: EnumDraftStatusFilter<"PresaleDraft"> | $Enums.DraftStatus
    consumedAt?: DateTimeNullableFilter<"PresaleDraft"> | Date | string | null
    consumedByPresaleId?: StringNullableFilter<"PresaleDraft"> | string | null
    createdAt?: DateTimeFilter<"PresaleDraft"> | Date | string
    expiresAt?: DateTimeNullableFilter<"PresaleDraft"> | Date | string | null
  }, "id" | "sha256Commit">

  export type PresaleDraftOrderByWithAggregationInput = {
    id?: SortOrder
    creatorUserId?: SortOrder
    addresses?: SortOrder
    count?: SortOrder
    merkleRoot?: SortOrder
    sha256Commit?: SortOrder
    status?: SortOrder
    consumedAt?: SortOrderInput | SortOrder
    consumedByPresaleId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: PresaleDraftCountOrderByAggregateInput
    _avg?: PresaleDraftAvgOrderByAggregateInput
    _max?: PresaleDraftMaxOrderByAggregateInput
    _min?: PresaleDraftMinOrderByAggregateInput
    _sum?: PresaleDraftSumOrderByAggregateInput
  }

  export type PresaleDraftScalarWhereWithAggregatesInput = {
    AND?: PresaleDraftScalarWhereWithAggregatesInput | PresaleDraftScalarWhereWithAggregatesInput[]
    OR?: PresaleDraftScalarWhereWithAggregatesInput[]
    NOT?: PresaleDraftScalarWhereWithAggregatesInput | PresaleDraftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PresaleDraft"> | string
    creatorUserId?: StringWithAggregatesFilter<"PresaleDraft"> | string
    addresses?: JsonWithAggregatesFilter<"PresaleDraft">
    count?: IntWithAggregatesFilter<"PresaleDraft"> | number
    merkleRoot?: StringWithAggregatesFilter<"PresaleDraft"> | string
    sha256Commit?: StringWithAggregatesFilter<"PresaleDraft"> | string
    status?: EnumDraftStatusWithAggregatesFilter<"PresaleDraft"> | $Enums.DraftStatus
    consumedAt?: DateTimeNullableWithAggregatesFilter<"PresaleDraft"> | Date | string | null
    consumedByPresaleId?: StringNullableWithAggregatesFilter<"PresaleDraft"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PresaleDraft"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PresaleDraft"> | Date | string | null
  }

  export type AssetUploadWhereInput = {
    AND?: AssetUploadWhereInput | AssetUploadWhereInput[]
    OR?: AssetUploadWhereInput[]
    NOT?: AssetUploadWhereInput | AssetUploadWhereInput[]
    id?: StringFilter<"AssetUpload"> | string
    uploaderUserId?: StringNullableFilter<"AssetUpload"> | string | null
    collectionId?: StringNullableFilter<"AssetUpload"> | string | null
    single721Id?: StringNullableFilter<"AssetUpload"> | string | null
    single1155Id?: StringNullableFilter<"AssetUpload"> | string | null
    provider?: StringFilter<"AssetUpload"> | string
    cid?: StringFilter<"AssetUpload"> | string
    url?: StringNullableFilter<"AssetUpload"> | string | null
    bytes?: IntNullableFilter<"AssetUpload"> | number | null
    sha256?: StringNullableFilter<"AssetUpload"> | string | null
    contentType?: StringNullableFilter<"AssetUpload"> | string | null
    originalName?: StringNullableFilter<"AssetUpload"> | string | null
    createdAt?: DateTimeFilter<"AssetUpload"> | Date | string
    collection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null
    single1155?: XOR<Single1155NullableScalarRelationFilter, Single1155WhereInput> | null
    single721?: XOR<Single721NullableScalarRelationFilter, Single721WhereInput> | null
  }

  export type AssetUploadOrderByWithRelationInput = {
    id?: SortOrder
    uploaderUserId?: SortOrderInput | SortOrder
    collectionId?: SortOrderInput | SortOrder
    single721Id?: SortOrderInput | SortOrder
    single1155Id?: SortOrderInput | SortOrder
    provider?: SortOrder
    cid?: SortOrder
    url?: SortOrderInput | SortOrder
    bytes?: SortOrderInput | SortOrder
    sha256?: SortOrderInput | SortOrder
    contentType?: SortOrderInput | SortOrder
    originalName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    collection?: CollectionOrderByWithRelationInput
    single1155?: Single1155OrderByWithRelationInput
    single721?: Single721OrderByWithRelationInput
  }

  export type AssetUploadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssetUploadWhereInput | AssetUploadWhereInput[]
    OR?: AssetUploadWhereInput[]
    NOT?: AssetUploadWhereInput | AssetUploadWhereInput[]
    uploaderUserId?: StringNullableFilter<"AssetUpload"> | string | null
    collectionId?: StringNullableFilter<"AssetUpload"> | string | null
    single721Id?: StringNullableFilter<"AssetUpload"> | string | null
    single1155Id?: StringNullableFilter<"AssetUpload"> | string | null
    provider?: StringFilter<"AssetUpload"> | string
    cid?: StringFilter<"AssetUpload"> | string
    url?: StringNullableFilter<"AssetUpload"> | string | null
    bytes?: IntNullableFilter<"AssetUpload"> | number | null
    sha256?: StringNullableFilter<"AssetUpload"> | string | null
    contentType?: StringNullableFilter<"AssetUpload"> | string | null
    originalName?: StringNullableFilter<"AssetUpload"> | string | null
    createdAt?: DateTimeFilter<"AssetUpload"> | Date | string
    collection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null
    single1155?: XOR<Single1155NullableScalarRelationFilter, Single1155WhereInput> | null
    single721?: XOR<Single721NullableScalarRelationFilter, Single721WhereInput> | null
  }, "id">

  export type AssetUploadOrderByWithAggregationInput = {
    id?: SortOrder
    uploaderUserId?: SortOrderInput | SortOrder
    collectionId?: SortOrderInput | SortOrder
    single721Id?: SortOrderInput | SortOrder
    single1155Id?: SortOrderInput | SortOrder
    provider?: SortOrder
    cid?: SortOrder
    url?: SortOrderInput | SortOrder
    bytes?: SortOrderInput | SortOrder
    sha256?: SortOrderInput | SortOrder
    contentType?: SortOrderInput | SortOrder
    originalName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AssetUploadCountOrderByAggregateInput
    _avg?: AssetUploadAvgOrderByAggregateInput
    _max?: AssetUploadMaxOrderByAggregateInput
    _min?: AssetUploadMinOrderByAggregateInput
    _sum?: AssetUploadSumOrderByAggregateInput
  }

  export type AssetUploadScalarWhereWithAggregatesInput = {
    AND?: AssetUploadScalarWhereWithAggregatesInput | AssetUploadScalarWhereWithAggregatesInput[]
    OR?: AssetUploadScalarWhereWithAggregatesInput[]
    NOT?: AssetUploadScalarWhereWithAggregatesInput | AssetUploadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssetUpload"> | string
    uploaderUserId?: StringNullableWithAggregatesFilter<"AssetUpload"> | string | null
    collectionId?: StringNullableWithAggregatesFilter<"AssetUpload"> | string | null
    single721Id?: StringNullableWithAggregatesFilter<"AssetUpload"> | string | null
    single1155Id?: StringNullableWithAggregatesFilter<"AssetUpload"> | string | null
    provider?: StringWithAggregatesFilter<"AssetUpload"> | string
    cid?: StringWithAggregatesFilter<"AssetUpload"> | string
    url?: StringNullableWithAggregatesFilter<"AssetUpload"> | string | null
    bytes?: IntNullableWithAggregatesFilter<"AssetUpload"> | number | null
    sha256?: StringNullableWithAggregatesFilter<"AssetUpload"> | string | null
    contentType?: StringNullableWithAggregatesFilter<"AssetUpload"> | string | null
    originalName?: StringNullableWithAggregatesFilter<"AssetUpload"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AssetUpload"> | Date | string
  }

  export type CollectionSubmissionWhereInput = {
    AND?: CollectionSubmissionWhereInput | CollectionSubmissionWhereInput[]
    OR?: CollectionSubmissionWhereInput[]
    NOT?: CollectionSubmissionWhereInput | CollectionSubmissionWhereInput[]
    id?: StringFilter<"CollectionSubmission"> | string
    submittedByUserId?: StringFilter<"CollectionSubmission"> | string
    contract?: StringFilter<"CollectionSubmission"> | string
    ownerAddress?: StringNullableFilter<"CollectionSubmission"> | string | null
    name?: StringNullableFilter<"CollectionSubmission"> | string | null
    symbol?: StringNullableFilter<"CollectionSubmission"> | string | null
    logoUrl?: StringNullableFilter<"CollectionSubmission"> | string | null
    coverUrl?: StringNullableFilter<"CollectionSubmission"> | string | null
    baseUri?: StringNullableFilter<"CollectionSubmission"> | string | null
    supply?: IntNullableFilter<"CollectionSubmission"> | number | null
    description?: StringNullableFilter<"CollectionSubmission"> | string | null
    website?: StringNullableFilter<"CollectionSubmission"> | string | null
    x?: StringNullableFilter<"CollectionSubmission"> | string | null
    instagram?: StringNullableFilter<"CollectionSubmission"> | string | null
    telegram?: StringNullableFilter<"CollectionSubmission"> | string | null
    feeTxHash?: StringNullableFilter<"CollectionSubmission"> | string | null
    feePaidWei?: DecimalNullableFilter<"CollectionSubmission"> | Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: DateTimeNullableFilter<"CollectionSubmission"> | Date | string | null
    ownershipVerified?: BoolFilter<"CollectionSubmission"> | boolean
    status?: EnumSubmissionStatusFilter<"CollectionSubmission"> | $Enums.SubmissionStatus
    statusReason?: StringNullableFilter<"CollectionSubmission"> | string | null
    reviewedByUserId?: StringNullableFilter<"CollectionSubmission"> | string | null
    reviewedAt?: DateTimeNullableFilter<"CollectionSubmission"> | Date | string | null
    createdAt?: DateTimeFilter<"CollectionSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionSubmission"> | Date | string
    submittedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CollectionSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    submittedByUserId?: SortOrder
    contract?: SortOrder
    ownerAddress?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    baseUri?: SortOrderInput | SortOrder
    supply?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    feeTxHash?: SortOrderInput | SortOrder
    feePaidWei?: SortOrderInput | SortOrder
    feeVerifiedAt?: SortOrderInput | SortOrder
    ownershipVerified?: SortOrder
    status?: SortOrder
    statusReason?: SortOrderInput | SortOrder
    reviewedByUserId?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submittedBy?: UserOrderByWithRelationInput
  }

  export type CollectionSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contract?: string
    feeTxHash?: string
    AND?: CollectionSubmissionWhereInput | CollectionSubmissionWhereInput[]
    OR?: CollectionSubmissionWhereInput[]
    NOT?: CollectionSubmissionWhereInput | CollectionSubmissionWhereInput[]
    submittedByUserId?: StringFilter<"CollectionSubmission"> | string
    ownerAddress?: StringNullableFilter<"CollectionSubmission"> | string | null
    name?: StringNullableFilter<"CollectionSubmission"> | string | null
    symbol?: StringNullableFilter<"CollectionSubmission"> | string | null
    logoUrl?: StringNullableFilter<"CollectionSubmission"> | string | null
    coverUrl?: StringNullableFilter<"CollectionSubmission"> | string | null
    baseUri?: StringNullableFilter<"CollectionSubmission"> | string | null
    supply?: IntNullableFilter<"CollectionSubmission"> | number | null
    description?: StringNullableFilter<"CollectionSubmission"> | string | null
    website?: StringNullableFilter<"CollectionSubmission"> | string | null
    x?: StringNullableFilter<"CollectionSubmission"> | string | null
    instagram?: StringNullableFilter<"CollectionSubmission"> | string | null
    telegram?: StringNullableFilter<"CollectionSubmission"> | string | null
    feePaidWei?: DecimalNullableFilter<"CollectionSubmission"> | Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: DateTimeNullableFilter<"CollectionSubmission"> | Date | string | null
    ownershipVerified?: BoolFilter<"CollectionSubmission"> | boolean
    status?: EnumSubmissionStatusFilter<"CollectionSubmission"> | $Enums.SubmissionStatus
    statusReason?: StringNullableFilter<"CollectionSubmission"> | string | null
    reviewedByUserId?: StringNullableFilter<"CollectionSubmission"> | string | null
    reviewedAt?: DateTimeNullableFilter<"CollectionSubmission"> | Date | string | null
    createdAt?: DateTimeFilter<"CollectionSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionSubmission"> | Date | string
    submittedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "contract" | "feeTxHash">

  export type CollectionSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    submittedByUserId?: SortOrder
    contract?: SortOrder
    ownerAddress?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    symbol?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    baseUri?: SortOrderInput | SortOrder
    supply?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    x?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    telegram?: SortOrderInput | SortOrder
    feeTxHash?: SortOrderInput | SortOrder
    feePaidWei?: SortOrderInput | SortOrder
    feeVerifiedAt?: SortOrderInput | SortOrder
    ownershipVerified?: SortOrder
    status?: SortOrder
    statusReason?: SortOrderInput | SortOrder
    reviewedByUserId?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CollectionSubmissionCountOrderByAggregateInput
    _avg?: CollectionSubmissionAvgOrderByAggregateInput
    _max?: CollectionSubmissionMaxOrderByAggregateInput
    _min?: CollectionSubmissionMinOrderByAggregateInput
    _sum?: CollectionSubmissionSumOrderByAggregateInput
  }

  export type CollectionSubmissionScalarWhereWithAggregatesInput = {
    AND?: CollectionSubmissionScalarWhereWithAggregatesInput | CollectionSubmissionScalarWhereWithAggregatesInput[]
    OR?: CollectionSubmissionScalarWhereWithAggregatesInput[]
    NOT?: CollectionSubmissionScalarWhereWithAggregatesInput | CollectionSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CollectionSubmission"> | string
    submittedByUserId?: StringWithAggregatesFilter<"CollectionSubmission"> | string
    contract?: StringWithAggregatesFilter<"CollectionSubmission"> | string
    ownerAddress?: StringNullableWithAggregatesFilter<"CollectionSubmission"> | string | null
    name?: StringNullableWithAggregatesFilter<"CollectionSubmission"> | string | null
    symbol?: StringNullableWithAggregatesFilter<"CollectionSubmission"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"CollectionSubmission"> | string | null
    coverUrl?: StringNullableWithAggregatesFilter<"CollectionSubmission"> | string | null
    baseUri?: StringNullableWithAggregatesFilter<"CollectionSubmission"> | string | null
    supply?: IntNullableWithAggregatesFilter<"CollectionSubmission"> | number | null
    description?: StringNullableWithAggregatesFilter<"CollectionSubmission"> | string | null
    website?: StringNullableWithAggregatesFilter<"CollectionSubmission"> | string | null
    x?: StringNullableWithAggregatesFilter<"CollectionSubmission"> | string | null
    instagram?: StringNullableWithAggregatesFilter<"CollectionSubmission"> | string | null
    telegram?: StringNullableWithAggregatesFilter<"CollectionSubmission"> | string | null
    feeTxHash?: StringNullableWithAggregatesFilter<"CollectionSubmission"> | string | null
    feePaidWei?: DecimalNullableWithAggregatesFilter<"CollectionSubmission"> | Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: DateTimeNullableWithAggregatesFilter<"CollectionSubmission"> | Date | string | null
    ownershipVerified?: BoolWithAggregatesFilter<"CollectionSubmission"> | boolean
    status?: EnumSubmissionStatusWithAggregatesFilter<"CollectionSubmission"> | $Enums.SubmissionStatus
    statusReason?: StringNullableWithAggregatesFilter<"CollectionSubmission"> | string | null
    reviewedByUserId?: StringNullableWithAggregatesFilter<"CollectionSubmission"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"CollectionSubmission"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CollectionSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CollectionSubmission"> | Date | string
  }

  export type NFTRarityWhereInput = {
    AND?: NFTRarityWhereInput | NFTRarityWhereInput[]
    OR?: NFTRarityWhereInput[]
    NOT?: NFTRarityWhereInput | NFTRarityWhereInput[]
    contract?: StringFilter<"NFTRarity"> | string
    tokenId?: StringFilter<"NFTRarity"> | string
    score?: DecimalFilter<"NFTRarity"> | Decimal | DecimalJsLike | number | string
    rank?: IntFilter<"NFTRarity"> | number
    updatedAt?: DateTimeFilter<"NFTRarity"> | Date | string
  }

  export type NFTRarityOrderByWithRelationInput = {
    contract?: SortOrder
    tokenId?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    updatedAt?: SortOrder
  }

  export type NFTRarityWhereUniqueInput = Prisma.AtLeast<{
    contract_tokenId?: NFTRarityContractTokenIdCompoundUniqueInput
    AND?: NFTRarityWhereInput | NFTRarityWhereInput[]
    OR?: NFTRarityWhereInput[]
    NOT?: NFTRarityWhereInput | NFTRarityWhereInput[]
    contract?: StringFilter<"NFTRarity"> | string
    tokenId?: StringFilter<"NFTRarity"> | string
    score?: DecimalFilter<"NFTRarity"> | Decimal | DecimalJsLike | number | string
    rank?: IntFilter<"NFTRarity"> | number
    updatedAt?: DateTimeFilter<"NFTRarity"> | Date | string
  }, "contract_tokenId">

  export type NFTRarityOrderByWithAggregationInput = {
    contract?: SortOrder
    tokenId?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    updatedAt?: SortOrder
    _count?: NFTRarityCountOrderByAggregateInput
    _avg?: NFTRarityAvgOrderByAggregateInput
    _max?: NFTRarityMaxOrderByAggregateInput
    _min?: NFTRarityMinOrderByAggregateInput
    _sum?: NFTRaritySumOrderByAggregateInput
  }

  export type NFTRarityScalarWhereWithAggregatesInput = {
    AND?: NFTRarityScalarWhereWithAggregatesInput | NFTRarityScalarWhereWithAggregatesInput[]
    OR?: NFTRarityScalarWhereWithAggregatesInput[]
    NOT?: NFTRarityScalarWhereWithAggregatesInput | NFTRarityScalarWhereWithAggregatesInput[]
    contract?: StringWithAggregatesFilter<"NFTRarity"> | string
    tokenId?: StringWithAggregatesFilter<"NFTRarity"> | string
    score?: DecimalWithAggregatesFilter<"NFTRarity"> | Decimal | DecimalJsLike | number | string
    rank?: IntWithAggregatesFilter<"NFTRarity"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"NFTRarity"> | Date | string
  }

  export type HolderRewardWhereInput = {
    AND?: HolderRewardWhereInput | HolderRewardWhereInput[]
    OR?: HolderRewardWhereInput[]
    NOT?: HolderRewardWhereInput | HolderRewardWhereInput[]
    user_id?: StringFilter<"HolderReward"> | string
    wallet_address?: StringNullableFilter<"HolderReward"> | string | null
    last_acc_per_token?: DecimalFilter<"HolderReward"> | Decimal | DecimalJsLike | number | string
    claimed_etn?: DecimalFilter<"HolderReward"> | Decimal | DecimalJsLike | number | string
    updated_at?: DateTimeFilter<"HolderReward"> | Date | string
  }

  export type HolderRewardOrderByWithRelationInput = {
    user_id?: SortOrder
    wallet_address?: SortOrderInput | SortOrder
    last_acc_per_token?: SortOrder
    claimed_etn?: SortOrder
    updated_at?: SortOrder
  }

  export type HolderRewardWhereUniqueInput = Prisma.AtLeast<{
    user_id?: string
    wallet_address?: string
    AND?: HolderRewardWhereInput | HolderRewardWhereInput[]
    OR?: HolderRewardWhereInput[]
    NOT?: HolderRewardWhereInput | HolderRewardWhereInput[]
    last_acc_per_token?: DecimalFilter<"HolderReward"> | Decimal | DecimalJsLike | number | string
    claimed_etn?: DecimalFilter<"HolderReward"> | Decimal | DecimalJsLike | number | string
    updated_at?: DateTimeFilter<"HolderReward"> | Date | string
  }, "user_id" | "wallet_address">

  export type HolderRewardOrderByWithAggregationInput = {
    user_id?: SortOrder
    wallet_address?: SortOrderInput | SortOrder
    last_acc_per_token?: SortOrder
    claimed_etn?: SortOrder
    updated_at?: SortOrder
    _count?: HolderRewardCountOrderByAggregateInput
    _avg?: HolderRewardAvgOrderByAggregateInput
    _max?: HolderRewardMaxOrderByAggregateInput
    _min?: HolderRewardMinOrderByAggregateInput
    _sum?: HolderRewardSumOrderByAggregateInput
  }

  export type HolderRewardScalarWhereWithAggregatesInput = {
    AND?: HolderRewardScalarWhereWithAggregatesInput | HolderRewardScalarWhereWithAggregatesInput[]
    OR?: HolderRewardScalarWhereWithAggregatesInput[]
    NOT?: HolderRewardScalarWhereWithAggregatesInput | HolderRewardScalarWhereWithAggregatesInput[]
    user_id?: StringWithAggregatesFilter<"HolderReward"> | string
    wallet_address?: StringNullableWithAggregatesFilter<"HolderReward"> | string | null
    last_acc_per_token?: DecimalWithAggregatesFilter<"HolderReward"> | Decimal | DecimalJsLike | number | string
    claimed_etn?: DecimalWithAggregatesFilter<"HolderReward"> | Decimal | DecimalJsLike | number | string
    updated_at?: DateTimeWithAggregatesFilter<"HolderReward"> | Date | string
  }

  export type RewardAccumulatorWhereInput = {
    AND?: RewardAccumulatorWhereInput | RewardAccumulatorWhereInput[]
    OR?: RewardAccumulatorWhereInput[]
    NOT?: RewardAccumulatorWhereInput | RewardAccumulatorWhereInput[]
    id?: StringFilter<"RewardAccumulator"> | string
    acc_per_token?: DecimalFilter<"RewardAccumulator"> | Decimal | DecimalJsLike | number | string
    updated_at?: DateTimeFilter<"RewardAccumulator"> | Date | string
  }

  export type RewardAccumulatorOrderByWithRelationInput = {
    id?: SortOrder
    acc_per_token?: SortOrder
    updated_at?: SortOrder
  }

  export type RewardAccumulatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RewardAccumulatorWhereInput | RewardAccumulatorWhereInput[]
    OR?: RewardAccumulatorWhereInput[]
    NOT?: RewardAccumulatorWhereInput | RewardAccumulatorWhereInput[]
    acc_per_token?: DecimalFilter<"RewardAccumulator"> | Decimal | DecimalJsLike | number | string
    updated_at?: DateTimeFilter<"RewardAccumulator"> | Date | string
  }, "id">

  export type RewardAccumulatorOrderByWithAggregationInput = {
    id?: SortOrder
    acc_per_token?: SortOrder
    updated_at?: SortOrder
    _count?: RewardAccumulatorCountOrderByAggregateInput
    _avg?: RewardAccumulatorAvgOrderByAggregateInput
    _max?: RewardAccumulatorMaxOrderByAggregateInput
    _min?: RewardAccumulatorMinOrderByAggregateInput
    _sum?: RewardAccumulatorSumOrderByAggregateInput
  }

  export type RewardAccumulatorScalarWhereWithAggregatesInput = {
    AND?: RewardAccumulatorScalarWhereWithAggregatesInput | RewardAccumulatorScalarWhereWithAggregatesInput[]
    OR?: RewardAccumulatorScalarWhereWithAggregatesInput[]
    NOT?: RewardAccumulatorScalarWhereWithAggregatesInput | RewardAccumulatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RewardAccumulator"> | string
    acc_per_token?: DecimalWithAggregatesFilter<"RewardAccumulator"> | Decimal | DecimalJsLike | number | string
    updated_at?: DateTimeWithAggregatesFilter<"RewardAccumulator"> | Date | string
  }

  export type FeaturedCycleWhereInput = {
    AND?: FeaturedCycleWhereInput | FeaturedCycleWhereInput[]
    OR?: FeaturedCycleWhereInput[]
    NOT?: FeaturedCycleWhereInput | FeaturedCycleWhereInput[]
    id?: StringFilter<"FeaturedCycle"> | string
    cycleId?: StringFilter<"FeaturedCycle"> | string
    startAt?: DateTimeFilter<"FeaturedCycle"> | Date | string
    endAt?: DateTimeFilter<"FeaturedCycle"> | Date | string
    status?: EnumFeaturedCycleStatusFilter<"FeaturedCycle"> | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalFilter<"FeaturedCycle"> | Decimal | DecimalJsLike | number | string
    winnerBidId?: StringNullableFilter<"FeaturedCycle"> | string | null
    winnerCollectionContract?: StringNullableFilter<"FeaturedCycle"> | string | null
    winnerAmountWei?: DecimalNullableFilter<"FeaturedCycle"> | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: DateTimeNullableFilter<"FeaturedCycle"> | Date | string | null
    createdAt?: DateTimeFilter<"FeaturedCycle"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedCycle"> | Date | string
    bids?: FeaturedBidListRelationFilter
    winnerBid?: XOR<FeaturedBidNullableScalarRelationFilter, FeaturedBidWhereInput> | null
    winnerCollection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null
  }

  export type FeaturedCycleOrderByWithRelationInput = {
    id?: SortOrder
    cycleId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    minBidWei?: SortOrder
    winnerBidId?: SortOrderInput | SortOrder
    winnerCollectionContract?: SortOrderInput | SortOrder
    winnerAmountWei?: SortOrderInput | SortOrder
    finalizedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bids?: FeaturedBidOrderByRelationAggregateInput
    winnerBid?: FeaturedBidOrderByWithRelationInput
    winnerCollection?: CollectionOrderByWithRelationInput
  }

  export type FeaturedCycleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cycleId?: string
    winnerBidId?: string
    AND?: FeaturedCycleWhereInput | FeaturedCycleWhereInput[]
    OR?: FeaturedCycleWhereInput[]
    NOT?: FeaturedCycleWhereInput | FeaturedCycleWhereInput[]
    startAt?: DateTimeFilter<"FeaturedCycle"> | Date | string
    endAt?: DateTimeFilter<"FeaturedCycle"> | Date | string
    status?: EnumFeaturedCycleStatusFilter<"FeaturedCycle"> | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalFilter<"FeaturedCycle"> | Decimal | DecimalJsLike | number | string
    winnerCollectionContract?: StringNullableFilter<"FeaturedCycle"> | string | null
    winnerAmountWei?: DecimalNullableFilter<"FeaturedCycle"> | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: DateTimeNullableFilter<"FeaturedCycle"> | Date | string | null
    createdAt?: DateTimeFilter<"FeaturedCycle"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedCycle"> | Date | string
    bids?: FeaturedBidListRelationFilter
    winnerBid?: XOR<FeaturedBidNullableScalarRelationFilter, FeaturedBidWhereInput> | null
    winnerCollection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null
  }, "id" | "cycleId" | "winnerBidId">

  export type FeaturedCycleOrderByWithAggregationInput = {
    id?: SortOrder
    cycleId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    minBidWei?: SortOrder
    winnerBidId?: SortOrderInput | SortOrder
    winnerCollectionContract?: SortOrderInput | SortOrder
    winnerAmountWei?: SortOrderInput | SortOrder
    finalizedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeaturedCycleCountOrderByAggregateInput
    _avg?: FeaturedCycleAvgOrderByAggregateInput
    _max?: FeaturedCycleMaxOrderByAggregateInput
    _min?: FeaturedCycleMinOrderByAggregateInput
    _sum?: FeaturedCycleSumOrderByAggregateInput
  }

  export type FeaturedCycleScalarWhereWithAggregatesInput = {
    AND?: FeaturedCycleScalarWhereWithAggregatesInput | FeaturedCycleScalarWhereWithAggregatesInput[]
    OR?: FeaturedCycleScalarWhereWithAggregatesInput[]
    NOT?: FeaturedCycleScalarWhereWithAggregatesInput | FeaturedCycleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeaturedCycle"> | string
    cycleId?: StringWithAggregatesFilter<"FeaturedCycle"> | string
    startAt?: DateTimeWithAggregatesFilter<"FeaturedCycle"> | Date | string
    endAt?: DateTimeWithAggregatesFilter<"FeaturedCycle"> | Date | string
    status?: EnumFeaturedCycleStatusWithAggregatesFilter<"FeaturedCycle"> | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalWithAggregatesFilter<"FeaturedCycle"> | Decimal | DecimalJsLike | number | string
    winnerBidId?: StringNullableWithAggregatesFilter<"FeaturedCycle"> | string | null
    winnerCollectionContract?: StringNullableWithAggregatesFilter<"FeaturedCycle"> | string | null
    winnerAmountWei?: DecimalNullableWithAggregatesFilter<"FeaturedCycle"> | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: DateTimeNullableWithAggregatesFilter<"FeaturedCycle"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FeaturedCycle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeaturedCycle"> | Date | string
  }

  export type FeaturedBidWhereInput = {
    AND?: FeaturedBidWhereInput | FeaturedBidWhereInput[]
    OR?: FeaturedBidWhereInput[]
    NOT?: FeaturedBidWhereInput | FeaturedBidWhereInput[]
    id?: StringFilter<"FeaturedBid"> | string
    cycleId?: StringFilter<"FeaturedBid"> | string
    bidderAddress?: StringFilter<"FeaturedBid"> | string
    bidderUserId?: StringNullableFilter<"FeaturedBid"> | string | null
    collectionContract?: StringFilter<"FeaturedBid"> | string
    totalBidWei?: DecimalFilter<"FeaturedBid"> | Decimal | DecimalJsLike | number | string
    txCount?: IntFilter<"FeaturedBid"> | number
    lastTxHash?: StringNullableFilter<"FeaturedBid"> | string | null
    createdAt?: DateTimeFilter<"FeaturedBid"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedBid"> | Date | string
    bidder?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>
    cycle?: XOR<FeaturedCycleScalarRelationFilter, FeaturedCycleWhereInput>
    winnerOf?: XOR<FeaturedCycleNullableScalarRelationFilter, FeaturedCycleWhereInput> | null
  }

  export type FeaturedBidOrderByWithRelationInput = {
    id?: SortOrder
    cycleId?: SortOrder
    bidderAddress?: SortOrder
    bidderUserId?: SortOrderInput | SortOrder
    collectionContract?: SortOrder
    totalBidWei?: SortOrder
    txCount?: SortOrder
    lastTxHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bidder?: UserOrderByWithRelationInput
    collection?: CollectionOrderByWithRelationInput
    cycle?: FeaturedCycleOrderByWithRelationInput
    winnerOf?: FeaturedCycleOrderByWithRelationInput
  }

  export type FeaturedBidWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cycleId_bidderAddress?: FeaturedBidCycleIdBidderAddressCompoundUniqueInput
    AND?: FeaturedBidWhereInput | FeaturedBidWhereInput[]
    OR?: FeaturedBidWhereInput[]
    NOT?: FeaturedBidWhereInput | FeaturedBidWhereInput[]
    cycleId?: StringFilter<"FeaturedBid"> | string
    bidderAddress?: StringFilter<"FeaturedBid"> | string
    bidderUserId?: StringNullableFilter<"FeaturedBid"> | string | null
    collectionContract?: StringFilter<"FeaturedBid"> | string
    totalBidWei?: DecimalFilter<"FeaturedBid"> | Decimal | DecimalJsLike | number | string
    txCount?: IntFilter<"FeaturedBid"> | number
    lastTxHash?: StringNullableFilter<"FeaturedBid"> | string | null
    createdAt?: DateTimeFilter<"FeaturedBid"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedBid"> | Date | string
    bidder?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    collection?: XOR<CollectionScalarRelationFilter, CollectionWhereInput>
    cycle?: XOR<FeaturedCycleScalarRelationFilter, FeaturedCycleWhereInput>
    winnerOf?: XOR<FeaturedCycleNullableScalarRelationFilter, FeaturedCycleWhereInput> | null
  }, "id" | "cycleId_bidderAddress">

  export type FeaturedBidOrderByWithAggregationInput = {
    id?: SortOrder
    cycleId?: SortOrder
    bidderAddress?: SortOrder
    bidderUserId?: SortOrderInput | SortOrder
    collectionContract?: SortOrder
    totalBidWei?: SortOrder
    txCount?: SortOrder
    lastTxHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeaturedBidCountOrderByAggregateInput
    _avg?: FeaturedBidAvgOrderByAggregateInput
    _max?: FeaturedBidMaxOrderByAggregateInput
    _min?: FeaturedBidMinOrderByAggregateInput
    _sum?: FeaturedBidSumOrderByAggregateInput
  }

  export type FeaturedBidScalarWhereWithAggregatesInput = {
    AND?: FeaturedBidScalarWhereWithAggregatesInput | FeaturedBidScalarWhereWithAggregatesInput[]
    OR?: FeaturedBidScalarWhereWithAggregatesInput[]
    NOT?: FeaturedBidScalarWhereWithAggregatesInput | FeaturedBidScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeaturedBid"> | string
    cycleId?: StringWithAggregatesFilter<"FeaturedBid"> | string
    bidderAddress?: StringWithAggregatesFilter<"FeaturedBid"> | string
    bidderUserId?: StringNullableWithAggregatesFilter<"FeaturedBid"> | string | null
    collectionContract?: StringWithAggregatesFilter<"FeaturedBid"> | string
    totalBidWei?: DecimalWithAggregatesFilter<"FeaturedBid"> | Decimal | DecimalJsLike | number | string
    txCount?: IntWithAggregatesFilter<"FeaturedBid"> | number
    lastTxHash?: StringNullableWithAggregatesFilter<"FeaturedBid"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FeaturedBid"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeaturedBid"> | Date | string
  }

  export type CurrencyWhereInput = {
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    id?: StringFilter<"Currency"> | string
    symbol?: StringFilter<"Currency"> | string
    decimals?: IntFilter<"Currency"> | number
    kind?: EnumCurrencyKindFilter<"Currency"> | $Enums.CurrencyKind
    tokenAddress?: StringNullableFilter<"Currency"> | string | null
    active?: BoolFilter<"Currency"> | boolean
    createdAt?: DateTimeFilter<"Currency"> | Date | string
    updatedAt?: DateTimeFilter<"Currency"> | Date | string
    auctions?: AuctionListRelationFilter
    bids?: AuctionBidListRelationFilter
    holderRewards?: HolderRewardMultiListRelationFilter
    listings?: MarketplaceListingListRelationFilter
    sales?: MarketplaceSaleListRelationFilter
    rewardAccumulators?: XOR<RewardAccumulatorMultiNullableScalarRelationFilter, RewardAccumulatorMultiWhereInput> | null
    claimLogs?: RewardClaimLogListRelationFilter
    distributionLogs?: RewardDistributionLogListRelationFilter
  }

  export type CurrencyOrderByWithRelationInput = {
    id?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    kind?: SortOrder
    tokenAddress?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    auctions?: AuctionOrderByRelationAggregateInput
    bids?: AuctionBidOrderByRelationAggregateInput
    holderRewards?: HolderRewardMultiOrderByRelationAggregateInput
    listings?: MarketplaceListingOrderByRelationAggregateInput
    sales?: MarketplaceSaleOrderByRelationAggregateInput
    rewardAccumulators?: RewardAccumulatorMultiOrderByWithRelationInput
    claimLogs?: RewardClaimLogOrderByRelationAggregateInput
    distributionLogs?: RewardDistributionLogOrderByRelationAggregateInput
  }

  export type CurrencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenAddress?: string
    symbol_tokenAddress?: CurrencySymbolTokenAddressCompoundUniqueInput
    AND?: CurrencyWhereInput | CurrencyWhereInput[]
    OR?: CurrencyWhereInput[]
    NOT?: CurrencyWhereInput | CurrencyWhereInput[]
    symbol?: StringFilter<"Currency"> | string
    decimals?: IntFilter<"Currency"> | number
    kind?: EnumCurrencyKindFilter<"Currency"> | $Enums.CurrencyKind
    active?: BoolFilter<"Currency"> | boolean
    createdAt?: DateTimeFilter<"Currency"> | Date | string
    updatedAt?: DateTimeFilter<"Currency"> | Date | string
    auctions?: AuctionListRelationFilter
    bids?: AuctionBidListRelationFilter
    holderRewards?: HolderRewardMultiListRelationFilter
    listings?: MarketplaceListingListRelationFilter
    sales?: MarketplaceSaleListRelationFilter
    rewardAccumulators?: XOR<RewardAccumulatorMultiNullableScalarRelationFilter, RewardAccumulatorMultiWhereInput> | null
    claimLogs?: RewardClaimLogListRelationFilter
    distributionLogs?: RewardDistributionLogListRelationFilter
  }, "id" | "tokenAddress" | "symbol_tokenAddress">

  export type CurrencyOrderByWithAggregationInput = {
    id?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    kind?: SortOrder
    tokenAddress?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CurrencyCountOrderByAggregateInput
    _avg?: CurrencyAvgOrderByAggregateInput
    _max?: CurrencyMaxOrderByAggregateInput
    _min?: CurrencyMinOrderByAggregateInput
    _sum?: CurrencySumOrderByAggregateInput
  }

  export type CurrencyScalarWhereWithAggregatesInput = {
    AND?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    OR?: CurrencyScalarWhereWithAggregatesInput[]
    NOT?: CurrencyScalarWhereWithAggregatesInput | CurrencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Currency"> | string
    symbol?: StringWithAggregatesFilter<"Currency"> | string
    decimals?: IntWithAggregatesFilter<"Currency"> | number
    kind?: EnumCurrencyKindWithAggregatesFilter<"Currency"> | $Enums.CurrencyKind
    tokenAddress?: StringNullableWithAggregatesFilter<"Currency"> | string | null
    active?: BoolWithAggregatesFilter<"Currency"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Currency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Currency"> | Date | string
  }

  export type MarketplaceSaleWhereInput = {
    AND?: MarketplaceSaleWhereInput | MarketplaceSaleWhereInput[]
    OR?: MarketplaceSaleWhereInput[]
    NOT?: MarketplaceSaleWhereInput | MarketplaceSaleWhereInput[]
    id?: StringFilter<"MarketplaceSale"> | string
    nftId?: StringFilter<"MarketplaceSale"> | string
    buyerAddress?: StringFilter<"MarketplaceSale"> | string
    sellerAddress?: StringFilter<"MarketplaceSale"> | string
    quantity?: IntFilter<"MarketplaceSale"> | number
    priceEtnWei?: DecimalFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: StringNullableFilter<"MarketplaceSale"> | string | null
    priceTokenAmount?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: StringNullableFilter<"MarketplaceSale"> | string | null
    marketplaceFeeRecipient?: StringNullableFilter<"MarketplaceSale"> | string | null
    txHash?: StringFilter<"MarketplaceSale"> | string
    logIndex?: IntFilter<"MarketplaceSale"> | number
    blockNumber?: IntFilter<"MarketplaceSale"> | number
    timestamp?: DateTimeFilter<"MarketplaceSale"> | Date | string
    createdAt?: DateTimeFilter<"MarketplaceSale"> | Date | string
    currency?: XOR<CurrencyNullableScalarRelationFilter, CurrencyWhereInput> | null
    nft?: XOR<NFTScalarRelationFilter, NFTWhereInput>
  }

  export type MarketplaceSaleOrderByWithRelationInput = {
    id?: SortOrder
    nftId?: SortOrder
    buyerAddress?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    priceEtnWei?: SortOrder
    royaltyPaidWei?: SortOrderInput | SortOrder
    marketplaceFeePaidWei?: SortOrderInput | SortOrder
    currencyId?: SortOrderInput | SortOrder
    priceTokenAmount?: SortOrderInput | SortOrder
    royaltyPaidTokenAmount?: SortOrderInput | SortOrder
    feePaidTokenAmount?: SortOrderInput | SortOrder
    royaltyRecipient?: SortOrderInput | SortOrder
    marketplaceFeeRecipient?: SortOrderInput | SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    currency?: CurrencyOrderByWithRelationInput
    nft?: NFTOrderByWithRelationInput
  }

  export type MarketplaceSaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    txHash_logIndex?: MarketplaceSaleTxHashLogIndexCompoundUniqueInput
    AND?: MarketplaceSaleWhereInput | MarketplaceSaleWhereInput[]
    OR?: MarketplaceSaleWhereInput[]
    NOT?: MarketplaceSaleWhereInput | MarketplaceSaleWhereInput[]
    nftId?: StringFilter<"MarketplaceSale"> | string
    buyerAddress?: StringFilter<"MarketplaceSale"> | string
    sellerAddress?: StringFilter<"MarketplaceSale"> | string
    quantity?: IntFilter<"MarketplaceSale"> | number
    priceEtnWei?: DecimalFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: StringNullableFilter<"MarketplaceSale"> | string | null
    priceTokenAmount?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: StringNullableFilter<"MarketplaceSale"> | string | null
    marketplaceFeeRecipient?: StringNullableFilter<"MarketplaceSale"> | string | null
    txHash?: StringFilter<"MarketplaceSale"> | string
    logIndex?: IntFilter<"MarketplaceSale"> | number
    blockNumber?: IntFilter<"MarketplaceSale"> | number
    timestamp?: DateTimeFilter<"MarketplaceSale"> | Date | string
    createdAt?: DateTimeFilter<"MarketplaceSale"> | Date | string
    currency?: XOR<CurrencyNullableScalarRelationFilter, CurrencyWhereInput> | null
    nft?: XOR<NFTScalarRelationFilter, NFTWhereInput>
  }, "id" | "txHash_logIndex">

  export type MarketplaceSaleOrderByWithAggregationInput = {
    id?: SortOrder
    nftId?: SortOrder
    buyerAddress?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    priceEtnWei?: SortOrder
    royaltyPaidWei?: SortOrderInput | SortOrder
    marketplaceFeePaidWei?: SortOrderInput | SortOrder
    currencyId?: SortOrderInput | SortOrder
    priceTokenAmount?: SortOrderInput | SortOrder
    royaltyPaidTokenAmount?: SortOrderInput | SortOrder
    feePaidTokenAmount?: SortOrderInput | SortOrder
    royaltyRecipient?: SortOrderInput | SortOrder
    marketplaceFeeRecipient?: SortOrderInput | SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: MarketplaceSaleCountOrderByAggregateInput
    _avg?: MarketplaceSaleAvgOrderByAggregateInput
    _max?: MarketplaceSaleMaxOrderByAggregateInput
    _min?: MarketplaceSaleMinOrderByAggregateInput
    _sum?: MarketplaceSaleSumOrderByAggregateInput
  }

  export type MarketplaceSaleScalarWhereWithAggregatesInput = {
    AND?: MarketplaceSaleScalarWhereWithAggregatesInput | MarketplaceSaleScalarWhereWithAggregatesInput[]
    OR?: MarketplaceSaleScalarWhereWithAggregatesInput[]
    NOT?: MarketplaceSaleScalarWhereWithAggregatesInput | MarketplaceSaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketplaceSale"> | string
    nftId?: StringWithAggregatesFilter<"MarketplaceSale"> | string
    buyerAddress?: StringWithAggregatesFilter<"MarketplaceSale"> | string
    sellerAddress?: StringWithAggregatesFilter<"MarketplaceSale"> | string
    quantity?: IntWithAggregatesFilter<"MarketplaceSale"> | number
    priceEtnWei?: DecimalWithAggregatesFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: DecimalNullableWithAggregatesFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: DecimalNullableWithAggregatesFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: StringNullableWithAggregatesFilter<"MarketplaceSale"> | string | null
    priceTokenAmount?: DecimalNullableWithAggregatesFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: DecimalNullableWithAggregatesFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: DecimalNullableWithAggregatesFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: StringNullableWithAggregatesFilter<"MarketplaceSale"> | string | null
    marketplaceFeeRecipient?: StringNullableWithAggregatesFilter<"MarketplaceSale"> | string | null
    txHash?: StringWithAggregatesFilter<"MarketplaceSale"> | string
    logIndex?: IntWithAggregatesFilter<"MarketplaceSale"> | number
    blockNumber?: IntWithAggregatesFilter<"MarketplaceSale"> | number
    timestamp?: DateTimeWithAggregatesFilter<"MarketplaceSale"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"MarketplaceSale"> | Date | string
  }

  export type RewardAccumulatorMultiWhereInput = {
    AND?: RewardAccumulatorMultiWhereInput | RewardAccumulatorMultiWhereInput[]
    OR?: RewardAccumulatorMultiWhereInput[]
    NOT?: RewardAccumulatorMultiWhereInput | RewardAccumulatorMultiWhereInput[]
    id?: StringFilter<"RewardAccumulatorMulti"> | string
    currencyId?: StringFilter<"RewardAccumulatorMulti"> | string
    accPerToken?: DecimalFilter<"RewardAccumulatorMulti"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"RewardAccumulatorMulti"> | Date | string
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }

  export type RewardAccumulatorMultiOrderByWithRelationInput = {
    id?: SortOrder
    currencyId?: SortOrder
    accPerToken?: SortOrder
    updatedAt?: SortOrder
    currency?: CurrencyOrderByWithRelationInput
  }

  export type RewardAccumulatorMultiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    currencyId?: string
    AND?: RewardAccumulatorMultiWhereInput | RewardAccumulatorMultiWhereInput[]
    OR?: RewardAccumulatorMultiWhereInput[]
    NOT?: RewardAccumulatorMultiWhereInput | RewardAccumulatorMultiWhereInput[]
    accPerToken?: DecimalFilter<"RewardAccumulatorMulti"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"RewardAccumulatorMulti"> | Date | string
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }, "id" | "currencyId">

  export type RewardAccumulatorMultiOrderByWithAggregationInput = {
    id?: SortOrder
    currencyId?: SortOrder
    accPerToken?: SortOrder
    updatedAt?: SortOrder
    _count?: RewardAccumulatorMultiCountOrderByAggregateInput
    _avg?: RewardAccumulatorMultiAvgOrderByAggregateInput
    _max?: RewardAccumulatorMultiMaxOrderByAggregateInput
    _min?: RewardAccumulatorMultiMinOrderByAggregateInput
    _sum?: RewardAccumulatorMultiSumOrderByAggregateInput
  }

  export type RewardAccumulatorMultiScalarWhereWithAggregatesInput = {
    AND?: RewardAccumulatorMultiScalarWhereWithAggregatesInput | RewardAccumulatorMultiScalarWhereWithAggregatesInput[]
    OR?: RewardAccumulatorMultiScalarWhereWithAggregatesInput[]
    NOT?: RewardAccumulatorMultiScalarWhereWithAggregatesInput | RewardAccumulatorMultiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RewardAccumulatorMulti"> | string
    currencyId?: StringWithAggregatesFilter<"RewardAccumulatorMulti"> | string
    accPerToken?: DecimalWithAggregatesFilter<"RewardAccumulatorMulti"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeWithAggregatesFilter<"RewardAccumulatorMulti"> | Date | string
  }

  export type HolderRewardMultiWhereInput = {
    AND?: HolderRewardMultiWhereInput | HolderRewardMultiWhereInput[]
    OR?: HolderRewardMultiWhereInput[]
    NOT?: HolderRewardMultiWhereInput | HolderRewardMultiWhereInput[]
    id?: StringFilter<"HolderRewardMulti"> | string
    userId?: StringNullableFilter<"HolderRewardMulti"> | string | null
    walletAddress?: StringFilter<"HolderRewardMulti"> | string
    currencyId?: StringFilter<"HolderRewardMulti"> | string
    lastAccPerToken?: DecimalFilter<"HolderRewardMulti"> | Decimal | DecimalJsLike | number | string
    claimedAmount?: DecimalFilter<"HolderRewardMulti"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"HolderRewardMulti"> | Date | string
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type HolderRewardMultiOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    walletAddress?: SortOrder
    currencyId?: SortOrder
    lastAccPerToken?: SortOrder
    claimedAmount?: SortOrder
    updatedAt?: SortOrder
    currency?: CurrencyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type HolderRewardMultiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    walletAddress_currencyId?: HolderRewardMultiWalletAddressCurrencyIdCompoundUniqueInput
    AND?: HolderRewardMultiWhereInput | HolderRewardMultiWhereInput[]
    OR?: HolderRewardMultiWhereInput[]
    NOT?: HolderRewardMultiWhereInput | HolderRewardMultiWhereInput[]
    userId?: StringNullableFilter<"HolderRewardMulti"> | string | null
    walletAddress?: StringFilter<"HolderRewardMulti"> | string
    currencyId?: StringFilter<"HolderRewardMulti"> | string
    lastAccPerToken?: DecimalFilter<"HolderRewardMulti"> | Decimal | DecimalJsLike | number | string
    claimedAmount?: DecimalFilter<"HolderRewardMulti"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"HolderRewardMulti"> | Date | string
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "walletAddress_currencyId">

  export type HolderRewardMultiOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    walletAddress?: SortOrder
    currencyId?: SortOrder
    lastAccPerToken?: SortOrder
    claimedAmount?: SortOrder
    updatedAt?: SortOrder
    _count?: HolderRewardMultiCountOrderByAggregateInput
    _avg?: HolderRewardMultiAvgOrderByAggregateInput
    _max?: HolderRewardMultiMaxOrderByAggregateInput
    _min?: HolderRewardMultiMinOrderByAggregateInput
    _sum?: HolderRewardMultiSumOrderByAggregateInput
  }

  export type HolderRewardMultiScalarWhereWithAggregatesInput = {
    AND?: HolderRewardMultiScalarWhereWithAggregatesInput | HolderRewardMultiScalarWhereWithAggregatesInput[]
    OR?: HolderRewardMultiScalarWhereWithAggregatesInput[]
    NOT?: HolderRewardMultiScalarWhereWithAggregatesInput | HolderRewardMultiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HolderRewardMulti"> | string
    userId?: StringNullableWithAggregatesFilter<"HolderRewardMulti"> | string | null
    walletAddress?: StringWithAggregatesFilter<"HolderRewardMulti"> | string
    currencyId?: StringWithAggregatesFilter<"HolderRewardMulti"> | string
    lastAccPerToken?: DecimalWithAggregatesFilter<"HolderRewardMulti"> | Decimal | DecimalJsLike | number | string
    claimedAmount?: DecimalWithAggregatesFilter<"HolderRewardMulti"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeWithAggregatesFilter<"HolderRewardMulti"> | Date | string
  }

  export type RewardDistributionLogWhereInput = {
    AND?: RewardDistributionLogWhereInput | RewardDistributionLogWhereInput[]
    OR?: RewardDistributionLogWhereInput[]
    NOT?: RewardDistributionLogWhereInput | RewardDistributionLogWhereInput[]
    id?: StringFilter<"RewardDistributionLog"> | string
    currencyId?: StringFilter<"RewardDistributionLog"> | string
    amount?: DecimalFilter<"RewardDistributionLog"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableFilter<"RewardDistributionLog"> | string | null
    blockNumber?: IntNullableFilter<"RewardDistributionLog"> | number | null
    timestamp?: DateTimeFilter<"RewardDistributionLog"> | Date | string
    note?: StringNullableFilter<"RewardDistributionLog"> | string | null
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }

  export type RewardDistributionLogOrderByWithRelationInput = {
    id?: SortOrder
    currencyId?: SortOrder
    amount?: SortOrder
    txHash?: SortOrderInput | SortOrder
    blockNumber?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    note?: SortOrderInput | SortOrder
    currency?: CurrencyOrderByWithRelationInput
  }

  export type RewardDistributionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RewardDistributionLogWhereInput | RewardDistributionLogWhereInput[]
    OR?: RewardDistributionLogWhereInput[]
    NOT?: RewardDistributionLogWhereInput | RewardDistributionLogWhereInput[]
    currencyId?: StringFilter<"RewardDistributionLog"> | string
    amount?: DecimalFilter<"RewardDistributionLog"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableFilter<"RewardDistributionLog"> | string | null
    blockNumber?: IntNullableFilter<"RewardDistributionLog"> | number | null
    timestamp?: DateTimeFilter<"RewardDistributionLog"> | Date | string
    note?: StringNullableFilter<"RewardDistributionLog"> | string | null
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
  }, "id">

  export type RewardDistributionLogOrderByWithAggregationInput = {
    id?: SortOrder
    currencyId?: SortOrder
    amount?: SortOrder
    txHash?: SortOrderInput | SortOrder
    blockNumber?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: RewardDistributionLogCountOrderByAggregateInput
    _avg?: RewardDistributionLogAvgOrderByAggregateInput
    _max?: RewardDistributionLogMaxOrderByAggregateInput
    _min?: RewardDistributionLogMinOrderByAggregateInput
    _sum?: RewardDistributionLogSumOrderByAggregateInput
  }

  export type RewardDistributionLogScalarWhereWithAggregatesInput = {
    AND?: RewardDistributionLogScalarWhereWithAggregatesInput | RewardDistributionLogScalarWhereWithAggregatesInput[]
    OR?: RewardDistributionLogScalarWhereWithAggregatesInput[]
    NOT?: RewardDistributionLogScalarWhereWithAggregatesInput | RewardDistributionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RewardDistributionLog"> | string
    currencyId?: StringWithAggregatesFilter<"RewardDistributionLog"> | string
    amount?: DecimalWithAggregatesFilter<"RewardDistributionLog"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableWithAggregatesFilter<"RewardDistributionLog"> | string | null
    blockNumber?: IntNullableWithAggregatesFilter<"RewardDistributionLog"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"RewardDistributionLog"> | Date | string
    note?: StringNullableWithAggregatesFilter<"RewardDistributionLog"> | string | null
  }

  export type RewardClaimLogWhereInput = {
    AND?: RewardClaimLogWhereInput | RewardClaimLogWhereInput[]
    OR?: RewardClaimLogWhereInput[]
    NOT?: RewardClaimLogWhereInput | RewardClaimLogWhereInput[]
    id?: StringFilter<"RewardClaimLog"> | string
    walletAddress?: StringFilter<"RewardClaimLog"> | string
    userId?: StringNullableFilter<"RewardClaimLog"> | string | null
    currencyId?: StringFilter<"RewardClaimLog"> | string
    amount?: DecimalFilter<"RewardClaimLog"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableFilter<"RewardClaimLog"> | string | null
    timestamp?: DateTimeFilter<"RewardClaimLog"> | Date | string
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type RewardClaimLogOrderByWithRelationInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    userId?: SortOrderInput | SortOrder
    currencyId?: SortOrder
    amount?: SortOrder
    txHash?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    currency?: CurrencyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RewardClaimLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RewardClaimLogWhereInput | RewardClaimLogWhereInput[]
    OR?: RewardClaimLogWhereInput[]
    NOT?: RewardClaimLogWhereInput | RewardClaimLogWhereInput[]
    walletAddress?: StringFilter<"RewardClaimLog"> | string
    userId?: StringNullableFilter<"RewardClaimLog"> | string | null
    currencyId?: StringFilter<"RewardClaimLog"> | string
    amount?: DecimalFilter<"RewardClaimLog"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableFilter<"RewardClaimLog"> | string | null
    timestamp?: DateTimeFilter<"RewardClaimLog"> | Date | string
    currency?: XOR<CurrencyScalarRelationFilter, CurrencyWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type RewardClaimLogOrderByWithAggregationInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    userId?: SortOrderInput | SortOrder
    currencyId?: SortOrder
    amount?: SortOrder
    txHash?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: RewardClaimLogCountOrderByAggregateInput
    _avg?: RewardClaimLogAvgOrderByAggregateInput
    _max?: RewardClaimLogMaxOrderByAggregateInput
    _min?: RewardClaimLogMinOrderByAggregateInput
    _sum?: RewardClaimLogSumOrderByAggregateInput
  }

  export type RewardClaimLogScalarWhereWithAggregatesInput = {
    AND?: RewardClaimLogScalarWhereWithAggregatesInput | RewardClaimLogScalarWhereWithAggregatesInput[]
    OR?: RewardClaimLogScalarWhereWithAggregatesInput[]
    NOT?: RewardClaimLogScalarWhereWithAggregatesInput | RewardClaimLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RewardClaimLog"> | string
    walletAddress?: StringWithAggregatesFilter<"RewardClaimLog"> | string
    userId?: StringNullableWithAggregatesFilter<"RewardClaimLog"> | string | null
    currencyId?: StringWithAggregatesFilter<"RewardClaimLog"> | string
    amount?: DecimalWithAggregatesFilter<"RewardClaimLog"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableWithAggregatesFilter<"RewardClaimLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"RewardClaimLog"> | Date | string
  }

  export type StolenItemWhereInput = {
    AND?: StolenItemWhereInput | StolenItemWhereInput[]
    OR?: StolenItemWhereInput[]
    NOT?: StolenItemWhereInput | StolenItemWhereInput[]
    id?: StringFilter<"StolenItem"> | string
    contract?: StringFilter<"StolenItem"> | string
    tokenId?: StringFilter<"StolenItem"> | string
    status?: EnumStolenStatusFilter<"StolenItem"> | $Enums.StolenStatus
    source?: EnumStolenSourceFilter<"StolenItem"> | $Enums.StolenSource
    reporterAddress?: StringNullableFilter<"StolenItem"> | string | null
    reporterUserId?: StringNullableFilter<"StolenItem"> | string | null
    evidenceUrl?: StringNullableFilter<"StolenItem"> | string | null
    notes?: StringNullableFilter<"StolenItem"> | string | null
    disputed?: BoolFilter<"StolenItem"> | boolean
    createdAt?: DateTimeFilter<"StolenItem"> | Date | string
    updatedAt?: DateTimeFilter<"StolenItem"> | Date | string
    reporter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type StolenItemOrderByWithRelationInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    status?: SortOrder
    source?: SortOrder
    reporterAddress?: SortOrderInput | SortOrder
    reporterUserId?: SortOrderInput | SortOrder
    evidenceUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    disputed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reporter?: UserOrderByWithRelationInput
  }

  export type StolenItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contract_tokenId?: StolenItemContractTokenIdCompoundUniqueInput
    AND?: StolenItemWhereInput | StolenItemWhereInput[]
    OR?: StolenItemWhereInput[]
    NOT?: StolenItemWhereInput | StolenItemWhereInput[]
    contract?: StringFilter<"StolenItem"> | string
    tokenId?: StringFilter<"StolenItem"> | string
    status?: EnumStolenStatusFilter<"StolenItem"> | $Enums.StolenStatus
    source?: EnumStolenSourceFilter<"StolenItem"> | $Enums.StolenSource
    reporterAddress?: StringNullableFilter<"StolenItem"> | string | null
    reporterUserId?: StringNullableFilter<"StolenItem"> | string | null
    evidenceUrl?: StringNullableFilter<"StolenItem"> | string | null
    notes?: StringNullableFilter<"StolenItem"> | string | null
    disputed?: BoolFilter<"StolenItem"> | boolean
    createdAt?: DateTimeFilter<"StolenItem"> | Date | string
    updatedAt?: DateTimeFilter<"StolenItem"> | Date | string
    reporter?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "contract_tokenId">

  export type StolenItemOrderByWithAggregationInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    status?: SortOrder
    source?: SortOrder
    reporterAddress?: SortOrderInput | SortOrder
    reporterUserId?: SortOrderInput | SortOrder
    evidenceUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    disputed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StolenItemCountOrderByAggregateInput
    _max?: StolenItemMaxOrderByAggregateInput
    _min?: StolenItemMinOrderByAggregateInput
  }

  export type StolenItemScalarWhereWithAggregatesInput = {
    AND?: StolenItemScalarWhereWithAggregatesInput | StolenItemScalarWhereWithAggregatesInput[]
    OR?: StolenItemScalarWhereWithAggregatesInput[]
    NOT?: StolenItemScalarWhereWithAggregatesInput | StolenItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StolenItem"> | string
    contract?: StringWithAggregatesFilter<"StolenItem"> | string
    tokenId?: StringWithAggregatesFilter<"StolenItem"> | string
    status?: EnumStolenStatusWithAggregatesFilter<"StolenItem"> | $Enums.StolenStatus
    source?: EnumStolenSourceWithAggregatesFilter<"StolenItem"> | $Enums.StolenSource
    reporterAddress?: StringNullableWithAggregatesFilter<"StolenItem"> | string | null
    reporterUserId?: StringNullableWithAggregatesFilter<"StolenItem"> | string | null
    evidenceUrl?: StringNullableWithAggregatesFilter<"StolenItem"> | string | null
    notes?: StringNullableWithAggregatesFilter<"StolenItem"> | string | null
    disputed?: BoolWithAggregatesFilter<"StolenItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StolenItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StolenItem"> | Date | string
  }

  export type StolenEventWhereInput = {
    AND?: StolenEventWhereInput | StolenEventWhereInput[]
    OR?: StolenEventWhereInput[]
    NOT?: StolenEventWhereInput | StolenEventWhereInput[]
    id?: StringFilter<"StolenEvent"> | string
    contract?: StringFilter<"StolenEvent"> | string
    tokenId?: StringFilter<"StolenEvent"> | string
    action?: StringFilter<"StolenEvent"> | string
    actorAddress?: StringNullableFilter<"StolenEvent"> | string | null
    txHash?: StringNullableFilter<"StolenEvent"> | string | null
    logIndex?: IntNullableFilter<"StolenEvent"> | number | null
    blockNumber?: IntNullableFilter<"StolenEvent"> | number | null
    timestamp?: DateTimeFilter<"StolenEvent"> | Date | string
    notes?: StringNullableFilter<"StolenEvent"> | string | null
    createdAt?: DateTimeFilter<"StolenEvent"> | Date | string
  }

  export type StolenEventOrderByWithRelationInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    action?: SortOrder
    actorAddress?: SortOrderInput | SortOrder
    txHash?: SortOrderInput | SortOrder
    logIndex?: SortOrderInput | SortOrder
    blockNumber?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type StolenEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StolenEventWhereInput | StolenEventWhereInput[]
    OR?: StolenEventWhereInput[]
    NOT?: StolenEventWhereInput | StolenEventWhereInput[]
    contract?: StringFilter<"StolenEvent"> | string
    tokenId?: StringFilter<"StolenEvent"> | string
    action?: StringFilter<"StolenEvent"> | string
    actorAddress?: StringNullableFilter<"StolenEvent"> | string | null
    txHash?: StringNullableFilter<"StolenEvent"> | string | null
    logIndex?: IntNullableFilter<"StolenEvent"> | number | null
    blockNumber?: IntNullableFilter<"StolenEvent"> | number | null
    timestamp?: DateTimeFilter<"StolenEvent"> | Date | string
    notes?: StringNullableFilter<"StolenEvent"> | string | null
    createdAt?: DateTimeFilter<"StolenEvent"> | Date | string
  }, "id">

  export type StolenEventOrderByWithAggregationInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    action?: SortOrder
    actorAddress?: SortOrderInput | SortOrder
    txHash?: SortOrderInput | SortOrder
    logIndex?: SortOrderInput | SortOrder
    blockNumber?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StolenEventCountOrderByAggregateInput
    _avg?: StolenEventAvgOrderByAggregateInput
    _max?: StolenEventMaxOrderByAggregateInput
    _min?: StolenEventMinOrderByAggregateInput
    _sum?: StolenEventSumOrderByAggregateInput
  }

  export type StolenEventScalarWhereWithAggregatesInput = {
    AND?: StolenEventScalarWhereWithAggregatesInput | StolenEventScalarWhereWithAggregatesInput[]
    OR?: StolenEventScalarWhereWithAggregatesInput[]
    NOT?: StolenEventScalarWhereWithAggregatesInput | StolenEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StolenEvent"> | string
    contract?: StringWithAggregatesFilter<"StolenEvent"> | string
    tokenId?: StringWithAggregatesFilter<"StolenEvent"> | string
    action?: StringWithAggregatesFilter<"StolenEvent"> | string
    actorAddress?: StringNullableWithAggregatesFilter<"StolenEvent"> | string | null
    txHash?: StringNullableWithAggregatesFilter<"StolenEvent"> | string | null
    logIndex?: IntNullableWithAggregatesFilter<"StolenEvent"> | number | null
    blockNumber?: IntNullableWithAggregatesFilter<"StolenEvent"> | number | null
    timestamp?: DateTimeWithAggregatesFilter<"StolenEvent"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"StolenEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StolenEvent"> | Date | string
  }

  export type MultisigSafeWhereInput = {
    AND?: MultisigSafeWhereInput | MultisigSafeWhereInput[]
    OR?: MultisigSafeWhereInput[]
    NOT?: MultisigSafeWhereInput | MultisigSafeWhereInput[]
    id?: StringFilter<"MultisigSafe"> | string
    contract?: StringFilter<"MultisigSafe"> | string
    name?: StringNullableFilter<"MultisigSafe"> | string | null
    threshold?: IntFilter<"MultisigSafe"> | number
    createdAt?: DateTimeFilter<"MultisigSafe"> | Date | string
    updatedAt?: DateTimeFilter<"MultisigSafe"> | Date | string
    owners?: MultisigOwnerListRelationFilter
    txs?: MultisigTxListRelationFilter
  }

  export type MultisigSafeOrderByWithRelationInput = {
    id?: SortOrder
    contract?: SortOrder
    name?: SortOrderInput | SortOrder
    threshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owners?: MultisigOwnerOrderByRelationAggregateInput
    txs?: MultisigTxOrderByRelationAggregateInput
  }

  export type MultisigSafeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contract?: string
    AND?: MultisigSafeWhereInput | MultisigSafeWhereInput[]
    OR?: MultisigSafeWhereInput[]
    NOT?: MultisigSafeWhereInput | MultisigSafeWhereInput[]
    name?: StringNullableFilter<"MultisigSafe"> | string | null
    threshold?: IntFilter<"MultisigSafe"> | number
    createdAt?: DateTimeFilter<"MultisigSafe"> | Date | string
    updatedAt?: DateTimeFilter<"MultisigSafe"> | Date | string
    owners?: MultisigOwnerListRelationFilter
    txs?: MultisigTxListRelationFilter
  }, "id" | "contract">

  export type MultisigSafeOrderByWithAggregationInput = {
    id?: SortOrder
    contract?: SortOrder
    name?: SortOrderInput | SortOrder
    threshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MultisigSafeCountOrderByAggregateInput
    _avg?: MultisigSafeAvgOrderByAggregateInput
    _max?: MultisigSafeMaxOrderByAggregateInput
    _min?: MultisigSafeMinOrderByAggregateInput
    _sum?: MultisigSafeSumOrderByAggregateInput
  }

  export type MultisigSafeScalarWhereWithAggregatesInput = {
    AND?: MultisigSafeScalarWhereWithAggregatesInput | MultisigSafeScalarWhereWithAggregatesInput[]
    OR?: MultisigSafeScalarWhereWithAggregatesInput[]
    NOT?: MultisigSafeScalarWhereWithAggregatesInput | MultisigSafeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MultisigSafe"> | string
    contract?: StringWithAggregatesFilter<"MultisigSafe"> | string
    name?: StringNullableWithAggregatesFilter<"MultisigSafe"> | string | null
    threshold?: IntWithAggregatesFilter<"MultisigSafe"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MultisigSafe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MultisigSafe"> | Date | string
  }

  export type MultisigOwnerWhereInput = {
    AND?: MultisigOwnerWhereInput | MultisigOwnerWhereInput[]
    OR?: MultisigOwnerWhereInput[]
    NOT?: MultisigOwnerWhereInput | MultisigOwnerWhereInput[]
    id?: StringFilter<"MultisigOwner"> | string
    safeId?: StringFilter<"MultisigOwner"> | string
    ownerAddress?: StringFilter<"MultisigOwner"> | string
    addedAt?: DateTimeFilter<"MultisigOwner"> | Date | string
    removedAt?: DateTimeNullableFilter<"MultisigOwner"> | Date | string | null
    safe?: XOR<MultisigSafeScalarRelationFilter, MultisigSafeWhereInput>
  }

  export type MultisigOwnerOrderByWithRelationInput = {
    id?: SortOrder
    safeId?: SortOrder
    ownerAddress?: SortOrder
    addedAt?: SortOrder
    removedAt?: SortOrderInput | SortOrder
    safe?: MultisigSafeOrderByWithRelationInput
  }

  export type MultisigOwnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    safeId_ownerAddress?: MultisigOwnerSafeIdOwnerAddressCompoundUniqueInput
    AND?: MultisigOwnerWhereInput | MultisigOwnerWhereInput[]
    OR?: MultisigOwnerWhereInput[]
    NOT?: MultisigOwnerWhereInput | MultisigOwnerWhereInput[]
    safeId?: StringFilter<"MultisigOwner"> | string
    ownerAddress?: StringFilter<"MultisigOwner"> | string
    addedAt?: DateTimeFilter<"MultisigOwner"> | Date | string
    removedAt?: DateTimeNullableFilter<"MultisigOwner"> | Date | string | null
    safe?: XOR<MultisigSafeScalarRelationFilter, MultisigSafeWhereInput>
  }, "id" | "safeId_ownerAddress">

  export type MultisigOwnerOrderByWithAggregationInput = {
    id?: SortOrder
    safeId?: SortOrder
    ownerAddress?: SortOrder
    addedAt?: SortOrder
    removedAt?: SortOrderInput | SortOrder
    _count?: MultisigOwnerCountOrderByAggregateInput
    _max?: MultisigOwnerMaxOrderByAggregateInput
    _min?: MultisigOwnerMinOrderByAggregateInput
  }

  export type MultisigOwnerScalarWhereWithAggregatesInput = {
    AND?: MultisigOwnerScalarWhereWithAggregatesInput | MultisigOwnerScalarWhereWithAggregatesInput[]
    OR?: MultisigOwnerScalarWhereWithAggregatesInput[]
    NOT?: MultisigOwnerScalarWhereWithAggregatesInput | MultisigOwnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MultisigOwner"> | string
    safeId?: StringWithAggregatesFilter<"MultisigOwner"> | string
    ownerAddress?: StringWithAggregatesFilter<"MultisigOwner"> | string
    addedAt?: DateTimeWithAggregatesFilter<"MultisigOwner"> | Date | string
    removedAt?: DateTimeNullableWithAggregatesFilter<"MultisigOwner"> | Date | string | null
  }

  export type MultisigTxWhereInput = {
    AND?: MultisigTxWhereInput | MultisigTxWhereInput[]
    OR?: MultisigTxWhereInput[]
    NOT?: MultisigTxWhereInput | MultisigTxWhereInput[]
    id?: StringFilter<"MultisigTx"> | string
    safeId?: StringFilter<"MultisigTx"> | string
    nonce?: IntFilter<"MultisigTx"> | number
    to?: StringFilter<"MultisigTx"> | string
    valueWei?: DecimalFilter<"MultisigTx"> | Decimal | DecimalJsLike | number | string
    dataHex?: StringNullableFilter<"MultisigTx"> | string | null
    operation?: IntNullableFilter<"MultisigTx"> | number | null
    submittedBy?: StringNullableFilter<"MultisigTx"> | string | null
    status?: EnumMultisigTxStatusFilter<"MultisigTx"> | $Enums.MultisigTxStatus
    executedTxHash?: StringNullableFilter<"MultisigTx"> | string | null
    createdAt?: DateTimeFilter<"MultisigTx"> | Date | string
    executedAt?: DateTimeNullableFilter<"MultisigTx"> | Date | string | null
    approvals?: MultisigApprovalListRelationFilter
    safe?: XOR<MultisigSafeScalarRelationFilter, MultisigSafeWhereInput>
  }

  export type MultisigTxOrderByWithRelationInput = {
    id?: SortOrder
    safeId?: SortOrder
    nonce?: SortOrder
    to?: SortOrder
    valueWei?: SortOrder
    dataHex?: SortOrderInput | SortOrder
    operation?: SortOrderInput | SortOrder
    submittedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    executedTxHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    approvals?: MultisigApprovalOrderByRelationAggregateInput
    safe?: MultisigSafeOrderByWithRelationInput
  }

  export type MultisigTxWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    safeId_nonce?: MultisigTxSafeIdNonceCompoundUniqueInput
    AND?: MultisigTxWhereInput | MultisigTxWhereInput[]
    OR?: MultisigTxWhereInput[]
    NOT?: MultisigTxWhereInput | MultisigTxWhereInput[]
    safeId?: StringFilter<"MultisigTx"> | string
    nonce?: IntFilter<"MultisigTx"> | number
    to?: StringFilter<"MultisigTx"> | string
    valueWei?: DecimalFilter<"MultisigTx"> | Decimal | DecimalJsLike | number | string
    dataHex?: StringNullableFilter<"MultisigTx"> | string | null
    operation?: IntNullableFilter<"MultisigTx"> | number | null
    submittedBy?: StringNullableFilter<"MultisigTx"> | string | null
    status?: EnumMultisigTxStatusFilter<"MultisigTx"> | $Enums.MultisigTxStatus
    executedTxHash?: StringNullableFilter<"MultisigTx"> | string | null
    createdAt?: DateTimeFilter<"MultisigTx"> | Date | string
    executedAt?: DateTimeNullableFilter<"MultisigTx"> | Date | string | null
    approvals?: MultisigApprovalListRelationFilter
    safe?: XOR<MultisigSafeScalarRelationFilter, MultisigSafeWhereInput>
  }, "id" | "safeId_nonce">

  export type MultisigTxOrderByWithAggregationInput = {
    id?: SortOrder
    safeId?: SortOrder
    nonce?: SortOrder
    to?: SortOrder
    valueWei?: SortOrder
    dataHex?: SortOrderInput | SortOrder
    operation?: SortOrderInput | SortOrder
    submittedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    executedTxHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrderInput | SortOrder
    _count?: MultisigTxCountOrderByAggregateInput
    _avg?: MultisigTxAvgOrderByAggregateInput
    _max?: MultisigTxMaxOrderByAggregateInput
    _min?: MultisigTxMinOrderByAggregateInput
    _sum?: MultisigTxSumOrderByAggregateInput
  }

  export type MultisigTxScalarWhereWithAggregatesInput = {
    AND?: MultisigTxScalarWhereWithAggregatesInput | MultisigTxScalarWhereWithAggregatesInput[]
    OR?: MultisigTxScalarWhereWithAggregatesInput[]
    NOT?: MultisigTxScalarWhereWithAggregatesInput | MultisigTxScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MultisigTx"> | string
    safeId?: StringWithAggregatesFilter<"MultisigTx"> | string
    nonce?: IntWithAggregatesFilter<"MultisigTx"> | number
    to?: StringWithAggregatesFilter<"MultisigTx"> | string
    valueWei?: DecimalWithAggregatesFilter<"MultisigTx"> | Decimal | DecimalJsLike | number | string
    dataHex?: StringNullableWithAggregatesFilter<"MultisigTx"> | string | null
    operation?: IntNullableWithAggregatesFilter<"MultisigTx"> | number | null
    submittedBy?: StringNullableWithAggregatesFilter<"MultisigTx"> | string | null
    status?: EnumMultisigTxStatusWithAggregatesFilter<"MultisigTx"> | $Enums.MultisigTxStatus
    executedTxHash?: StringNullableWithAggregatesFilter<"MultisigTx"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MultisigTx"> | Date | string
    executedAt?: DateTimeNullableWithAggregatesFilter<"MultisigTx"> | Date | string | null
  }

  export type MultisigApprovalWhereInput = {
    AND?: MultisigApprovalWhereInput | MultisigApprovalWhereInput[]
    OR?: MultisigApprovalWhereInput[]
    NOT?: MultisigApprovalWhereInput | MultisigApprovalWhereInput[]
    id?: StringFilter<"MultisigApproval"> | string
    txId?: StringFilter<"MultisigApproval"> | string
    ownerAddress?: StringFilter<"MultisigApproval"> | string
    signature?: StringNullableFilter<"MultisigApproval"> | string | null
    createdAt?: DateTimeFilter<"MultisigApproval"> | Date | string
    tx?: XOR<MultisigTxScalarRelationFilter, MultisigTxWhereInput>
  }

  export type MultisigApprovalOrderByWithRelationInput = {
    id?: SortOrder
    txId?: SortOrder
    ownerAddress?: SortOrder
    signature?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tx?: MultisigTxOrderByWithRelationInput
  }

  export type MultisigApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    txId_ownerAddress?: MultisigApprovalTxIdOwnerAddressCompoundUniqueInput
    AND?: MultisigApprovalWhereInput | MultisigApprovalWhereInput[]
    OR?: MultisigApprovalWhereInput[]
    NOT?: MultisigApprovalWhereInput | MultisigApprovalWhereInput[]
    txId?: StringFilter<"MultisigApproval"> | string
    ownerAddress?: StringFilter<"MultisigApproval"> | string
    signature?: StringNullableFilter<"MultisigApproval"> | string | null
    createdAt?: DateTimeFilter<"MultisigApproval"> | Date | string
    tx?: XOR<MultisigTxScalarRelationFilter, MultisigTxWhereInput>
  }, "id" | "txId_ownerAddress">

  export type MultisigApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    txId?: SortOrder
    ownerAddress?: SortOrder
    signature?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MultisigApprovalCountOrderByAggregateInput
    _max?: MultisigApprovalMaxOrderByAggregateInput
    _min?: MultisigApprovalMinOrderByAggregateInput
  }

  export type MultisigApprovalScalarWhereWithAggregatesInput = {
    AND?: MultisigApprovalScalarWhereWithAggregatesInput | MultisigApprovalScalarWhereWithAggregatesInput[]
    OR?: MultisigApprovalScalarWhereWithAggregatesInput[]
    NOT?: MultisigApprovalScalarWhereWithAggregatesInput | MultisigApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MultisigApproval"> | string
    txId?: StringWithAggregatesFilter<"MultisigApproval"> | string
    ownerAddress?: StringWithAggregatesFilter<"MultisigApproval"> | string
    signature?: StringNullableWithAggregatesFilter<"MultisigApproval"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MultisigApproval"> | Date | string
  }

  export type PendingChainActionWhereInput = {
    AND?: PendingChainActionWhereInput | PendingChainActionWhereInput[]
    OR?: PendingChainActionWhereInput[]
    NOT?: PendingChainActionWhereInput | PendingChainActionWhereInput[]
    id?: StringFilter<"PendingChainAction"> | string
    type?: EnumPendingChainActionTypeFilter<"PendingChainAction"> | $Enums.PendingChainActionType
    txHash?: StringFilter<"PendingChainAction"> | string
    from?: StringFilter<"PendingChainAction"> | string
    chainId?: IntFilter<"PendingChainAction"> | number
    payload?: JsonFilter<"PendingChainAction">
    relatedId?: StringNullableFilter<"PendingChainAction"> | string | null
    status?: EnumPendingStatusFilter<"PendingChainAction"> | $Enums.PendingStatus
    createdAt?: DateTimeFilter<"PendingChainAction"> | Date | string
    updatedAt?: DateTimeFilter<"PendingChainAction"> | Date | string
  }

  export type PendingChainActionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    txHash?: SortOrder
    from?: SortOrder
    chainId?: SortOrder
    payload?: SortOrder
    relatedId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingChainActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    txHash?: string
    AND?: PendingChainActionWhereInput | PendingChainActionWhereInput[]
    OR?: PendingChainActionWhereInput[]
    NOT?: PendingChainActionWhereInput | PendingChainActionWhereInput[]
    type?: EnumPendingChainActionTypeFilter<"PendingChainAction"> | $Enums.PendingChainActionType
    from?: StringFilter<"PendingChainAction"> | string
    chainId?: IntFilter<"PendingChainAction"> | number
    payload?: JsonFilter<"PendingChainAction">
    relatedId?: StringNullableFilter<"PendingChainAction"> | string | null
    status?: EnumPendingStatusFilter<"PendingChainAction"> | $Enums.PendingStatus
    createdAt?: DateTimeFilter<"PendingChainAction"> | Date | string
    updatedAt?: DateTimeFilter<"PendingChainAction"> | Date | string
  }, "id" | "txHash">

  export type PendingChainActionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    txHash?: SortOrder
    from?: SortOrder
    chainId?: SortOrder
    payload?: SortOrder
    relatedId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PendingChainActionCountOrderByAggregateInput
    _avg?: PendingChainActionAvgOrderByAggregateInput
    _max?: PendingChainActionMaxOrderByAggregateInput
    _min?: PendingChainActionMinOrderByAggregateInput
    _sum?: PendingChainActionSumOrderByAggregateInput
  }

  export type PendingChainActionScalarWhereWithAggregatesInput = {
    AND?: PendingChainActionScalarWhereWithAggregatesInput | PendingChainActionScalarWhereWithAggregatesInput[]
    OR?: PendingChainActionScalarWhereWithAggregatesInput[]
    NOT?: PendingChainActionScalarWhereWithAggregatesInput | PendingChainActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PendingChainAction"> | string
    type?: EnumPendingChainActionTypeWithAggregatesFilter<"PendingChainAction"> | $Enums.PendingChainActionType
    txHash?: StringWithAggregatesFilter<"PendingChainAction"> | string
    from?: StringWithAggregatesFilter<"PendingChainAction"> | string
    chainId?: IntWithAggregatesFilter<"PendingChainAction"> | number
    payload?: JsonWithAggregatesFilter<"PendingChainAction">
    relatedId?: StringNullableWithAggregatesFilter<"PendingChainAction"> | string | null
    status?: EnumPendingStatusWithAggregatesFilter<"PendingChainAction"> | $Enums.PendingStatus
    createdAt?: DateTimeWithAggregatesFilter<"PendingChainAction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PendingChainAction"> | Date | string
  }

  export type ChainStateCreateInput = {
    id?: string
    userAddress: string
    contract: string
    lastBlockNumber?: number
  }

  export type ChainStateUncheckedCreateInput = {
    id?: string
    userAddress: string
    contract: string
    lastBlockNumber?: number
  }

  export type ChainStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    lastBlockNumber?: IntFieldUpdateOperationsInput | number
  }

  export type ChainStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    lastBlockNumber?: IntFieldUpdateOperationsInput | number
  }

  export type ChainStateCreateManyInput = {
    id?: string
    userAddress: string
    contract: string
    lastBlockNumber?: number
  }

  export type ChainStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    lastBlockNumber?: IntFieldUpdateOperationsInput | number
  }

  export type ChainStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAddress?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    lastBlockNumber?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collections?: CollectionCreateNestedManyWithoutCreatorInput
    submissions?: CollectionSubmissionCreateNestedManyWithoutSubmittedByInput
    featuredBids?: FeaturedBidCreateNestedManyWithoutBidderInput
    holderRewardsMulti?: HolderRewardMultiCreateNestedManyWithoutUserInput
    ownedNFTs?: NFTCreateNestedManyWithoutOwnerInput
    rewardClaimLogs?: RewardClaimLogCreateNestedManyWithoutUserInput
    stolenReports?: StolenItemCreateNestedManyWithoutReporterInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collections?: CollectionUncheckedCreateNestedManyWithoutCreatorInput
    submissions?: CollectionSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    featuredBids?: FeaturedBidUncheckedCreateNestedManyWithoutBidderInput
    holderRewardsMulti?: HolderRewardMultiUncheckedCreateNestedManyWithoutUserInput
    ownedNFTs?: NFTUncheckedCreateNestedManyWithoutOwnerInput
    rewardClaimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutUserInput
    stolenReports?: StolenItemUncheckedCreateNestedManyWithoutReporterInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUpdateManyWithoutCreatorNestedInput
    submissions?: CollectionSubmissionUpdateManyWithoutSubmittedByNestedInput
    featuredBids?: FeaturedBidUpdateManyWithoutBidderNestedInput
    holderRewardsMulti?: HolderRewardMultiUpdateManyWithoutUserNestedInput
    ownedNFTs?: NFTUpdateManyWithoutOwnerNestedInput
    rewardClaimLogs?: RewardClaimLogUpdateManyWithoutUserNestedInput
    stolenReports?: StolenItemUpdateManyWithoutReporterNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUncheckedUpdateManyWithoutCreatorNestedInput
    submissions?: CollectionSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    featuredBids?: FeaturedBidUncheckedUpdateManyWithoutBidderNestedInput
    holderRewardsMulti?: HolderRewardMultiUncheckedUpdateManyWithoutUserNestedInput
    ownedNFTs?: NFTUncheckedUpdateManyWithoutOwnerNestedInput
    rewardClaimLogs?: RewardClaimLogUncheckedUpdateManyWithoutUserNestedInput
    stolenReports?: StolenItemUncheckedUpdateManyWithoutReporterNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCreateInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutCollectionInput
    creator: UserCreateNestedOneWithoutCollectionsInput
    deployment?: DeployedContractCreateNestedOneWithoutCollectionInput
    featuredBidEntries?: FeaturedBidCreateNestedManyWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleCreateNestedManyWithoutWinnerCollectionInput
    nfts?: NFTCreateNestedManyWithoutCollectionInput
    presale?: PresaleCreateNestedOneWithoutCollectionInput
    publicSale?: PublicSaleCreateNestedOneWithoutCollectionInput
  }

  export type CollectionUncheckedCreateInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    creatorId: string
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutCollectionInput
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutCollectionInput
    featuredBidEntries?: FeaturedBidUncheckedCreateNestedManyWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleUncheckedCreateNestedManyWithoutWinnerCollectionInput
    nfts?: NFTUncheckedCreateNestedManyWithoutCollectionInput
    presale?: PresaleUncheckedCreateNestedOneWithoutCollectionInput
    publicSale?: PublicSaleUncheckedCreateNestedOneWithoutCollectionInput
  }

  export type CollectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutCollectionNestedInput
    creator?: UserUpdateOneRequiredWithoutCollectionsNestedInput
    deployment?: DeployedContractUpdateOneWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUpdateManyWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUpdateManyWithoutWinnerCollectionNestedInput
    nfts?: NFTUpdateManyWithoutCollectionNestedInput
    presale?: PresaleUpdateOneWithoutCollectionNestedInput
    publicSale?: PublicSaleUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutCollectionNestedInput
    deployment?: DeployedContractUncheckedUpdateOneWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUncheckedUpdateManyWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUncheckedUpdateManyWithoutWinnerCollectionNestedInput
    nfts?: NFTUncheckedUpdateManyWithoutCollectionNestedInput
    presale?: PresaleUncheckedUpdateOneWithoutCollectionNestedInput
    publicSale?: PublicSaleUncheckedUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionCreateManyInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    creatorId: string
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTCreateInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionCreateNestedManyWithoutNftInput
    listingEntries?: MarketplaceListingCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleCreateNestedManyWithoutNftInput
    collection?: CollectionCreateNestedOneWithoutNftsInput
    owner?: UserCreateNestedOneWithoutOwnedNFTsInput
    single1155?: Single1155CreateNestedOneWithoutNftsInput
    single721?: Single721CreateNestedOneWithoutNftsInput
    activities?: NFTActivityCreateNestedManyWithoutNftInput
  }

  export type NFTUncheckedCreateInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    ownerId?: string | null
    collectionId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedCreateNestedManyWithoutNftInput
    listingEntries?: MarketplaceListingUncheckedCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutNftInput
    activities?: NFTActivityUncheckedCreateNestedManyWithoutNftInput
  }

  export type NFTUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUpdateManyWithoutNftNestedInput
    listingEntries?: MarketplaceListingUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutNftNestedInput
    collection?: CollectionUpdateOneWithoutNftsNestedInput
    owner?: UserUpdateOneWithoutOwnedNFTsNestedInput
    single1155?: Single1155UpdateOneWithoutNftsNestedInput
    single721?: Single721UpdateOneWithoutNftsNestedInput
    activities?: NFTActivityUpdateManyWithoutNftNestedInput
  }

  export type NFTUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedUpdateManyWithoutNftNestedInput
    listingEntries?: MarketplaceListingUncheckedUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutNftNestedInput
    activities?: NFTActivityUncheckedUpdateManyWithoutNftNestedInput
  }

  export type NFTCreateManyInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    ownerId?: string | null
    collectionId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
  }

  export type NFTUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type NFTUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type TraitStatCreateInput = {
    id?: string
    contract: string
    trait_type: string
    value: JsonNullValueInput | InputJsonValue
    count: number
    frequency: number
    createdAt?: Date | string
  }

  export type TraitStatUncheckedCreateInput = {
    id?: string
    contract: string
    trait_type: string
    value: JsonNullValueInput | InputJsonValue
    count: number
    frequency: number
    createdAt?: Date | string
  }

  export type TraitStatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    trait_type?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraitStatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    trait_type?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraitStatCreateManyInput = {
    id?: string
    contract: string
    trait_type: string
    value: JsonNullValueInput | InputJsonValue
    count: number
    frequency: number
    createdAt?: Date | string
  }

  export type TraitStatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    trait_type?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraitStatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    trait_type?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
    frequency?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTActivityCreateInput = {
    id?: string
    contract: string
    tokenId: string
    type: string
    fromAddress: string
    toAddress: string
    priceEtnWei?: Decimal | DecimalJsLike | number | string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    marketplace?: string | null
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    nft: NFTCreateNestedOneWithoutActivitiesInput
  }

  export type NFTActivityUncheckedCreateInput = {
    id?: string
    nftId: string
    contract: string
    tokenId: string
    type: string
    fromAddress: string
    toAddress: string
    priceEtnWei?: Decimal | DecimalJsLike | number | string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    marketplace?: string | null
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NFTActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    priceEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nft?: NFTUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type NFTActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    priceEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTActivityCreateManyInput = {
    id?: string
    nftId: string
    contract: string
    tokenId: string
    type: string
    fromAddress: string
    toAddress: string
    priceEtnWei?: Decimal | DecimalJsLike | number | string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    marketplace?: string | null
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NFTActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    priceEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    priceEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Single721CreateInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    tokenUri: string
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutSingle721Input
    deployment?: DeployedContractCreateNestedOneWithoutSingle721Input
    nfts?: NFTCreateNestedManyWithoutSingle721Input
  }

  export type Single721UncheckedCreateInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    tokenUri: string
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutSingle721Input
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutSingle721Input
    nfts?: NFTUncheckedCreateNestedManyWithoutSingle721Input
  }

  export type Single721UpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenUri?: StringFieldUpdateOperationsInput | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutSingle721NestedInput
    deployment?: DeployedContractUpdateOneWithoutSingle721NestedInput
    nfts?: NFTUpdateManyWithoutSingle721NestedInput
  }

  export type Single721UncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenUri?: StringFieldUpdateOperationsInput | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutSingle721NestedInput
    deployment?: DeployedContractUncheckedUpdateOneWithoutSingle721NestedInput
    nfts?: NFTUncheckedUpdateManyWithoutSingle721NestedInput
  }

  export type Single721CreateManyInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    tokenUri: string
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Single721UpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenUri?: StringFieldUpdateOperationsInput | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Single721UncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenUri?: StringFieldUpdateOperationsInput | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Single1155CreateInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    baseUri: string
    maxSupply: number
    mintPriceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutSingle1155Input
    deployment?: DeployedContractCreateNestedOneWithoutSingle1155Input
    balances?: Erc1155BalanceCreateNestedManyWithoutSingle1155Input
    nfts?: NFTCreateNestedManyWithoutSingle1155Input
  }

  export type Single1155UncheckedCreateInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    baseUri: string
    maxSupply: number
    mintPriceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutSingle1155Input
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutSingle1155Input
    balances?: Erc1155BalanceUncheckedCreateNestedManyWithoutSingle1155Input
    nfts?: NFTUncheckedCreateNestedManyWithoutSingle1155Input
  }

  export type Single1155UpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    baseUri?: StringFieldUpdateOperationsInput | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    mintPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutSingle1155NestedInput
    deployment?: DeployedContractUpdateOneWithoutSingle1155NestedInput
    balances?: Erc1155BalanceUpdateManyWithoutSingle1155NestedInput
    nfts?: NFTUpdateManyWithoutSingle1155NestedInput
  }

  export type Single1155UncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    baseUri?: StringFieldUpdateOperationsInput | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    mintPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutSingle1155NestedInput
    deployment?: DeployedContractUncheckedUpdateOneWithoutSingle1155NestedInput
    balances?: Erc1155BalanceUncheckedUpdateManyWithoutSingle1155NestedInput
    nfts?: NFTUncheckedUpdateManyWithoutSingle1155NestedInput
  }

  export type Single1155CreateManyInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    baseUri: string
    maxSupply: number
    mintPriceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type Single1155UpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    baseUri?: StringFieldUpdateOperationsInput | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    mintPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Single1155UncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    baseUri?: StringFieldUpdateOperationsInput | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    mintPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Erc1155BalanceCreateInput = {
    id?: string
    ownerAddress: string
    balance?: number
    updatedAt?: Date | string
    single1155: Single1155CreateNestedOneWithoutBalancesInput
  }

  export type Erc1155BalanceUncheckedCreateInput = {
    id?: string
    single1155Id: string
    ownerAddress: string
    balance?: number
    updatedAt?: Date | string
  }

  export type Erc1155BalanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    single1155?: Single1155UpdateOneRequiredWithoutBalancesNestedInput
  }

  export type Erc1155BalanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    single1155Id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Erc1155BalanceCreateManyInput = {
    id?: string
    single1155Id: string
    ownerAddress: string
    balance?: number
    updatedAt?: Date | string
  }

  export type Erc1155BalanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Erc1155BalanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    single1155Id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Erc1155HoldingCreateInput = {
    id?: string
    contract: string
    tokenId: string
    ownerAddress: string
    balance?: number
    updatedAt?: Date | string
  }

  export type Erc1155HoldingUncheckedCreateInput = {
    id?: string
    contract: string
    tokenId: string
    ownerAddress: string
    balance?: number
    updatedAt?: Date | string
  }

  export type Erc1155HoldingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Erc1155HoldingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Erc1155HoldingCreateManyInput = {
    id?: string
    contract: string
    tokenId: string
    ownerAddress: string
    balance?: number
    updatedAt?: Date | string
  }

  export type Erc1155HoldingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Erc1155HoldingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceListingCreateInput = {
    id?: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ListingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    txHashCreated?: string | null
    txHashFilled?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: CurrencyCreateNestedOneWithoutListingsInput
    nft: NFTCreateNestedOneWithoutListingEntriesInput
  }

  export type MarketplaceListingUncheckedCreateInput = {
    id?: string
    nftId: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    currencyId?: string | null
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ListingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    txHashCreated?: string | null
    txHashFilled?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceListingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFilled?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: CurrencyUpdateOneWithoutListingsNestedInput
    nft?: NFTUpdateOneRequiredWithoutListingEntriesNestedInput
  }

  export type MarketplaceListingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFilled?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceListingCreateManyInput = {
    id?: string
    nftId: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    currencyId?: string | null
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ListingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    txHashCreated?: string | null
    txHashFilled?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceListingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFilled?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceListingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFilled?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionCreateInput = {
    id?: string
    sellerAddress: string
    quantity?: number
    startPriceEtnWei: Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: Decimal | DecimalJsLike | number | string | null
    startPriceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime: Date | string
    status?: $Enums.AuctionStatus
    txHashCreated?: string | null
    txHashFinalized?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highestBidder?: string | null
    currency?: CurrencyCreateNestedOneWithoutAuctionsInput
    nft: NFTCreateNestedOneWithoutAuctionEntriesInput
    bids?: AuctionBidCreateNestedManyWithoutAuctionInput
  }

  export type AuctionUncheckedCreateInput = {
    id?: string
    nftId: string
    sellerAddress: string
    quantity?: number
    startPriceEtnWei: Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: Decimal | DecimalJsLike | number | string | null
    currencyId?: string | null
    startPriceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime: Date | string
    status?: $Enums.AuctionStatus
    txHashCreated?: string | null
    txHashFinalized?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highestBidder?: string | null
    bids?: AuctionBidUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type AuctionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startPriceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFinalized?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highestBidder?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: CurrencyUpdateOneWithoutAuctionsNestedInput
    nft?: NFTUpdateOneRequiredWithoutAuctionEntriesNestedInput
    bids?: AuctionBidUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    startPriceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFinalized?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highestBidder?: NullableStringFieldUpdateOperationsInput | string | null
    bids?: AuctionBidUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionCreateManyInput = {
    id?: string
    nftId: string
    sellerAddress: string
    quantity?: number
    startPriceEtnWei: Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: Decimal | DecimalJsLike | number | string | null
    currencyId?: string | null
    startPriceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime: Date | string
    status?: $Enums.AuctionStatus
    txHashCreated?: string | null
    txHashFinalized?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highestBidder?: string | null
  }

  export type AuctionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startPriceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFinalized?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highestBidder?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuctionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    startPriceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFinalized?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highestBidder?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuctionBidCreateInput = {
    id?: string
    bidderAddress: string
    amountWei: Decimal | DecimalJsLike | number | string
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
    auction: AuctionCreateNestedOneWithoutBidsInput
    currency?: CurrencyCreateNestedOneWithoutBidsInput
  }

  export type AuctionBidUncheckedCreateInput = {
    id?: string
    auctionId: string
    bidderAddress: string
    amountWei: Decimal | DecimalJsLike | number | string
    currencyId?: string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type AuctionBidUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    amountWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auction?: AuctionUpdateOneRequiredWithoutBidsNestedInput
    currency?: CurrencyUpdateOneWithoutBidsNestedInput
  }

  export type AuctionBidUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    amountWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionBidCreateManyInput = {
    id?: string
    auctionId: string
    bidderAddress: string
    amountWei: Decimal | DecimalJsLike | number | string
    currencyId?: string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type AuctionBidUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    amountWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionBidUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    amountWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeployedContractCreateInput = {
    id?: string
    contractType: $Enums.ContractType
    cloneAddress: string
    implementationAddr: string
    factoryAddress: string
    deployerAddress: string
    txHash: string
    blockNumber: number
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal | DecimalJsLike | number | string
    royaltyRecipient: string
    royaltyBps: number
    baseURI?: string | null
    maxSupply?: number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    collection?: CollectionCreateNestedOneWithoutDeploymentInput
    single1155?: Single1155CreateNestedOneWithoutDeploymentInput
    single721?: Single721CreateNestedOneWithoutDeploymentInput
  }

  export type DeployedContractUncheckedCreateInput = {
    id?: string
    contractType: $Enums.ContractType
    cloneAddress: string
    implementationAddr: string
    factoryAddress: string
    deployerAddress: string
    txHash: string
    blockNumber: number
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal | DecimalJsLike | number | string
    royaltyRecipient: string
    royaltyBps: number
    baseURI?: string | null
    maxSupply?: number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    collectionId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
  }

  export type DeployedContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    cloneAddress?: StringFieldUpdateOperationsInput | string
    implementationAddr?: StringFieldUpdateOperationsInput | string
    factoryAddress?: StringFieldUpdateOperationsInput | string
    deployerAddress?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    baseURI?: NullableStringFieldUpdateOperationsInput | string | null
    maxSupply?: NullableIntFieldUpdateOperationsInput | number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: CollectionUpdateOneWithoutDeploymentNestedInput
    single1155?: Single1155UpdateOneWithoutDeploymentNestedInput
    single721?: Single721UpdateOneWithoutDeploymentNestedInput
  }

  export type DeployedContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    cloneAddress?: StringFieldUpdateOperationsInput | string
    implementationAddr?: StringFieldUpdateOperationsInput | string
    factoryAddress?: StringFieldUpdateOperationsInput | string
    deployerAddress?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    baseURI?: NullableStringFieldUpdateOperationsInput | string | null
    maxSupply?: NullableIntFieldUpdateOperationsInput | number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeployedContractCreateManyInput = {
    id?: string
    contractType: $Enums.ContractType
    cloneAddress: string
    implementationAddr: string
    factoryAddress: string
    deployerAddress: string
    txHash: string
    blockNumber: number
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal | DecimalJsLike | number | string
    royaltyRecipient: string
    royaltyBps: number
    baseURI?: string | null
    maxSupply?: number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    collectionId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
  }

  export type DeployedContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    cloneAddress?: StringFieldUpdateOperationsInput | string
    implementationAddr?: StringFieldUpdateOperationsInput | string
    factoryAddress?: StringFieldUpdateOperationsInput | string
    deployerAddress?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    baseURI?: NullableStringFieldUpdateOperationsInput | string | null
    maxSupply?: NullableIntFieldUpdateOperationsInput | number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeployedContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    cloneAddress?: StringFieldUpdateOperationsInput | string
    implementationAddr?: StringFieldUpdateOperationsInput | string
    factoryAddress?: StringFieldUpdateOperationsInput | string
    deployerAddress?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    baseURI?: NullableStringFieldUpdateOperationsInput | string | null
    maxSupply?: NullableIntFieldUpdateOperationsInput | number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeeConfigCreateInput = {
    id?: string
    contractType: $Enums.ContractType
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedByUserId?: string | null
    targetUsdCents?: number | null
    pricingSource?: string
    pricingPair?: string
    lastPriceUsd?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
    logs?: FeeConfigLogCreateNestedManyWithoutFeeConfigInput
  }

  export type FeeConfigUncheckedCreateInput = {
    id?: string
    contractType: $Enums.ContractType
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedByUserId?: string | null
    targetUsdCents?: number | null
    pricingSource?: string
    pricingPair?: string
    lastPriceUsd?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
    logs?: FeeConfigLogUncheckedCreateNestedManyWithoutFeeConfigInput
  }

  export type FeeConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    targetUsdCents?: NullableIntFieldUpdateOperationsInput | number | null
    pricingSource?: StringFieldUpdateOperationsInput | string
    pricingPair?: StringFieldUpdateOperationsInput | string
    lastPriceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: FeeConfigLogUpdateManyWithoutFeeConfigNestedInput
  }

  export type FeeConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    targetUsdCents?: NullableIntFieldUpdateOperationsInput | number | null
    pricingSource?: StringFieldUpdateOperationsInput | string
    pricingPair?: StringFieldUpdateOperationsInput | string
    lastPriceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: FeeConfigLogUncheckedUpdateManyWithoutFeeConfigNestedInput
  }

  export type FeeConfigCreateManyInput = {
    id?: string
    contractType: $Enums.ContractType
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedByUserId?: string | null
    targetUsdCents?: number | null
    pricingSource?: string
    pricingPair?: string
    lastPriceUsd?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
  }

  export type FeeConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    targetUsdCents?: NullableIntFieldUpdateOperationsInput | number | null
    pricingSource?: StringFieldUpdateOperationsInput | string
    pricingPair?: StringFieldUpdateOperationsInput | string
    lastPriceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeeConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    targetUsdCents?: NullableIntFieldUpdateOperationsInput | number | null
    pricingSource?: StringFieldUpdateOperationsInput | string
    pricingPair?: StringFieldUpdateOperationsInput | string
    lastPriceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeeConfigLogCreateInput = {
    id?: string
    previousRecipient?: string | null
    newRecipient?: string | null
    previousAmountEtnWei?: Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: Decimal | DecimalJsLike | number | string | null
    changedByUserId?: string | null
    reason?: string | null
    createdAt?: Date | string
    feeConfig: FeeConfigCreateNestedOneWithoutLogsInput
  }

  export type FeeConfigLogUncheckedCreateInput = {
    id?: string
    feeConfigId: string
    previousRecipient?: string | null
    newRecipient?: string | null
    previousAmountEtnWei?: Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: Decimal | DecimalJsLike | number | string | null
    changedByUserId?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type FeeConfigLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    newRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    previousAmountEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeConfig?: FeeConfigUpdateOneRequiredWithoutLogsNestedInput
  }

  export type FeeConfigLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeConfigId?: StringFieldUpdateOperationsInput | string
    previousRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    newRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    previousAmountEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeConfigLogCreateManyInput = {
    id?: string
    feeConfigId: string
    previousRecipient?: string | null
    newRecipient?: string | null
    previousAmountEtnWei?: Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: Decimal | DecimalJsLike | number | string | null
    changedByUserId?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type FeeConfigLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    newRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    previousAmountEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeConfigLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeConfigId?: StringFieldUpdateOperationsInput | string
    previousRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    newRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    previousAmountEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicSaleCreateInput = {
    id?: string
    startTime: Date | string
    priceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    maxPerTx: number
    createdAt?: Date | string
    updatedAt?: Date | string
    collection: CollectionCreateNestedOneWithoutPublicSaleInput
  }

  export type PublicSaleUncheckedCreateInput = {
    id?: string
    collectionId: string
    startTime: Date | string
    priceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    maxPerTx: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicSaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    maxPerTx?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: CollectionUpdateOneRequiredWithoutPublicSaleNestedInput
  }

  export type PublicSaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    maxPerTx?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicSaleCreateManyInput = {
    id?: string
    collectionId: string
    startTime: Date | string
    priceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    maxPerTx: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicSaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    maxPerTx?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicSaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    maxPerTx?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PresaleCreateInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    priceEtnWei: Decimal | DecimalJsLike | number | string
    maxSupply: number
    merkleRoot: string
    whitelistCount?: number | null
    allowlistCommit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collection: CollectionCreateNestedOneWithoutPresaleInput
    whitelist?: PresaleWhitelistAddressCreateNestedManyWithoutPresaleInput
  }

  export type PresaleUncheckedCreateInput = {
    id?: string
    collectionId: string
    startTime: Date | string
    endTime: Date | string
    priceEtnWei: Decimal | DecimalJsLike | number | string
    maxSupply: number
    merkleRoot: string
    whitelistCount?: number | null
    allowlistCommit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whitelist?: PresaleWhitelistAddressUncheckedCreateNestedManyWithoutPresaleInput
  }

  export type PresaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    merkleRoot?: StringFieldUpdateOperationsInput | string
    whitelistCount?: NullableIntFieldUpdateOperationsInput | number | null
    allowlistCommit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: CollectionUpdateOneRequiredWithoutPresaleNestedInput
    whitelist?: PresaleWhitelistAddressUpdateManyWithoutPresaleNestedInput
  }

  export type PresaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    merkleRoot?: StringFieldUpdateOperationsInput | string
    whitelistCount?: NullableIntFieldUpdateOperationsInput | number | null
    allowlistCommit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whitelist?: PresaleWhitelistAddressUncheckedUpdateManyWithoutPresaleNestedInput
  }

  export type PresaleCreateManyInput = {
    id?: string
    collectionId: string
    startTime: Date | string
    endTime: Date | string
    priceEtnWei: Decimal | DecimalJsLike | number | string
    maxSupply: number
    merkleRoot: string
    whitelistCount?: number | null
    allowlistCommit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PresaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    merkleRoot?: StringFieldUpdateOperationsInput | string
    whitelistCount?: NullableIntFieldUpdateOperationsInput | number | null
    allowlistCommit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PresaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    merkleRoot?: StringFieldUpdateOperationsInput | string
    whitelistCount?: NullableIntFieldUpdateOperationsInput | number | null
    allowlistCommit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PresaleWhitelistAddressCreateInput = {
    id?: string
    address: string
    maxAllocation?: number | null
    presale: PresaleCreateNestedOneWithoutWhitelistInput
  }

  export type PresaleWhitelistAddressUncheckedCreateInput = {
    id?: string
    presaleId: string
    address: string
    maxAllocation?: number | null
  }

  export type PresaleWhitelistAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    maxAllocation?: NullableIntFieldUpdateOperationsInput | number | null
    presale?: PresaleUpdateOneRequiredWithoutWhitelistNestedInput
  }

  export type PresaleWhitelistAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    presaleId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    maxAllocation?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PresaleWhitelistAddressCreateManyInput = {
    id?: string
    presaleId: string
    address: string
    maxAllocation?: number | null
  }

  export type PresaleWhitelistAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    maxAllocation?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PresaleWhitelistAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    presaleId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    maxAllocation?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PresaleDraftCreateInput = {
    id?: string
    creatorUserId: string
    addresses: JsonNullValueInput | InputJsonValue
    count: number
    merkleRoot: string
    sha256Commit: string
    status?: $Enums.DraftStatus
    consumedAt?: Date | string | null
    consumedByPresaleId?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PresaleDraftUncheckedCreateInput = {
    id?: string
    creatorUserId: string
    addresses: JsonNullValueInput | InputJsonValue
    count: number
    merkleRoot: string
    sha256Commit: string
    status?: $Enums.DraftStatus
    consumedAt?: Date | string | null
    consumedByPresaleId?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PresaleDraftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorUserId?: StringFieldUpdateOperationsInput | string
    addresses?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
    merkleRoot?: StringFieldUpdateOperationsInput | string
    sha256Commit?: StringFieldUpdateOperationsInput | string
    status?: EnumDraftStatusFieldUpdateOperationsInput | $Enums.DraftStatus
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consumedByPresaleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PresaleDraftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorUserId?: StringFieldUpdateOperationsInput | string
    addresses?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
    merkleRoot?: StringFieldUpdateOperationsInput | string
    sha256Commit?: StringFieldUpdateOperationsInput | string
    status?: EnumDraftStatusFieldUpdateOperationsInput | $Enums.DraftStatus
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consumedByPresaleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PresaleDraftCreateManyInput = {
    id?: string
    creatorUserId: string
    addresses: JsonNullValueInput | InputJsonValue
    count: number
    merkleRoot: string
    sha256Commit: string
    status?: $Enums.DraftStatus
    consumedAt?: Date | string | null
    consumedByPresaleId?: string | null
    createdAt?: Date | string
    expiresAt?: Date | string | null
  }

  export type PresaleDraftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorUserId?: StringFieldUpdateOperationsInput | string
    addresses?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
    merkleRoot?: StringFieldUpdateOperationsInput | string
    sha256Commit?: StringFieldUpdateOperationsInput | string
    status?: EnumDraftStatusFieldUpdateOperationsInput | $Enums.DraftStatus
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consumedByPresaleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PresaleDraftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorUserId?: StringFieldUpdateOperationsInput | string
    addresses?: JsonNullValueInput | InputJsonValue
    count?: IntFieldUpdateOperationsInput | number
    merkleRoot?: StringFieldUpdateOperationsInput | string
    sha256Commit?: StringFieldUpdateOperationsInput | string
    status?: EnumDraftStatusFieldUpdateOperationsInput | $Enums.DraftStatus
    consumedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consumedByPresaleId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssetUploadCreateInput = {
    id?: string
    uploaderUserId?: string | null
    provider?: string
    cid: string
    url?: string | null
    bytes?: number | null
    sha256?: string | null
    contentType?: string | null
    originalName?: string | null
    createdAt?: Date | string
    collection?: CollectionCreateNestedOneWithoutAssetUploadsInput
    single1155?: Single1155CreateNestedOneWithoutAssetUploadsInput
    single721?: Single721CreateNestedOneWithoutAssetUploadsInput
  }

  export type AssetUploadUncheckedCreateInput = {
    id?: string
    uploaderUserId?: string | null
    collectionId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
    provider?: string
    cid: string
    url?: string | null
    bytes?: number | null
    sha256?: string | null
    contentType?: string | null
    originalName?: string | null
    createdAt?: Date | string
  }

  export type AssetUploadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    bytes?: NullableIntFieldUpdateOperationsInput | number | null
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: CollectionUpdateOneWithoutAssetUploadsNestedInput
    single1155?: Single1155UpdateOneWithoutAssetUploadsNestedInput
    single721?: Single721UpdateOneWithoutAssetUploadsNestedInput
  }

  export type AssetUploadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    bytes?: NullableIntFieldUpdateOperationsInput | number | null
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUploadCreateManyInput = {
    id?: string
    uploaderUserId?: string | null
    collectionId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
    provider?: string
    cid: string
    url?: string | null
    bytes?: number | null
    sha256?: string | null
    contentType?: string | null
    originalName?: string | null
    createdAt?: Date | string
  }

  export type AssetUploadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    bytes?: NullableIntFieldUpdateOperationsInput | number | null
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUploadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    bytes?: NullableIntFieldUpdateOperationsInput | number | null
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionSubmissionCreateInput = {
    id?: string
    contract: string
    ownerAddress?: string | null
    name?: string | null
    symbol?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    baseUri?: string | null
    supply?: number | null
    description?: string | null
    website?: string | null
    x?: string | null
    instagram?: string | null
    telegram?: string | null
    feeTxHash?: string | null
    feePaidWei?: Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: Date | string | null
    ownershipVerified?: boolean
    status?: $Enums.SubmissionStatus
    statusReason?: string | null
    reviewedByUserId?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedBy: UserCreateNestedOneWithoutSubmissionsInput
  }

  export type CollectionSubmissionUncheckedCreateInput = {
    id?: string
    submittedByUserId: string
    contract: string
    ownerAddress?: string | null
    name?: string | null
    symbol?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    baseUri?: string | null
    supply?: number | null
    description?: string | null
    website?: string | null
    x?: string | null
    instagram?: string | null
    telegram?: string | null
    feeTxHash?: string | null
    feePaidWei?: Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: Date | string | null
    ownershipVerified?: boolean
    status?: $Enums.SubmissionStatus
    statusReason?: string | null
    reviewedByUserId?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    feeTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    feePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedBy?: UserUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type CollectionSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    submittedByUserId?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    feeTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    feePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionSubmissionCreateManyInput = {
    id?: string
    submittedByUserId: string
    contract: string
    ownerAddress?: string | null
    name?: string | null
    symbol?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    baseUri?: string | null
    supply?: number | null
    description?: string | null
    website?: string | null
    x?: string | null
    instagram?: string | null
    telegram?: string | null
    feeTxHash?: string | null
    feePaidWei?: Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: Date | string | null
    ownershipVerified?: boolean
    status?: $Enums.SubmissionStatus
    statusReason?: string | null
    reviewedByUserId?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    feeTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    feePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    submittedByUserId?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    feeTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    feePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTRarityCreateInput = {
    contract: string
    tokenId: string
    score: Decimal | DecimalJsLike | number | string
    rank: number
    updatedAt?: Date | string
  }

  export type NFTRarityUncheckedCreateInput = {
    contract: string
    tokenId: string
    score: Decimal | DecimalJsLike | number | string
    rank: number
    updatedAt?: Date | string
  }

  export type NFTRarityUpdateInput = {
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rank?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTRarityUncheckedUpdateInput = {
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rank?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTRarityCreateManyInput = {
    contract: string
    tokenId: string
    score: Decimal | DecimalJsLike | number | string
    rank: number
    updatedAt?: Date | string
  }

  export type NFTRarityUpdateManyMutationInput = {
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rank?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTRarityUncheckedUpdateManyInput = {
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    rank?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolderRewardCreateInput = {
    user_id: string
    wallet_address?: string | null
    last_acc_per_token?: Decimal | DecimalJsLike | number | string
    claimed_etn?: Decimal | DecimalJsLike | number | string
    updated_at?: Date | string
  }

  export type HolderRewardUncheckedCreateInput = {
    user_id: string
    wallet_address?: string | null
    last_acc_per_token?: Decimal | DecimalJsLike | number | string
    claimed_etn?: Decimal | DecimalJsLike | number | string
    updated_at?: Date | string
  }

  export type HolderRewardUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    last_acc_per_token?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    claimed_etn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolderRewardUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    last_acc_per_token?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    claimed_etn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolderRewardCreateManyInput = {
    user_id: string
    wallet_address?: string | null
    last_acc_per_token?: Decimal | DecimalJsLike | number | string
    claimed_etn?: Decimal | DecimalJsLike | number | string
    updated_at?: Date | string
  }

  export type HolderRewardUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    last_acc_per_token?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    claimed_etn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolderRewardUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    wallet_address?: NullableStringFieldUpdateOperationsInput | string | null
    last_acc_per_token?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    claimed_etn?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardAccumulatorCreateInput = {
    id: string
    acc_per_token?: Decimal | DecimalJsLike | number | string
    updated_at?: Date | string
  }

  export type RewardAccumulatorUncheckedCreateInput = {
    id: string
    acc_per_token?: Decimal | DecimalJsLike | number | string
    updated_at?: Date | string
  }

  export type RewardAccumulatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    acc_per_token?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardAccumulatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    acc_per_token?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardAccumulatorCreateManyInput = {
    id: string
    acc_per_token?: Decimal | DecimalJsLike | number | string
    updated_at?: Date | string
  }

  export type RewardAccumulatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    acc_per_token?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardAccumulatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    acc_per_token?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedCycleCreateInput = {
    id?: string
    cycleId: string
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.FeaturedCycleStatus
    minBidWei: Decimal | DecimalJsLike | number | string
    winnerAmountWei?: Decimal | DecimalJsLike | number | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: FeaturedBidCreateNestedManyWithoutCycleInput
    winnerBid?: FeaturedBidCreateNestedOneWithoutWinnerOfInput
    winnerCollection?: CollectionCreateNestedOneWithoutFeaturedAsWinnerInput
  }

  export type FeaturedCycleUncheckedCreateInput = {
    id?: string
    cycleId: string
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.FeaturedCycleStatus
    minBidWei: Decimal | DecimalJsLike | number | string
    winnerBidId?: string | null
    winnerCollectionContract?: string | null
    winnerAmountWei?: Decimal | DecimalJsLike | number | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: FeaturedBidUncheckedCreateNestedManyWithoutCycleInput
  }

  export type FeaturedCycleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeaturedCycleStatusFieldUpdateOperationsInput | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winnerAmountWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: FeaturedBidUpdateManyWithoutCycleNestedInput
    winnerBid?: FeaturedBidUpdateOneWithoutWinnerOfNestedInput
    winnerCollection?: CollectionUpdateOneWithoutFeaturedAsWinnerNestedInput
  }

  export type FeaturedCycleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeaturedCycleStatusFieldUpdateOperationsInput | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winnerBidId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerCollectionContract?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAmountWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: FeaturedBidUncheckedUpdateManyWithoutCycleNestedInput
  }

  export type FeaturedCycleCreateManyInput = {
    id?: string
    cycleId: string
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.FeaturedCycleStatus
    minBidWei: Decimal | DecimalJsLike | number | string
    winnerBidId?: string | null
    winnerCollectionContract?: string | null
    winnerAmountWei?: Decimal | DecimalJsLike | number | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedCycleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeaturedCycleStatusFieldUpdateOperationsInput | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winnerAmountWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedCycleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeaturedCycleStatusFieldUpdateOperationsInput | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winnerBidId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerCollectionContract?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAmountWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedBidCreateInput = {
    id?: string
    bidderAddress: string
    totalBidWei: Decimal | DecimalJsLike | number | string
    txCount?: number
    lastTxHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidder?: UserCreateNestedOneWithoutFeaturedBidsInput
    collection: CollectionCreateNestedOneWithoutFeaturedBidEntriesInput
    cycle: FeaturedCycleCreateNestedOneWithoutBidsInput
    winnerOf?: FeaturedCycleCreateNestedOneWithoutWinnerBidInput
  }

  export type FeaturedBidUncheckedCreateInput = {
    id?: string
    cycleId: string
    bidderAddress: string
    bidderUserId?: string | null
    collectionContract: string
    totalBidWei: Decimal | DecimalJsLike | number | string
    txCount?: number
    lastTxHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    winnerOf?: FeaturedCycleUncheckedCreateNestedOneWithoutWinnerBidInput
  }

  export type FeaturedBidUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidder?: UserUpdateOneWithoutFeaturedBidsNestedInput
    collection?: CollectionUpdateOneRequiredWithoutFeaturedBidEntriesNestedInput
    cycle?: FeaturedCycleUpdateOneRequiredWithoutBidsNestedInput
    winnerOf?: FeaturedCycleUpdateOneWithoutWinnerBidNestedInput
  }

  export type FeaturedBidUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    bidderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionContract?: StringFieldUpdateOperationsInput | string
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    winnerOf?: FeaturedCycleUncheckedUpdateOneWithoutWinnerBidNestedInput
  }

  export type FeaturedBidCreateManyInput = {
    id?: string
    cycleId: string
    bidderAddress: string
    bidderUserId?: string | null
    collectionContract: string
    totalBidWei: Decimal | DecimalJsLike | number | string
    txCount?: number
    lastTxHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedBidUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedBidUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    bidderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionContract?: StringFieldUpdateOperationsInput | string
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyCreateInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionCreateNestedManyWithoutCurrencyInput
    bids?: AuctionBidCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiCreateNestedOneWithoutCurrencyInput
    claimLogs?: RewardClaimLogCreateNestedManyWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionUncheckedCreateNestedManyWithoutCurrencyInput
    bids?: AuctionBidUncheckedCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiUncheckedCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedCreateNestedOneWithoutCurrencyInput
    claimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUpdateManyWithoutCurrencyNestedInput
    bids?: AuctionBidUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUpdateOneWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUpdateManyWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUncheckedUpdateManyWithoutCurrencyNestedInput
    bids?: AuctionBidUncheckedUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUncheckedUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedUpdateOneWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUncheckedUpdateManyWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyCreateManyInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceSaleCreateInput = {
    id?: string
    buyerAddress: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: Decimal | DecimalJsLike | number | string | null
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: string | null
    marketplaceFeeRecipient?: string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
    currency?: CurrencyCreateNestedOneWithoutSalesInput
    nft: NFTCreateNestedOneWithoutSalesInput
  }

  export type MarketplaceSaleUncheckedCreateInput = {
    id?: string
    nftId: string
    buyerAddress: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: Decimal | DecimalJsLike | number | string | null
    currencyId?: string | null
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: string | null
    marketplaceFeeRecipient?: string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type MarketplaceSaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerAddress?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    marketplaceFeeRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: CurrencyUpdateOneWithoutSalesNestedInput
    nft?: NFTUpdateOneRequiredWithoutSalesNestedInput
  }

  export type MarketplaceSaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    buyerAddress?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    marketplaceFeeRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceSaleCreateManyInput = {
    id?: string
    nftId: string
    buyerAddress: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: Decimal | DecimalJsLike | number | string | null
    currencyId?: string | null
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: string | null
    marketplaceFeeRecipient?: string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type MarketplaceSaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerAddress?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    marketplaceFeeRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceSaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    buyerAddress?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    marketplaceFeeRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardAccumulatorMultiCreateInput = {
    id?: string
    accPerToken?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    currency: CurrencyCreateNestedOneWithoutRewardAccumulatorsInput
  }

  export type RewardAccumulatorMultiUncheckedCreateInput = {
    id?: string
    currencyId: string
    accPerToken?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type RewardAccumulatorMultiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: CurrencyUpdateOneRequiredWithoutRewardAccumulatorsNestedInput
  }

  export type RewardAccumulatorMultiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    accPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardAccumulatorMultiCreateManyInput = {
    id?: string
    currencyId: string
    accPerToken?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type RewardAccumulatorMultiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardAccumulatorMultiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    accPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolderRewardMultiCreateInput = {
    id?: string
    walletAddress: string
    lastAccPerToken?: Decimal | DecimalJsLike | number | string
    claimedAmount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    currency: CurrencyCreateNestedOneWithoutHolderRewardsInput
    user?: UserCreateNestedOneWithoutHolderRewardsMultiInput
  }

  export type HolderRewardMultiUncheckedCreateInput = {
    id?: string
    userId?: string | null
    walletAddress: string
    currencyId: string
    lastAccPerToken?: Decimal | DecimalJsLike | number | string
    claimedAmount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type HolderRewardMultiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    lastAccPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    claimedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: CurrencyUpdateOneRequiredWithoutHolderRewardsNestedInput
    user?: UserUpdateOneWithoutHolderRewardsMultiNestedInput
  }

  export type HolderRewardMultiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    lastAccPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    claimedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolderRewardMultiCreateManyInput = {
    id?: string
    userId?: string | null
    walletAddress: string
    currencyId: string
    lastAccPerToken?: Decimal | DecimalJsLike | number | string
    claimedAmount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type HolderRewardMultiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    lastAccPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    claimedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolderRewardMultiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    lastAccPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    claimedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardDistributionLogCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    blockNumber?: number | null
    timestamp?: Date | string
    note?: string | null
    currency: CurrencyCreateNestedOneWithoutDistributionLogsInput
  }

  export type RewardDistributionLogUncheckedCreateInput = {
    id?: string
    currencyId: string
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    blockNumber?: number | null
    timestamp?: Date | string
    note?: string | null
  }

  export type RewardDistributionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: CurrencyUpdateOneRequiredWithoutDistributionLogsNestedInput
  }

  export type RewardDistributionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardDistributionLogCreateManyInput = {
    id?: string
    currencyId: string
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    blockNumber?: number | null
    timestamp?: Date | string
    note?: string | null
  }

  export type RewardDistributionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardDistributionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardClaimLogCreateInput = {
    id?: string
    walletAddress: string
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    timestamp?: Date | string
    currency: CurrencyCreateNestedOneWithoutClaimLogsInput
    user?: UserCreateNestedOneWithoutRewardClaimLogsInput
  }

  export type RewardClaimLogUncheckedCreateInput = {
    id?: string
    walletAddress: string
    userId?: string | null
    currencyId: string
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    timestamp?: Date | string
  }

  export type RewardClaimLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: CurrencyUpdateOneRequiredWithoutClaimLogsNestedInput
    user?: UserUpdateOneWithoutRewardClaimLogsNestedInput
  }

  export type RewardClaimLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    currencyId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardClaimLogCreateManyInput = {
    id?: string
    walletAddress: string
    userId?: string | null
    currencyId: string
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    timestamp?: Date | string
  }

  export type RewardClaimLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardClaimLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    currencyId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StolenItemCreateInput = {
    id?: string
    contract: string
    tokenId: string
    status?: $Enums.StolenStatus
    source?: $Enums.StolenSource
    reporterAddress?: string | null
    evidenceUrl?: string | null
    notes?: string | null
    disputed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reporter?: UserCreateNestedOneWithoutStolenReportsInput
  }

  export type StolenItemUncheckedCreateInput = {
    id?: string
    contract: string
    tokenId: string
    status?: $Enums.StolenStatus
    source?: $Enums.StolenSource
    reporterAddress?: string | null
    reporterUserId?: string | null
    evidenceUrl?: string | null
    notes?: string | null
    disputed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StolenItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    status?: EnumStolenStatusFieldUpdateOperationsInput | $Enums.StolenStatus
    source?: EnumStolenSourceFieldUpdateOperationsInput | $Enums.StolenSource
    reporterAddress?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    disputed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reporter?: UserUpdateOneWithoutStolenReportsNestedInput
  }

  export type StolenItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    status?: EnumStolenStatusFieldUpdateOperationsInput | $Enums.StolenStatus
    source?: EnumStolenSourceFieldUpdateOperationsInput | $Enums.StolenSource
    reporterAddress?: NullableStringFieldUpdateOperationsInput | string | null
    reporterUserId?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    disputed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StolenItemCreateManyInput = {
    id?: string
    contract: string
    tokenId: string
    status?: $Enums.StolenStatus
    source?: $Enums.StolenSource
    reporterAddress?: string | null
    reporterUserId?: string | null
    evidenceUrl?: string | null
    notes?: string | null
    disputed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StolenItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    status?: EnumStolenStatusFieldUpdateOperationsInput | $Enums.StolenStatus
    source?: EnumStolenSourceFieldUpdateOperationsInput | $Enums.StolenSource
    reporterAddress?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    disputed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StolenItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    status?: EnumStolenStatusFieldUpdateOperationsInput | $Enums.StolenStatus
    source?: EnumStolenSourceFieldUpdateOperationsInput | $Enums.StolenSource
    reporterAddress?: NullableStringFieldUpdateOperationsInput | string | null
    reporterUserId?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    disputed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StolenEventCreateInput = {
    id?: string
    contract: string
    tokenId: string
    action: string
    actorAddress?: string | null
    txHash?: string | null
    logIndex?: number | null
    blockNumber?: number | null
    timestamp?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type StolenEventUncheckedCreateInput = {
    id?: string
    contract: string
    tokenId: string
    action: string
    actorAddress?: string | null
    txHash?: string | null
    logIndex?: number | null
    blockNumber?: number | null
    timestamp?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type StolenEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actorAddress?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    logIndex?: NullableIntFieldUpdateOperationsInput | number | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StolenEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actorAddress?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    logIndex?: NullableIntFieldUpdateOperationsInput | number | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StolenEventCreateManyInput = {
    id?: string
    contract: string
    tokenId: string
    action: string
    actorAddress?: string | null
    txHash?: string | null
    logIndex?: number | null
    blockNumber?: number | null
    timestamp?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type StolenEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actorAddress?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    logIndex?: NullableIntFieldUpdateOperationsInput | number | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StolenEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    actorAddress?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    logIndex?: NullableIntFieldUpdateOperationsInput | number | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultisigSafeCreateInput = {
    id?: string
    contract: string
    name?: string | null
    threshold: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owners?: MultisigOwnerCreateNestedManyWithoutSafeInput
    txs?: MultisigTxCreateNestedManyWithoutSafeInput
  }

  export type MultisigSafeUncheckedCreateInput = {
    id?: string
    contract: string
    name?: string | null
    threshold: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owners?: MultisigOwnerUncheckedCreateNestedManyWithoutSafeInput
    txs?: MultisigTxUncheckedCreateNestedManyWithoutSafeInput
  }

  export type MultisigSafeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners?: MultisigOwnerUpdateManyWithoutSafeNestedInput
    txs?: MultisigTxUpdateManyWithoutSafeNestedInput
  }

  export type MultisigSafeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners?: MultisigOwnerUncheckedUpdateManyWithoutSafeNestedInput
    txs?: MultisigTxUncheckedUpdateManyWithoutSafeNestedInput
  }

  export type MultisigSafeCreateManyInput = {
    id?: string
    contract: string
    name?: string | null
    threshold: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MultisigSafeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultisigSafeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultisigOwnerCreateInput = {
    id?: string
    ownerAddress: string
    addedAt?: Date | string
    removedAt?: Date | string | null
    safe: MultisigSafeCreateNestedOneWithoutOwnersInput
  }

  export type MultisigOwnerUncheckedCreateInput = {
    id?: string
    safeId: string
    ownerAddress: string
    addedAt?: Date | string
    removedAt?: Date | string | null
  }

  export type MultisigOwnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    safe?: MultisigSafeUpdateOneRequiredWithoutOwnersNestedInput
  }

  export type MultisigOwnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    safeId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultisigOwnerCreateManyInput = {
    id?: string
    safeId: string
    ownerAddress: string
    addedAt?: Date | string
    removedAt?: Date | string | null
  }

  export type MultisigOwnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultisigOwnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    safeId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultisigTxCreateInput = {
    id?: string
    nonce: number
    to: string
    valueWei?: Decimal | DecimalJsLike | number | string
    dataHex?: string | null
    operation?: number | null
    submittedBy?: string | null
    status?: $Enums.MultisigTxStatus
    executedTxHash?: string | null
    createdAt?: Date | string
    executedAt?: Date | string | null
    approvals?: MultisigApprovalCreateNestedManyWithoutTxInput
    safe: MultisigSafeCreateNestedOneWithoutTxsInput
  }

  export type MultisigTxUncheckedCreateInput = {
    id?: string
    safeId: string
    nonce: number
    to: string
    valueWei?: Decimal | DecimalJsLike | number | string
    dataHex?: string | null
    operation?: number | null
    submittedBy?: string | null
    status?: $Enums.MultisigTxStatus
    executedTxHash?: string | null
    createdAt?: Date | string
    executedAt?: Date | string | null
    approvals?: MultisigApprovalUncheckedCreateNestedManyWithoutTxInput
  }

  export type MultisigTxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    to?: StringFieldUpdateOperationsInput | string
    valueWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataHex?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableIntFieldUpdateOperationsInput | number | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMultisigTxStatusFieldUpdateOperationsInput | $Enums.MultisigTxStatus
    executedTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvals?: MultisigApprovalUpdateManyWithoutTxNestedInput
    safe?: MultisigSafeUpdateOneRequiredWithoutTxsNestedInput
  }

  export type MultisigTxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    safeId?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    to?: StringFieldUpdateOperationsInput | string
    valueWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataHex?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableIntFieldUpdateOperationsInput | number | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMultisigTxStatusFieldUpdateOperationsInput | $Enums.MultisigTxStatus
    executedTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvals?: MultisigApprovalUncheckedUpdateManyWithoutTxNestedInput
  }

  export type MultisigTxCreateManyInput = {
    id?: string
    safeId: string
    nonce: number
    to: string
    valueWei?: Decimal | DecimalJsLike | number | string
    dataHex?: string | null
    operation?: number | null
    submittedBy?: string | null
    status?: $Enums.MultisigTxStatus
    executedTxHash?: string | null
    createdAt?: Date | string
    executedAt?: Date | string | null
  }

  export type MultisigTxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    to?: StringFieldUpdateOperationsInput | string
    valueWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataHex?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableIntFieldUpdateOperationsInput | number | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMultisigTxStatusFieldUpdateOperationsInput | $Enums.MultisigTxStatus
    executedTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultisigTxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    safeId?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    to?: StringFieldUpdateOperationsInput | string
    valueWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataHex?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableIntFieldUpdateOperationsInput | number | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMultisigTxStatusFieldUpdateOperationsInput | $Enums.MultisigTxStatus
    executedTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultisigApprovalCreateInput = {
    id?: string
    ownerAddress: string
    signature?: string | null
    createdAt?: Date | string
    tx: MultisigTxCreateNestedOneWithoutApprovalsInput
  }

  export type MultisigApprovalUncheckedCreateInput = {
    id?: string
    txId: string
    ownerAddress: string
    signature?: string | null
    createdAt?: Date | string
  }

  export type MultisigApprovalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tx?: MultisigTxUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type MultisigApprovalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    txId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultisigApprovalCreateManyInput = {
    id?: string
    txId: string
    ownerAddress: string
    signature?: string | null
    createdAt?: Date | string
  }

  export type MultisigApprovalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultisigApprovalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    txId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingChainActionCreateInput = {
    id?: string
    type: $Enums.PendingChainActionType
    txHash: string
    from: string
    chainId: number
    payload: JsonNullValueInput | InputJsonValue
    relatedId?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingChainActionUncheckedCreateInput = {
    id?: string
    type: $Enums.PendingChainActionType
    txHash: string
    from: string
    chainId: number
    payload: JsonNullValueInput | InputJsonValue
    relatedId?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingChainActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPendingChainActionTypeFieldUpdateOperationsInput | $Enums.PendingChainActionType
    txHash?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    payload?: JsonNullValueInput | InputJsonValue
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingChainActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPendingChainActionTypeFieldUpdateOperationsInput | $Enums.PendingChainActionType
    txHash?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    payload?: JsonNullValueInput | InputJsonValue
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingChainActionCreateManyInput = {
    id?: string
    type: $Enums.PendingChainActionType
    txHash: string
    from: string
    chainId: number
    payload: JsonNullValueInput | InputJsonValue
    relatedId?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingChainActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPendingChainActionTypeFieldUpdateOperationsInput | $Enums.PendingChainActionType
    txHash?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    payload?: JsonNullValueInput | InputJsonValue
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingChainActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumPendingChainActionTypeFieldUpdateOperationsInput | $Enums.PendingChainActionType
    txHash?: StringFieldUpdateOperationsInput | string
    from?: StringFieldUpdateOperationsInput | string
    chainId?: IntFieldUpdateOperationsInput | number
    payload?: JsonNullValueInput | InputJsonValue
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ChainStateContract_userAddressCompoundUniqueInput = {
    userAddress: string
    contract: string
  }

  export type ChainStateCountOrderByAggregateInput = {
    id?: SortOrder
    userAddress?: SortOrder
    contract?: SortOrder
    lastBlockNumber?: SortOrder
  }

  export type ChainStateAvgOrderByAggregateInput = {
    lastBlockNumber?: SortOrder
  }

  export type ChainStateMaxOrderByAggregateInput = {
    id?: SortOrder
    userAddress?: SortOrder
    contract?: SortOrder
    lastBlockNumber?: SortOrder
  }

  export type ChainStateMinOrderByAggregateInput = {
    id?: SortOrder
    userAddress?: SortOrder
    contract?: SortOrder
    lastBlockNumber?: SortOrder
  }

  export type ChainStateSumOrderByAggregateInput = {
    lastBlockNumber?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CollectionListRelationFilter = {
    every?: CollectionWhereInput
    some?: CollectionWhereInput
    none?: CollectionWhereInput
  }

  export type CollectionSubmissionListRelationFilter = {
    every?: CollectionSubmissionWhereInput
    some?: CollectionSubmissionWhereInput
    none?: CollectionSubmissionWhereInput
  }

  export type FeaturedBidListRelationFilter = {
    every?: FeaturedBidWhereInput
    some?: FeaturedBidWhereInput
    none?: FeaturedBidWhereInput
  }

  export type HolderRewardMultiListRelationFilter = {
    every?: HolderRewardMultiWhereInput
    some?: HolderRewardMultiWhereInput
    none?: HolderRewardMultiWhereInput
  }

  export type NFTListRelationFilter = {
    every?: NFTWhereInput
    some?: NFTWhereInput
    none?: NFTWhereInput
  }

  export type RewardClaimLogListRelationFilter = {
    every?: RewardClaimLogWhereInput
    some?: RewardClaimLogWhereInput
    none?: RewardClaimLogWhereInput
  }

  export type StolenItemListRelationFilter = {
    every?: StolenItemWhereInput
    some?: StolenItemWhereInput
    none?: StolenItemWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CollectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeaturedBidOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HolderRewardMultiOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NFTOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RewardClaimLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StolenItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    username?: SortOrder
    bio?: SortOrder
    profileBanner?: SortOrder
    profileAvatar?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    website?: SortOrder
    telegram?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    username?: SortOrder
    bio?: SortOrder
    profileBanner?: SortOrder
    profileAvatar?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    website?: SortOrder
    telegram?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    username?: SortOrder
    bio?: SortOrder
    profileBanner?: SortOrder
    profileAvatar?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    website?: SortOrder
    telegram?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumGatewayPrefFilter<$PrismaModel = never> = {
    equals?: $Enums.GatewayPref | EnumGatewayPrefFieldRefInput<$PrismaModel>
    in?: $Enums.GatewayPref[] | ListEnumGatewayPrefFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatewayPref[] | ListEnumGatewayPrefFieldRefInput<$PrismaModel>
    not?: NestedEnumGatewayPrefFilter<$PrismaModel> | $Enums.GatewayPref
  }

  export type EnumIndexStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IndexStatus | EnumIndexStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IndexStatus[] | ListEnumIndexStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndexStatus[] | ListEnumIndexStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIndexStatusFilter<$PrismaModel> | $Enums.IndexStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AssetUploadListRelationFilter = {
    every?: AssetUploadWhereInput
    some?: AssetUploadWhereInput
    none?: AssetUploadWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DeployedContractNullableScalarRelationFilter = {
    is?: DeployedContractWhereInput | null
    isNot?: DeployedContractWhereInput | null
  }

  export type FeaturedCycleListRelationFilter = {
    every?: FeaturedCycleWhereInput
    some?: FeaturedCycleWhereInput
    none?: FeaturedCycleWhereInput
  }

  export type PresaleNullableScalarRelationFilter = {
    is?: PresaleWhereInput | null
    isNot?: PresaleWhereInput | null
  }

  export type PublicSaleNullableScalarRelationFilter = {
    is?: PublicSaleWhereInput | null
    isNot?: PublicSaleWhereInput | null
  }

  export type AssetUploadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeaturedCycleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    coverUrl?: SortOrder
    standard?: SortOrder
    supply?: SortOrder
    baseUri?: SortOrder
    gatewayPref?: SortOrder
    indexStatus?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    website?: SortOrder
    discord?: SortOrder
    telegram?: SortOrder
    floorPrice?: SortOrder
    volume?: SortOrder
    itemsCount?: SortOrder
    ownersCount?: SortOrder
    change24h?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    isOrphan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionAvgOrderByAggregateInput = {
    supply?: SortOrder
    floorPrice?: SortOrder
    volume?: SortOrder
    itemsCount?: SortOrder
    ownersCount?: SortOrder
    change24h?: SortOrder
  }

  export type CollectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    coverUrl?: SortOrder
    standard?: SortOrder
    supply?: SortOrder
    baseUri?: SortOrder
    gatewayPref?: SortOrder
    indexStatus?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    website?: SortOrder
    discord?: SortOrder
    telegram?: SortOrder
    floorPrice?: SortOrder
    volume?: SortOrder
    itemsCount?: SortOrder
    ownersCount?: SortOrder
    change24h?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    isOrphan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    coverUrl?: SortOrder
    standard?: SortOrder
    supply?: SortOrder
    baseUri?: SortOrder
    gatewayPref?: SortOrder
    indexStatus?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    website?: SortOrder
    discord?: SortOrder
    telegram?: SortOrder
    floorPrice?: SortOrder
    volume?: SortOrder
    itemsCount?: SortOrder
    ownersCount?: SortOrder
    change24h?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    isOrphan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionSumOrderByAggregateInput = {
    supply?: SortOrder
    floorPrice?: SortOrder
    volume?: SortOrder
    itemsCount?: SortOrder
    ownersCount?: SortOrder
    change24h?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumGatewayPrefWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GatewayPref | EnumGatewayPrefFieldRefInput<$PrismaModel>
    in?: $Enums.GatewayPref[] | ListEnumGatewayPrefFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatewayPref[] | ListEnumGatewayPrefFieldRefInput<$PrismaModel>
    not?: NestedEnumGatewayPrefWithAggregatesFilter<$PrismaModel> | $Enums.GatewayPref
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGatewayPrefFilter<$PrismaModel>
    _max?: NestedEnumGatewayPrefFilter<$PrismaModel>
  }

  export type EnumIndexStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IndexStatus | EnumIndexStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IndexStatus[] | ListEnumIndexStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndexStatus[] | ListEnumIndexStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIndexStatusWithAggregatesFilter<$PrismaModel> | $Enums.IndexStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIndexStatusFilter<$PrismaModel>
    _max?: NestedEnumIndexStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumNftStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NftStatus | EnumNftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NftStatus[] | ListEnumNftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NftStatus[] | ListEnumNftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNftStatusFilter<$PrismaModel> | $Enums.NftStatus
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type AuctionListRelationFilter = {
    every?: AuctionWhereInput
    some?: AuctionWhereInput
    none?: AuctionWhereInput
  }

  export type MarketplaceListingListRelationFilter = {
    every?: MarketplaceListingWhereInput
    some?: MarketplaceListingWhereInput
    none?: MarketplaceListingWhereInput
  }

  export type MarketplaceSaleListRelationFilter = {
    every?: MarketplaceSaleWhereInput
    some?: MarketplaceSaleWhereInput
    none?: MarketplaceSaleWhereInput
  }

  export type CollectionNullableScalarRelationFilter = {
    is?: CollectionWhereInput | null
    isNot?: CollectionWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type Single1155NullableScalarRelationFilter = {
    is?: Single1155WhereInput | null
    isNot?: Single1155WhereInput | null
  }

  export type Single721NullableScalarRelationFilter = {
    is?: Single721WhereInput | null
    isNot?: Single721WhereInput | null
  }

  export type NFTActivityListRelationFilter = {
    every?: NFTActivityWhereInput
    some?: NFTActivityWhereInput
    none?: NFTActivityWhereInput
  }

  export type AuctionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketplaceListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketplaceSaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NFTActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NFTContractTokenIdCompoundUniqueInput = {
    contract: string
    tokenId: string
  }

  export type NFTTokenIdContractCollectionIdCompoundUniqueInput = {
    tokenId: string
    contract: string
    collectionId: string
  }

  export type NFTCountOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrder
    traits?: SortOrder
    attributes?: SortOrder
    tokenUri?: SortOrder
    contract?: SortOrder
    standard?: SortOrder
    rawMetadata?: SortOrder
    royaltyBps?: SortOrder
    royaltyRecipient?: SortOrder
    ownerId?: SortOrder
    collectionId?: SortOrder
    single721Id?: SortOrder
    single1155Id?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rarityScore?: SortOrder
  }

  export type NFTAvgOrderByAggregateInput = {
    royaltyBps?: SortOrder
    retryCount?: SortOrder
    rarityScore?: SortOrder
  }

  export type NFTMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrder
    tokenUri?: SortOrder
    contract?: SortOrder
    standard?: SortOrder
    royaltyBps?: SortOrder
    royaltyRecipient?: SortOrder
    ownerId?: SortOrder
    collectionId?: SortOrder
    single721Id?: SortOrder
    single1155Id?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rarityScore?: SortOrder
  }

  export type NFTMinOrderByAggregateInput = {
    id?: SortOrder
    tokenId?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    description?: SortOrder
    tokenUri?: SortOrder
    contract?: SortOrder
    standard?: SortOrder
    royaltyBps?: SortOrder
    royaltyRecipient?: SortOrder
    ownerId?: SortOrder
    collectionId?: SortOrder
    single721Id?: SortOrder
    single1155Id?: SortOrder
    status?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rarityScore?: SortOrder
  }

  export type NFTSumOrderByAggregateInput = {
    royaltyBps?: SortOrder
    retryCount?: SortOrder
    rarityScore?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumNftStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NftStatus | EnumNftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NftStatus[] | ListEnumNftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NftStatus[] | ListEnumNftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNftStatusWithAggregatesFilter<$PrismaModel> | $Enums.NftStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNftStatusFilter<$PrismaModel>
    _max?: NestedEnumNftStatusFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TraitStatContractTrait_typeValueCompoundUniqueInput = {
    contract: string
    trait_type: string
    value: InputJsonValue
  }

  export type TraitStatCountOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    trait_type?: SortOrder
    value?: SortOrder
    count?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
  }

  export type TraitStatAvgOrderByAggregateInput = {
    count?: SortOrder
    frequency?: SortOrder
  }

  export type TraitStatMaxOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    trait_type?: SortOrder
    count?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
  }

  export type TraitStatMinOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    trait_type?: SortOrder
    count?: SortOrder
    frequency?: SortOrder
    createdAt?: SortOrder
  }

  export type TraitStatSumOrderByAggregateInput = {
    count?: SortOrder
    frequency?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type NFTScalarRelationFilter = {
    is?: NFTWhereInput
    isNot?: NFTWhereInput
  }

  export type NFTActivityTxHashLogIndexCompoundUniqueInput = {
    txHash: string
    logIndex: number
  }

  export type NFTActivityCountOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    priceEtnWei?: SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    marketplace?: SortOrder
    rawData?: SortOrder
    createdAt?: SortOrder
  }

  export type NFTActivityAvgOrderByAggregateInput = {
    priceEtnWei?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
  }

  export type NFTActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    priceEtnWei?: SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    marketplace?: SortOrder
    createdAt?: SortOrder
  }

  export type NFTActivityMinOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    type?: SortOrder
    fromAddress?: SortOrder
    toAddress?: SortOrder
    priceEtnWei?: SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    marketplace?: SortOrder
    createdAt?: SortOrder
  }

  export type NFTActivitySumOrderByAggregateInput = {
    priceEtnWei?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
  }

  export type Single721CountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    tokenUri?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    indexStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Single721AvgOrderByAggregateInput = {
    royaltyBps?: SortOrder
  }

  export type Single721MaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    tokenUri?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    indexStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Single721MinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    tokenUri?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    indexStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Single721SumOrderByAggregateInput = {
    royaltyBps?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Erc1155BalanceListRelationFilter = {
    every?: Erc1155BalanceWhereInput
    some?: Erc1155BalanceWhereInput
    none?: Erc1155BalanceWhereInput
  }

  export type Erc1155BalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Single1155CountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    baseUri?: SortOrder
    maxSupply?: SortOrder
    mintPriceEtnWei?: SortOrder
    maxPerWallet?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    indexStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Single1155AvgOrderByAggregateInput = {
    maxSupply?: SortOrder
    mintPriceEtnWei?: SortOrder
    maxPerWallet?: SortOrder
    royaltyBps?: SortOrder
  }

  export type Single1155MaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    baseUri?: SortOrder
    maxSupply?: SortOrder
    mintPriceEtnWei?: SortOrder
    maxPerWallet?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    indexStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Single1155MinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    contract?: SortOrder
    baseUri?: SortOrder
    maxSupply?: SortOrder
    mintPriceEtnWei?: SortOrder
    maxPerWallet?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    creatorId?: SortOrder
    ownerAddress?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    indexStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Single1155SumOrderByAggregateInput = {
    maxSupply?: SortOrder
    mintPriceEtnWei?: SortOrder
    maxPerWallet?: SortOrder
    royaltyBps?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Single1155ScalarRelationFilter = {
    is?: Single1155WhereInput
    isNot?: Single1155WhereInput
  }

  export type Erc1155BalanceSingle1155IdOwnerAddressCompoundUniqueInput = {
    single1155Id: string
    ownerAddress: string
  }

  export type Erc1155BalanceCountOrderByAggregateInput = {
    id?: SortOrder
    single1155Id?: SortOrder
    ownerAddress?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
  }

  export type Erc1155BalanceAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type Erc1155BalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    single1155Id?: SortOrder
    ownerAddress?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
  }

  export type Erc1155BalanceMinOrderByAggregateInput = {
    id?: SortOrder
    single1155Id?: SortOrder
    ownerAddress?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
  }

  export type Erc1155BalanceSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type Erc1155HoldingContractTokenIdOwnerAddressCompoundUniqueInput = {
    contract: string
    tokenId: string
    ownerAddress: string
  }

  export type Erc1155HoldingCountOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    ownerAddress?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
  }

  export type Erc1155HoldingAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type Erc1155HoldingMaxOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    ownerAddress?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
  }

  export type Erc1155HoldingMinOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    ownerAddress?: SortOrder
    balance?: SortOrder
    updatedAt?: SortOrder
  }

  export type Erc1155HoldingSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type EnumListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusFilter<$PrismaModel> | $Enums.ListingStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CurrencyNullableScalarRelationFilter = {
    is?: CurrencyWhereInput | null
    isNot?: CurrencyWhereInput | null
  }

  export type MarketplaceListingCountOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    priceEtnWei?: SortOrder
    currencyId?: SortOrder
    priceTokenAmount?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    txHashCreated?: SortOrder
    txHashFilled?: SortOrder
    txHashCancelled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceListingAvgOrderByAggregateInput = {
    quantity?: SortOrder
    priceEtnWei?: SortOrder
    priceTokenAmount?: SortOrder
  }

  export type MarketplaceListingMaxOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    priceEtnWei?: SortOrder
    currencyId?: SortOrder
    priceTokenAmount?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    txHashCreated?: SortOrder
    txHashFilled?: SortOrder
    txHashCancelled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceListingMinOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    priceEtnWei?: SortOrder
    currencyId?: SortOrder
    priceTokenAmount?: SortOrder
    status?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    txHashCreated?: SortOrder
    txHashFilled?: SortOrder
    txHashCancelled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketplaceListingSumOrderByAggregateInput = {
    quantity?: SortOrder
    priceEtnWei?: SortOrder
    priceTokenAmount?: SortOrder
  }

  export type EnumListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingStatusFilter<$PrismaModel>
    _max?: NestedEnumListingStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumAuctionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuctionStatus | EnumAuctionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuctionStatusFilter<$PrismaModel> | $Enums.AuctionStatus
  }

  export type AuctionBidListRelationFilter = {
    every?: AuctionBidWhereInput
    some?: AuctionBidWhereInput
    none?: AuctionBidWhereInput
  }

  export type AuctionBidOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuctionCountOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    startPriceEtnWei?: SortOrder
    highestBidEtnWei?: SortOrder
    minIncrementEtnWei?: SortOrder
    currencyId?: SortOrder
    startPriceTokenAmount?: SortOrder
    highestBidTokenAmount?: SortOrder
    minIncrementTokenAmount?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    txHashCreated?: SortOrder
    txHashFinalized?: SortOrder
    txHashCancelled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highestBidder?: SortOrder
  }

  export type AuctionAvgOrderByAggregateInput = {
    quantity?: SortOrder
    startPriceEtnWei?: SortOrder
    highestBidEtnWei?: SortOrder
    minIncrementEtnWei?: SortOrder
    startPriceTokenAmount?: SortOrder
    highestBidTokenAmount?: SortOrder
    minIncrementTokenAmount?: SortOrder
  }

  export type AuctionMaxOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    startPriceEtnWei?: SortOrder
    highestBidEtnWei?: SortOrder
    minIncrementEtnWei?: SortOrder
    currencyId?: SortOrder
    startPriceTokenAmount?: SortOrder
    highestBidTokenAmount?: SortOrder
    minIncrementTokenAmount?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    txHashCreated?: SortOrder
    txHashFinalized?: SortOrder
    txHashCancelled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highestBidder?: SortOrder
  }

  export type AuctionMinOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    startPriceEtnWei?: SortOrder
    highestBidEtnWei?: SortOrder
    minIncrementEtnWei?: SortOrder
    currencyId?: SortOrder
    startPriceTokenAmount?: SortOrder
    highestBidTokenAmount?: SortOrder
    minIncrementTokenAmount?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    txHashCreated?: SortOrder
    txHashFinalized?: SortOrder
    txHashCancelled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    highestBidder?: SortOrder
  }

  export type AuctionSumOrderByAggregateInput = {
    quantity?: SortOrder
    startPriceEtnWei?: SortOrder
    highestBidEtnWei?: SortOrder
    minIncrementEtnWei?: SortOrder
    startPriceTokenAmount?: SortOrder
    highestBidTokenAmount?: SortOrder
    minIncrementTokenAmount?: SortOrder
  }

  export type EnumAuctionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuctionStatus | EnumAuctionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuctionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuctionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuctionStatusFilter<$PrismaModel>
    _max?: NestedEnumAuctionStatusFilter<$PrismaModel>
  }

  export type AuctionScalarRelationFilter = {
    is?: AuctionWhereInput
    isNot?: AuctionWhereInput
  }

  export type AuctionBidTxHashLogIndexCompoundUniqueInput = {
    txHash: string
    logIndex: number
  }

  export type AuctionBidCountOrderByAggregateInput = {
    id?: SortOrder
    auctionId?: SortOrder
    bidderAddress?: SortOrder
    amountWei?: SortOrder
    currencyId?: SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type AuctionBidAvgOrderByAggregateInput = {
    amountWei?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
  }

  export type AuctionBidMaxOrderByAggregateInput = {
    id?: SortOrder
    auctionId?: SortOrder
    bidderAddress?: SortOrder
    amountWei?: SortOrder
    currencyId?: SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type AuctionBidMinOrderByAggregateInput = {
    id?: SortOrder
    auctionId?: SortOrder
    bidderAddress?: SortOrder
    amountWei?: SortOrder
    currencyId?: SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type AuctionBidSumOrderByAggregateInput = {
    amountWei?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
  }

  export type EnumContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeFilter<$PrismaModel> | $Enums.ContractType
  }

  export type EnumMetadataOptionFilter<$PrismaModel = never> = {
    equals?: $Enums.MetadataOption | EnumMetadataOptionFieldRefInput<$PrismaModel>
    in?: $Enums.MetadataOption[] | ListEnumMetadataOptionFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetadataOption[] | ListEnumMetadataOptionFieldRefInput<$PrismaModel>
    not?: NestedEnumMetadataOptionFilter<$PrismaModel> | $Enums.MetadataOption
  }

  export type DeployedContractCountOrderByAggregateInput = {
    id?: SortOrder
    contractType?: SortOrder
    cloneAddress?: SortOrder
    implementationAddr?: SortOrder
    factoryAddress?: SortOrder
    deployerAddress?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    metadataOption?: SortOrder
    feeRecipient?: SortOrder
    feeAmountEtnWei?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    baseURI?: SortOrder
    maxSupply?: SortOrder
    rawInit?: SortOrder
    createdAt?: SortOrder
    collectionId?: SortOrder
    single721Id?: SortOrder
    single1155Id?: SortOrder
  }

  export type DeployedContractAvgOrderByAggregateInput = {
    blockNumber?: SortOrder
    feeAmountEtnWei?: SortOrder
    royaltyBps?: SortOrder
    maxSupply?: SortOrder
  }

  export type DeployedContractMaxOrderByAggregateInput = {
    id?: SortOrder
    contractType?: SortOrder
    cloneAddress?: SortOrder
    implementationAddr?: SortOrder
    factoryAddress?: SortOrder
    deployerAddress?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    metadataOption?: SortOrder
    feeRecipient?: SortOrder
    feeAmountEtnWei?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    baseURI?: SortOrder
    maxSupply?: SortOrder
    createdAt?: SortOrder
    collectionId?: SortOrder
    single721Id?: SortOrder
    single1155Id?: SortOrder
  }

  export type DeployedContractMinOrderByAggregateInput = {
    id?: SortOrder
    contractType?: SortOrder
    cloneAddress?: SortOrder
    implementationAddr?: SortOrder
    factoryAddress?: SortOrder
    deployerAddress?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    metadataOption?: SortOrder
    feeRecipient?: SortOrder
    feeAmountEtnWei?: SortOrder
    royaltyRecipient?: SortOrder
    royaltyBps?: SortOrder
    baseURI?: SortOrder
    maxSupply?: SortOrder
    createdAt?: SortOrder
    collectionId?: SortOrder
    single721Id?: SortOrder
    single1155Id?: SortOrder
  }

  export type DeployedContractSumOrderByAggregateInput = {
    blockNumber?: SortOrder
    feeAmountEtnWei?: SortOrder
    royaltyBps?: SortOrder
    maxSupply?: SortOrder
  }

  export type EnumContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractTypeFilter<$PrismaModel>
    _max?: NestedEnumContractTypeFilter<$PrismaModel>
  }

  export type EnumMetadataOptionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetadataOption | EnumMetadataOptionFieldRefInput<$PrismaModel>
    in?: $Enums.MetadataOption[] | ListEnumMetadataOptionFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetadataOption[] | ListEnumMetadataOptionFieldRefInput<$PrismaModel>
    not?: NestedEnumMetadataOptionWithAggregatesFilter<$PrismaModel> | $Enums.MetadataOption
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetadataOptionFilter<$PrismaModel>
    _max?: NestedEnumMetadataOptionFilter<$PrismaModel>
  }

  export type FeeConfigLogListRelationFilter = {
    every?: FeeConfigLogWhereInput
    some?: FeeConfigLogWhereInput
    none?: FeeConfigLogWhereInput
  }

  export type FeeConfigLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeeConfigContractTypeMetadataOptionCompoundUniqueInput = {
    contractType: $Enums.ContractType
    metadataOption: $Enums.MetadataOption
  }

  export type FeeConfigCountOrderByAggregateInput = {
    id?: SortOrder
    contractType?: SortOrder
    metadataOption?: SortOrder
    feeRecipient?: SortOrder
    feeAmountEtnWei?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedByUserId?: SortOrder
    targetUsdCents?: SortOrder
    pricingSource?: SortOrder
    pricingPair?: SortOrder
    lastPriceUsd?: SortOrder
    lastPriceAt?: SortOrder
  }

  export type FeeConfigAvgOrderByAggregateInput = {
    feeAmountEtnWei?: SortOrder
    targetUsdCents?: SortOrder
    lastPriceUsd?: SortOrder
  }

  export type FeeConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    contractType?: SortOrder
    metadataOption?: SortOrder
    feeRecipient?: SortOrder
    feeAmountEtnWei?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedByUserId?: SortOrder
    targetUsdCents?: SortOrder
    pricingSource?: SortOrder
    pricingPair?: SortOrder
    lastPriceUsd?: SortOrder
    lastPriceAt?: SortOrder
  }

  export type FeeConfigMinOrderByAggregateInput = {
    id?: SortOrder
    contractType?: SortOrder
    metadataOption?: SortOrder
    feeRecipient?: SortOrder
    feeAmountEtnWei?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    updatedByUserId?: SortOrder
    targetUsdCents?: SortOrder
    pricingSource?: SortOrder
    pricingPair?: SortOrder
    lastPriceUsd?: SortOrder
    lastPriceAt?: SortOrder
  }

  export type FeeConfigSumOrderByAggregateInput = {
    feeAmountEtnWei?: SortOrder
    targetUsdCents?: SortOrder
    lastPriceUsd?: SortOrder
  }

  export type FeeConfigScalarRelationFilter = {
    is?: FeeConfigWhereInput
    isNot?: FeeConfigWhereInput
  }

  export type FeeConfigLogCountOrderByAggregateInput = {
    id?: SortOrder
    feeConfigId?: SortOrder
    previousRecipient?: SortOrder
    newRecipient?: SortOrder
    previousAmountEtnWei?: SortOrder
    newAmountEtnWei?: SortOrder
    changedByUserId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type FeeConfigLogAvgOrderByAggregateInput = {
    previousAmountEtnWei?: SortOrder
    newAmountEtnWei?: SortOrder
  }

  export type FeeConfigLogMaxOrderByAggregateInput = {
    id?: SortOrder
    feeConfigId?: SortOrder
    previousRecipient?: SortOrder
    newRecipient?: SortOrder
    previousAmountEtnWei?: SortOrder
    newAmountEtnWei?: SortOrder
    changedByUserId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type FeeConfigLogMinOrderByAggregateInput = {
    id?: SortOrder
    feeConfigId?: SortOrder
    previousRecipient?: SortOrder
    newRecipient?: SortOrder
    previousAmountEtnWei?: SortOrder
    newAmountEtnWei?: SortOrder
    changedByUserId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type FeeConfigLogSumOrderByAggregateInput = {
    previousAmountEtnWei?: SortOrder
    newAmountEtnWei?: SortOrder
  }

  export type CollectionScalarRelationFilter = {
    is?: CollectionWhereInput
    isNot?: CollectionWhereInput
  }

  export type PublicSaleCountOrderByAggregateInput = {
    id?: SortOrder
    collectionId?: SortOrder
    startTime?: SortOrder
    priceEtnWei?: SortOrder
    maxPerWallet?: SortOrder
    maxPerTx?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicSaleAvgOrderByAggregateInput = {
    priceEtnWei?: SortOrder
    maxPerWallet?: SortOrder
    maxPerTx?: SortOrder
  }

  export type PublicSaleMaxOrderByAggregateInput = {
    id?: SortOrder
    collectionId?: SortOrder
    startTime?: SortOrder
    priceEtnWei?: SortOrder
    maxPerWallet?: SortOrder
    maxPerTx?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicSaleMinOrderByAggregateInput = {
    id?: SortOrder
    collectionId?: SortOrder
    startTime?: SortOrder
    priceEtnWei?: SortOrder
    maxPerWallet?: SortOrder
    maxPerTx?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PublicSaleSumOrderByAggregateInput = {
    priceEtnWei?: SortOrder
    maxPerWallet?: SortOrder
    maxPerTx?: SortOrder
  }

  export type PresaleWhitelistAddressListRelationFilter = {
    every?: PresaleWhitelistAddressWhereInput
    some?: PresaleWhitelistAddressWhereInput
    none?: PresaleWhitelistAddressWhereInput
  }

  export type PresaleWhitelistAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PresaleCountOrderByAggregateInput = {
    id?: SortOrder
    collectionId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    priceEtnWei?: SortOrder
    maxSupply?: SortOrder
    merkleRoot?: SortOrder
    whitelistCount?: SortOrder
    allowlistCommit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PresaleAvgOrderByAggregateInput = {
    priceEtnWei?: SortOrder
    maxSupply?: SortOrder
    whitelistCount?: SortOrder
  }

  export type PresaleMaxOrderByAggregateInput = {
    id?: SortOrder
    collectionId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    priceEtnWei?: SortOrder
    maxSupply?: SortOrder
    merkleRoot?: SortOrder
    whitelistCount?: SortOrder
    allowlistCommit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PresaleMinOrderByAggregateInput = {
    id?: SortOrder
    collectionId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    priceEtnWei?: SortOrder
    maxSupply?: SortOrder
    merkleRoot?: SortOrder
    whitelistCount?: SortOrder
    allowlistCommit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PresaleSumOrderByAggregateInput = {
    priceEtnWei?: SortOrder
    maxSupply?: SortOrder
    whitelistCount?: SortOrder
  }

  export type PresaleScalarRelationFilter = {
    is?: PresaleWhereInput
    isNot?: PresaleWhereInput
  }

  export type PresaleWhitelistAddressPresaleIdAddressCompoundUniqueInput = {
    presaleId: string
    address: string
  }

  export type PresaleWhitelistAddressCountOrderByAggregateInput = {
    id?: SortOrder
    presaleId?: SortOrder
    address?: SortOrder
    maxAllocation?: SortOrder
  }

  export type PresaleWhitelistAddressAvgOrderByAggregateInput = {
    maxAllocation?: SortOrder
  }

  export type PresaleWhitelistAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    presaleId?: SortOrder
    address?: SortOrder
    maxAllocation?: SortOrder
  }

  export type PresaleWhitelistAddressMinOrderByAggregateInput = {
    id?: SortOrder
    presaleId?: SortOrder
    address?: SortOrder
    maxAllocation?: SortOrder
  }

  export type PresaleWhitelistAddressSumOrderByAggregateInput = {
    maxAllocation?: SortOrder
  }

  export type EnumDraftStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DraftStatus | EnumDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DraftStatus[] | ListEnumDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DraftStatus[] | ListEnumDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDraftStatusFilter<$PrismaModel> | $Enums.DraftStatus
  }

  export type PresaleDraftCountOrderByAggregateInput = {
    id?: SortOrder
    creatorUserId?: SortOrder
    addresses?: SortOrder
    count?: SortOrder
    merkleRoot?: SortOrder
    sha256Commit?: SortOrder
    status?: SortOrder
    consumedAt?: SortOrder
    consumedByPresaleId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PresaleDraftAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type PresaleDraftMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorUserId?: SortOrder
    count?: SortOrder
    merkleRoot?: SortOrder
    sha256Commit?: SortOrder
    status?: SortOrder
    consumedAt?: SortOrder
    consumedByPresaleId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PresaleDraftMinOrderByAggregateInput = {
    id?: SortOrder
    creatorUserId?: SortOrder
    count?: SortOrder
    merkleRoot?: SortOrder
    sha256Commit?: SortOrder
    status?: SortOrder
    consumedAt?: SortOrder
    consumedByPresaleId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PresaleDraftSumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type EnumDraftStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DraftStatus | EnumDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DraftStatus[] | ListEnumDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DraftStatus[] | ListEnumDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDraftStatusWithAggregatesFilter<$PrismaModel> | $Enums.DraftStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDraftStatusFilter<$PrismaModel>
    _max?: NestedEnumDraftStatusFilter<$PrismaModel>
  }

  export type AssetUploadCountOrderByAggregateInput = {
    id?: SortOrder
    uploaderUserId?: SortOrder
    collectionId?: SortOrder
    single721Id?: SortOrder
    single1155Id?: SortOrder
    provider?: SortOrder
    cid?: SortOrder
    url?: SortOrder
    bytes?: SortOrder
    sha256?: SortOrder
    contentType?: SortOrder
    originalName?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetUploadAvgOrderByAggregateInput = {
    bytes?: SortOrder
  }

  export type AssetUploadMaxOrderByAggregateInput = {
    id?: SortOrder
    uploaderUserId?: SortOrder
    collectionId?: SortOrder
    single721Id?: SortOrder
    single1155Id?: SortOrder
    provider?: SortOrder
    cid?: SortOrder
    url?: SortOrder
    bytes?: SortOrder
    sha256?: SortOrder
    contentType?: SortOrder
    originalName?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetUploadMinOrderByAggregateInput = {
    id?: SortOrder
    uploaderUserId?: SortOrder
    collectionId?: SortOrder
    single721Id?: SortOrder
    single1155Id?: SortOrder
    provider?: SortOrder
    cid?: SortOrder
    url?: SortOrder
    bytes?: SortOrder
    sha256?: SortOrder
    contentType?: SortOrder
    originalName?: SortOrder
    createdAt?: SortOrder
  }

  export type AssetUploadSumOrderByAggregateInput = {
    bytes?: SortOrder
  }

  export type EnumSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusFilter<$PrismaModel> | $Enums.SubmissionStatus
  }

  export type CollectionSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    submittedByUserId?: SortOrder
    contract?: SortOrder
    ownerAddress?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    logoUrl?: SortOrder
    coverUrl?: SortOrder
    baseUri?: SortOrder
    supply?: SortOrder
    description?: SortOrder
    website?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    telegram?: SortOrder
    feeTxHash?: SortOrder
    feePaidWei?: SortOrder
    feeVerifiedAt?: SortOrder
    ownershipVerified?: SortOrder
    status?: SortOrder
    statusReason?: SortOrder
    reviewedByUserId?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionSubmissionAvgOrderByAggregateInput = {
    supply?: SortOrder
    feePaidWei?: SortOrder
  }

  export type CollectionSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    submittedByUserId?: SortOrder
    contract?: SortOrder
    ownerAddress?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    logoUrl?: SortOrder
    coverUrl?: SortOrder
    baseUri?: SortOrder
    supply?: SortOrder
    description?: SortOrder
    website?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    telegram?: SortOrder
    feeTxHash?: SortOrder
    feePaidWei?: SortOrder
    feeVerifiedAt?: SortOrder
    ownershipVerified?: SortOrder
    status?: SortOrder
    statusReason?: SortOrder
    reviewedByUserId?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    submittedByUserId?: SortOrder
    contract?: SortOrder
    ownerAddress?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    logoUrl?: SortOrder
    coverUrl?: SortOrder
    baseUri?: SortOrder
    supply?: SortOrder
    description?: SortOrder
    website?: SortOrder
    x?: SortOrder
    instagram?: SortOrder
    telegram?: SortOrder
    feeTxHash?: SortOrder
    feePaidWei?: SortOrder
    feeVerifiedAt?: SortOrder
    ownershipVerified?: SortOrder
    status?: SortOrder
    statusReason?: SortOrder
    reviewedByUserId?: SortOrder
    reviewedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CollectionSubmissionSumOrderByAggregateInput = {
    supply?: SortOrder
    feePaidWei?: SortOrder
  }

  export type EnumSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubmissionStatusFilter<$PrismaModel>
  }

  export type NFTRarityContractTokenIdCompoundUniqueInput = {
    contract: string
    tokenId: string
  }

  export type NFTRarityCountOrderByAggregateInput = {
    contract?: SortOrder
    tokenId?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    updatedAt?: SortOrder
  }

  export type NFTRarityAvgOrderByAggregateInput = {
    score?: SortOrder
    rank?: SortOrder
  }

  export type NFTRarityMaxOrderByAggregateInput = {
    contract?: SortOrder
    tokenId?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    updatedAt?: SortOrder
  }

  export type NFTRarityMinOrderByAggregateInput = {
    contract?: SortOrder
    tokenId?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    updatedAt?: SortOrder
  }

  export type NFTRaritySumOrderByAggregateInput = {
    score?: SortOrder
    rank?: SortOrder
  }

  export type HolderRewardCountOrderByAggregateInput = {
    user_id?: SortOrder
    wallet_address?: SortOrder
    last_acc_per_token?: SortOrder
    claimed_etn?: SortOrder
    updated_at?: SortOrder
  }

  export type HolderRewardAvgOrderByAggregateInput = {
    last_acc_per_token?: SortOrder
    claimed_etn?: SortOrder
  }

  export type HolderRewardMaxOrderByAggregateInput = {
    user_id?: SortOrder
    wallet_address?: SortOrder
    last_acc_per_token?: SortOrder
    claimed_etn?: SortOrder
    updated_at?: SortOrder
  }

  export type HolderRewardMinOrderByAggregateInput = {
    user_id?: SortOrder
    wallet_address?: SortOrder
    last_acc_per_token?: SortOrder
    claimed_etn?: SortOrder
    updated_at?: SortOrder
  }

  export type HolderRewardSumOrderByAggregateInput = {
    last_acc_per_token?: SortOrder
    claimed_etn?: SortOrder
  }

  export type RewardAccumulatorCountOrderByAggregateInput = {
    id?: SortOrder
    acc_per_token?: SortOrder
    updated_at?: SortOrder
  }

  export type RewardAccumulatorAvgOrderByAggregateInput = {
    acc_per_token?: SortOrder
  }

  export type RewardAccumulatorMaxOrderByAggregateInput = {
    id?: SortOrder
    acc_per_token?: SortOrder
    updated_at?: SortOrder
  }

  export type RewardAccumulatorMinOrderByAggregateInput = {
    id?: SortOrder
    acc_per_token?: SortOrder
    updated_at?: SortOrder
  }

  export type RewardAccumulatorSumOrderByAggregateInput = {
    acc_per_token?: SortOrder
  }

  export type EnumFeaturedCycleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeaturedCycleStatus | EnumFeaturedCycleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeaturedCycleStatus[] | ListEnumFeaturedCycleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeaturedCycleStatus[] | ListEnumFeaturedCycleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeaturedCycleStatusFilter<$PrismaModel> | $Enums.FeaturedCycleStatus
  }

  export type FeaturedBidNullableScalarRelationFilter = {
    is?: FeaturedBidWhereInput | null
    isNot?: FeaturedBidWhereInput | null
  }

  export type FeaturedCycleCountOrderByAggregateInput = {
    id?: SortOrder
    cycleId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    minBidWei?: SortOrder
    winnerBidId?: SortOrder
    winnerCollectionContract?: SortOrder
    winnerAmountWei?: SortOrder
    finalizedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedCycleAvgOrderByAggregateInput = {
    minBidWei?: SortOrder
    winnerAmountWei?: SortOrder
  }

  export type FeaturedCycleMaxOrderByAggregateInput = {
    id?: SortOrder
    cycleId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    minBidWei?: SortOrder
    winnerBidId?: SortOrder
    winnerCollectionContract?: SortOrder
    winnerAmountWei?: SortOrder
    finalizedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedCycleMinOrderByAggregateInput = {
    id?: SortOrder
    cycleId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    minBidWei?: SortOrder
    winnerBidId?: SortOrder
    winnerCollectionContract?: SortOrder
    winnerAmountWei?: SortOrder
    finalizedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedCycleSumOrderByAggregateInput = {
    minBidWei?: SortOrder
    winnerAmountWei?: SortOrder
  }

  export type EnumFeaturedCycleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeaturedCycleStatus | EnumFeaturedCycleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeaturedCycleStatus[] | ListEnumFeaturedCycleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeaturedCycleStatus[] | ListEnumFeaturedCycleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeaturedCycleStatusWithAggregatesFilter<$PrismaModel> | $Enums.FeaturedCycleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeaturedCycleStatusFilter<$PrismaModel>
    _max?: NestedEnumFeaturedCycleStatusFilter<$PrismaModel>
  }

  export type FeaturedCycleScalarRelationFilter = {
    is?: FeaturedCycleWhereInput
    isNot?: FeaturedCycleWhereInput
  }

  export type FeaturedCycleNullableScalarRelationFilter = {
    is?: FeaturedCycleWhereInput | null
    isNot?: FeaturedCycleWhereInput | null
  }

  export type FeaturedBidCycleIdBidderAddressCompoundUniqueInput = {
    cycleId: string
    bidderAddress: string
  }

  export type FeaturedBidCountOrderByAggregateInput = {
    id?: SortOrder
    cycleId?: SortOrder
    bidderAddress?: SortOrder
    bidderUserId?: SortOrder
    collectionContract?: SortOrder
    totalBidWei?: SortOrder
    txCount?: SortOrder
    lastTxHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedBidAvgOrderByAggregateInput = {
    totalBidWei?: SortOrder
    txCount?: SortOrder
  }

  export type FeaturedBidMaxOrderByAggregateInput = {
    id?: SortOrder
    cycleId?: SortOrder
    bidderAddress?: SortOrder
    bidderUserId?: SortOrder
    collectionContract?: SortOrder
    totalBidWei?: SortOrder
    txCount?: SortOrder
    lastTxHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedBidMinOrderByAggregateInput = {
    id?: SortOrder
    cycleId?: SortOrder
    bidderAddress?: SortOrder
    bidderUserId?: SortOrder
    collectionContract?: SortOrder
    totalBidWei?: SortOrder
    txCount?: SortOrder
    lastTxHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeaturedBidSumOrderByAggregateInput = {
    totalBidWei?: SortOrder
    txCount?: SortOrder
  }

  export type EnumCurrencyKindFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyKind | EnumCurrencyKindFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyKind[] | ListEnumCurrencyKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyKind[] | ListEnumCurrencyKindFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyKindFilter<$PrismaModel> | $Enums.CurrencyKind
  }

  export type RewardAccumulatorMultiNullableScalarRelationFilter = {
    is?: RewardAccumulatorMultiWhereInput | null
    isNot?: RewardAccumulatorMultiWhereInput | null
  }

  export type RewardDistributionLogListRelationFilter = {
    every?: RewardDistributionLogWhereInput
    some?: RewardDistributionLogWhereInput
    none?: RewardDistributionLogWhereInput
  }

  export type RewardDistributionLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CurrencySymbolTokenAddressCompoundUniqueInput = {
    symbol: string
    tokenAddress: string
  }

  export type CurrencyCountOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    kind?: SortOrder
    tokenAddress?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyAvgOrderByAggregateInput = {
    decimals?: SortOrder
  }

  export type CurrencyMaxOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    kind?: SortOrder
    tokenAddress?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencyMinOrderByAggregateInput = {
    id?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    kind?: SortOrder
    tokenAddress?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrencySumOrderByAggregateInput = {
    decimals?: SortOrder
  }

  export type EnumCurrencyKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyKind | EnumCurrencyKindFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyKind[] | ListEnumCurrencyKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyKind[] | ListEnumCurrencyKindFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyKindWithAggregatesFilter<$PrismaModel> | $Enums.CurrencyKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyKindFilter<$PrismaModel>
    _max?: NestedEnumCurrencyKindFilter<$PrismaModel>
  }

  export type MarketplaceSaleTxHashLogIndexCompoundUniqueInput = {
    txHash: string
    logIndex: number
  }

  export type MarketplaceSaleCountOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    buyerAddress?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    priceEtnWei?: SortOrder
    royaltyPaidWei?: SortOrder
    marketplaceFeePaidWei?: SortOrder
    currencyId?: SortOrder
    priceTokenAmount?: SortOrder
    royaltyPaidTokenAmount?: SortOrder
    feePaidTokenAmount?: SortOrder
    royaltyRecipient?: SortOrder
    marketplaceFeeRecipient?: SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketplaceSaleAvgOrderByAggregateInput = {
    quantity?: SortOrder
    priceEtnWei?: SortOrder
    royaltyPaidWei?: SortOrder
    marketplaceFeePaidWei?: SortOrder
    priceTokenAmount?: SortOrder
    royaltyPaidTokenAmount?: SortOrder
    feePaidTokenAmount?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
  }

  export type MarketplaceSaleMaxOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    buyerAddress?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    priceEtnWei?: SortOrder
    royaltyPaidWei?: SortOrder
    marketplaceFeePaidWei?: SortOrder
    currencyId?: SortOrder
    priceTokenAmount?: SortOrder
    royaltyPaidTokenAmount?: SortOrder
    feePaidTokenAmount?: SortOrder
    royaltyRecipient?: SortOrder
    marketplaceFeeRecipient?: SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketplaceSaleMinOrderByAggregateInput = {
    id?: SortOrder
    nftId?: SortOrder
    buyerAddress?: SortOrder
    sellerAddress?: SortOrder
    quantity?: SortOrder
    priceEtnWei?: SortOrder
    royaltyPaidWei?: SortOrder
    marketplaceFeePaidWei?: SortOrder
    currencyId?: SortOrder
    priceTokenAmount?: SortOrder
    royaltyPaidTokenAmount?: SortOrder
    feePaidTokenAmount?: SortOrder
    royaltyRecipient?: SortOrder
    marketplaceFeeRecipient?: SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type MarketplaceSaleSumOrderByAggregateInput = {
    quantity?: SortOrder
    priceEtnWei?: SortOrder
    royaltyPaidWei?: SortOrder
    marketplaceFeePaidWei?: SortOrder
    priceTokenAmount?: SortOrder
    royaltyPaidTokenAmount?: SortOrder
    feePaidTokenAmount?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
  }

  export type CurrencyScalarRelationFilter = {
    is?: CurrencyWhereInput
    isNot?: CurrencyWhereInput
  }

  export type RewardAccumulatorMultiCountOrderByAggregateInput = {
    id?: SortOrder
    currencyId?: SortOrder
    accPerToken?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardAccumulatorMultiAvgOrderByAggregateInput = {
    accPerToken?: SortOrder
  }

  export type RewardAccumulatorMultiMaxOrderByAggregateInput = {
    id?: SortOrder
    currencyId?: SortOrder
    accPerToken?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardAccumulatorMultiMinOrderByAggregateInput = {
    id?: SortOrder
    currencyId?: SortOrder
    accPerToken?: SortOrder
    updatedAt?: SortOrder
  }

  export type RewardAccumulatorMultiSumOrderByAggregateInput = {
    accPerToken?: SortOrder
  }

  export type HolderRewardMultiWalletAddressCurrencyIdCompoundUniqueInput = {
    walletAddress: string
    currencyId: string
  }

  export type HolderRewardMultiCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    walletAddress?: SortOrder
    currencyId?: SortOrder
    lastAccPerToken?: SortOrder
    claimedAmount?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolderRewardMultiAvgOrderByAggregateInput = {
    lastAccPerToken?: SortOrder
    claimedAmount?: SortOrder
  }

  export type HolderRewardMultiMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    walletAddress?: SortOrder
    currencyId?: SortOrder
    lastAccPerToken?: SortOrder
    claimedAmount?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolderRewardMultiMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    walletAddress?: SortOrder
    currencyId?: SortOrder
    lastAccPerToken?: SortOrder
    claimedAmount?: SortOrder
    updatedAt?: SortOrder
  }

  export type HolderRewardMultiSumOrderByAggregateInput = {
    lastAccPerToken?: SortOrder
    claimedAmount?: SortOrder
  }

  export type RewardDistributionLogCountOrderByAggregateInput = {
    id?: SortOrder
    currencyId?: SortOrder
    amount?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    note?: SortOrder
  }

  export type RewardDistributionLogAvgOrderByAggregateInput = {
    amount?: SortOrder
    blockNumber?: SortOrder
  }

  export type RewardDistributionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    currencyId?: SortOrder
    amount?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    note?: SortOrder
  }

  export type RewardDistributionLogMinOrderByAggregateInput = {
    id?: SortOrder
    currencyId?: SortOrder
    amount?: SortOrder
    txHash?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    note?: SortOrder
  }

  export type RewardDistributionLogSumOrderByAggregateInput = {
    amount?: SortOrder
    blockNumber?: SortOrder
  }

  export type RewardClaimLogCountOrderByAggregateInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    userId?: SortOrder
    currencyId?: SortOrder
    amount?: SortOrder
    txHash?: SortOrder
    timestamp?: SortOrder
  }

  export type RewardClaimLogAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RewardClaimLogMaxOrderByAggregateInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    userId?: SortOrder
    currencyId?: SortOrder
    amount?: SortOrder
    txHash?: SortOrder
    timestamp?: SortOrder
  }

  export type RewardClaimLogMinOrderByAggregateInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    userId?: SortOrder
    currencyId?: SortOrder
    amount?: SortOrder
    txHash?: SortOrder
    timestamp?: SortOrder
  }

  export type RewardClaimLogSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumStolenStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StolenStatus | EnumStolenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StolenStatus[] | ListEnumStolenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StolenStatus[] | ListEnumStolenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStolenStatusFilter<$PrismaModel> | $Enums.StolenStatus
  }

  export type EnumStolenSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.StolenSource | EnumStolenSourceFieldRefInput<$PrismaModel>
    in?: $Enums.StolenSource[] | ListEnumStolenSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.StolenSource[] | ListEnumStolenSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumStolenSourceFilter<$PrismaModel> | $Enums.StolenSource
  }

  export type StolenItemContractTokenIdCompoundUniqueInput = {
    contract: string
    tokenId: string
  }

  export type StolenItemCountOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    status?: SortOrder
    source?: SortOrder
    reporterAddress?: SortOrder
    reporterUserId?: SortOrder
    evidenceUrl?: SortOrder
    notes?: SortOrder
    disputed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StolenItemMaxOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    status?: SortOrder
    source?: SortOrder
    reporterAddress?: SortOrder
    reporterUserId?: SortOrder
    evidenceUrl?: SortOrder
    notes?: SortOrder
    disputed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StolenItemMinOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    status?: SortOrder
    source?: SortOrder
    reporterAddress?: SortOrder
    reporterUserId?: SortOrder
    evidenceUrl?: SortOrder
    notes?: SortOrder
    disputed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStolenStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StolenStatus | EnumStolenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StolenStatus[] | ListEnumStolenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StolenStatus[] | ListEnumStolenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStolenStatusWithAggregatesFilter<$PrismaModel> | $Enums.StolenStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStolenStatusFilter<$PrismaModel>
    _max?: NestedEnumStolenStatusFilter<$PrismaModel>
  }

  export type EnumStolenSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StolenSource | EnumStolenSourceFieldRefInput<$PrismaModel>
    in?: $Enums.StolenSource[] | ListEnumStolenSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.StolenSource[] | ListEnumStolenSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumStolenSourceWithAggregatesFilter<$PrismaModel> | $Enums.StolenSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStolenSourceFilter<$PrismaModel>
    _max?: NestedEnumStolenSourceFilter<$PrismaModel>
  }

  export type StolenEventCountOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    action?: SortOrder
    actorAddress?: SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type StolenEventAvgOrderByAggregateInput = {
    logIndex?: SortOrder
    blockNumber?: SortOrder
  }

  export type StolenEventMaxOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    action?: SortOrder
    actorAddress?: SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type StolenEventMinOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    tokenId?: SortOrder
    action?: SortOrder
    actorAddress?: SortOrder
    txHash?: SortOrder
    logIndex?: SortOrder
    blockNumber?: SortOrder
    timestamp?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type StolenEventSumOrderByAggregateInput = {
    logIndex?: SortOrder
    blockNumber?: SortOrder
  }

  export type MultisigOwnerListRelationFilter = {
    every?: MultisigOwnerWhereInput
    some?: MultisigOwnerWhereInput
    none?: MultisigOwnerWhereInput
  }

  export type MultisigTxListRelationFilter = {
    every?: MultisigTxWhereInput
    some?: MultisigTxWhereInput
    none?: MultisigTxWhereInput
  }

  export type MultisigOwnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MultisigTxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MultisigSafeCountOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    name?: SortOrder
    threshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MultisigSafeAvgOrderByAggregateInput = {
    threshold?: SortOrder
  }

  export type MultisigSafeMaxOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    name?: SortOrder
    threshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MultisigSafeMinOrderByAggregateInput = {
    id?: SortOrder
    contract?: SortOrder
    name?: SortOrder
    threshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MultisigSafeSumOrderByAggregateInput = {
    threshold?: SortOrder
  }

  export type MultisigSafeScalarRelationFilter = {
    is?: MultisigSafeWhereInput
    isNot?: MultisigSafeWhereInput
  }

  export type MultisigOwnerSafeIdOwnerAddressCompoundUniqueInput = {
    safeId: string
    ownerAddress: string
  }

  export type MultisigOwnerCountOrderByAggregateInput = {
    id?: SortOrder
    safeId?: SortOrder
    ownerAddress?: SortOrder
    addedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type MultisigOwnerMaxOrderByAggregateInput = {
    id?: SortOrder
    safeId?: SortOrder
    ownerAddress?: SortOrder
    addedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type MultisigOwnerMinOrderByAggregateInput = {
    id?: SortOrder
    safeId?: SortOrder
    ownerAddress?: SortOrder
    addedAt?: SortOrder
    removedAt?: SortOrder
  }

  export type EnumMultisigTxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MultisigTxStatus | EnumMultisigTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MultisigTxStatus[] | ListEnumMultisigTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MultisigTxStatus[] | ListEnumMultisigTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMultisigTxStatusFilter<$PrismaModel> | $Enums.MultisigTxStatus
  }

  export type MultisigApprovalListRelationFilter = {
    every?: MultisigApprovalWhereInput
    some?: MultisigApprovalWhereInput
    none?: MultisigApprovalWhereInput
  }

  export type MultisigApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MultisigTxSafeIdNonceCompoundUniqueInput = {
    safeId: string
    nonce: number
  }

  export type MultisigTxCountOrderByAggregateInput = {
    id?: SortOrder
    safeId?: SortOrder
    nonce?: SortOrder
    to?: SortOrder
    valueWei?: SortOrder
    dataHex?: SortOrder
    operation?: SortOrder
    submittedBy?: SortOrder
    status?: SortOrder
    executedTxHash?: SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrder
  }

  export type MultisigTxAvgOrderByAggregateInput = {
    nonce?: SortOrder
    valueWei?: SortOrder
    operation?: SortOrder
  }

  export type MultisigTxMaxOrderByAggregateInput = {
    id?: SortOrder
    safeId?: SortOrder
    nonce?: SortOrder
    to?: SortOrder
    valueWei?: SortOrder
    dataHex?: SortOrder
    operation?: SortOrder
    submittedBy?: SortOrder
    status?: SortOrder
    executedTxHash?: SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrder
  }

  export type MultisigTxMinOrderByAggregateInput = {
    id?: SortOrder
    safeId?: SortOrder
    nonce?: SortOrder
    to?: SortOrder
    valueWei?: SortOrder
    dataHex?: SortOrder
    operation?: SortOrder
    submittedBy?: SortOrder
    status?: SortOrder
    executedTxHash?: SortOrder
    createdAt?: SortOrder
    executedAt?: SortOrder
  }

  export type MultisigTxSumOrderByAggregateInput = {
    nonce?: SortOrder
    valueWei?: SortOrder
    operation?: SortOrder
  }

  export type EnumMultisigTxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MultisigTxStatus | EnumMultisigTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MultisigTxStatus[] | ListEnumMultisigTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MultisigTxStatus[] | ListEnumMultisigTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMultisigTxStatusWithAggregatesFilter<$PrismaModel> | $Enums.MultisigTxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMultisigTxStatusFilter<$PrismaModel>
    _max?: NestedEnumMultisigTxStatusFilter<$PrismaModel>
  }

  export type MultisigTxScalarRelationFilter = {
    is?: MultisigTxWhereInput
    isNot?: MultisigTxWhereInput
  }

  export type MultisigApprovalTxIdOwnerAddressCompoundUniqueInput = {
    txId: string
    ownerAddress: string
  }

  export type MultisigApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    txId?: SortOrder
    ownerAddress?: SortOrder
    signature?: SortOrder
    createdAt?: SortOrder
  }

  export type MultisigApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    txId?: SortOrder
    ownerAddress?: SortOrder
    signature?: SortOrder
    createdAt?: SortOrder
  }

  export type MultisigApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    txId?: SortOrder
    ownerAddress?: SortOrder
    signature?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPendingChainActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingChainActionType | EnumPendingChainActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PendingChainActionType[] | ListEnumPendingChainActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingChainActionType[] | ListEnumPendingChainActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingChainActionTypeFilter<$PrismaModel> | $Enums.PendingChainActionType
  }

  export type EnumPendingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingStatus | EnumPendingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingStatusFilter<$PrismaModel> | $Enums.PendingStatus
  }

  export type PendingChainActionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    txHash?: SortOrder
    from?: SortOrder
    chainId?: SortOrder
    payload?: SortOrder
    relatedId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingChainActionAvgOrderByAggregateInput = {
    chainId?: SortOrder
  }

  export type PendingChainActionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    txHash?: SortOrder
    from?: SortOrder
    chainId?: SortOrder
    relatedId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingChainActionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    txHash?: SortOrder
    from?: SortOrder
    chainId?: SortOrder
    relatedId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingChainActionSumOrderByAggregateInput = {
    chainId?: SortOrder
  }

  export type EnumPendingChainActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingChainActionType | EnumPendingChainActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PendingChainActionType[] | ListEnumPendingChainActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingChainActionType[] | ListEnumPendingChainActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingChainActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.PendingChainActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPendingChainActionTypeFilter<$PrismaModel>
    _max?: NestedEnumPendingChainActionTypeFilter<$PrismaModel>
  }

  export type EnumPendingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingStatus | EnumPendingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingStatusWithAggregatesFilter<$PrismaModel> | $Enums.PendingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPendingStatusFilter<$PrismaModel>
    _max?: NestedEnumPendingStatusFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CollectionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CollectionCreateWithoutCreatorInput, CollectionUncheckedCreateWithoutCreatorInput> | CollectionCreateWithoutCreatorInput[] | CollectionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutCreatorInput | CollectionCreateOrConnectWithoutCreatorInput[]
    createMany?: CollectionCreateManyCreatorInputEnvelope
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
  }

  export type CollectionSubmissionCreateNestedManyWithoutSubmittedByInput = {
    create?: XOR<CollectionSubmissionCreateWithoutSubmittedByInput, CollectionSubmissionUncheckedCreateWithoutSubmittedByInput> | CollectionSubmissionCreateWithoutSubmittedByInput[] | CollectionSubmissionUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: CollectionSubmissionCreateOrConnectWithoutSubmittedByInput | CollectionSubmissionCreateOrConnectWithoutSubmittedByInput[]
    createMany?: CollectionSubmissionCreateManySubmittedByInputEnvelope
    connect?: CollectionSubmissionWhereUniqueInput | CollectionSubmissionWhereUniqueInput[]
  }

  export type FeaturedBidCreateNestedManyWithoutBidderInput = {
    create?: XOR<FeaturedBidCreateWithoutBidderInput, FeaturedBidUncheckedCreateWithoutBidderInput> | FeaturedBidCreateWithoutBidderInput[] | FeaturedBidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: FeaturedBidCreateOrConnectWithoutBidderInput | FeaturedBidCreateOrConnectWithoutBidderInput[]
    createMany?: FeaturedBidCreateManyBidderInputEnvelope
    connect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
  }

  export type HolderRewardMultiCreateNestedManyWithoutUserInput = {
    create?: XOR<HolderRewardMultiCreateWithoutUserInput, HolderRewardMultiUncheckedCreateWithoutUserInput> | HolderRewardMultiCreateWithoutUserInput[] | HolderRewardMultiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HolderRewardMultiCreateOrConnectWithoutUserInput | HolderRewardMultiCreateOrConnectWithoutUserInput[]
    createMany?: HolderRewardMultiCreateManyUserInputEnvelope
    connect?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
  }

  export type NFTCreateNestedManyWithoutOwnerInput = {
    create?: XOR<NFTCreateWithoutOwnerInput, NFTUncheckedCreateWithoutOwnerInput> | NFTCreateWithoutOwnerInput[] | NFTUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: NFTCreateOrConnectWithoutOwnerInput | NFTCreateOrConnectWithoutOwnerInput[]
    createMany?: NFTCreateManyOwnerInputEnvelope
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
  }

  export type RewardClaimLogCreateNestedManyWithoutUserInput = {
    create?: XOR<RewardClaimLogCreateWithoutUserInput, RewardClaimLogUncheckedCreateWithoutUserInput> | RewardClaimLogCreateWithoutUserInput[] | RewardClaimLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardClaimLogCreateOrConnectWithoutUserInput | RewardClaimLogCreateOrConnectWithoutUserInput[]
    createMany?: RewardClaimLogCreateManyUserInputEnvelope
    connect?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
  }

  export type StolenItemCreateNestedManyWithoutReporterInput = {
    create?: XOR<StolenItemCreateWithoutReporterInput, StolenItemUncheckedCreateWithoutReporterInput> | StolenItemCreateWithoutReporterInput[] | StolenItemUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: StolenItemCreateOrConnectWithoutReporterInput | StolenItemCreateOrConnectWithoutReporterInput[]
    createMany?: StolenItemCreateManyReporterInputEnvelope
    connect?: StolenItemWhereUniqueInput | StolenItemWhereUniqueInput[]
  }

  export type CollectionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CollectionCreateWithoutCreatorInput, CollectionUncheckedCreateWithoutCreatorInput> | CollectionCreateWithoutCreatorInput[] | CollectionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutCreatorInput | CollectionCreateOrConnectWithoutCreatorInput[]
    createMany?: CollectionCreateManyCreatorInputEnvelope
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
  }

  export type CollectionSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput = {
    create?: XOR<CollectionSubmissionCreateWithoutSubmittedByInput, CollectionSubmissionUncheckedCreateWithoutSubmittedByInput> | CollectionSubmissionCreateWithoutSubmittedByInput[] | CollectionSubmissionUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: CollectionSubmissionCreateOrConnectWithoutSubmittedByInput | CollectionSubmissionCreateOrConnectWithoutSubmittedByInput[]
    createMany?: CollectionSubmissionCreateManySubmittedByInputEnvelope
    connect?: CollectionSubmissionWhereUniqueInput | CollectionSubmissionWhereUniqueInput[]
  }

  export type FeaturedBidUncheckedCreateNestedManyWithoutBidderInput = {
    create?: XOR<FeaturedBidCreateWithoutBidderInput, FeaturedBidUncheckedCreateWithoutBidderInput> | FeaturedBidCreateWithoutBidderInput[] | FeaturedBidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: FeaturedBidCreateOrConnectWithoutBidderInput | FeaturedBidCreateOrConnectWithoutBidderInput[]
    createMany?: FeaturedBidCreateManyBidderInputEnvelope
    connect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
  }

  export type HolderRewardMultiUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HolderRewardMultiCreateWithoutUserInput, HolderRewardMultiUncheckedCreateWithoutUserInput> | HolderRewardMultiCreateWithoutUserInput[] | HolderRewardMultiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HolderRewardMultiCreateOrConnectWithoutUserInput | HolderRewardMultiCreateOrConnectWithoutUserInput[]
    createMany?: HolderRewardMultiCreateManyUserInputEnvelope
    connect?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
  }

  export type NFTUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<NFTCreateWithoutOwnerInput, NFTUncheckedCreateWithoutOwnerInput> | NFTCreateWithoutOwnerInput[] | NFTUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: NFTCreateOrConnectWithoutOwnerInput | NFTCreateOrConnectWithoutOwnerInput[]
    createMany?: NFTCreateManyOwnerInputEnvelope
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
  }

  export type RewardClaimLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RewardClaimLogCreateWithoutUserInput, RewardClaimLogUncheckedCreateWithoutUserInput> | RewardClaimLogCreateWithoutUserInput[] | RewardClaimLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardClaimLogCreateOrConnectWithoutUserInput | RewardClaimLogCreateOrConnectWithoutUserInput[]
    createMany?: RewardClaimLogCreateManyUserInputEnvelope
    connect?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
  }

  export type StolenItemUncheckedCreateNestedManyWithoutReporterInput = {
    create?: XOR<StolenItemCreateWithoutReporterInput, StolenItemUncheckedCreateWithoutReporterInput> | StolenItemCreateWithoutReporterInput[] | StolenItemUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: StolenItemCreateOrConnectWithoutReporterInput | StolenItemCreateOrConnectWithoutReporterInput[]
    createMany?: StolenItemCreateManyReporterInputEnvelope
    connect?: StolenItemWhereUniqueInput | StolenItemWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CollectionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CollectionCreateWithoutCreatorInput, CollectionUncheckedCreateWithoutCreatorInput> | CollectionCreateWithoutCreatorInput[] | CollectionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutCreatorInput | CollectionCreateOrConnectWithoutCreatorInput[]
    upsert?: CollectionUpsertWithWhereUniqueWithoutCreatorInput | CollectionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CollectionCreateManyCreatorInputEnvelope
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    update?: CollectionUpdateWithWhereUniqueWithoutCreatorInput | CollectionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CollectionUpdateManyWithWhereWithoutCreatorInput | CollectionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
  }

  export type CollectionSubmissionUpdateManyWithoutSubmittedByNestedInput = {
    create?: XOR<CollectionSubmissionCreateWithoutSubmittedByInput, CollectionSubmissionUncheckedCreateWithoutSubmittedByInput> | CollectionSubmissionCreateWithoutSubmittedByInput[] | CollectionSubmissionUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: CollectionSubmissionCreateOrConnectWithoutSubmittedByInput | CollectionSubmissionCreateOrConnectWithoutSubmittedByInput[]
    upsert?: CollectionSubmissionUpsertWithWhereUniqueWithoutSubmittedByInput | CollectionSubmissionUpsertWithWhereUniqueWithoutSubmittedByInput[]
    createMany?: CollectionSubmissionCreateManySubmittedByInputEnvelope
    set?: CollectionSubmissionWhereUniqueInput | CollectionSubmissionWhereUniqueInput[]
    disconnect?: CollectionSubmissionWhereUniqueInput | CollectionSubmissionWhereUniqueInput[]
    delete?: CollectionSubmissionWhereUniqueInput | CollectionSubmissionWhereUniqueInput[]
    connect?: CollectionSubmissionWhereUniqueInput | CollectionSubmissionWhereUniqueInput[]
    update?: CollectionSubmissionUpdateWithWhereUniqueWithoutSubmittedByInput | CollectionSubmissionUpdateWithWhereUniqueWithoutSubmittedByInput[]
    updateMany?: CollectionSubmissionUpdateManyWithWhereWithoutSubmittedByInput | CollectionSubmissionUpdateManyWithWhereWithoutSubmittedByInput[]
    deleteMany?: CollectionSubmissionScalarWhereInput | CollectionSubmissionScalarWhereInput[]
  }

  export type FeaturedBidUpdateManyWithoutBidderNestedInput = {
    create?: XOR<FeaturedBidCreateWithoutBidderInput, FeaturedBidUncheckedCreateWithoutBidderInput> | FeaturedBidCreateWithoutBidderInput[] | FeaturedBidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: FeaturedBidCreateOrConnectWithoutBidderInput | FeaturedBidCreateOrConnectWithoutBidderInput[]
    upsert?: FeaturedBidUpsertWithWhereUniqueWithoutBidderInput | FeaturedBidUpsertWithWhereUniqueWithoutBidderInput[]
    createMany?: FeaturedBidCreateManyBidderInputEnvelope
    set?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    disconnect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    delete?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    connect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    update?: FeaturedBidUpdateWithWhereUniqueWithoutBidderInput | FeaturedBidUpdateWithWhereUniqueWithoutBidderInput[]
    updateMany?: FeaturedBidUpdateManyWithWhereWithoutBidderInput | FeaturedBidUpdateManyWithWhereWithoutBidderInput[]
    deleteMany?: FeaturedBidScalarWhereInput | FeaturedBidScalarWhereInput[]
  }

  export type HolderRewardMultiUpdateManyWithoutUserNestedInput = {
    create?: XOR<HolderRewardMultiCreateWithoutUserInput, HolderRewardMultiUncheckedCreateWithoutUserInput> | HolderRewardMultiCreateWithoutUserInput[] | HolderRewardMultiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HolderRewardMultiCreateOrConnectWithoutUserInput | HolderRewardMultiCreateOrConnectWithoutUserInput[]
    upsert?: HolderRewardMultiUpsertWithWhereUniqueWithoutUserInput | HolderRewardMultiUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HolderRewardMultiCreateManyUserInputEnvelope
    set?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    disconnect?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    delete?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    connect?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    update?: HolderRewardMultiUpdateWithWhereUniqueWithoutUserInput | HolderRewardMultiUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HolderRewardMultiUpdateManyWithWhereWithoutUserInput | HolderRewardMultiUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HolderRewardMultiScalarWhereInput | HolderRewardMultiScalarWhereInput[]
  }

  export type NFTUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<NFTCreateWithoutOwnerInput, NFTUncheckedCreateWithoutOwnerInput> | NFTCreateWithoutOwnerInput[] | NFTUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: NFTCreateOrConnectWithoutOwnerInput | NFTCreateOrConnectWithoutOwnerInput[]
    upsert?: NFTUpsertWithWhereUniqueWithoutOwnerInput | NFTUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: NFTCreateManyOwnerInputEnvelope
    set?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    disconnect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    delete?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    update?: NFTUpdateWithWhereUniqueWithoutOwnerInput | NFTUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: NFTUpdateManyWithWhereWithoutOwnerInput | NFTUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: NFTScalarWhereInput | NFTScalarWhereInput[]
  }

  export type RewardClaimLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<RewardClaimLogCreateWithoutUserInput, RewardClaimLogUncheckedCreateWithoutUserInput> | RewardClaimLogCreateWithoutUserInput[] | RewardClaimLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardClaimLogCreateOrConnectWithoutUserInput | RewardClaimLogCreateOrConnectWithoutUserInput[]
    upsert?: RewardClaimLogUpsertWithWhereUniqueWithoutUserInput | RewardClaimLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RewardClaimLogCreateManyUserInputEnvelope
    set?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    disconnect?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    delete?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    connect?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    update?: RewardClaimLogUpdateWithWhereUniqueWithoutUserInput | RewardClaimLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RewardClaimLogUpdateManyWithWhereWithoutUserInput | RewardClaimLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RewardClaimLogScalarWhereInput | RewardClaimLogScalarWhereInput[]
  }

  export type StolenItemUpdateManyWithoutReporterNestedInput = {
    create?: XOR<StolenItemCreateWithoutReporterInput, StolenItemUncheckedCreateWithoutReporterInput> | StolenItemCreateWithoutReporterInput[] | StolenItemUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: StolenItemCreateOrConnectWithoutReporterInput | StolenItemCreateOrConnectWithoutReporterInput[]
    upsert?: StolenItemUpsertWithWhereUniqueWithoutReporterInput | StolenItemUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: StolenItemCreateManyReporterInputEnvelope
    set?: StolenItemWhereUniqueInput | StolenItemWhereUniqueInput[]
    disconnect?: StolenItemWhereUniqueInput | StolenItemWhereUniqueInput[]
    delete?: StolenItemWhereUniqueInput | StolenItemWhereUniqueInput[]
    connect?: StolenItemWhereUniqueInput | StolenItemWhereUniqueInput[]
    update?: StolenItemUpdateWithWhereUniqueWithoutReporterInput | StolenItemUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: StolenItemUpdateManyWithWhereWithoutReporterInput | StolenItemUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: StolenItemScalarWhereInput | StolenItemScalarWhereInput[]
  }

  export type CollectionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CollectionCreateWithoutCreatorInput, CollectionUncheckedCreateWithoutCreatorInput> | CollectionCreateWithoutCreatorInput[] | CollectionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutCreatorInput | CollectionCreateOrConnectWithoutCreatorInput[]
    upsert?: CollectionUpsertWithWhereUniqueWithoutCreatorInput | CollectionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CollectionCreateManyCreatorInputEnvelope
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    update?: CollectionUpdateWithWhereUniqueWithoutCreatorInput | CollectionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CollectionUpdateManyWithWhereWithoutCreatorInput | CollectionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
  }

  export type CollectionSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput = {
    create?: XOR<CollectionSubmissionCreateWithoutSubmittedByInput, CollectionSubmissionUncheckedCreateWithoutSubmittedByInput> | CollectionSubmissionCreateWithoutSubmittedByInput[] | CollectionSubmissionUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: CollectionSubmissionCreateOrConnectWithoutSubmittedByInput | CollectionSubmissionCreateOrConnectWithoutSubmittedByInput[]
    upsert?: CollectionSubmissionUpsertWithWhereUniqueWithoutSubmittedByInput | CollectionSubmissionUpsertWithWhereUniqueWithoutSubmittedByInput[]
    createMany?: CollectionSubmissionCreateManySubmittedByInputEnvelope
    set?: CollectionSubmissionWhereUniqueInput | CollectionSubmissionWhereUniqueInput[]
    disconnect?: CollectionSubmissionWhereUniqueInput | CollectionSubmissionWhereUniqueInput[]
    delete?: CollectionSubmissionWhereUniqueInput | CollectionSubmissionWhereUniqueInput[]
    connect?: CollectionSubmissionWhereUniqueInput | CollectionSubmissionWhereUniqueInput[]
    update?: CollectionSubmissionUpdateWithWhereUniqueWithoutSubmittedByInput | CollectionSubmissionUpdateWithWhereUniqueWithoutSubmittedByInput[]
    updateMany?: CollectionSubmissionUpdateManyWithWhereWithoutSubmittedByInput | CollectionSubmissionUpdateManyWithWhereWithoutSubmittedByInput[]
    deleteMany?: CollectionSubmissionScalarWhereInput | CollectionSubmissionScalarWhereInput[]
  }

  export type FeaturedBidUncheckedUpdateManyWithoutBidderNestedInput = {
    create?: XOR<FeaturedBidCreateWithoutBidderInput, FeaturedBidUncheckedCreateWithoutBidderInput> | FeaturedBidCreateWithoutBidderInput[] | FeaturedBidUncheckedCreateWithoutBidderInput[]
    connectOrCreate?: FeaturedBidCreateOrConnectWithoutBidderInput | FeaturedBidCreateOrConnectWithoutBidderInput[]
    upsert?: FeaturedBidUpsertWithWhereUniqueWithoutBidderInput | FeaturedBidUpsertWithWhereUniqueWithoutBidderInput[]
    createMany?: FeaturedBidCreateManyBidderInputEnvelope
    set?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    disconnect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    delete?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    connect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    update?: FeaturedBidUpdateWithWhereUniqueWithoutBidderInput | FeaturedBidUpdateWithWhereUniqueWithoutBidderInput[]
    updateMany?: FeaturedBidUpdateManyWithWhereWithoutBidderInput | FeaturedBidUpdateManyWithWhereWithoutBidderInput[]
    deleteMany?: FeaturedBidScalarWhereInput | FeaturedBidScalarWhereInput[]
  }

  export type HolderRewardMultiUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HolderRewardMultiCreateWithoutUserInput, HolderRewardMultiUncheckedCreateWithoutUserInput> | HolderRewardMultiCreateWithoutUserInput[] | HolderRewardMultiUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HolderRewardMultiCreateOrConnectWithoutUserInput | HolderRewardMultiCreateOrConnectWithoutUserInput[]
    upsert?: HolderRewardMultiUpsertWithWhereUniqueWithoutUserInput | HolderRewardMultiUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HolderRewardMultiCreateManyUserInputEnvelope
    set?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    disconnect?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    delete?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    connect?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    update?: HolderRewardMultiUpdateWithWhereUniqueWithoutUserInput | HolderRewardMultiUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HolderRewardMultiUpdateManyWithWhereWithoutUserInput | HolderRewardMultiUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HolderRewardMultiScalarWhereInput | HolderRewardMultiScalarWhereInput[]
  }

  export type NFTUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<NFTCreateWithoutOwnerInput, NFTUncheckedCreateWithoutOwnerInput> | NFTCreateWithoutOwnerInput[] | NFTUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: NFTCreateOrConnectWithoutOwnerInput | NFTCreateOrConnectWithoutOwnerInput[]
    upsert?: NFTUpsertWithWhereUniqueWithoutOwnerInput | NFTUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: NFTCreateManyOwnerInputEnvelope
    set?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    disconnect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    delete?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    update?: NFTUpdateWithWhereUniqueWithoutOwnerInput | NFTUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: NFTUpdateManyWithWhereWithoutOwnerInput | NFTUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: NFTScalarWhereInput | NFTScalarWhereInput[]
  }

  export type RewardClaimLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RewardClaimLogCreateWithoutUserInput, RewardClaimLogUncheckedCreateWithoutUserInput> | RewardClaimLogCreateWithoutUserInput[] | RewardClaimLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RewardClaimLogCreateOrConnectWithoutUserInput | RewardClaimLogCreateOrConnectWithoutUserInput[]
    upsert?: RewardClaimLogUpsertWithWhereUniqueWithoutUserInput | RewardClaimLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RewardClaimLogCreateManyUserInputEnvelope
    set?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    disconnect?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    delete?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    connect?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    update?: RewardClaimLogUpdateWithWhereUniqueWithoutUserInput | RewardClaimLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RewardClaimLogUpdateManyWithWhereWithoutUserInput | RewardClaimLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RewardClaimLogScalarWhereInput | RewardClaimLogScalarWhereInput[]
  }

  export type StolenItemUncheckedUpdateManyWithoutReporterNestedInput = {
    create?: XOR<StolenItemCreateWithoutReporterInput, StolenItemUncheckedCreateWithoutReporterInput> | StolenItemCreateWithoutReporterInput[] | StolenItemUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: StolenItemCreateOrConnectWithoutReporterInput | StolenItemCreateOrConnectWithoutReporterInput[]
    upsert?: StolenItemUpsertWithWhereUniqueWithoutReporterInput | StolenItemUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: StolenItemCreateManyReporterInputEnvelope
    set?: StolenItemWhereUniqueInput | StolenItemWhereUniqueInput[]
    disconnect?: StolenItemWhereUniqueInput | StolenItemWhereUniqueInput[]
    delete?: StolenItemWhereUniqueInput | StolenItemWhereUniqueInput[]
    connect?: StolenItemWhereUniqueInput | StolenItemWhereUniqueInput[]
    update?: StolenItemUpdateWithWhereUniqueWithoutReporterInput | StolenItemUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: StolenItemUpdateManyWithWhereWithoutReporterInput | StolenItemUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: StolenItemScalarWhereInput | StolenItemScalarWhereInput[]
  }

  export type AssetUploadCreateNestedManyWithoutCollectionInput = {
    create?: XOR<AssetUploadCreateWithoutCollectionInput, AssetUploadUncheckedCreateWithoutCollectionInput> | AssetUploadCreateWithoutCollectionInput[] | AssetUploadUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: AssetUploadCreateOrConnectWithoutCollectionInput | AssetUploadCreateOrConnectWithoutCollectionInput[]
    createMany?: AssetUploadCreateManyCollectionInputEnvelope
    connect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCollectionsInput = {
    create?: XOR<UserCreateWithoutCollectionsInput, UserUncheckedCreateWithoutCollectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCollectionsInput
    connect?: UserWhereUniqueInput
  }

  export type DeployedContractCreateNestedOneWithoutCollectionInput = {
    create?: XOR<DeployedContractCreateWithoutCollectionInput, DeployedContractUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: DeployedContractCreateOrConnectWithoutCollectionInput
    connect?: DeployedContractWhereUniqueInput
  }

  export type FeaturedBidCreateNestedManyWithoutCollectionInput = {
    create?: XOR<FeaturedBidCreateWithoutCollectionInput, FeaturedBidUncheckedCreateWithoutCollectionInput> | FeaturedBidCreateWithoutCollectionInput[] | FeaturedBidUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: FeaturedBidCreateOrConnectWithoutCollectionInput | FeaturedBidCreateOrConnectWithoutCollectionInput[]
    createMany?: FeaturedBidCreateManyCollectionInputEnvelope
    connect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
  }

  export type FeaturedCycleCreateNestedManyWithoutWinnerCollectionInput = {
    create?: XOR<FeaturedCycleCreateWithoutWinnerCollectionInput, FeaturedCycleUncheckedCreateWithoutWinnerCollectionInput> | FeaturedCycleCreateWithoutWinnerCollectionInput[] | FeaturedCycleUncheckedCreateWithoutWinnerCollectionInput[]
    connectOrCreate?: FeaturedCycleCreateOrConnectWithoutWinnerCollectionInput | FeaturedCycleCreateOrConnectWithoutWinnerCollectionInput[]
    createMany?: FeaturedCycleCreateManyWinnerCollectionInputEnvelope
    connect?: FeaturedCycleWhereUniqueInput | FeaturedCycleWhereUniqueInput[]
  }

  export type NFTCreateNestedManyWithoutCollectionInput = {
    create?: XOR<NFTCreateWithoutCollectionInput, NFTUncheckedCreateWithoutCollectionInput> | NFTCreateWithoutCollectionInput[] | NFTUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: NFTCreateOrConnectWithoutCollectionInput | NFTCreateOrConnectWithoutCollectionInput[]
    createMany?: NFTCreateManyCollectionInputEnvelope
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
  }

  export type PresaleCreateNestedOneWithoutCollectionInput = {
    create?: XOR<PresaleCreateWithoutCollectionInput, PresaleUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: PresaleCreateOrConnectWithoutCollectionInput
    connect?: PresaleWhereUniqueInput
  }

  export type PublicSaleCreateNestedOneWithoutCollectionInput = {
    create?: XOR<PublicSaleCreateWithoutCollectionInput, PublicSaleUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: PublicSaleCreateOrConnectWithoutCollectionInput
    connect?: PublicSaleWhereUniqueInput
  }

  export type AssetUploadUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<AssetUploadCreateWithoutCollectionInput, AssetUploadUncheckedCreateWithoutCollectionInput> | AssetUploadCreateWithoutCollectionInput[] | AssetUploadUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: AssetUploadCreateOrConnectWithoutCollectionInput | AssetUploadCreateOrConnectWithoutCollectionInput[]
    createMany?: AssetUploadCreateManyCollectionInputEnvelope
    connect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
  }

  export type DeployedContractUncheckedCreateNestedOneWithoutCollectionInput = {
    create?: XOR<DeployedContractCreateWithoutCollectionInput, DeployedContractUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: DeployedContractCreateOrConnectWithoutCollectionInput
    connect?: DeployedContractWhereUniqueInput
  }

  export type FeaturedBidUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<FeaturedBidCreateWithoutCollectionInput, FeaturedBidUncheckedCreateWithoutCollectionInput> | FeaturedBidCreateWithoutCollectionInput[] | FeaturedBidUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: FeaturedBidCreateOrConnectWithoutCollectionInput | FeaturedBidCreateOrConnectWithoutCollectionInput[]
    createMany?: FeaturedBidCreateManyCollectionInputEnvelope
    connect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
  }

  export type FeaturedCycleUncheckedCreateNestedManyWithoutWinnerCollectionInput = {
    create?: XOR<FeaturedCycleCreateWithoutWinnerCollectionInput, FeaturedCycleUncheckedCreateWithoutWinnerCollectionInput> | FeaturedCycleCreateWithoutWinnerCollectionInput[] | FeaturedCycleUncheckedCreateWithoutWinnerCollectionInput[]
    connectOrCreate?: FeaturedCycleCreateOrConnectWithoutWinnerCollectionInput | FeaturedCycleCreateOrConnectWithoutWinnerCollectionInput[]
    createMany?: FeaturedCycleCreateManyWinnerCollectionInputEnvelope
    connect?: FeaturedCycleWhereUniqueInput | FeaturedCycleWhereUniqueInput[]
  }

  export type NFTUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<NFTCreateWithoutCollectionInput, NFTUncheckedCreateWithoutCollectionInput> | NFTCreateWithoutCollectionInput[] | NFTUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: NFTCreateOrConnectWithoutCollectionInput | NFTCreateOrConnectWithoutCollectionInput[]
    createMany?: NFTCreateManyCollectionInputEnvelope
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
  }

  export type PresaleUncheckedCreateNestedOneWithoutCollectionInput = {
    create?: XOR<PresaleCreateWithoutCollectionInput, PresaleUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: PresaleCreateOrConnectWithoutCollectionInput
    connect?: PresaleWhereUniqueInput
  }

  export type PublicSaleUncheckedCreateNestedOneWithoutCollectionInput = {
    create?: XOR<PublicSaleCreateWithoutCollectionInput, PublicSaleUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: PublicSaleCreateOrConnectWithoutCollectionInput
    connect?: PublicSaleWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumGatewayPrefFieldUpdateOperationsInput = {
    set?: $Enums.GatewayPref
  }

  export type EnumIndexStatusFieldUpdateOperationsInput = {
    set?: $Enums.IndexStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AssetUploadUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<AssetUploadCreateWithoutCollectionInput, AssetUploadUncheckedCreateWithoutCollectionInput> | AssetUploadCreateWithoutCollectionInput[] | AssetUploadUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: AssetUploadCreateOrConnectWithoutCollectionInput | AssetUploadCreateOrConnectWithoutCollectionInput[]
    upsert?: AssetUploadUpsertWithWhereUniqueWithoutCollectionInput | AssetUploadUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: AssetUploadCreateManyCollectionInputEnvelope
    set?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    disconnect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    delete?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    connect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    update?: AssetUploadUpdateWithWhereUniqueWithoutCollectionInput | AssetUploadUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: AssetUploadUpdateManyWithWhereWithoutCollectionInput | AssetUploadUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: AssetUploadScalarWhereInput | AssetUploadScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCollectionsNestedInput = {
    create?: XOR<UserCreateWithoutCollectionsInput, UserUncheckedCreateWithoutCollectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCollectionsInput
    upsert?: UserUpsertWithoutCollectionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCollectionsInput, UserUpdateWithoutCollectionsInput>, UserUncheckedUpdateWithoutCollectionsInput>
  }

  export type DeployedContractUpdateOneWithoutCollectionNestedInput = {
    create?: XOR<DeployedContractCreateWithoutCollectionInput, DeployedContractUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: DeployedContractCreateOrConnectWithoutCollectionInput
    upsert?: DeployedContractUpsertWithoutCollectionInput
    disconnect?: DeployedContractWhereInput | boolean
    delete?: DeployedContractWhereInput | boolean
    connect?: DeployedContractWhereUniqueInput
    update?: XOR<XOR<DeployedContractUpdateToOneWithWhereWithoutCollectionInput, DeployedContractUpdateWithoutCollectionInput>, DeployedContractUncheckedUpdateWithoutCollectionInput>
  }

  export type FeaturedBidUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<FeaturedBidCreateWithoutCollectionInput, FeaturedBidUncheckedCreateWithoutCollectionInput> | FeaturedBidCreateWithoutCollectionInput[] | FeaturedBidUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: FeaturedBidCreateOrConnectWithoutCollectionInput | FeaturedBidCreateOrConnectWithoutCollectionInput[]
    upsert?: FeaturedBidUpsertWithWhereUniqueWithoutCollectionInput | FeaturedBidUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: FeaturedBidCreateManyCollectionInputEnvelope
    set?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    disconnect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    delete?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    connect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    update?: FeaturedBidUpdateWithWhereUniqueWithoutCollectionInput | FeaturedBidUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: FeaturedBidUpdateManyWithWhereWithoutCollectionInput | FeaturedBidUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: FeaturedBidScalarWhereInput | FeaturedBidScalarWhereInput[]
  }

  export type FeaturedCycleUpdateManyWithoutWinnerCollectionNestedInput = {
    create?: XOR<FeaturedCycleCreateWithoutWinnerCollectionInput, FeaturedCycleUncheckedCreateWithoutWinnerCollectionInput> | FeaturedCycleCreateWithoutWinnerCollectionInput[] | FeaturedCycleUncheckedCreateWithoutWinnerCollectionInput[]
    connectOrCreate?: FeaturedCycleCreateOrConnectWithoutWinnerCollectionInput | FeaturedCycleCreateOrConnectWithoutWinnerCollectionInput[]
    upsert?: FeaturedCycleUpsertWithWhereUniqueWithoutWinnerCollectionInput | FeaturedCycleUpsertWithWhereUniqueWithoutWinnerCollectionInput[]
    createMany?: FeaturedCycleCreateManyWinnerCollectionInputEnvelope
    set?: FeaturedCycleWhereUniqueInput | FeaturedCycleWhereUniqueInput[]
    disconnect?: FeaturedCycleWhereUniqueInput | FeaturedCycleWhereUniqueInput[]
    delete?: FeaturedCycleWhereUniqueInput | FeaturedCycleWhereUniqueInput[]
    connect?: FeaturedCycleWhereUniqueInput | FeaturedCycleWhereUniqueInput[]
    update?: FeaturedCycleUpdateWithWhereUniqueWithoutWinnerCollectionInput | FeaturedCycleUpdateWithWhereUniqueWithoutWinnerCollectionInput[]
    updateMany?: FeaturedCycleUpdateManyWithWhereWithoutWinnerCollectionInput | FeaturedCycleUpdateManyWithWhereWithoutWinnerCollectionInput[]
    deleteMany?: FeaturedCycleScalarWhereInput | FeaturedCycleScalarWhereInput[]
  }

  export type NFTUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<NFTCreateWithoutCollectionInput, NFTUncheckedCreateWithoutCollectionInput> | NFTCreateWithoutCollectionInput[] | NFTUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: NFTCreateOrConnectWithoutCollectionInput | NFTCreateOrConnectWithoutCollectionInput[]
    upsert?: NFTUpsertWithWhereUniqueWithoutCollectionInput | NFTUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: NFTCreateManyCollectionInputEnvelope
    set?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    disconnect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    delete?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    update?: NFTUpdateWithWhereUniqueWithoutCollectionInput | NFTUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: NFTUpdateManyWithWhereWithoutCollectionInput | NFTUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: NFTScalarWhereInput | NFTScalarWhereInput[]
  }

  export type PresaleUpdateOneWithoutCollectionNestedInput = {
    create?: XOR<PresaleCreateWithoutCollectionInput, PresaleUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: PresaleCreateOrConnectWithoutCollectionInput
    upsert?: PresaleUpsertWithoutCollectionInput
    disconnect?: PresaleWhereInput | boolean
    delete?: PresaleWhereInput | boolean
    connect?: PresaleWhereUniqueInput
    update?: XOR<XOR<PresaleUpdateToOneWithWhereWithoutCollectionInput, PresaleUpdateWithoutCollectionInput>, PresaleUncheckedUpdateWithoutCollectionInput>
  }

  export type PublicSaleUpdateOneWithoutCollectionNestedInput = {
    create?: XOR<PublicSaleCreateWithoutCollectionInput, PublicSaleUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: PublicSaleCreateOrConnectWithoutCollectionInput
    upsert?: PublicSaleUpsertWithoutCollectionInput
    disconnect?: PublicSaleWhereInput | boolean
    delete?: PublicSaleWhereInput | boolean
    connect?: PublicSaleWhereUniqueInput
    update?: XOR<XOR<PublicSaleUpdateToOneWithWhereWithoutCollectionInput, PublicSaleUpdateWithoutCollectionInput>, PublicSaleUncheckedUpdateWithoutCollectionInput>
  }

  export type AssetUploadUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<AssetUploadCreateWithoutCollectionInput, AssetUploadUncheckedCreateWithoutCollectionInput> | AssetUploadCreateWithoutCollectionInput[] | AssetUploadUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: AssetUploadCreateOrConnectWithoutCollectionInput | AssetUploadCreateOrConnectWithoutCollectionInput[]
    upsert?: AssetUploadUpsertWithWhereUniqueWithoutCollectionInput | AssetUploadUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: AssetUploadCreateManyCollectionInputEnvelope
    set?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    disconnect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    delete?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    connect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    update?: AssetUploadUpdateWithWhereUniqueWithoutCollectionInput | AssetUploadUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: AssetUploadUpdateManyWithWhereWithoutCollectionInput | AssetUploadUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: AssetUploadScalarWhereInput | AssetUploadScalarWhereInput[]
  }

  export type DeployedContractUncheckedUpdateOneWithoutCollectionNestedInput = {
    create?: XOR<DeployedContractCreateWithoutCollectionInput, DeployedContractUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: DeployedContractCreateOrConnectWithoutCollectionInput
    upsert?: DeployedContractUpsertWithoutCollectionInput
    disconnect?: DeployedContractWhereInput | boolean
    delete?: DeployedContractWhereInput | boolean
    connect?: DeployedContractWhereUniqueInput
    update?: XOR<XOR<DeployedContractUpdateToOneWithWhereWithoutCollectionInput, DeployedContractUpdateWithoutCollectionInput>, DeployedContractUncheckedUpdateWithoutCollectionInput>
  }

  export type FeaturedBidUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<FeaturedBidCreateWithoutCollectionInput, FeaturedBidUncheckedCreateWithoutCollectionInput> | FeaturedBidCreateWithoutCollectionInput[] | FeaturedBidUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: FeaturedBidCreateOrConnectWithoutCollectionInput | FeaturedBidCreateOrConnectWithoutCollectionInput[]
    upsert?: FeaturedBidUpsertWithWhereUniqueWithoutCollectionInput | FeaturedBidUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: FeaturedBidCreateManyCollectionInputEnvelope
    set?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    disconnect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    delete?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    connect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    update?: FeaturedBidUpdateWithWhereUniqueWithoutCollectionInput | FeaturedBidUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: FeaturedBidUpdateManyWithWhereWithoutCollectionInput | FeaturedBidUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: FeaturedBidScalarWhereInput | FeaturedBidScalarWhereInput[]
  }

  export type FeaturedCycleUncheckedUpdateManyWithoutWinnerCollectionNestedInput = {
    create?: XOR<FeaturedCycleCreateWithoutWinnerCollectionInput, FeaturedCycleUncheckedCreateWithoutWinnerCollectionInput> | FeaturedCycleCreateWithoutWinnerCollectionInput[] | FeaturedCycleUncheckedCreateWithoutWinnerCollectionInput[]
    connectOrCreate?: FeaturedCycleCreateOrConnectWithoutWinnerCollectionInput | FeaturedCycleCreateOrConnectWithoutWinnerCollectionInput[]
    upsert?: FeaturedCycleUpsertWithWhereUniqueWithoutWinnerCollectionInput | FeaturedCycleUpsertWithWhereUniqueWithoutWinnerCollectionInput[]
    createMany?: FeaturedCycleCreateManyWinnerCollectionInputEnvelope
    set?: FeaturedCycleWhereUniqueInput | FeaturedCycleWhereUniqueInput[]
    disconnect?: FeaturedCycleWhereUniqueInput | FeaturedCycleWhereUniqueInput[]
    delete?: FeaturedCycleWhereUniqueInput | FeaturedCycleWhereUniqueInput[]
    connect?: FeaturedCycleWhereUniqueInput | FeaturedCycleWhereUniqueInput[]
    update?: FeaturedCycleUpdateWithWhereUniqueWithoutWinnerCollectionInput | FeaturedCycleUpdateWithWhereUniqueWithoutWinnerCollectionInput[]
    updateMany?: FeaturedCycleUpdateManyWithWhereWithoutWinnerCollectionInput | FeaturedCycleUpdateManyWithWhereWithoutWinnerCollectionInput[]
    deleteMany?: FeaturedCycleScalarWhereInput | FeaturedCycleScalarWhereInput[]
  }

  export type NFTUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<NFTCreateWithoutCollectionInput, NFTUncheckedCreateWithoutCollectionInput> | NFTCreateWithoutCollectionInput[] | NFTUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: NFTCreateOrConnectWithoutCollectionInput | NFTCreateOrConnectWithoutCollectionInput[]
    upsert?: NFTUpsertWithWhereUniqueWithoutCollectionInput | NFTUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: NFTCreateManyCollectionInputEnvelope
    set?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    disconnect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    delete?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    update?: NFTUpdateWithWhereUniqueWithoutCollectionInput | NFTUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: NFTUpdateManyWithWhereWithoutCollectionInput | NFTUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: NFTScalarWhereInput | NFTScalarWhereInput[]
  }

  export type PresaleUncheckedUpdateOneWithoutCollectionNestedInput = {
    create?: XOR<PresaleCreateWithoutCollectionInput, PresaleUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: PresaleCreateOrConnectWithoutCollectionInput
    upsert?: PresaleUpsertWithoutCollectionInput
    disconnect?: PresaleWhereInput | boolean
    delete?: PresaleWhereInput | boolean
    connect?: PresaleWhereUniqueInput
    update?: XOR<XOR<PresaleUpdateToOneWithWhereWithoutCollectionInput, PresaleUpdateWithoutCollectionInput>, PresaleUncheckedUpdateWithoutCollectionInput>
  }

  export type PublicSaleUncheckedUpdateOneWithoutCollectionNestedInput = {
    create?: XOR<PublicSaleCreateWithoutCollectionInput, PublicSaleUncheckedCreateWithoutCollectionInput>
    connectOrCreate?: PublicSaleCreateOrConnectWithoutCollectionInput
    upsert?: PublicSaleUpsertWithoutCollectionInput
    disconnect?: PublicSaleWhereInput | boolean
    delete?: PublicSaleWhereInput | boolean
    connect?: PublicSaleWhereUniqueInput
    update?: XOR<XOR<PublicSaleUpdateToOneWithWhereWithoutCollectionInput, PublicSaleUpdateWithoutCollectionInput>, PublicSaleUncheckedUpdateWithoutCollectionInput>
  }

  export type AuctionCreateNestedManyWithoutNftInput = {
    create?: XOR<AuctionCreateWithoutNftInput, AuctionUncheckedCreateWithoutNftInput> | AuctionCreateWithoutNftInput[] | AuctionUncheckedCreateWithoutNftInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutNftInput | AuctionCreateOrConnectWithoutNftInput[]
    createMany?: AuctionCreateManyNftInputEnvelope
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
  }

  export type MarketplaceListingCreateNestedManyWithoutNftInput = {
    create?: XOR<MarketplaceListingCreateWithoutNftInput, MarketplaceListingUncheckedCreateWithoutNftInput> | MarketplaceListingCreateWithoutNftInput[] | MarketplaceListingUncheckedCreateWithoutNftInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutNftInput | MarketplaceListingCreateOrConnectWithoutNftInput[]
    createMany?: MarketplaceListingCreateManyNftInputEnvelope
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
  }

  export type MarketplaceSaleCreateNestedManyWithoutNftInput = {
    create?: XOR<MarketplaceSaleCreateWithoutNftInput, MarketplaceSaleUncheckedCreateWithoutNftInput> | MarketplaceSaleCreateWithoutNftInput[] | MarketplaceSaleUncheckedCreateWithoutNftInput[]
    connectOrCreate?: MarketplaceSaleCreateOrConnectWithoutNftInput | MarketplaceSaleCreateOrConnectWithoutNftInput[]
    createMany?: MarketplaceSaleCreateManyNftInputEnvelope
    connect?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
  }

  export type CollectionCreateNestedOneWithoutNftsInput = {
    create?: XOR<CollectionCreateWithoutNftsInput, CollectionUncheckedCreateWithoutNftsInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutNftsInput
    connect?: CollectionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedNFTsInput = {
    create?: XOR<UserCreateWithoutOwnedNFTsInput, UserUncheckedCreateWithoutOwnedNFTsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedNFTsInput
    connect?: UserWhereUniqueInput
  }

  export type Single1155CreateNestedOneWithoutNftsInput = {
    create?: XOR<Single1155CreateWithoutNftsInput, Single1155UncheckedCreateWithoutNftsInput>
    connectOrCreate?: Single1155CreateOrConnectWithoutNftsInput
    connect?: Single1155WhereUniqueInput
  }

  export type Single721CreateNestedOneWithoutNftsInput = {
    create?: XOR<Single721CreateWithoutNftsInput, Single721UncheckedCreateWithoutNftsInput>
    connectOrCreate?: Single721CreateOrConnectWithoutNftsInput
    connect?: Single721WhereUniqueInput
  }

  export type NFTActivityCreateNestedManyWithoutNftInput = {
    create?: XOR<NFTActivityCreateWithoutNftInput, NFTActivityUncheckedCreateWithoutNftInput> | NFTActivityCreateWithoutNftInput[] | NFTActivityUncheckedCreateWithoutNftInput[]
    connectOrCreate?: NFTActivityCreateOrConnectWithoutNftInput | NFTActivityCreateOrConnectWithoutNftInput[]
    createMany?: NFTActivityCreateManyNftInputEnvelope
    connect?: NFTActivityWhereUniqueInput | NFTActivityWhereUniqueInput[]
  }

  export type AuctionUncheckedCreateNestedManyWithoutNftInput = {
    create?: XOR<AuctionCreateWithoutNftInput, AuctionUncheckedCreateWithoutNftInput> | AuctionCreateWithoutNftInput[] | AuctionUncheckedCreateWithoutNftInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutNftInput | AuctionCreateOrConnectWithoutNftInput[]
    createMany?: AuctionCreateManyNftInputEnvelope
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
  }

  export type MarketplaceListingUncheckedCreateNestedManyWithoutNftInput = {
    create?: XOR<MarketplaceListingCreateWithoutNftInput, MarketplaceListingUncheckedCreateWithoutNftInput> | MarketplaceListingCreateWithoutNftInput[] | MarketplaceListingUncheckedCreateWithoutNftInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutNftInput | MarketplaceListingCreateOrConnectWithoutNftInput[]
    createMany?: MarketplaceListingCreateManyNftInputEnvelope
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
  }

  export type MarketplaceSaleUncheckedCreateNestedManyWithoutNftInput = {
    create?: XOR<MarketplaceSaleCreateWithoutNftInput, MarketplaceSaleUncheckedCreateWithoutNftInput> | MarketplaceSaleCreateWithoutNftInput[] | MarketplaceSaleUncheckedCreateWithoutNftInput[]
    connectOrCreate?: MarketplaceSaleCreateOrConnectWithoutNftInput | MarketplaceSaleCreateOrConnectWithoutNftInput[]
    createMany?: MarketplaceSaleCreateManyNftInputEnvelope
    connect?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
  }

  export type NFTActivityUncheckedCreateNestedManyWithoutNftInput = {
    create?: XOR<NFTActivityCreateWithoutNftInput, NFTActivityUncheckedCreateWithoutNftInput> | NFTActivityCreateWithoutNftInput[] | NFTActivityUncheckedCreateWithoutNftInput[]
    connectOrCreate?: NFTActivityCreateOrConnectWithoutNftInput | NFTActivityCreateOrConnectWithoutNftInput[]
    createMany?: NFTActivityCreateManyNftInputEnvelope
    connect?: NFTActivityWhereUniqueInput | NFTActivityWhereUniqueInput[]
  }

  export type EnumNftStatusFieldUpdateOperationsInput = {
    set?: $Enums.NftStatus
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type AuctionUpdateManyWithoutNftNestedInput = {
    create?: XOR<AuctionCreateWithoutNftInput, AuctionUncheckedCreateWithoutNftInput> | AuctionCreateWithoutNftInput[] | AuctionUncheckedCreateWithoutNftInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutNftInput | AuctionCreateOrConnectWithoutNftInput[]
    upsert?: AuctionUpsertWithWhereUniqueWithoutNftInput | AuctionUpsertWithWhereUniqueWithoutNftInput[]
    createMany?: AuctionCreateManyNftInputEnvelope
    set?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    disconnect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    delete?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    update?: AuctionUpdateWithWhereUniqueWithoutNftInput | AuctionUpdateWithWhereUniqueWithoutNftInput[]
    updateMany?: AuctionUpdateManyWithWhereWithoutNftInput | AuctionUpdateManyWithWhereWithoutNftInput[]
    deleteMany?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
  }

  export type MarketplaceListingUpdateManyWithoutNftNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutNftInput, MarketplaceListingUncheckedCreateWithoutNftInput> | MarketplaceListingCreateWithoutNftInput[] | MarketplaceListingUncheckedCreateWithoutNftInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutNftInput | MarketplaceListingCreateOrConnectWithoutNftInput[]
    upsert?: MarketplaceListingUpsertWithWhereUniqueWithoutNftInput | MarketplaceListingUpsertWithWhereUniqueWithoutNftInput[]
    createMany?: MarketplaceListingCreateManyNftInputEnvelope
    set?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    disconnect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    delete?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    update?: MarketplaceListingUpdateWithWhereUniqueWithoutNftInput | MarketplaceListingUpdateWithWhereUniqueWithoutNftInput[]
    updateMany?: MarketplaceListingUpdateManyWithWhereWithoutNftInput | MarketplaceListingUpdateManyWithWhereWithoutNftInput[]
    deleteMany?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
  }

  export type MarketplaceSaleUpdateManyWithoutNftNestedInput = {
    create?: XOR<MarketplaceSaleCreateWithoutNftInput, MarketplaceSaleUncheckedCreateWithoutNftInput> | MarketplaceSaleCreateWithoutNftInput[] | MarketplaceSaleUncheckedCreateWithoutNftInput[]
    connectOrCreate?: MarketplaceSaleCreateOrConnectWithoutNftInput | MarketplaceSaleCreateOrConnectWithoutNftInput[]
    upsert?: MarketplaceSaleUpsertWithWhereUniqueWithoutNftInput | MarketplaceSaleUpsertWithWhereUniqueWithoutNftInput[]
    createMany?: MarketplaceSaleCreateManyNftInputEnvelope
    set?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    disconnect?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    delete?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    connect?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    update?: MarketplaceSaleUpdateWithWhereUniqueWithoutNftInput | MarketplaceSaleUpdateWithWhereUniqueWithoutNftInput[]
    updateMany?: MarketplaceSaleUpdateManyWithWhereWithoutNftInput | MarketplaceSaleUpdateManyWithWhereWithoutNftInput[]
    deleteMany?: MarketplaceSaleScalarWhereInput | MarketplaceSaleScalarWhereInput[]
  }

  export type CollectionUpdateOneWithoutNftsNestedInput = {
    create?: XOR<CollectionCreateWithoutNftsInput, CollectionUncheckedCreateWithoutNftsInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutNftsInput
    upsert?: CollectionUpsertWithoutNftsInput
    disconnect?: CollectionWhereInput | boolean
    delete?: CollectionWhereInput | boolean
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutNftsInput, CollectionUpdateWithoutNftsInput>, CollectionUncheckedUpdateWithoutNftsInput>
  }

  export type UserUpdateOneWithoutOwnedNFTsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedNFTsInput, UserUncheckedCreateWithoutOwnedNFTsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedNFTsInput
    upsert?: UserUpsertWithoutOwnedNFTsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedNFTsInput, UserUpdateWithoutOwnedNFTsInput>, UserUncheckedUpdateWithoutOwnedNFTsInput>
  }

  export type Single1155UpdateOneWithoutNftsNestedInput = {
    create?: XOR<Single1155CreateWithoutNftsInput, Single1155UncheckedCreateWithoutNftsInput>
    connectOrCreate?: Single1155CreateOrConnectWithoutNftsInput
    upsert?: Single1155UpsertWithoutNftsInput
    disconnect?: Single1155WhereInput | boolean
    delete?: Single1155WhereInput | boolean
    connect?: Single1155WhereUniqueInput
    update?: XOR<XOR<Single1155UpdateToOneWithWhereWithoutNftsInput, Single1155UpdateWithoutNftsInput>, Single1155UncheckedUpdateWithoutNftsInput>
  }

  export type Single721UpdateOneWithoutNftsNestedInput = {
    create?: XOR<Single721CreateWithoutNftsInput, Single721UncheckedCreateWithoutNftsInput>
    connectOrCreate?: Single721CreateOrConnectWithoutNftsInput
    upsert?: Single721UpsertWithoutNftsInput
    disconnect?: Single721WhereInput | boolean
    delete?: Single721WhereInput | boolean
    connect?: Single721WhereUniqueInput
    update?: XOR<XOR<Single721UpdateToOneWithWhereWithoutNftsInput, Single721UpdateWithoutNftsInput>, Single721UncheckedUpdateWithoutNftsInput>
  }

  export type NFTActivityUpdateManyWithoutNftNestedInput = {
    create?: XOR<NFTActivityCreateWithoutNftInput, NFTActivityUncheckedCreateWithoutNftInput> | NFTActivityCreateWithoutNftInput[] | NFTActivityUncheckedCreateWithoutNftInput[]
    connectOrCreate?: NFTActivityCreateOrConnectWithoutNftInput | NFTActivityCreateOrConnectWithoutNftInput[]
    upsert?: NFTActivityUpsertWithWhereUniqueWithoutNftInput | NFTActivityUpsertWithWhereUniqueWithoutNftInput[]
    createMany?: NFTActivityCreateManyNftInputEnvelope
    set?: NFTActivityWhereUniqueInput | NFTActivityWhereUniqueInput[]
    disconnect?: NFTActivityWhereUniqueInput | NFTActivityWhereUniqueInput[]
    delete?: NFTActivityWhereUniqueInput | NFTActivityWhereUniqueInput[]
    connect?: NFTActivityWhereUniqueInput | NFTActivityWhereUniqueInput[]
    update?: NFTActivityUpdateWithWhereUniqueWithoutNftInput | NFTActivityUpdateWithWhereUniqueWithoutNftInput[]
    updateMany?: NFTActivityUpdateManyWithWhereWithoutNftInput | NFTActivityUpdateManyWithWhereWithoutNftInput[]
    deleteMany?: NFTActivityScalarWhereInput | NFTActivityScalarWhereInput[]
  }

  export type AuctionUncheckedUpdateManyWithoutNftNestedInput = {
    create?: XOR<AuctionCreateWithoutNftInput, AuctionUncheckedCreateWithoutNftInput> | AuctionCreateWithoutNftInput[] | AuctionUncheckedCreateWithoutNftInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutNftInput | AuctionCreateOrConnectWithoutNftInput[]
    upsert?: AuctionUpsertWithWhereUniqueWithoutNftInput | AuctionUpsertWithWhereUniqueWithoutNftInput[]
    createMany?: AuctionCreateManyNftInputEnvelope
    set?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    disconnect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    delete?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    update?: AuctionUpdateWithWhereUniqueWithoutNftInput | AuctionUpdateWithWhereUniqueWithoutNftInput[]
    updateMany?: AuctionUpdateManyWithWhereWithoutNftInput | AuctionUpdateManyWithWhereWithoutNftInput[]
    deleteMany?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
  }

  export type MarketplaceListingUncheckedUpdateManyWithoutNftNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutNftInput, MarketplaceListingUncheckedCreateWithoutNftInput> | MarketplaceListingCreateWithoutNftInput[] | MarketplaceListingUncheckedCreateWithoutNftInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutNftInput | MarketplaceListingCreateOrConnectWithoutNftInput[]
    upsert?: MarketplaceListingUpsertWithWhereUniqueWithoutNftInput | MarketplaceListingUpsertWithWhereUniqueWithoutNftInput[]
    createMany?: MarketplaceListingCreateManyNftInputEnvelope
    set?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    disconnect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    delete?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    update?: MarketplaceListingUpdateWithWhereUniqueWithoutNftInput | MarketplaceListingUpdateWithWhereUniqueWithoutNftInput[]
    updateMany?: MarketplaceListingUpdateManyWithWhereWithoutNftInput | MarketplaceListingUpdateManyWithWhereWithoutNftInput[]
    deleteMany?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
  }

  export type MarketplaceSaleUncheckedUpdateManyWithoutNftNestedInput = {
    create?: XOR<MarketplaceSaleCreateWithoutNftInput, MarketplaceSaleUncheckedCreateWithoutNftInput> | MarketplaceSaleCreateWithoutNftInput[] | MarketplaceSaleUncheckedCreateWithoutNftInput[]
    connectOrCreate?: MarketplaceSaleCreateOrConnectWithoutNftInput | MarketplaceSaleCreateOrConnectWithoutNftInput[]
    upsert?: MarketplaceSaleUpsertWithWhereUniqueWithoutNftInput | MarketplaceSaleUpsertWithWhereUniqueWithoutNftInput[]
    createMany?: MarketplaceSaleCreateManyNftInputEnvelope
    set?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    disconnect?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    delete?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    connect?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    update?: MarketplaceSaleUpdateWithWhereUniqueWithoutNftInput | MarketplaceSaleUpdateWithWhereUniqueWithoutNftInput[]
    updateMany?: MarketplaceSaleUpdateManyWithWhereWithoutNftInput | MarketplaceSaleUpdateManyWithWhereWithoutNftInput[]
    deleteMany?: MarketplaceSaleScalarWhereInput | MarketplaceSaleScalarWhereInput[]
  }

  export type NFTActivityUncheckedUpdateManyWithoutNftNestedInput = {
    create?: XOR<NFTActivityCreateWithoutNftInput, NFTActivityUncheckedCreateWithoutNftInput> | NFTActivityCreateWithoutNftInput[] | NFTActivityUncheckedCreateWithoutNftInput[]
    connectOrCreate?: NFTActivityCreateOrConnectWithoutNftInput | NFTActivityCreateOrConnectWithoutNftInput[]
    upsert?: NFTActivityUpsertWithWhereUniqueWithoutNftInput | NFTActivityUpsertWithWhereUniqueWithoutNftInput[]
    createMany?: NFTActivityCreateManyNftInputEnvelope
    set?: NFTActivityWhereUniqueInput | NFTActivityWhereUniqueInput[]
    disconnect?: NFTActivityWhereUniqueInput | NFTActivityWhereUniqueInput[]
    delete?: NFTActivityWhereUniqueInput | NFTActivityWhereUniqueInput[]
    connect?: NFTActivityWhereUniqueInput | NFTActivityWhereUniqueInput[]
    update?: NFTActivityUpdateWithWhereUniqueWithoutNftInput | NFTActivityUpdateWithWhereUniqueWithoutNftInput[]
    updateMany?: NFTActivityUpdateManyWithWhereWithoutNftInput | NFTActivityUpdateManyWithWhereWithoutNftInput[]
    deleteMany?: NFTActivityScalarWhereInput | NFTActivityScalarWhereInput[]
  }

  export type NFTCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<NFTCreateWithoutActivitiesInput, NFTUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: NFTCreateOrConnectWithoutActivitiesInput
    connect?: NFTWhereUniqueInput
  }

  export type NFTUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<NFTCreateWithoutActivitiesInput, NFTUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: NFTCreateOrConnectWithoutActivitiesInput
    upsert?: NFTUpsertWithoutActivitiesInput
    connect?: NFTWhereUniqueInput
    update?: XOR<XOR<NFTUpdateToOneWithWhereWithoutActivitiesInput, NFTUpdateWithoutActivitiesInput>, NFTUncheckedUpdateWithoutActivitiesInput>
  }

  export type AssetUploadCreateNestedManyWithoutSingle721Input = {
    create?: XOR<AssetUploadCreateWithoutSingle721Input, AssetUploadUncheckedCreateWithoutSingle721Input> | AssetUploadCreateWithoutSingle721Input[] | AssetUploadUncheckedCreateWithoutSingle721Input[]
    connectOrCreate?: AssetUploadCreateOrConnectWithoutSingle721Input | AssetUploadCreateOrConnectWithoutSingle721Input[]
    createMany?: AssetUploadCreateManySingle721InputEnvelope
    connect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
  }

  export type DeployedContractCreateNestedOneWithoutSingle721Input = {
    create?: XOR<DeployedContractCreateWithoutSingle721Input, DeployedContractUncheckedCreateWithoutSingle721Input>
    connectOrCreate?: DeployedContractCreateOrConnectWithoutSingle721Input
    connect?: DeployedContractWhereUniqueInput
  }

  export type NFTCreateNestedManyWithoutSingle721Input = {
    create?: XOR<NFTCreateWithoutSingle721Input, NFTUncheckedCreateWithoutSingle721Input> | NFTCreateWithoutSingle721Input[] | NFTUncheckedCreateWithoutSingle721Input[]
    connectOrCreate?: NFTCreateOrConnectWithoutSingle721Input | NFTCreateOrConnectWithoutSingle721Input[]
    createMany?: NFTCreateManySingle721InputEnvelope
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
  }

  export type AssetUploadUncheckedCreateNestedManyWithoutSingle721Input = {
    create?: XOR<AssetUploadCreateWithoutSingle721Input, AssetUploadUncheckedCreateWithoutSingle721Input> | AssetUploadCreateWithoutSingle721Input[] | AssetUploadUncheckedCreateWithoutSingle721Input[]
    connectOrCreate?: AssetUploadCreateOrConnectWithoutSingle721Input | AssetUploadCreateOrConnectWithoutSingle721Input[]
    createMany?: AssetUploadCreateManySingle721InputEnvelope
    connect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
  }

  export type DeployedContractUncheckedCreateNestedOneWithoutSingle721Input = {
    create?: XOR<DeployedContractCreateWithoutSingle721Input, DeployedContractUncheckedCreateWithoutSingle721Input>
    connectOrCreate?: DeployedContractCreateOrConnectWithoutSingle721Input
    connect?: DeployedContractWhereUniqueInput
  }

  export type NFTUncheckedCreateNestedManyWithoutSingle721Input = {
    create?: XOR<NFTCreateWithoutSingle721Input, NFTUncheckedCreateWithoutSingle721Input> | NFTCreateWithoutSingle721Input[] | NFTUncheckedCreateWithoutSingle721Input[]
    connectOrCreate?: NFTCreateOrConnectWithoutSingle721Input | NFTCreateOrConnectWithoutSingle721Input[]
    createMany?: NFTCreateManySingle721InputEnvelope
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
  }

  export type AssetUploadUpdateManyWithoutSingle721NestedInput = {
    create?: XOR<AssetUploadCreateWithoutSingle721Input, AssetUploadUncheckedCreateWithoutSingle721Input> | AssetUploadCreateWithoutSingle721Input[] | AssetUploadUncheckedCreateWithoutSingle721Input[]
    connectOrCreate?: AssetUploadCreateOrConnectWithoutSingle721Input | AssetUploadCreateOrConnectWithoutSingle721Input[]
    upsert?: AssetUploadUpsertWithWhereUniqueWithoutSingle721Input | AssetUploadUpsertWithWhereUniqueWithoutSingle721Input[]
    createMany?: AssetUploadCreateManySingle721InputEnvelope
    set?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    disconnect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    delete?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    connect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    update?: AssetUploadUpdateWithWhereUniqueWithoutSingle721Input | AssetUploadUpdateWithWhereUniqueWithoutSingle721Input[]
    updateMany?: AssetUploadUpdateManyWithWhereWithoutSingle721Input | AssetUploadUpdateManyWithWhereWithoutSingle721Input[]
    deleteMany?: AssetUploadScalarWhereInput | AssetUploadScalarWhereInput[]
  }

  export type DeployedContractUpdateOneWithoutSingle721NestedInput = {
    create?: XOR<DeployedContractCreateWithoutSingle721Input, DeployedContractUncheckedCreateWithoutSingle721Input>
    connectOrCreate?: DeployedContractCreateOrConnectWithoutSingle721Input
    upsert?: DeployedContractUpsertWithoutSingle721Input
    disconnect?: DeployedContractWhereInput | boolean
    delete?: DeployedContractWhereInput | boolean
    connect?: DeployedContractWhereUniqueInput
    update?: XOR<XOR<DeployedContractUpdateToOneWithWhereWithoutSingle721Input, DeployedContractUpdateWithoutSingle721Input>, DeployedContractUncheckedUpdateWithoutSingle721Input>
  }

  export type NFTUpdateManyWithoutSingle721NestedInput = {
    create?: XOR<NFTCreateWithoutSingle721Input, NFTUncheckedCreateWithoutSingle721Input> | NFTCreateWithoutSingle721Input[] | NFTUncheckedCreateWithoutSingle721Input[]
    connectOrCreate?: NFTCreateOrConnectWithoutSingle721Input | NFTCreateOrConnectWithoutSingle721Input[]
    upsert?: NFTUpsertWithWhereUniqueWithoutSingle721Input | NFTUpsertWithWhereUniqueWithoutSingle721Input[]
    createMany?: NFTCreateManySingle721InputEnvelope
    set?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    disconnect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    delete?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    update?: NFTUpdateWithWhereUniqueWithoutSingle721Input | NFTUpdateWithWhereUniqueWithoutSingle721Input[]
    updateMany?: NFTUpdateManyWithWhereWithoutSingle721Input | NFTUpdateManyWithWhereWithoutSingle721Input[]
    deleteMany?: NFTScalarWhereInput | NFTScalarWhereInput[]
  }

  export type AssetUploadUncheckedUpdateManyWithoutSingle721NestedInput = {
    create?: XOR<AssetUploadCreateWithoutSingle721Input, AssetUploadUncheckedCreateWithoutSingle721Input> | AssetUploadCreateWithoutSingle721Input[] | AssetUploadUncheckedCreateWithoutSingle721Input[]
    connectOrCreate?: AssetUploadCreateOrConnectWithoutSingle721Input | AssetUploadCreateOrConnectWithoutSingle721Input[]
    upsert?: AssetUploadUpsertWithWhereUniqueWithoutSingle721Input | AssetUploadUpsertWithWhereUniqueWithoutSingle721Input[]
    createMany?: AssetUploadCreateManySingle721InputEnvelope
    set?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    disconnect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    delete?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    connect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    update?: AssetUploadUpdateWithWhereUniqueWithoutSingle721Input | AssetUploadUpdateWithWhereUniqueWithoutSingle721Input[]
    updateMany?: AssetUploadUpdateManyWithWhereWithoutSingle721Input | AssetUploadUpdateManyWithWhereWithoutSingle721Input[]
    deleteMany?: AssetUploadScalarWhereInput | AssetUploadScalarWhereInput[]
  }

  export type DeployedContractUncheckedUpdateOneWithoutSingle721NestedInput = {
    create?: XOR<DeployedContractCreateWithoutSingle721Input, DeployedContractUncheckedCreateWithoutSingle721Input>
    connectOrCreate?: DeployedContractCreateOrConnectWithoutSingle721Input
    upsert?: DeployedContractUpsertWithoutSingle721Input
    disconnect?: DeployedContractWhereInput | boolean
    delete?: DeployedContractWhereInput | boolean
    connect?: DeployedContractWhereUniqueInput
    update?: XOR<XOR<DeployedContractUpdateToOneWithWhereWithoutSingle721Input, DeployedContractUpdateWithoutSingle721Input>, DeployedContractUncheckedUpdateWithoutSingle721Input>
  }

  export type NFTUncheckedUpdateManyWithoutSingle721NestedInput = {
    create?: XOR<NFTCreateWithoutSingle721Input, NFTUncheckedCreateWithoutSingle721Input> | NFTCreateWithoutSingle721Input[] | NFTUncheckedCreateWithoutSingle721Input[]
    connectOrCreate?: NFTCreateOrConnectWithoutSingle721Input | NFTCreateOrConnectWithoutSingle721Input[]
    upsert?: NFTUpsertWithWhereUniqueWithoutSingle721Input | NFTUpsertWithWhereUniqueWithoutSingle721Input[]
    createMany?: NFTCreateManySingle721InputEnvelope
    set?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    disconnect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    delete?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    update?: NFTUpdateWithWhereUniqueWithoutSingle721Input | NFTUpdateWithWhereUniqueWithoutSingle721Input[]
    updateMany?: NFTUpdateManyWithWhereWithoutSingle721Input | NFTUpdateManyWithWhereWithoutSingle721Input[]
    deleteMany?: NFTScalarWhereInput | NFTScalarWhereInput[]
  }

  export type AssetUploadCreateNestedManyWithoutSingle1155Input = {
    create?: XOR<AssetUploadCreateWithoutSingle1155Input, AssetUploadUncheckedCreateWithoutSingle1155Input> | AssetUploadCreateWithoutSingle1155Input[] | AssetUploadUncheckedCreateWithoutSingle1155Input[]
    connectOrCreate?: AssetUploadCreateOrConnectWithoutSingle1155Input | AssetUploadCreateOrConnectWithoutSingle1155Input[]
    createMany?: AssetUploadCreateManySingle1155InputEnvelope
    connect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
  }

  export type DeployedContractCreateNestedOneWithoutSingle1155Input = {
    create?: XOR<DeployedContractCreateWithoutSingle1155Input, DeployedContractUncheckedCreateWithoutSingle1155Input>
    connectOrCreate?: DeployedContractCreateOrConnectWithoutSingle1155Input
    connect?: DeployedContractWhereUniqueInput
  }

  export type Erc1155BalanceCreateNestedManyWithoutSingle1155Input = {
    create?: XOR<Erc1155BalanceCreateWithoutSingle1155Input, Erc1155BalanceUncheckedCreateWithoutSingle1155Input> | Erc1155BalanceCreateWithoutSingle1155Input[] | Erc1155BalanceUncheckedCreateWithoutSingle1155Input[]
    connectOrCreate?: Erc1155BalanceCreateOrConnectWithoutSingle1155Input | Erc1155BalanceCreateOrConnectWithoutSingle1155Input[]
    createMany?: Erc1155BalanceCreateManySingle1155InputEnvelope
    connect?: Erc1155BalanceWhereUniqueInput | Erc1155BalanceWhereUniqueInput[]
  }

  export type NFTCreateNestedManyWithoutSingle1155Input = {
    create?: XOR<NFTCreateWithoutSingle1155Input, NFTUncheckedCreateWithoutSingle1155Input> | NFTCreateWithoutSingle1155Input[] | NFTUncheckedCreateWithoutSingle1155Input[]
    connectOrCreate?: NFTCreateOrConnectWithoutSingle1155Input | NFTCreateOrConnectWithoutSingle1155Input[]
    createMany?: NFTCreateManySingle1155InputEnvelope
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
  }

  export type AssetUploadUncheckedCreateNestedManyWithoutSingle1155Input = {
    create?: XOR<AssetUploadCreateWithoutSingle1155Input, AssetUploadUncheckedCreateWithoutSingle1155Input> | AssetUploadCreateWithoutSingle1155Input[] | AssetUploadUncheckedCreateWithoutSingle1155Input[]
    connectOrCreate?: AssetUploadCreateOrConnectWithoutSingle1155Input | AssetUploadCreateOrConnectWithoutSingle1155Input[]
    createMany?: AssetUploadCreateManySingle1155InputEnvelope
    connect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
  }

  export type DeployedContractUncheckedCreateNestedOneWithoutSingle1155Input = {
    create?: XOR<DeployedContractCreateWithoutSingle1155Input, DeployedContractUncheckedCreateWithoutSingle1155Input>
    connectOrCreate?: DeployedContractCreateOrConnectWithoutSingle1155Input
    connect?: DeployedContractWhereUniqueInput
  }

  export type Erc1155BalanceUncheckedCreateNestedManyWithoutSingle1155Input = {
    create?: XOR<Erc1155BalanceCreateWithoutSingle1155Input, Erc1155BalanceUncheckedCreateWithoutSingle1155Input> | Erc1155BalanceCreateWithoutSingle1155Input[] | Erc1155BalanceUncheckedCreateWithoutSingle1155Input[]
    connectOrCreate?: Erc1155BalanceCreateOrConnectWithoutSingle1155Input | Erc1155BalanceCreateOrConnectWithoutSingle1155Input[]
    createMany?: Erc1155BalanceCreateManySingle1155InputEnvelope
    connect?: Erc1155BalanceWhereUniqueInput | Erc1155BalanceWhereUniqueInput[]
  }

  export type NFTUncheckedCreateNestedManyWithoutSingle1155Input = {
    create?: XOR<NFTCreateWithoutSingle1155Input, NFTUncheckedCreateWithoutSingle1155Input> | NFTCreateWithoutSingle1155Input[] | NFTUncheckedCreateWithoutSingle1155Input[]
    connectOrCreate?: NFTCreateOrConnectWithoutSingle1155Input | NFTCreateOrConnectWithoutSingle1155Input[]
    createMany?: NFTCreateManySingle1155InputEnvelope
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type AssetUploadUpdateManyWithoutSingle1155NestedInput = {
    create?: XOR<AssetUploadCreateWithoutSingle1155Input, AssetUploadUncheckedCreateWithoutSingle1155Input> | AssetUploadCreateWithoutSingle1155Input[] | AssetUploadUncheckedCreateWithoutSingle1155Input[]
    connectOrCreate?: AssetUploadCreateOrConnectWithoutSingle1155Input | AssetUploadCreateOrConnectWithoutSingle1155Input[]
    upsert?: AssetUploadUpsertWithWhereUniqueWithoutSingle1155Input | AssetUploadUpsertWithWhereUniqueWithoutSingle1155Input[]
    createMany?: AssetUploadCreateManySingle1155InputEnvelope
    set?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    disconnect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    delete?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    connect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    update?: AssetUploadUpdateWithWhereUniqueWithoutSingle1155Input | AssetUploadUpdateWithWhereUniqueWithoutSingle1155Input[]
    updateMany?: AssetUploadUpdateManyWithWhereWithoutSingle1155Input | AssetUploadUpdateManyWithWhereWithoutSingle1155Input[]
    deleteMany?: AssetUploadScalarWhereInput | AssetUploadScalarWhereInput[]
  }

  export type DeployedContractUpdateOneWithoutSingle1155NestedInput = {
    create?: XOR<DeployedContractCreateWithoutSingle1155Input, DeployedContractUncheckedCreateWithoutSingle1155Input>
    connectOrCreate?: DeployedContractCreateOrConnectWithoutSingle1155Input
    upsert?: DeployedContractUpsertWithoutSingle1155Input
    disconnect?: DeployedContractWhereInput | boolean
    delete?: DeployedContractWhereInput | boolean
    connect?: DeployedContractWhereUniqueInput
    update?: XOR<XOR<DeployedContractUpdateToOneWithWhereWithoutSingle1155Input, DeployedContractUpdateWithoutSingle1155Input>, DeployedContractUncheckedUpdateWithoutSingle1155Input>
  }

  export type Erc1155BalanceUpdateManyWithoutSingle1155NestedInput = {
    create?: XOR<Erc1155BalanceCreateWithoutSingle1155Input, Erc1155BalanceUncheckedCreateWithoutSingle1155Input> | Erc1155BalanceCreateWithoutSingle1155Input[] | Erc1155BalanceUncheckedCreateWithoutSingle1155Input[]
    connectOrCreate?: Erc1155BalanceCreateOrConnectWithoutSingle1155Input | Erc1155BalanceCreateOrConnectWithoutSingle1155Input[]
    upsert?: Erc1155BalanceUpsertWithWhereUniqueWithoutSingle1155Input | Erc1155BalanceUpsertWithWhereUniqueWithoutSingle1155Input[]
    createMany?: Erc1155BalanceCreateManySingle1155InputEnvelope
    set?: Erc1155BalanceWhereUniqueInput | Erc1155BalanceWhereUniqueInput[]
    disconnect?: Erc1155BalanceWhereUniqueInput | Erc1155BalanceWhereUniqueInput[]
    delete?: Erc1155BalanceWhereUniqueInput | Erc1155BalanceWhereUniqueInput[]
    connect?: Erc1155BalanceWhereUniqueInput | Erc1155BalanceWhereUniqueInput[]
    update?: Erc1155BalanceUpdateWithWhereUniqueWithoutSingle1155Input | Erc1155BalanceUpdateWithWhereUniqueWithoutSingle1155Input[]
    updateMany?: Erc1155BalanceUpdateManyWithWhereWithoutSingle1155Input | Erc1155BalanceUpdateManyWithWhereWithoutSingle1155Input[]
    deleteMany?: Erc1155BalanceScalarWhereInput | Erc1155BalanceScalarWhereInput[]
  }

  export type NFTUpdateManyWithoutSingle1155NestedInput = {
    create?: XOR<NFTCreateWithoutSingle1155Input, NFTUncheckedCreateWithoutSingle1155Input> | NFTCreateWithoutSingle1155Input[] | NFTUncheckedCreateWithoutSingle1155Input[]
    connectOrCreate?: NFTCreateOrConnectWithoutSingle1155Input | NFTCreateOrConnectWithoutSingle1155Input[]
    upsert?: NFTUpsertWithWhereUniqueWithoutSingle1155Input | NFTUpsertWithWhereUniqueWithoutSingle1155Input[]
    createMany?: NFTCreateManySingle1155InputEnvelope
    set?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    disconnect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    delete?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    update?: NFTUpdateWithWhereUniqueWithoutSingle1155Input | NFTUpdateWithWhereUniqueWithoutSingle1155Input[]
    updateMany?: NFTUpdateManyWithWhereWithoutSingle1155Input | NFTUpdateManyWithWhereWithoutSingle1155Input[]
    deleteMany?: NFTScalarWhereInput | NFTScalarWhereInput[]
  }

  export type AssetUploadUncheckedUpdateManyWithoutSingle1155NestedInput = {
    create?: XOR<AssetUploadCreateWithoutSingle1155Input, AssetUploadUncheckedCreateWithoutSingle1155Input> | AssetUploadCreateWithoutSingle1155Input[] | AssetUploadUncheckedCreateWithoutSingle1155Input[]
    connectOrCreate?: AssetUploadCreateOrConnectWithoutSingle1155Input | AssetUploadCreateOrConnectWithoutSingle1155Input[]
    upsert?: AssetUploadUpsertWithWhereUniqueWithoutSingle1155Input | AssetUploadUpsertWithWhereUniqueWithoutSingle1155Input[]
    createMany?: AssetUploadCreateManySingle1155InputEnvelope
    set?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    disconnect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    delete?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    connect?: AssetUploadWhereUniqueInput | AssetUploadWhereUniqueInput[]
    update?: AssetUploadUpdateWithWhereUniqueWithoutSingle1155Input | AssetUploadUpdateWithWhereUniqueWithoutSingle1155Input[]
    updateMany?: AssetUploadUpdateManyWithWhereWithoutSingle1155Input | AssetUploadUpdateManyWithWhereWithoutSingle1155Input[]
    deleteMany?: AssetUploadScalarWhereInput | AssetUploadScalarWhereInput[]
  }

  export type DeployedContractUncheckedUpdateOneWithoutSingle1155NestedInput = {
    create?: XOR<DeployedContractCreateWithoutSingle1155Input, DeployedContractUncheckedCreateWithoutSingle1155Input>
    connectOrCreate?: DeployedContractCreateOrConnectWithoutSingle1155Input
    upsert?: DeployedContractUpsertWithoutSingle1155Input
    disconnect?: DeployedContractWhereInput | boolean
    delete?: DeployedContractWhereInput | boolean
    connect?: DeployedContractWhereUniqueInput
    update?: XOR<XOR<DeployedContractUpdateToOneWithWhereWithoutSingle1155Input, DeployedContractUpdateWithoutSingle1155Input>, DeployedContractUncheckedUpdateWithoutSingle1155Input>
  }

  export type Erc1155BalanceUncheckedUpdateManyWithoutSingle1155NestedInput = {
    create?: XOR<Erc1155BalanceCreateWithoutSingle1155Input, Erc1155BalanceUncheckedCreateWithoutSingle1155Input> | Erc1155BalanceCreateWithoutSingle1155Input[] | Erc1155BalanceUncheckedCreateWithoutSingle1155Input[]
    connectOrCreate?: Erc1155BalanceCreateOrConnectWithoutSingle1155Input | Erc1155BalanceCreateOrConnectWithoutSingle1155Input[]
    upsert?: Erc1155BalanceUpsertWithWhereUniqueWithoutSingle1155Input | Erc1155BalanceUpsertWithWhereUniqueWithoutSingle1155Input[]
    createMany?: Erc1155BalanceCreateManySingle1155InputEnvelope
    set?: Erc1155BalanceWhereUniqueInput | Erc1155BalanceWhereUniqueInput[]
    disconnect?: Erc1155BalanceWhereUniqueInput | Erc1155BalanceWhereUniqueInput[]
    delete?: Erc1155BalanceWhereUniqueInput | Erc1155BalanceWhereUniqueInput[]
    connect?: Erc1155BalanceWhereUniqueInput | Erc1155BalanceWhereUniqueInput[]
    update?: Erc1155BalanceUpdateWithWhereUniqueWithoutSingle1155Input | Erc1155BalanceUpdateWithWhereUniqueWithoutSingle1155Input[]
    updateMany?: Erc1155BalanceUpdateManyWithWhereWithoutSingle1155Input | Erc1155BalanceUpdateManyWithWhereWithoutSingle1155Input[]
    deleteMany?: Erc1155BalanceScalarWhereInput | Erc1155BalanceScalarWhereInput[]
  }

  export type NFTUncheckedUpdateManyWithoutSingle1155NestedInput = {
    create?: XOR<NFTCreateWithoutSingle1155Input, NFTUncheckedCreateWithoutSingle1155Input> | NFTCreateWithoutSingle1155Input[] | NFTUncheckedCreateWithoutSingle1155Input[]
    connectOrCreate?: NFTCreateOrConnectWithoutSingle1155Input | NFTCreateOrConnectWithoutSingle1155Input[]
    upsert?: NFTUpsertWithWhereUniqueWithoutSingle1155Input | NFTUpsertWithWhereUniqueWithoutSingle1155Input[]
    createMany?: NFTCreateManySingle1155InputEnvelope
    set?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    disconnect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    delete?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    connect?: NFTWhereUniqueInput | NFTWhereUniqueInput[]
    update?: NFTUpdateWithWhereUniqueWithoutSingle1155Input | NFTUpdateWithWhereUniqueWithoutSingle1155Input[]
    updateMany?: NFTUpdateManyWithWhereWithoutSingle1155Input | NFTUpdateManyWithWhereWithoutSingle1155Input[]
    deleteMany?: NFTScalarWhereInput | NFTScalarWhereInput[]
  }

  export type Single1155CreateNestedOneWithoutBalancesInput = {
    create?: XOR<Single1155CreateWithoutBalancesInput, Single1155UncheckedCreateWithoutBalancesInput>
    connectOrCreate?: Single1155CreateOrConnectWithoutBalancesInput
    connect?: Single1155WhereUniqueInput
  }

  export type Single1155UpdateOneRequiredWithoutBalancesNestedInput = {
    create?: XOR<Single1155CreateWithoutBalancesInput, Single1155UncheckedCreateWithoutBalancesInput>
    connectOrCreate?: Single1155CreateOrConnectWithoutBalancesInput
    upsert?: Single1155UpsertWithoutBalancesInput
    connect?: Single1155WhereUniqueInput
    update?: XOR<XOR<Single1155UpdateToOneWithWhereWithoutBalancesInput, Single1155UpdateWithoutBalancesInput>, Single1155UncheckedUpdateWithoutBalancesInput>
  }

  export type CurrencyCreateNestedOneWithoutListingsInput = {
    create?: XOR<CurrencyCreateWithoutListingsInput, CurrencyUncheckedCreateWithoutListingsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutListingsInput
    connect?: CurrencyWhereUniqueInput
  }

  export type NFTCreateNestedOneWithoutListingEntriesInput = {
    create?: XOR<NFTCreateWithoutListingEntriesInput, NFTUncheckedCreateWithoutListingEntriesInput>
    connectOrCreate?: NFTCreateOrConnectWithoutListingEntriesInput
    connect?: NFTWhereUniqueInput
  }

  export type EnumListingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ListingStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CurrencyUpdateOneWithoutListingsNestedInput = {
    create?: XOR<CurrencyCreateWithoutListingsInput, CurrencyUncheckedCreateWithoutListingsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutListingsInput
    upsert?: CurrencyUpsertWithoutListingsInput
    disconnect?: CurrencyWhereInput | boolean
    delete?: CurrencyWhereInput | boolean
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutListingsInput, CurrencyUpdateWithoutListingsInput>, CurrencyUncheckedUpdateWithoutListingsInput>
  }

  export type NFTUpdateOneRequiredWithoutListingEntriesNestedInput = {
    create?: XOR<NFTCreateWithoutListingEntriesInput, NFTUncheckedCreateWithoutListingEntriesInput>
    connectOrCreate?: NFTCreateOrConnectWithoutListingEntriesInput
    upsert?: NFTUpsertWithoutListingEntriesInput
    connect?: NFTWhereUniqueInput
    update?: XOR<XOR<NFTUpdateToOneWithWhereWithoutListingEntriesInput, NFTUpdateWithoutListingEntriesInput>, NFTUncheckedUpdateWithoutListingEntriesInput>
  }

  export type CurrencyCreateNestedOneWithoutAuctionsInput = {
    create?: XOR<CurrencyCreateWithoutAuctionsInput, CurrencyUncheckedCreateWithoutAuctionsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutAuctionsInput
    connect?: CurrencyWhereUniqueInput
  }

  export type NFTCreateNestedOneWithoutAuctionEntriesInput = {
    create?: XOR<NFTCreateWithoutAuctionEntriesInput, NFTUncheckedCreateWithoutAuctionEntriesInput>
    connectOrCreate?: NFTCreateOrConnectWithoutAuctionEntriesInput
    connect?: NFTWhereUniqueInput
  }

  export type AuctionBidCreateNestedManyWithoutAuctionInput = {
    create?: XOR<AuctionBidCreateWithoutAuctionInput, AuctionBidUncheckedCreateWithoutAuctionInput> | AuctionBidCreateWithoutAuctionInput[] | AuctionBidUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutAuctionInput | AuctionBidCreateOrConnectWithoutAuctionInput[]
    createMany?: AuctionBidCreateManyAuctionInputEnvelope
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
  }

  export type AuctionBidUncheckedCreateNestedManyWithoutAuctionInput = {
    create?: XOR<AuctionBidCreateWithoutAuctionInput, AuctionBidUncheckedCreateWithoutAuctionInput> | AuctionBidCreateWithoutAuctionInput[] | AuctionBidUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutAuctionInput | AuctionBidCreateOrConnectWithoutAuctionInput[]
    createMany?: AuctionBidCreateManyAuctionInputEnvelope
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
  }

  export type EnumAuctionStatusFieldUpdateOperationsInput = {
    set?: $Enums.AuctionStatus
  }

  export type CurrencyUpdateOneWithoutAuctionsNestedInput = {
    create?: XOR<CurrencyCreateWithoutAuctionsInput, CurrencyUncheckedCreateWithoutAuctionsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutAuctionsInput
    upsert?: CurrencyUpsertWithoutAuctionsInput
    disconnect?: CurrencyWhereInput | boolean
    delete?: CurrencyWhereInput | boolean
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutAuctionsInput, CurrencyUpdateWithoutAuctionsInput>, CurrencyUncheckedUpdateWithoutAuctionsInput>
  }

  export type NFTUpdateOneRequiredWithoutAuctionEntriesNestedInput = {
    create?: XOR<NFTCreateWithoutAuctionEntriesInput, NFTUncheckedCreateWithoutAuctionEntriesInput>
    connectOrCreate?: NFTCreateOrConnectWithoutAuctionEntriesInput
    upsert?: NFTUpsertWithoutAuctionEntriesInput
    connect?: NFTWhereUniqueInput
    update?: XOR<XOR<NFTUpdateToOneWithWhereWithoutAuctionEntriesInput, NFTUpdateWithoutAuctionEntriesInput>, NFTUncheckedUpdateWithoutAuctionEntriesInput>
  }

  export type AuctionBidUpdateManyWithoutAuctionNestedInput = {
    create?: XOR<AuctionBidCreateWithoutAuctionInput, AuctionBidUncheckedCreateWithoutAuctionInput> | AuctionBidCreateWithoutAuctionInput[] | AuctionBidUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutAuctionInput | AuctionBidCreateOrConnectWithoutAuctionInput[]
    upsert?: AuctionBidUpsertWithWhereUniqueWithoutAuctionInput | AuctionBidUpsertWithWhereUniqueWithoutAuctionInput[]
    createMany?: AuctionBidCreateManyAuctionInputEnvelope
    set?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    disconnect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    delete?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    update?: AuctionBidUpdateWithWhereUniqueWithoutAuctionInput | AuctionBidUpdateWithWhereUniqueWithoutAuctionInput[]
    updateMany?: AuctionBidUpdateManyWithWhereWithoutAuctionInput | AuctionBidUpdateManyWithWhereWithoutAuctionInput[]
    deleteMany?: AuctionBidScalarWhereInput | AuctionBidScalarWhereInput[]
  }

  export type AuctionBidUncheckedUpdateManyWithoutAuctionNestedInput = {
    create?: XOR<AuctionBidCreateWithoutAuctionInput, AuctionBidUncheckedCreateWithoutAuctionInput> | AuctionBidCreateWithoutAuctionInput[] | AuctionBidUncheckedCreateWithoutAuctionInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutAuctionInput | AuctionBidCreateOrConnectWithoutAuctionInput[]
    upsert?: AuctionBidUpsertWithWhereUniqueWithoutAuctionInput | AuctionBidUpsertWithWhereUniqueWithoutAuctionInput[]
    createMany?: AuctionBidCreateManyAuctionInputEnvelope
    set?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    disconnect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    delete?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    update?: AuctionBidUpdateWithWhereUniqueWithoutAuctionInput | AuctionBidUpdateWithWhereUniqueWithoutAuctionInput[]
    updateMany?: AuctionBidUpdateManyWithWhereWithoutAuctionInput | AuctionBidUpdateManyWithWhereWithoutAuctionInput[]
    deleteMany?: AuctionBidScalarWhereInput | AuctionBidScalarWhereInput[]
  }

  export type AuctionCreateNestedOneWithoutBidsInput = {
    create?: XOR<AuctionCreateWithoutBidsInput, AuctionUncheckedCreateWithoutBidsInput>
    connectOrCreate?: AuctionCreateOrConnectWithoutBidsInput
    connect?: AuctionWhereUniqueInput
  }

  export type CurrencyCreateNestedOneWithoutBidsInput = {
    create?: XOR<CurrencyCreateWithoutBidsInput, CurrencyUncheckedCreateWithoutBidsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutBidsInput
    connect?: CurrencyWhereUniqueInput
  }

  export type AuctionUpdateOneRequiredWithoutBidsNestedInput = {
    create?: XOR<AuctionCreateWithoutBidsInput, AuctionUncheckedCreateWithoutBidsInput>
    connectOrCreate?: AuctionCreateOrConnectWithoutBidsInput
    upsert?: AuctionUpsertWithoutBidsInput
    connect?: AuctionWhereUniqueInput
    update?: XOR<XOR<AuctionUpdateToOneWithWhereWithoutBidsInput, AuctionUpdateWithoutBidsInput>, AuctionUncheckedUpdateWithoutBidsInput>
  }

  export type CurrencyUpdateOneWithoutBidsNestedInput = {
    create?: XOR<CurrencyCreateWithoutBidsInput, CurrencyUncheckedCreateWithoutBidsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutBidsInput
    upsert?: CurrencyUpsertWithoutBidsInput
    disconnect?: CurrencyWhereInput | boolean
    delete?: CurrencyWhereInput | boolean
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutBidsInput, CurrencyUpdateWithoutBidsInput>, CurrencyUncheckedUpdateWithoutBidsInput>
  }

  export type CollectionCreateNestedOneWithoutDeploymentInput = {
    create?: XOR<CollectionCreateWithoutDeploymentInput, CollectionUncheckedCreateWithoutDeploymentInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutDeploymentInput
    connect?: CollectionWhereUniqueInput
  }

  export type Single1155CreateNestedOneWithoutDeploymentInput = {
    create?: XOR<Single1155CreateWithoutDeploymentInput, Single1155UncheckedCreateWithoutDeploymentInput>
    connectOrCreate?: Single1155CreateOrConnectWithoutDeploymentInput
    connect?: Single1155WhereUniqueInput
  }

  export type Single721CreateNestedOneWithoutDeploymentInput = {
    create?: XOR<Single721CreateWithoutDeploymentInput, Single721UncheckedCreateWithoutDeploymentInput>
    connectOrCreate?: Single721CreateOrConnectWithoutDeploymentInput
    connect?: Single721WhereUniqueInput
  }

  export type EnumContractTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContractType
  }

  export type EnumMetadataOptionFieldUpdateOperationsInput = {
    set?: $Enums.MetadataOption
  }

  export type CollectionUpdateOneWithoutDeploymentNestedInput = {
    create?: XOR<CollectionCreateWithoutDeploymentInput, CollectionUncheckedCreateWithoutDeploymentInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutDeploymentInput
    upsert?: CollectionUpsertWithoutDeploymentInput
    disconnect?: CollectionWhereInput | boolean
    delete?: CollectionWhereInput | boolean
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutDeploymentInput, CollectionUpdateWithoutDeploymentInput>, CollectionUncheckedUpdateWithoutDeploymentInput>
  }

  export type Single1155UpdateOneWithoutDeploymentNestedInput = {
    create?: XOR<Single1155CreateWithoutDeploymentInput, Single1155UncheckedCreateWithoutDeploymentInput>
    connectOrCreate?: Single1155CreateOrConnectWithoutDeploymentInput
    upsert?: Single1155UpsertWithoutDeploymentInput
    disconnect?: Single1155WhereInput | boolean
    delete?: Single1155WhereInput | boolean
    connect?: Single1155WhereUniqueInput
    update?: XOR<XOR<Single1155UpdateToOneWithWhereWithoutDeploymentInput, Single1155UpdateWithoutDeploymentInput>, Single1155UncheckedUpdateWithoutDeploymentInput>
  }

  export type Single721UpdateOneWithoutDeploymentNestedInput = {
    create?: XOR<Single721CreateWithoutDeploymentInput, Single721UncheckedCreateWithoutDeploymentInput>
    connectOrCreate?: Single721CreateOrConnectWithoutDeploymentInput
    upsert?: Single721UpsertWithoutDeploymentInput
    disconnect?: Single721WhereInput | boolean
    delete?: Single721WhereInput | boolean
    connect?: Single721WhereUniqueInput
    update?: XOR<XOR<Single721UpdateToOneWithWhereWithoutDeploymentInput, Single721UpdateWithoutDeploymentInput>, Single721UncheckedUpdateWithoutDeploymentInput>
  }

  export type FeeConfigLogCreateNestedManyWithoutFeeConfigInput = {
    create?: XOR<FeeConfigLogCreateWithoutFeeConfigInput, FeeConfigLogUncheckedCreateWithoutFeeConfigInput> | FeeConfigLogCreateWithoutFeeConfigInput[] | FeeConfigLogUncheckedCreateWithoutFeeConfigInput[]
    connectOrCreate?: FeeConfigLogCreateOrConnectWithoutFeeConfigInput | FeeConfigLogCreateOrConnectWithoutFeeConfigInput[]
    createMany?: FeeConfigLogCreateManyFeeConfigInputEnvelope
    connect?: FeeConfigLogWhereUniqueInput | FeeConfigLogWhereUniqueInput[]
  }

  export type FeeConfigLogUncheckedCreateNestedManyWithoutFeeConfigInput = {
    create?: XOR<FeeConfigLogCreateWithoutFeeConfigInput, FeeConfigLogUncheckedCreateWithoutFeeConfigInput> | FeeConfigLogCreateWithoutFeeConfigInput[] | FeeConfigLogUncheckedCreateWithoutFeeConfigInput[]
    connectOrCreate?: FeeConfigLogCreateOrConnectWithoutFeeConfigInput | FeeConfigLogCreateOrConnectWithoutFeeConfigInput[]
    createMany?: FeeConfigLogCreateManyFeeConfigInputEnvelope
    connect?: FeeConfigLogWhereUniqueInput | FeeConfigLogWhereUniqueInput[]
  }

  export type FeeConfigLogUpdateManyWithoutFeeConfigNestedInput = {
    create?: XOR<FeeConfigLogCreateWithoutFeeConfigInput, FeeConfigLogUncheckedCreateWithoutFeeConfigInput> | FeeConfigLogCreateWithoutFeeConfigInput[] | FeeConfigLogUncheckedCreateWithoutFeeConfigInput[]
    connectOrCreate?: FeeConfigLogCreateOrConnectWithoutFeeConfigInput | FeeConfigLogCreateOrConnectWithoutFeeConfigInput[]
    upsert?: FeeConfigLogUpsertWithWhereUniqueWithoutFeeConfigInput | FeeConfigLogUpsertWithWhereUniqueWithoutFeeConfigInput[]
    createMany?: FeeConfigLogCreateManyFeeConfigInputEnvelope
    set?: FeeConfigLogWhereUniqueInput | FeeConfigLogWhereUniqueInput[]
    disconnect?: FeeConfigLogWhereUniqueInput | FeeConfigLogWhereUniqueInput[]
    delete?: FeeConfigLogWhereUniqueInput | FeeConfigLogWhereUniqueInput[]
    connect?: FeeConfigLogWhereUniqueInput | FeeConfigLogWhereUniqueInput[]
    update?: FeeConfigLogUpdateWithWhereUniqueWithoutFeeConfigInput | FeeConfigLogUpdateWithWhereUniqueWithoutFeeConfigInput[]
    updateMany?: FeeConfigLogUpdateManyWithWhereWithoutFeeConfigInput | FeeConfigLogUpdateManyWithWhereWithoutFeeConfigInput[]
    deleteMany?: FeeConfigLogScalarWhereInput | FeeConfigLogScalarWhereInput[]
  }

  export type FeeConfigLogUncheckedUpdateManyWithoutFeeConfigNestedInput = {
    create?: XOR<FeeConfigLogCreateWithoutFeeConfigInput, FeeConfigLogUncheckedCreateWithoutFeeConfigInput> | FeeConfigLogCreateWithoutFeeConfigInput[] | FeeConfigLogUncheckedCreateWithoutFeeConfigInput[]
    connectOrCreate?: FeeConfigLogCreateOrConnectWithoutFeeConfigInput | FeeConfigLogCreateOrConnectWithoutFeeConfigInput[]
    upsert?: FeeConfigLogUpsertWithWhereUniqueWithoutFeeConfigInput | FeeConfigLogUpsertWithWhereUniqueWithoutFeeConfigInput[]
    createMany?: FeeConfigLogCreateManyFeeConfigInputEnvelope
    set?: FeeConfigLogWhereUniqueInput | FeeConfigLogWhereUniqueInput[]
    disconnect?: FeeConfigLogWhereUniqueInput | FeeConfigLogWhereUniqueInput[]
    delete?: FeeConfigLogWhereUniqueInput | FeeConfigLogWhereUniqueInput[]
    connect?: FeeConfigLogWhereUniqueInput | FeeConfigLogWhereUniqueInput[]
    update?: FeeConfigLogUpdateWithWhereUniqueWithoutFeeConfigInput | FeeConfigLogUpdateWithWhereUniqueWithoutFeeConfigInput[]
    updateMany?: FeeConfigLogUpdateManyWithWhereWithoutFeeConfigInput | FeeConfigLogUpdateManyWithWhereWithoutFeeConfigInput[]
    deleteMany?: FeeConfigLogScalarWhereInput | FeeConfigLogScalarWhereInput[]
  }

  export type FeeConfigCreateNestedOneWithoutLogsInput = {
    create?: XOR<FeeConfigCreateWithoutLogsInput, FeeConfigUncheckedCreateWithoutLogsInput>
    connectOrCreate?: FeeConfigCreateOrConnectWithoutLogsInput
    connect?: FeeConfigWhereUniqueInput
  }

  export type FeeConfigUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<FeeConfigCreateWithoutLogsInput, FeeConfigUncheckedCreateWithoutLogsInput>
    connectOrCreate?: FeeConfigCreateOrConnectWithoutLogsInput
    upsert?: FeeConfigUpsertWithoutLogsInput
    connect?: FeeConfigWhereUniqueInput
    update?: XOR<XOR<FeeConfigUpdateToOneWithWhereWithoutLogsInput, FeeConfigUpdateWithoutLogsInput>, FeeConfigUncheckedUpdateWithoutLogsInput>
  }

  export type CollectionCreateNestedOneWithoutPublicSaleInput = {
    create?: XOR<CollectionCreateWithoutPublicSaleInput, CollectionUncheckedCreateWithoutPublicSaleInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutPublicSaleInput
    connect?: CollectionWhereUniqueInput
  }

  export type CollectionUpdateOneRequiredWithoutPublicSaleNestedInput = {
    create?: XOR<CollectionCreateWithoutPublicSaleInput, CollectionUncheckedCreateWithoutPublicSaleInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutPublicSaleInput
    upsert?: CollectionUpsertWithoutPublicSaleInput
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutPublicSaleInput, CollectionUpdateWithoutPublicSaleInput>, CollectionUncheckedUpdateWithoutPublicSaleInput>
  }

  export type CollectionCreateNestedOneWithoutPresaleInput = {
    create?: XOR<CollectionCreateWithoutPresaleInput, CollectionUncheckedCreateWithoutPresaleInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutPresaleInput
    connect?: CollectionWhereUniqueInput
  }

  export type PresaleWhitelistAddressCreateNestedManyWithoutPresaleInput = {
    create?: XOR<PresaleWhitelistAddressCreateWithoutPresaleInput, PresaleWhitelistAddressUncheckedCreateWithoutPresaleInput> | PresaleWhitelistAddressCreateWithoutPresaleInput[] | PresaleWhitelistAddressUncheckedCreateWithoutPresaleInput[]
    connectOrCreate?: PresaleWhitelistAddressCreateOrConnectWithoutPresaleInput | PresaleWhitelistAddressCreateOrConnectWithoutPresaleInput[]
    createMany?: PresaleWhitelistAddressCreateManyPresaleInputEnvelope
    connect?: PresaleWhitelistAddressWhereUniqueInput | PresaleWhitelistAddressWhereUniqueInput[]
  }

  export type PresaleWhitelistAddressUncheckedCreateNestedManyWithoutPresaleInput = {
    create?: XOR<PresaleWhitelistAddressCreateWithoutPresaleInput, PresaleWhitelistAddressUncheckedCreateWithoutPresaleInput> | PresaleWhitelistAddressCreateWithoutPresaleInput[] | PresaleWhitelistAddressUncheckedCreateWithoutPresaleInput[]
    connectOrCreate?: PresaleWhitelistAddressCreateOrConnectWithoutPresaleInput | PresaleWhitelistAddressCreateOrConnectWithoutPresaleInput[]
    createMany?: PresaleWhitelistAddressCreateManyPresaleInputEnvelope
    connect?: PresaleWhitelistAddressWhereUniqueInput | PresaleWhitelistAddressWhereUniqueInput[]
  }

  export type CollectionUpdateOneRequiredWithoutPresaleNestedInput = {
    create?: XOR<CollectionCreateWithoutPresaleInput, CollectionUncheckedCreateWithoutPresaleInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutPresaleInput
    upsert?: CollectionUpsertWithoutPresaleInput
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutPresaleInput, CollectionUpdateWithoutPresaleInput>, CollectionUncheckedUpdateWithoutPresaleInput>
  }

  export type PresaleWhitelistAddressUpdateManyWithoutPresaleNestedInput = {
    create?: XOR<PresaleWhitelistAddressCreateWithoutPresaleInput, PresaleWhitelistAddressUncheckedCreateWithoutPresaleInput> | PresaleWhitelistAddressCreateWithoutPresaleInput[] | PresaleWhitelistAddressUncheckedCreateWithoutPresaleInput[]
    connectOrCreate?: PresaleWhitelistAddressCreateOrConnectWithoutPresaleInput | PresaleWhitelistAddressCreateOrConnectWithoutPresaleInput[]
    upsert?: PresaleWhitelistAddressUpsertWithWhereUniqueWithoutPresaleInput | PresaleWhitelistAddressUpsertWithWhereUniqueWithoutPresaleInput[]
    createMany?: PresaleWhitelistAddressCreateManyPresaleInputEnvelope
    set?: PresaleWhitelistAddressWhereUniqueInput | PresaleWhitelistAddressWhereUniqueInput[]
    disconnect?: PresaleWhitelistAddressWhereUniqueInput | PresaleWhitelistAddressWhereUniqueInput[]
    delete?: PresaleWhitelistAddressWhereUniqueInput | PresaleWhitelistAddressWhereUniqueInput[]
    connect?: PresaleWhitelistAddressWhereUniqueInput | PresaleWhitelistAddressWhereUniqueInput[]
    update?: PresaleWhitelistAddressUpdateWithWhereUniqueWithoutPresaleInput | PresaleWhitelistAddressUpdateWithWhereUniqueWithoutPresaleInput[]
    updateMany?: PresaleWhitelistAddressUpdateManyWithWhereWithoutPresaleInput | PresaleWhitelistAddressUpdateManyWithWhereWithoutPresaleInput[]
    deleteMany?: PresaleWhitelistAddressScalarWhereInput | PresaleWhitelistAddressScalarWhereInput[]
  }

  export type PresaleWhitelistAddressUncheckedUpdateManyWithoutPresaleNestedInput = {
    create?: XOR<PresaleWhitelistAddressCreateWithoutPresaleInput, PresaleWhitelistAddressUncheckedCreateWithoutPresaleInput> | PresaleWhitelistAddressCreateWithoutPresaleInput[] | PresaleWhitelistAddressUncheckedCreateWithoutPresaleInput[]
    connectOrCreate?: PresaleWhitelistAddressCreateOrConnectWithoutPresaleInput | PresaleWhitelistAddressCreateOrConnectWithoutPresaleInput[]
    upsert?: PresaleWhitelistAddressUpsertWithWhereUniqueWithoutPresaleInput | PresaleWhitelistAddressUpsertWithWhereUniqueWithoutPresaleInput[]
    createMany?: PresaleWhitelistAddressCreateManyPresaleInputEnvelope
    set?: PresaleWhitelistAddressWhereUniqueInput | PresaleWhitelistAddressWhereUniqueInput[]
    disconnect?: PresaleWhitelistAddressWhereUniqueInput | PresaleWhitelistAddressWhereUniqueInput[]
    delete?: PresaleWhitelistAddressWhereUniqueInput | PresaleWhitelistAddressWhereUniqueInput[]
    connect?: PresaleWhitelistAddressWhereUniqueInput | PresaleWhitelistAddressWhereUniqueInput[]
    update?: PresaleWhitelistAddressUpdateWithWhereUniqueWithoutPresaleInput | PresaleWhitelistAddressUpdateWithWhereUniqueWithoutPresaleInput[]
    updateMany?: PresaleWhitelistAddressUpdateManyWithWhereWithoutPresaleInput | PresaleWhitelistAddressUpdateManyWithWhereWithoutPresaleInput[]
    deleteMany?: PresaleWhitelistAddressScalarWhereInput | PresaleWhitelistAddressScalarWhereInput[]
  }

  export type PresaleCreateNestedOneWithoutWhitelistInput = {
    create?: XOR<PresaleCreateWithoutWhitelistInput, PresaleUncheckedCreateWithoutWhitelistInput>
    connectOrCreate?: PresaleCreateOrConnectWithoutWhitelistInput
    connect?: PresaleWhereUniqueInput
  }

  export type PresaleUpdateOneRequiredWithoutWhitelistNestedInput = {
    create?: XOR<PresaleCreateWithoutWhitelistInput, PresaleUncheckedCreateWithoutWhitelistInput>
    connectOrCreate?: PresaleCreateOrConnectWithoutWhitelistInput
    upsert?: PresaleUpsertWithoutWhitelistInput
    connect?: PresaleWhereUniqueInput
    update?: XOR<XOR<PresaleUpdateToOneWithWhereWithoutWhitelistInput, PresaleUpdateWithoutWhitelistInput>, PresaleUncheckedUpdateWithoutWhitelistInput>
  }

  export type EnumDraftStatusFieldUpdateOperationsInput = {
    set?: $Enums.DraftStatus
  }

  export type CollectionCreateNestedOneWithoutAssetUploadsInput = {
    create?: XOR<CollectionCreateWithoutAssetUploadsInput, CollectionUncheckedCreateWithoutAssetUploadsInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutAssetUploadsInput
    connect?: CollectionWhereUniqueInput
  }

  export type Single1155CreateNestedOneWithoutAssetUploadsInput = {
    create?: XOR<Single1155CreateWithoutAssetUploadsInput, Single1155UncheckedCreateWithoutAssetUploadsInput>
    connectOrCreate?: Single1155CreateOrConnectWithoutAssetUploadsInput
    connect?: Single1155WhereUniqueInput
  }

  export type Single721CreateNestedOneWithoutAssetUploadsInput = {
    create?: XOR<Single721CreateWithoutAssetUploadsInput, Single721UncheckedCreateWithoutAssetUploadsInput>
    connectOrCreate?: Single721CreateOrConnectWithoutAssetUploadsInput
    connect?: Single721WhereUniqueInput
  }

  export type CollectionUpdateOneWithoutAssetUploadsNestedInput = {
    create?: XOR<CollectionCreateWithoutAssetUploadsInput, CollectionUncheckedCreateWithoutAssetUploadsInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutAssetUploadsInput
    upsert?: CollectionUpsertWithoutAssetUploadsInput
    disconnect?: CollectionWhereInput | boolean
    delete?: CollectionWhereInput | boolean
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutAssetUploadsInput, CollectionUpdateWithoutAssetUploadsInput>, CollectionUncheckedUpdateWithoutAssetUploadsInput>
  }

  export type Single1155UpdateOneWithoutAssetUploadsNestedInput = {
    create?: XOR<Single1155CreateWithoutAssetUploadsInput, Single1155UncheckedCreateWithoutAssetUploadsInput>
    connectOrCreate?: Single1155CreateOrConnectWithoutAssetUploadsInput
    upsert?: Single1155UpsertWithoutAssetUploadsInput
    disconnect?: Single1155WhereInput | boolean
    delete?: Single1155WhereInput | boolean
    connect?: Single1155WhereUniqueInput
    update?: XOR<XOR<Single1155UpdateToOneWithWhereWithoutAssetUploadsInput, Single1155UpdateWithoutAssetUploadsInput>, Single1155UncheckedUpdateWithoutAssetUploadsInput>
  }

  export type Single721UpdateOneWithoutAssetUploadsNestedInput = {
    create?: XOR<Single721CreateWithoutAssetUploadsInput, Single721UncheckedCreateWithoutAssetUploadsInput>
    connectOrCreate?: Single721CreateOrConnectWithoutAssetUploadsInput
    upsert?: Single721UpsertWithoutAssetUploadsInput
    disconnect?: Single721WhereInput | boolean
    delete?: Single721WhereInput | boolean
    connect?: Single721WhereUniqueInput
    update?: XOR<XOR<Single721UpdateToOneWithWhereWithoutAssetUploadsInput, Single721UpdateWithoutAssetUploadsInput>, Single721UncheckedUpdateWithoutAssetUploadsInput>
  }

  export type UserCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSubmissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubmissionStatus
  }

  export type UserUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionsInput
    upsert?: UserUpsertWithoutSubmissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubmissionsInput, UserUpdateWithoutSubmissionsInput>, UserUncheckedUpdateWithoutSubmissionsInput>
  }

  export type FeaturedBidCreateNestedManyWithoutCycleInput = {
    create?: XOR<FeaturedBidCreateWithoutCycleInput, FeaturedBidUncheckedCreateWithoutCycleInput> | FeaturedBidCreateWithoutCycleInput[] | FeaturedBidUncheckedCreateWithoutCycleInput[]
    connectOrCreate?: FeaturedBidCreateOrConnectWithoutCycleInput | FeaturedBidCreateOrConnectWithoutCycleInput[]
    createMany?: FeaturedBidCreateManyCycleInputEnvelope
    connect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
  }

  export type FeaturedBidCreateNestedOneWithoutWinnerOfInput = {
    create?: XOR<FeaturedBidCreateWithoutWinnerOfInput, FeaturedBidUncheckedCreateWithoutWinnerOfInput>
    connectOrCreate?: FeaturedBidCreateOrConnectWithoutWinnerOfInput
    connect?: FeaturedBidWhereUniqueInput
  }

  export type CollectionCreateNestedOneWithoutFeaturedAsWinnerInput = {
    create?: XOR<CollectionCreateWithoutFeaturedAsWinnerInput, CollectionUncheckedCreateWithoutFeaturedAsWinnerInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutFeaturedAsWinnerInput
    connect?: CollectionWhereUniqueInput
  }

  export type FeaturedBidUncheckedCreateNestedManyWithoutCycleInput = {
    create?: XOR<FeaturedBidCreateWithoutCycleInput, FeaturedBidUncheckedCreateWithoutCycleInput> | FeaturedBidCreateWithoutCycleInput[] | FeaturedBidUncheckedCreateWithoutCycleInput[]
    connectOrCreate?: FeaturedBidCreateOrConnectWithoutCycleInput | FeaturedBidCreateOrConnectWithoutCycleInput[]
    createMany?: FeaturedBidCreateManyCycleInputEnvelope
    connect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
  }

  export type EnumFeaturedCycleStatusFieldUpdateOperationsInput = {
    set?: $Enums.FeaturedCycleStatus
  }

  export type FeaturedBidUpdateManyWithoutCycleNestedInput = {
    create?: XOR<FeaturedBidCreateWithoutCycleInput, FeaturedBidUncheckedCreateWithoutCycleInput> | FeaturedBidCreateWithoutCycleInput[] | FeaturedBidUncheckedCreateWithoutCycleInput[]
    connectOrCreate?: FeaturedBidCreateOrConnectWithoutCycleInput | FeaturedBidCreateOrConnectWithoutCycleInput[]
    upsert?: FeaturedBidUpsertWithWhereUniqueWithoutCycleInput | FeaturedBidUpsertWithWhereUniqueWithoutCycleInput[]
    createMany?: FeaturedBidCreateManyCycleInputEnvelope
    set?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    disconnect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    delete?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    connect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    update?: FeaturedBidUpdateWithWhereUniqueWithoutCycleInput | FeaturedBidUpdateWithWhereUniqueWithoutCycleInput[]
    updateMany?: FeaturedBidUpdateManyWithWhereWithoutCycleInput | FeaturedBidUpdateManyWithWhereWithoutCycleInput[]
    deleteMany?: FeaturedBidScalarWhereInput | FeaturedBidScalarWhereInput[]
  }

  export type FeaturedBidUpdateOneWithoutWinnerOfNestedInput = {
    create?: XOR<FeaturedBidCreateWithoutWinnerOfInput, FeaturedBidUncheckedCreateWithoutWinnerOfInput>
    connectOrCreate?: FeaturedBidCreateOrConnectWithoutWinnerOfInput
    upsert?: FeaturedBidUpsertWithoutWinnerOfInput
    disconnect?: FeaturedBidWhereInput | boolean
    delete?: FeaturedBidWhereInput | boolean
    connect?: FeaturedBidWhereUniqueInput
    update?: XOR<XOR<FeaturedBidUpdateToOneWithWhereWithoutWinnerOfInput, FeaturedBidUpdateWithoutWinnerOfInput>, FeaturedBidUncheckedUpdateWithoutWinnerOfInput>
  }

  export type CollectionUpdateOneWithoutFeaturedAsWinnerNestedInput = {
    create?: XOR<CollectionCreateWithoutFeaturedAsWinnerInput, CollectionUncheckedCreateWithoutFeaturedAsWinnerInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutFeaturedAsWinnerInput
    upsert?: CollectionUpsertWithoutFeaturedAsWinnerInput
    disconnect?: CollectionWhereInput | boolean
    delete?: CollectionWhereInput | boolean
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutFeaturedAsWinnerInput, CollectionUpdateWithoutFeaturedAsWinnerInput>, CollectionUncheckedUpdateWithoutFeaturedAsWinnerInput>
  }

  export type FeaturedBidUncheckedUpdateManyWithoutCycleNestedInput = {
    create?: XOR<FeaturedBidCreateWithoutCycleInput, FeaturedBidUncheckedCreateWithoutCycleInput> | FeaturedBidCreateWithoutCycleInput[] | FeaturedBidUncheckedCreateWithoutCycleInput[]
    connectOrCreate?: FeaturedBidCreateOrConnectWithoutCycleInput | FeaturedBidCreateOrConnectWithoutCycleInput[]
    upsert?: FeaturedBidUpsertWithWhereUniqueWithoutCycleInput | FeaturedBidUpsertWithWhereUniqueWithoutCycleInput[]
    createMany?: FeaturedBidCreateManyCycleInputEnvelope
    set?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    disconnect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    delete?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    connect?: FeaturedBidWhereUniqueInput | FeaturedBidWhereUniqueInput[]
    update?: FeaturedBidUpdateWithWhereUniqueWithoutCycleInput | FeaturedBidUpdateWithWhereUniqueWithoutCycleInput[]
    updateMany?: FeaturedBidUpdateManyWithWhereWithoutCycleInput | FeaturedBidUpdateManyWithWhereWithoutCycleInput[]
    deleteMany?: FeaturedBidScalarWhereInput | FeaturedBidScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFeaturedBidsInput = {
    create?: XOR<UserCreateWithoutFeaturedBidsInput, UserUncheckedCreateWithoutFeaturedBidsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeaturedBidsInput
    connect?: UserWhereUniqueInput
  }

  export type CollectionCreateNestedOneWithoutFeaturedBidEntriesInput = {
    create?: XOR<CollectionCreateWithoutFeaturedBidEntriesInput, CollectionUncheckedCreateWithoutFeaturedBidEntriesInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutFeaturedBidEntriesInput
    connect?: CollectionWhereUniqueInput
  }

  export type FeaturedCycleCreateNestedOneWithoutBidsInput = {
    create?: XOR<FeaturedCycleCreateWithoutBidsInput, FeaturedCycleUncheckedCreateWithoutBidsInput>
    connectOrCreate?: FeaturedCycleCreateOrConnectWithoutBidsInput
    connect?: FeaturedCycleWhereUniqueInput
  }

  export type FeaturedCycleCreateNestedOneWithoutWinnerBidInput = {
    create?: XOR<FeaturedCycleCreateWithoutWinnerBidInput, FeaturedCycleUncheckedCreateWithoutWinnerBidInput>
    connectOrCreate?: FeaturedCycleCreateOrConnectWithoutWinnerBidInput
    connect?: FeaturedCycleWhereUniqueInput
  }

  export type FeaturedCycleUncheckedCreateNestedOneWithoutWinnerBidInput = {
    create?: XOR<FeaturedCycleCreateWithoutWinnerBidInput, FeaturedCycleUncheckedCreateWithoutWinnerBidInput>
    connectOrCreate?: FeaturedCycleCreateOrConnectWithoutWinnerBidInput
    connect?: FeaturedCycleWhereUniqueInput
  }

  export type UserUpdateOneWithoutFeaturedBidsNestedInput = {
    create?: XOR<UserCreateWithoutFeaturedBidsInput, UserUncheckedCreateWithoutFeaturedBidsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeaturedBidsInput
    upsert?: UserUpsertWithoutFeaturedBidsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeaturedBidsInput, UserUpdateWithoutFeaturedBidsInput>, UserUncheckedUpdateWithoutFeaturedBidsInput>
  }

  export type CollectionUpdateOneRequiredWithoutFeaturedBidEntriesNestedInput = {
    create?: XOR<CollectionCreateWithoutFeaturedBidEntriesInput, CollectionUncheckedCreateWithoutFeaturedBidEntriesInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutFeaturedBidEntriesInput
    upsert?: CollectionUpsertWithoutFeaturedBidEntriesInput
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutFeaturedBidEntriesInput, CollectionUpdateWithoutFeaturedBidEntriesInput>, CollectionUncheckedUpdateWithoutFeaturedBidEntriesInput>
  }

  export type FeaturedCycleUpdateOneRequiredWithoutBidsNestedInput = {
    create?: XOR<FeaturedCycleCreateWithoutBidsInput, FeaturedCycleUncheckedCreateWithoutBidsInput>
    connectOrCreate?: FeaturedCycleCreateOrConnectWithoutBidsInput
    upsert?: FeaturedCycleUpsertWithoutBidsInput
    connect?: FeaturedCycleWhereUniqueInput
    update?: XOR<XOR<FeaturedCycleUpdateToOneWithWhereWithoutBidsInput, FeaturedCycleUpdateWithoutBidsInput>, FeaturedCycleUncheckedUpdateWithoutBidsInput>
  }

  export type FeaturedCycleUpdateOneWithoutWinnerBidNestedInput = {
    create?: XOR<FeaturedCycleCreateWithoutWinnerBidInput, FeaturedCycleUncheckedCreateWithoutWinnerBidInput>
    connectOrCreate?: FeaturedCycleCreateOrConnectWithoutWinnerBidInput
    upsert?: FeaturedCycleUpsertWithoutWinnerBidInput
    disconnect?: FeaturedCycleWhereInput | boolean
    delete?: FeaturedCycleWhereInput | boolean
    connect?: FeaturedCycleWhereUniqueInput
    update?: XOR<XOR<FeaturedCycleUpdateToOneWithWhereWithoutWinnerBidInput, FeaturedCycleUpdateWithoutWinnerBidInput>, FeaturedCycleUncheckedUpdateWithoutWinnerBidInput>
  }

  export type FeaturedCycleUncheckedUpdateOneWithoutWinnerBidNestedInput = {
    create?: XOR<FeaturedCycleCreateWithoutWinnerBidInput, FeaturedCycleUncheckedCreateWithoutWinnerBidInput>
    connectOrCreate?: FeaturedCycleCreateOrConnectWithoutWinnerBidInput
    upsert?: FeaturedCycleUpsertWithoutWinnerBidInput
    disconnect?: FeaturedCycleWhereInput | boolean
    delete?: FeaturedCycleWhereInput | boolean
    connect?: FeaturedCycleWhereUniqueInput
    update?: XOR<XOR<FeaturedCycleUpdateToOneWithWhereWithoutWinnerBidInput, FeaturedCycleUpdateWithoutWinnerBidInput>, FeaturedCycleUncheckedUpdateWithoutWinnerBidInput>
  }

  export type AuctionCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<AuctionCreateWithoutCurrencyInput, AuctionUncheckedCreateWithoutCurrencyInput> | AuctionCreateWithoutCurrencyInput[] | AuctionUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutCurrencyInput | AuctionCreateOrConnectWithoutCurrencyInput[]
    createMany?: AuctionCreateManyCurrencyInputEnvelope
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
  }

  export type AuctionBidCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<AuctionBidCreateWithoutCurrencyInput, AuctionBidUncheckedCreateWithoutCurrencyInput> | AuctionBidCreateWithoutCurrencyInput[] | AuctionBidUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutCurrencyInput | AuctionBidCreateOrConnectWithoutCurrencyInput[]
    createMany?: AuctionBidCreateManyCurrencyInputEnvelope
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
  }

  export type HolderRewardMultiCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<HolderRewardMultiCreateWithoutCurrencyInput, HolderRewardMultiUncheckedCreateWithoutCurrencyInput> | HolderRewardMultiCreateWithoutCurrencyInput[] | HolderRewardMultiUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: HolderRewardMultiCreateOrConnectWithoutCurrencyInput | HolderRewardMultiCreateOrConnectWithoutCurrencyInput[]
    createMany?: HolderRewardMultiCreateManyCurrencyInputEnvelope
    connect?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
  }

  export type MarketplaceListingCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<MarketplaceListingCreateWithoutCurrencyInput, MarketplaceListingUncheckedCreateWithoutCurrencyInput> | MarketplaceListingCreateWithoutCurrencyInput[] | MarketplaceListingUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutCurrencyInput | MarketplaceListingCreateOrConnectWithoutCurrencyInput[]
    createMany?: MarketplaceListingCreateManyCurrencyInputEnvelope
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
  }

  export type MarketplaceSaleCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<MarketplaceSaleCreateWithoutCurrencyInput, MarketplaceSaleUncheckedCreateWithoutCurrencyInput> | MarketplaceSaleCreateWithoutCurrencyInput[] | MarketplaceSaleUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: MarketplaceSaleCreateOrConnectWithoutCurrencyInput | MarketplaceSaleCreateOrConnectWithoutCurrencyInput[]
    createMany?: MarketplaceSaleCreateManyCurrencyInputEnvelope
    connect?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
  }

  export type RewardAccumulatorMultiCreateNestedOneWithoutCurrencyInput = {
    create?: XOR<RewardAccumulatorMultiCreateWithoutCurrencyInput, RewardAccumulatorMultiUncheckedCreateWithoutCurrencyInput>
    connectOrCreate?: RewardAccumulatorMultiCreateOrConnectWithoutCurrencyInput
    connect?: RewardAccumulatorMultiWhereUniqueInput
  }

  export type RewardClaimLogCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<RewardClaimLogCreateWithoutCurrencyInput, RewardClaimLogUncheckedCreateWithoutCurrencyInput> | RewardClaimLogCreateWithoutCurrencyInput[] | RewardClaimLogUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: RewardClaimLogCreateOrConnectWithoutCurrencyInput | RewardClaimLogCreateOrConnectWithoutCurrencyInput[]
    createMany?: RewardClaimLogCreateManyCurrencyInputEnvelope
    connect?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
  }

  export type RewardDistributionLogCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<RewardDistributionLogCreateWithoutCurrencyInput, RewardDistributionLogUncheckedCreateWithoutCurrencyInput> | RewardDistributionLogCreateWithoutCurrencyInput[] | RewardDistributionLogUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: RewardDistributionLogCreateOrConnectWithoutCurrencyInput | RewardDistributionLogCreateOrConnectWithoutCurrencyInput[]
    createMany?: RewardDistributionLogCreateManyCurrencyInputEnvelope
    connect?: RewardDistributionLogWhereUniqueInput | RewardDistributionLogWhereUniqueInput[]
  }

  export type AuctionUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<AuctionCreateWithoutCurrencyInput, AuctionUncheckedCreateWithoutCurrencyInput> | AuctionCreateWithoutCurrencyInput[] | AuctionUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutCurrencyInput | AuctionCreateOrConnectWithoutCurrencyInput[]
    createMany?: AuctionCreateManyCurrencyInputEnvelope
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
  }

  export type AuctionBidUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<AuctionBidCreateWithoutCurrencyInput, AuctionBidUncheckedCreateWithoutCurrencyInput> | AuctionBidCreateWithoutCurrencyInput[] | AuctionBidUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutCurrencyInput | AuctionBidCreateOrConnectWithoutCurrencyInput[]
    createMany?: AuctionBidCreateManyCurrencyInputEnvelope
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
  }

  export type HolderRewardMultiUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<HolderRewardMultiCreateWithoutCurrencyInput, HolderRewardMultiUncheckedCreateWithoutCurrencyInput> | HolderRewardMultiCreateWithoutCurrencyInput[] | HolderRewardMultiUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: HolderRewardMultiCreateOrConnectWithoutCurrencyInput | HolderRewardMultiCreateOrConnectWithoutCurrencyInput[]
    createMany?: HolderRewardMultiCreateManyCurrencyInputEnvelope
    connect?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
  }

  export type MarketplaceListingUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<MarketplaceListingCreateWithoutCurrencyInput, MarketplaceListingUncheckedCreateWithoutCurrencyInput> | MarketplaceListingCreateWithoutCurrencyInput[] | MarketplaceListingUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutCurrencyInput | MarketplaceListingCreateOrConnectWithoutCurrencyInput[]
    createMany?: MarketplaceListingCreateManyCurrencyInputEnvelope
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
  }

  export type MarketplaceSaleUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<MarketplaceSaleCreateWithoutCurrencyInput, MarketplaceSaleUncheckedCreateWithoutCurrencyInput> | MarketplaceSaleCreateWithoutCurrencyInput[] | MarketplaceSaleUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: MarketplaceSaleCreateOrConnectWithoutCurrencyInput | MarketplaceSaleCreateOrConnectWithoutCurrencyInput[]
    createMany?: MarketplaceSaleCreateManyCurrencyInputEnvelope
    connect?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
  }

  export type RewardAccumulatorMultiUncheckedCreateNestedOneWithoutCurrencyInput = {
    create?: XOR<RewardAccumulatorMultiCreateWithoutCurrencyInput, RewardAccumulatorMultiUncheckedCreateWithoutCurrencyInput>
    connectOrCreate?: RewardAccumulatorMultiCreateOrConnectWithoutCurrencyInput
    connect?: RewardAccumulatorMultiWhereUniqueInput
  }

  export type RewardClaimLogUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<RewardClaimLogCreateWithoutCurrencyInput, RewardClaimLogUncheckedCreateWithoutCurrencyInput> | RewardClaimLogCreateWithoutCurrencyInput[] | RewardClaimLogUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: RewardClaimLogCreateOrConnectWithoutCurrencyInput | RewardClaimLogCreateOrConnectWithoutCurrencyInput[]
    createMany?: RewardClaimLogCreateManyCurrencyInputEnvelope
    connect?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
  }

  export type RewardDistributionLogUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<RewardDistributionLogCreateWithoutCurrencyInput, RewardDistributionLogUncheckedCreateWithoutCurrencyInput> | RewardDistributionLogCreateWithoutCurrencyInput[] | RewardDistributionLogUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: RewardDistributionLogCreateOrConnectWithoutCurrencyInput | RewardDistributionLogCreateOrConnectWithoutCurrencyInput[]
    createMany?: RewardDistributionLogCreateManyCurrencyInputEnvelope
    connect?: RewardDistributionLogWhereUniqueInput | RewardDistributionLogWhereUniqueInput[]
  }

  export type EnumCurrencyKindFieldUpdateOperationsInput = {
    set?: $Enums.CurrencyKind
  }

  export type AuctionUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<AuctionCreateWithoutCurrencyInput, AuctionUncheckedCreateWithoutCurrencyInput> | AuctionCreateWithoutCurrencyInput[] | AuctionUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutCurrencyInput | AuctionCreateOrConnectWithoutCurrencyInput[]
    upsert?: AuctionUpsertWithWhereUniqueWithoutCurrencyInput | AuctionUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: AuctionCreateManyCurrencyInputEnvelope
    set?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    disconnect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    delete?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    update?: AuctionUpdateWithWhereUniqueWithoutCurrencyInput | AuctionUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: AuctionUpdateManyWithWhereWithoutCurrencyInput | AuctionUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
  }

  export type AuctionBidUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<AuctionBidCreateWithoutCurrencyInput, AuctionBidUncheckedCreateWithoutCurrencyInput> | AuctionBidCreateWithoutCurrencyInput[] | AuctionBidUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutCurrencyInput | AuctionBidCreateOrConnectWithoutCurrencyInput[]
    upsert?: AuctionBidUpsertWithWhereUniqueWithoutCurrencyInput | AuctionBidUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: AuctionBidCreateManyCurrencyInputEnvelope
    set?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    disconnect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    delete?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    update?: AuctionBidUpdateWithWhereUniqueWithoutCurrencyInput | AuctionBidUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: AuctionBidUpdateManyWithWhereWithoutCurrencyInput | AuctionBidUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: AuctionBidScalarWhereInput | AuctionBidScalarWhereInput[]
  }

  export type HolderRewardMultiUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<HolderRewardMultiCreateWithoutCurrencyInput, HolderRewardMultiUncheckedCreateWithoutCurrencyInput> | HolderRewardMultiCreateWithoutCurrencyInput[] | HolderRewardMultiUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: HolderRewardMultiCreateOrConnectWithoutCurrencyInput | HolderRewardMultiCreateOrConnectWithoutCurrencyInput[]
    upsert?: HolderRewardMultiUpsertWithWhereUniqueWithoutCurrencyInput | HolderRewardMultiUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: HolderRewardMultiCreateManyCurrencyInputEnvelope
    set?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    disconnect?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    delete?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    connect?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    update?: HolderRewardMultiUpdateWithWhereUniqueWithoutCurrencyInput | HolderRewardMultiUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: HolderRewardMultiUpdateManyWithWhereWithoutCurrencyInput | HolderRewardMultiUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: HolderRewardMultiScalarWhereInput | HolderRewardMultiScalarWhereInput[]
  }

  export type MarketplaceListingUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutCurrencyInput, MarketplaceListingUncheckedCreateWithoutCurrencyInput> | MarketplaceListingCreateWithoutCurrencyInput[] | MarketplaceListingUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutCurrencyInput | MarketplaceListingCreateOrConnectWithoutCurrencyInput[]
    upsert?: MarketplaceListingUpsertWithWhereUniqueWithoutCurrencyInput | MarketplaceListingUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: MarketplaceListingCreateManyCurrencyInputEnvelope
    set?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    disconnect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    delete?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    update?: MarketplaceListingUpdateWithWhereUniqueWithoutCurrencyInput | MarketplaceListingUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: MarketplaceListingUpdateManyWithWhereWithoutCurrencyInput | MarketplaceListingUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
  }

  export type MarketplaceSaleUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<MarketplaceSaleCreateWithoutCurrencyInput, MarketplaceSaleUncheckedCreateWithoutCurrencyInput> | MarketplaceSaleCreateWithoutCurrencyInput[] | MarketplaceSaleUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: MarketplaceSaleCreateOrConnectWithoutCurrencyInput | MarketplaceSaleCreateOrConnectWithoutCurrencyInput[]
    upsert?: MarketplaceSaleUpsertWithWhereUniqueWithoutCurrencyInput | MarketplaceSaleUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: MarketplaceSaleCreateManyCurrencyInputEnvelope
    set?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    disconnect?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    delete?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    connect?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    update?: MarketplaceSaleUpdateWithWhereUniqueWithoutCurrencyInput | MarketplaceSaleUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: MarketplaceSaleUpdateManyWithWhereWithoutCurrencyInput | MarketplaceSaleUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: MarketplaceSaleScalarWhereInput | MarketplaceSaleScalarWhereInput[]
  }

  export type RewardAccumulatorMultiUpdateOneWithoutCurrencyNestedInput = {
    create?: XOR<RewardAccumulatorMultiCreateWithoutCurrencyInput, RewardAccumulatorMultiUncheckedCreateWithoutCurrencyInput>
    connectOrCreate?: RewardAccumulatorMultiCreateOrConnectWithoutCurrencyInput
    upsert?: RewardAccumulatorMultiUpsertWithoutCurrencyInput
    disconnect?: RewardAccumulatorMultiWhereInput | boolean
    delete?: RewardAccumulatorMultiWhereInput | boolean
    connect?: RewardAccumulatorMultiWhereUniqueInput
    update?: XOR<XOR<RewardAccumulatorMultiUpdateToOneWithWhereWithoutCurrencyInput, RewardAccumulatorMultiUpdateWithoutCurrencyInput>, RewardAccumulatorMultiUncheckedUpdateWithoutCurrencyInput>
  }

  export type RewardClaimLogUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<RewardClaimLogCreateWithoutCurrencyInput, RewardClaimLogUncheckedCreateWithoutCurrencyInput> | RewardClaimLogCreateWithoutCurrencyInput[] | RewardClaimLogUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: RewardClaimLogCreateOrConnectWithoutCurrencyInput | RewardClaimLogCreateOrConnectWithoutCurrencyInput[]
    upsert?: RewardClaimLogUpsertWithWhereUniqueWithoutCurrencyInput | RewardClaimLogUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: RewardClaimLogCreateManyCurrencyInputEnvelope
    set?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    disconnect?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    delete?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    connect?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    update?: RewardClaimLogUpdateWithWhereUniqueWithoutCurrencyInput | RewardClaimLogUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: RewardClaimLogUpdateManyWithWhereWithoutCurrencyInput | RewardClaimLogUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: RewardClaimLogScalarWhereInput | RewardClaimLogScalarWhereInput[]
  }

  export type RewardDistributionLogUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<RewardDistributionLogCreateWithoutCurrencyInput, RewardDistributionLogUncheckedCreateWithoutCurrencyInput> | RewardDistributionLogCreateWithoutCurrencyInput[] | RewardDistributionLogUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: RewardDistributionLogCreateOrConnectWithoutCurrencyInput | RewardDistributionLogCreateOrConnectWithoutCurrencyInput[]
    upsert?: RewardDistributionLogUpsertWithWhereUniqueWithoutCurrencyInput | RewardDistributionLogUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: RewardDistributionLogCreateManyCurrencyInputEnvelope
    set?: RewardDistributionLogWhereUniqueInput | RewardDistributionLogWhereUniqueInput[]
    disconnect?: RewardDistributionLogWhereUniqueInput | RewardDistributionLogWhereUniqueInput[]
    delete?: RewardDistributionLogWhereUniqueInput | RewardDistributionLogWhereUniqueInput[]
    connect?: RewardDistributionLogWhereUniqueInput | RewardDistributionLogWhereUniqueInput[]
    update?: RewardDistributionLogUpdateWithWhereUniqueWithoutCurrencyInput | RewardDistributionLogUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: RewardDistributionLogUpdateManyWithWhereWithoutCurrencyInput | RewardDistributionLogUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: RewardDistributionLogScalarWhereInput | RewardDistributionLogScalarWhereInput[]
  }

  export type AuctionUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<AuctionCreateWithoutCurrencyInput, AuctionUncheckedCreateWithoutCurrencyInput> | AuctionCreateWithoutCurrencyInput[] | AuctionUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: AuctionCreateOrConnectWithoutCurrencyInput | AuctionCreateOrConnectWithoutCurrencyInput[]
    upsert?: AuctionUpsertWithWhereUniqueWithoutCurrencyInput | AuctionUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: AuctionCreateManyCurrencyInputEnvelope
    set?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    disconnect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    delete?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    connect?: AuctionWhereUniqueInput | AuctionWhereUniqueInput[]
    update?: AuctionUpdateWithWhereUniqueWithoutCurrencyInput | AuctionUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: AuctionUpdateManyWithWhereWithoutCurrencyInput | AuctionUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
  }

  export type AuctionBidUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<AuctionBidCreateWithoutCurrencyInput, AuctionBidUncheckedCreateWithoutCurrencyInput> | AuctionBidCreateWithoutCurrencyInput[] | AuctionBidUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: AuctionBidCreateOrConnectWithoutCurrencyInput | AuctionBidCreateOrConnectWithoutCurrencyInput[]
    upsert?: AuctionBidUpsertWithWhereUniqueWithoutCurrencyInput | AuctionBidUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: AuctionBidCreateManyCurrencyInputEnvelope
    set?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    disconnect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    delete?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    connect?: AuctionBidWhereUniqueInput | AuctionBidWhereUniqueInput[]
    update?: AuctionBidUpdateWithWhereUniqueWithoutCurrencyInput | AuctionBidUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: AuctionBidUpdateManyWithWhereWithoutCurrencyInput | AuctionBidUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: AuctionBidScalarWhereInput | AuctionBidScalarWhereInput[]
  }

  export type HolderRewardMultiUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<HolderRewardMultiCreateWithoutCurrencyInput, HolderRewardMultiUncheckedCreateWithoutCurrencyInput> | HolderRewardMultiCreateWithoutCurrencyInput[] | HolderRewardMultiUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: HolderRewardMultiCreateOrConnectWithoutCurrencyInput | HolderRewardMultiCreateOrConnectWithoutCurrencyInput[]
    upsert?: HolderRewardMultiUpsertWithWhereUniqueWithoutCurrencyInput | HolderRewardMultiUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: HolderRewardMultiCreateManyCurrencyInputEnvelope
    set?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    disconnect?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    delete?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    connect?: HolderRewardMultiWhereUniqueInput | HolderRewardMultiWhereUniqueInput[]
    update?: HolderRewardMultiUpdateWithWhereUniqueWithoutCurrencyInput | HolderRewardMultiUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: HolderRewardMultiUpdateManyWithWhereWithoutCurrencyInput | HolderRewardMultiUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: HolderRewardMultiScalarWhereInput | HolderRewardMultiScalarWhereInput[]
  }

  export type MarketplaceListingUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<MarketplaceListingCreateWithoutCurrencyInput, MarketplaceListingUncheckedCreateWithoutCurrencyInput> | MarketplaceListingCreateWithoutCurrencyInput[] | MarketplaceListingUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: MarketplaceListingCreateOrConnectWithoutCurrencyInput | MarketplaceListingCreateOrConnectWithoutCurrencyInput[]
    upsert?: MarketplaceListingUpsertWithWhereUniqueWithoutCurrencyInput | MarketplaceListingUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: MarketplaceListingCreateManyCurrencyInputEnvelope
    set?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    disconnect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    delete?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    connect?: MarketplaceListingWhereUniqueInput | MarketplaceListingWhereUniqueInput[]
    update?: MarketplaceListingUpdateWithWhereUniqueWithoutCurrencyInput | MarketplaceListingUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: MarketplaceListingUpdateManyWithWhereWithoutCurrencyInput | MarketplaceListingUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
  }

  export type MarketplaceSaleUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<MarketplaceSaleCreateWithoutCurrencyInput, MarketplaceSaleUncheckedCreateWithoutCurrencyInput> | MarketplaceSaleCreateWithoutCurrencyInput[] | MarketplaceSaleUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: MarketplaceSaleCreateOrConnectWithoutCurrencyInput | MarketplaceSaleCreateOrConnectWithoutCurrencyInput[]
    upsert?: MarketplaceSaleUpsertWithWhereUniqueWithoutCurrencyInput | MarketplaceSaleUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: MarketplaceSaleCreateManyCurrencyInputEnvelope
    set?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    disconnect?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    delete?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    connect?: MarketplaceSaleWhereUniqueInput | MarketplaceSaleWhereUniqueInput[]
    update?: MarketplaceSaleUpdateWithWhereUniqueWithoutCurrencyInput | MarketplaceSaleUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: MarketplaceSaleUpdateManyWithWhereWithoutCurrencyInput | MarketplaceSaleUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: MarketplaceSaleScalarWhereInput | MarketplaceSaleScalarWhereInput[]
  }

  export type RewardAccumulatorMultiUncheckedUpdateOneWithoutCurrencyNestedInput = {
    create?: XOR<RewardAccumulatorMultiCreateWithoutCurrencyInput, RewardAccumulatorMultiUncheckedCreateWithoutCurrencyInput>
    connectOrCreate?: RewardAccumulatorMultiCreateOrConnectWithoutCurrencyInput
    upsert?: RewardAccumulatorMultiUpsertWithoutCurrencyInput
    disconnect?: RewardAccumulatorMultiWhereInput | boolean
    delete?: RewardAccumulatorMultiWhereInput | boolean
    connect?: RewardAccumulatorMultiWhereUniqueInput
    update?: XOR<XOR<RewardAccumulatorMultiUpdateToOneWithWhereWithoutCurrencyInput, RewardAccumulatorMultiUpdateWithoutCurrencyInput>, RewardAccumulatorMultiUncheckedUpdateWithoutCurrencyInput>
  }

  export type RewardClaimLogUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<RewardClaimLogCreateWithoutCurrencyInput, RewardClaimLogUncheckedCreateWithoutCurrencyInput> | RewardClaimLogCreateWithoutCurrencyInput[] | RewardClaimLogUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: RewardClaimLogCreateOrConnectWithoutCurrencyInput | RewardClaimLogCreateOrConnectWithoutCurrencyInput[]
    upsert?: RewardClaimLogUpsertWithWhereUniqueWithoutCurrencyInput | RewardClaimLogUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: RewardClaimLogCreateManyCurrencyInputEnvelope
    set?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    disconnect?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    delete?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    connect?: RewardClaimLogWhereUniqueInput | RewardClaimLogWhereUniqueInput[]
    update?: RewardClaimLogUpdateWithWhereUniqueWithoutCurrencyInput | RewardClaimLogUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: RewardClaimLogUpdateManyWithWhereWithoutCurrencyInput | RewardClaimLogUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: RewardClaimLogScalarWhereInput | RewardClaimLogScalarWhereInput[]
  }

  export type RewardDistributionLogUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<RewardDistributionLogCreateWithoutCurrencyInput, RewardDistributionLogUncheckedCreateWithoutCurrencyInput> | RewardDistributionLogCreateWithoutCurrencyInput[] | RewardDistributionLogUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: RewardDistributionLogCreateOrConnectWithoutCurrencyInput | RewardDistributionLogCreateOrConnectWithoutCurrencyInput[]
    upsert?: RewardDistributionLogUpsertWithWhereUniqueWithoutCurrencyInput | RewardDistributionLogUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: RewardDistributionLogCreateManyCurrencyInputEnvelope
    set?: RewardDistributionLogWhereUniqueInput | RewardDistributionLogWhereUniqueInput[]
    disconnect?: RewardDistributionLogWhereUniqueInput | RewardDistributionLogWhereUniqueInput[]
    delete?: RewardDistributionLogWhereUniqueInput | RewardDistributionLogWhereUniqueInput[]
    connect?: RewardDistributionLogWhereUniqueInput | RewardDistributionLogWhereUniqueInput[]
    update?: RewardDistributionLogUpdateWithWhereUniqueWithoutCurrencyInput | RewardDistributionLogUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: RewardDistributionLogUpdateManyWithWhereWithoutCurrencyInput | RewardDistributionLogUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: RewardDistributionLogScalarWhereInput | RewardDistributionLogScalarWhereInput[]
  }

  export type CurrencyCreateNestedOneWithoutSalesInput = {
    create?: XOR<CurrencyCreateWithoutSalesInput, CurrencyUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutSalesInput
    connect?: CurrencyWhereUniqueInput
  }

  export type NFTCreateNestedOneWithoutSalesInput = {
    create?: XOR<NFTCreateWithoutSalesInput, NFTUncheckedCreateWithoutSalesInput>
    connectOrCreate?: NFTCreateOrConnectWithoutSalesInput
    connect?: NFTWhereUniqueInput
  }

  export type CurrencyUpdateOneWithoutSalesNestedInput = {
    create?: XOR<CurrencyCreateWithoutSalesInput, CurrencyUncheckedCreateWithoutSalesInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutSalesInput
    upsert?: CurrencyUpsertWithoutSalesInput
    disconnect?: CurrencyWhereInput | boolean
    delete?: CurrencyWhereInput | boolean
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutSalesInput, CurrencyUpdateWithoutSalesInput>, CurrencyUncheckedUpdateWithoutSalesInput>
  }

  export type NFTUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<NFTCreateWithoutSalesInput, NFTUncheckedCreateWithoutSalesInput>
    connectOrCreate?: NFTCreateOrConnectWithoutSalesInput
    upsert?: NFTUpsertWithoutSalesInput
    connect?: NFTWhereUniqueInput
    update?: XOR<XOR<NFTUpdateToOneWithWhereWithoutSalesInput, NFTUpdateWithoutSalesInput>, NFTUncheckedUpdateWithoutSalesInput>
  }

  export type CurrencyCreateNestedOneWithoutRewardAccumulatorsInput = {
    create?: XOR<CurrencyCreateWithoutRewardAccumulatorsInput, CurrencyUncheckedCreateWithoutRewardAccumulatorsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutRewardAccumulatorsInput
    connect?: CurrencyWhereUniqueInput
  }

  export type CurrencyUpdateOneRequiredWithoutRewardAccumulatorsNestedInput = {
    create?: XOR<CurrencyCreateWithoutRewardAccumulatorsInput, CurrencyUncheckedCreateWithoutRewardAccumulatorsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutRewardAccumulatorsInput
    upsert?: CurrencyUpsertWithoutRewardAccumulatorsInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutRewardAccumulatorsInput, CurrencyUpdateWithoutRewardAccumulatorsInput>, CurrencyUncheckedUpdateWithoutRewardAccumulatorsInput>
  }

  export type CurrencyCreateNestedOneWithoutHolderRewardsInput = {
    create?: XOR<CurrencyCreateWithoutHolderRewardsInput, CurrencyUncheckedCreateWithoutHolderRewardsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutHolderRewardsInput
    connect?: CurrencyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHolderRewardsMultiInput = {
    create?: XOR<UserCreateWithoutHolderRewardsMultiInput, UserUncheckedCreateWithoutHolderRewardsMultiInput>
    connectOrCreate?: UserCreateOrConnectWithoutHolderRewardsMultiInput
    connect?: UserWhereUniqueInput
  }

  export type CurrencyUpdateOneRequiredWithoutHolderRewardsNestedInput = {
    create?: XOR<CurrencyCreateWithoutHolderRewardsInput, CurrencyUncheckedCreateWithoutHolderRewardsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutHolderRewardsInput
    upsert?: CurrencyUpsertWithoutHolderRewardsInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutHolderRewardsInput, CurrencyUpdateWithoutHolderRewardsInput>, CurrencyUncheckedUpdateWithoutHolderRewardsInput>
  }

  export type UserUpdateOneWithoutHolderRewardsMultiNestedInput = {
    create?: XOR<UserCreateWithoutHolderRewardsMultiInput, UserUncheckedCreateWithoutHolderRewardsMultiInput>
    connectOrCreate?: UserCreateOrConnectWithoutHolderRewardsMultiInput
    upsert?: UserUpsertWithoutHolderRewardsMultiInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHolderRewardsMultiInput, UserUpdateWithoutHolderRewardsMultiInput>, UserUncheckedUpdateWithoutHolderRewardsMultiInput>
  }

  export type CurrencyCreateNestedOneWithoutDistributionLogsInput = {
    create?: XOR<CurrencyCreateWithoutDistributionLogsInput, CurrencyUncheckedCreateWithoutDistributionLogsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutDistributionLogsInput
    connect?: CurrencyWhereUniqueInput
  }

  export type CurrencyUpdateOneRequiredWithoutDistributionLogsNestedInput = {
    create?: XOR<CurrencyCreateWithoutDistributionLogsInput, CurrencyUncheckedCreateWithoutDistributionLogsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutDistributionLogsInput
    upsert?: CurrencyUpsertWithoutDistributionLogsInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutDistributionLogsInput, CurrencyUpdateWithoutDistributionLogsInput>, CurrencyUncheckedUpdateWithoutDistributionLogsInput>
  }

  export type CurrencyCreateNestedOneWithoutClaimLogsInput = {
    create?: XOR<CurrencyCreateWithoutClaimLogsInput, CurrencyUncheckedCreateWithoutClaimLogsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutClaimLogsInput
    connect?: CurrencyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRewardClaimLogsInput = {
    create?: XOR<UserCreateWithoutRewardClaimLogsInput, UserUncheckedCreateWithoutRewardClaimLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardClaimLogsInput
    connect?: UserWhereUniqueInput
  }

  export type CurrencyUpdateOneRequiredWithoutClaimLogsNestedInput = {
    create?: XOR<CurrencyCreateWithoutClaimLogsInput, CurrencyUncheckedCreateWithoutClaimLogsInput>
    connectOrCreate?: CurrencyCreateOrConnectWithoutClaimLogsInput
    upsert?: CurrencyUpsertWithoutClaimLogsInput
    connect?: CurrencyWhereUniqueInput
    update?: XOR<XOR<CurrencyUpdateToOneWithWhereWithoutClaimLogsInput, CurrencyUpdateWithoutClaimLogsInput>, CurrencyUncheckedUpdateWithoutClaimLogsInput>
  }

  export type UserUpdateOneWithoutRewardClaimLogsNestedInput = {
    create?: XOR<UserCreateWithoutRewardClaimLogsInput, UserUncheckedCreateWithoutRewardClaimLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRewardClaimLogsInput
    upsert?: UserUpsertWithoutRewardClaimLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRewardClaimLogsInput, UserUpdateWithoutRewardClaimLogsInput>, UserUncheckedUpdateWithoutRewardClaimLogsInput>
  }

  export type UserCreateNestedOneWithoutStolenReportsInput = {
    create?: XOR<UserCreateWithoutStolenReportsInput, UserUncheckedCreateWithoutStolenReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStolenReportsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumStolenStatusFieldUpdateOperationsInput = {
    set?: $Enums.StolenStatus
  }

  export type EnumStolenSourceFieldUpdateOperationsInput = {
    set?: $Enums.StolenSource
  }

  export type UserUpdateOneWithoutStolenReportsNestedInput = {
    create?: XOR<UserCreateWithoutStolenReportsInput, UserUncheckedCreateWithoutStolenReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStolenReportsInput
    upsert?: UserUpsertWithoutStolenReportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStolenReportsInput, UserUpdateWithoutStolenReportsInput>, UserUncheckedUpdateWithoutStolenReportsInput>
  }

  export type MultisigOwnerCreateNestedManyWithoutSafeInput = {
    create?: XOR<MultisigOwnerCreateWithoutSafeInput, MultisigOwnerUncheckedCreateWithoutSafeInput> | MultisigOwnerCreateWithoutSafeInput[] | MultisigOwnerUncheckedCreateWithoutSafeInput[]
    connectOrCreate?: MultisigOwnerCreateOrConnectWithoutSafeInput | MultisigOwnerCreateOrConnectWithoutSafeInput[]
    createMany?: MultisigOwnerCreateManySafeInputEnvelope
    connect?: MultisigOwnerWhereUniqueInput | MultisigOwnerWhereUniqueInput[]
  }

  export type MultisigTxCreateNestedManyWithoutSafeInput = {
    create?: XOR<MultisigTxCreateWithoutSafeInput, MultisigTxUncheckedCreateWithoutSafeInput> | MultisigTxCreateWithoutSafeInput[] | MultisigTxUncheckedCreateWithoutSafeInput[]
    connectOrCreate?: MultisigTxCreateOrConnectWithoutSafeInput | MultisigTxCreateOrConnectWithoutSafeInput[]
    createMany?: MultisigTxCreateManySafeInputEnvelope
    connect?: MultisigTxWhereUniqueInput | MultisigTxWhereUniqueInput[]
  }

  export type MultisigOwnerUncheckedCreateNestedManyWithoutSafeInput = {
    create?: XOR<MultisigOwnerCreateWithoutSafeInput, MultisigOwnerUncheckedCreateWithoutSafeInput> | MultisigOwnerCreateWithoutSafeInput[] | MultisigOwnerUncheckedCreateWithoutSafeInput[]
    connectOrCreate?: MultisigOwnerCreateOrConnectWithoutSafeInput | MultisigOwnerCreateOrConnectWithoutSafeInput[]
    createMany?: MultisigOwnerCreateManySafeInputEnvelope
    connect?: MultisigOwnerWhereUniqueInput | MultisigOwnerWhereUniqueInput[]
  }

  export type MultisigTxUncheckedCreateNestedManyWithoutSafeInput = {
    create?: XOR<MultisigTxCreateWithoutSafeInput, MultisigTxUncheckedCreateWithoutSafeInput> | MultisigTxCreateWithoutSafeInput[] | MultisigTxUncheckedCreateWithoutSafeInput[]
    connectOrCreate?: MultisigTxCreateOrConnectWithoutSafeInput | MultisigTxCreateOrConnectWithoutSafeInput[]
    createMany?: MultisigTxCreateManySafeInputEnvelope
    connect?: MultisigTxWhereUniqueInput | MultisigTxWhereUniqueInput[]
  }

  export type MultisigOwnerUpdateManyWithoutSafeNestedInput = {
    create?: XOR<MultisigOwnerCreateWithoutSafeInput, MultisigOwnerUncheckedCreateWithoutSafeInput> | MultisigOwnerCreateWithoutSafeInput[] | MultisigOwnerUncheckedCreateWithoutSafeInput[]
    connectOrCreate?: MultisigOwnerCreateOrConnectWithoutSafeInput | MultisigOwnerCreateOrConnectWithoutSafeInput[]
    upsert?: MultisigOwnerUpsertWithWhereUniqueWithoutSafeInput | MultisigOwnerUpsertWithWhereUniqueWithoutSafeInput[]
    createMany?: MultisigOwnerCreateManySafeInputEnvelope
    set?: MultisigOwnerWhereUniqueInput | MultisigOwnerWhereUniqueInput[]
    disconnect?: MultisigOwnerWhereUniqueInput | MultisigOwnerWhereUniqueInput[]
    delete?: MultisigOwnerWhereUniqueInput | MultisigOwnerWhereUniqueInput[]
    connect?: MultisigOwnerWhereUniqueInput | MultisigOwnerWhereUniqueInput[]
    update?: MultisigOwnerUpdateWithWhereUniqueWithoutSafeInput | MultisigOwnerUpdateWithWhereUniqueWithoutSafeInput[]
    updateMany?: MultisigOwnerUpdateManyWithWhereWithoutSafeInput | MultisigOwnerUpdateManyWithWhereWithoutSafeInput[]
    deleteMany?: MultisigOwnerScalarWhereInput | MultisigOwnerScalarWhereInput[]
  }

  export type MultisigTxUpdateManyWithoutSafeNestedInput = {
    create?: XOR<MultisigTxCreateWithoutSafeInput, MultisigTxUncheckedCreateWithoutSafeInput> | MultisigTxCreateWithoutSafeInput[] | MultisigTxUncheckedCreateWithoutSafeInput[]
    connectOrCreate?: MultisigTxCreateOrConnectWithoutSafeInput | MultisigTxCreateOrConnectWithoutSafeInput[]
    upsert?: MultisigTxUpsertWithWhereUniqueWithoutSafeInput | MultisigTxUpsertWithWhereUniqueWithoutSafeInput[]
    createMany?: MultisigTxCreateManySafeInputEnvelope
    set?: MultisigTxWhereUniqueInput | MultisigTxWhereUniqueInput[]
    disconnect?: MultisigTxWhereUniqueInput | MultisigTxWhereUniqueInput[]
    delete?: MultisigTxWhereUniqueInput | MultisigTxWhereUniqueInput[]
    connect?: MultisigTxWhereUniqueInput | MultisigTxWhereUniqueInput[]
    update?: MultisigTxUpdateWithWhereUniqueWithoutSafeInput | MultisigTxUpdateWithWhereUniqueWithoutSafeInput[]
    updateMany?: MultisigTxUpdateManyWithWhereWithoutSafeInput | MultisigTxUpdateManyWithWhereWithoutSafeInput[]
    deleteMany?: MultisigTxScalarWhereInput | MultisigTxScalarWhereInput[]
  }

  export type MultisigOwnerUncheckedUpdateManyWithoutSafeNestedInput = {
    create?: XOR<MultisigOwnerCreateWithoutSafeInput, MultisigOwnerUncheckedCreateWithoutSafeInput> | MultisigOwnerCreateWithoutSafeInput[] | MultisigOwnerUncheckedCreateWithoutSafeInput[]
    connectOrCreate?: MultisigOwnerCreateOrConnectWithoutSafeInput | MultisigOwnerCreateOrConnectWithoutSafeInput[]
    upsert?: MultisigOwnerUpsertWithWhereUniqueWithoutSafeInput | MultisigOwnerUpsertWithWhereUniqueWithoutSafeInput[]
    createMany?: MultisigOwnerCreateManySafeInputEnvelope
    set?: MultisigOwnerWhereUniqueInput | MultisigOwnerWhereUniqueInput[]
    disconnect?: MultisigOwnerWhereUniqueInput | MultisigOwnerWhereUniqueInput[]
    delete?: MultisigOwnerWhereUniqueInput | MultisigOwnerWhereUniqueInput[]
    connect?: MultisigOwnerWhereUniqueInput | MultisigOwnerWhereUniqueInput[]
    update?: MultisigOwnerUpdateWithWhereUniqueWithoutSafeInput | MultisigOwnerUpdateWithWhereUniqueWithoutSafeInput[]
    updateMany?: MultisigOwnerUpdateManyWithWhereWithoutSafeInput | MultisigOwnerUpdateManyWithWhereWithoutSafeInput[]
    deleteMany?: MultisigOwnerScalarWhereInput | MultisigOwnerScalarWhereInput[]
  }

  export type MultisigTxUncheckedUpdateManyWithoutSafeNestedInput = {
    create?: XOR<MultisigTxCreateWithoutSafeInput, MultisigTxUncheckedCreateWithoutSafeInput> | MultisigTxCreateWithoutSafeInput[] | MultisigTxUncheckedCreateWithoutSafeInput[]
    connectOrCreate?: MultisigTxCreateOrConnectWithoutSafeInput | MultisigTxCreateOrConnectWithoutSafeInput[]
    upsert?: MultisigTxUpsertWithWhereUniqueWithoutSafeInput | MultisigTxUpsertWithWhereUniqueWithoutSafeInput[]
    createMany?: MultisigTxCreateManySafeInputEnvelope
    set?: MultisigTxWhereUniqueInput | MultisigTxWhereUniqueInput[]
    disconnect?: MultisigTxWhereUniqueInput | MultisigTxWhereUniqueInput[]
    delete?: MultisigTxWhereUniqueInput | MultisigTxWhereUniqueInput[]
    connect?: MultisigTxWhereUniqueInput | MultisigTxWhereUniqueInput[]
    update?: MultisigTxUpdateWithWhereUniqueWithoutSafeInput | MultisigTxUpdateWithWhereUniqueWithoutSafeInput[]
    updateMany?: MultisigTxUpdateManyWithWhereWithoutSafeInput | MultisigTxUpdateManyWithWhereWithoutSafeInput[]
    deleteMany?: MultisigTxScalarWhereInput | MultisigTxScalarWhereInput[]
  }

  export type MultisigSafeCreateNestedOneWithoutOwnersInput = {
    create?: XOR<MultisigSafeCreateWithoutOwnersInput, MultisigSafeUncheckedCreateWithoutOwnersInput>
    connectOrCreate?: MultisigSafeCreateOrConnectWithoutOwnersInput
    connect?: MultisigSafeWhereUniqueInput
  }

  export type MultisigSafeUpdateOneRequiredWithoutOwnersNestedInput = {
    create?: XOR<MultisigSafeCreateWithoutOwnersInput, MultisigSafeUncheckedCreateWithoutOwnersInput>
    connectOrCreate?: MultisigSafeCreateOrConnectWithoutOwnersInput
    upsert?: MultisigSafeUpsertWithoutOwnersInput
    connect?: MultisigSafeWhereUniqueInput
    update?: XOR<XOR<MultisigSafeUpdateToOneWithWhereWithoutOwnersInput, MultisigSafeUpdateWithoutOwnersInput>, MultisigSafeUncheckedUpdateWithoutOwnersInput>
  }

  export type MultisigApprovalCreateNestedManyWithoutTxInput = {
    create?: XOR<MultisigApprovalCreateWithoutTxInput, MultisigApprovalUncheckedCreateWithoutTxInput> | MultisigApprovalCreateWithoutTxInput[] | MultisigApprovalUncheckedCreateWithoutTxInput[]
    connectOrCreate?: MultisigApprovalCreateOrConnectWithoutTxInput | MultisigApprovalCreateOrConnectWithoutTxInput[]
    createMany?: MultisigApprovalCreateManyTxInputEnvelope
    connect?: MultisigApprovalWhereUniqueInput | MultisigApprovalWhereUniqueInput[]
  }

  export type MultisigSafeCreateNestedOneWithoutTxsInput = {
    create?: XOR<MultisigSafeCreateWithoutTxsInput, MultisigSafeUncheckedCreateWithoutTxsInput>
    connectOrCreate?: MultisigSafeCreateOrConnectWithoutTxsInput
    connect?: MultisigSafeWhereUniqueInput
  }

  export type MultisigApprovalUncheckedCreateNestedManyWithoutTxInput = {
    create?: XOR<MultisigApprovalCreateWithoutTxInput, MultisigApprovalUncheckedCreateWithoutTxInput> | MultisigApprovalCreateWithoutTxInput[] | MultisigApprovalUncheckedCreateWithoutTxInput[]
    connectOrCreate?: MultisigApprovalCreateOrConnectWithoutTxInput | MultisigApprovalCreateOrConnectWithoutTxInput[]
    createMany?: MultisigApprovalCreateManyTxInputEnvelope
    connect?: MultisigApprovalWhereUniqueInput | MultisigApprovalWhereUniqueInput[]
  }

  export type EnumMultisigTxStatusFieldUpdateOperationsInput = {
    set?: $Enums.MultisigTxStatus
  }

  export type MultisigApprovalUpdateManyWithoutTxNestedInput = {
    create?: XOR<MultisigApprovalCreateWithoutTxInput, MultisigApprovalUncheckedCreateWithoutTxInput> | MultisigApprovalCreateWithoutTxInput[] | MultisigApprovalUncheckedCreateWithoutTxInput[]
    connectOrCreate?: MultisigApprovalCreateOrConnectWithoutTxInput | MultisigApprovalCreateOrConnectWithoutTxInput[]
    upsert?: MultisigApprovalUpsertWithWhereUniqueWithoutTxInput | MultisigApprovalUpsertWithWhereUniqueWithoutTxInput[]
    createMany?: MultisigApprovalCreateManyTxInputEnvelope
    set?: MultisigApprovalWhereUniqueInput | MultisigApprovalWhereUniqueInput[]
    disconnect?: MultisigApprovalWhereUniqueInput | MultisigApprovalWhereUniqueInput[]
    delete?: MultisigApprovalWhereUniqueInput | MultisigApprovalWhereUniqueInput[]
    connect?: MultisigApprovalWhereUniqueInput | MultisigApprovalWhereUniqueInput[]
    update?: MultisigApprovalUpdateWithWhereUniqueWithoutTxInput | MultisigApprovalUpdateWithWhereUniqueWithoutTxInput[]
    updateMany?: MultisigApprovalUpdateManyWithWhereWithoutTxInput | MultisigApprovalUpdateManyWithWhereWithoutTxInput[]
    deleteMany?: MultisigApprovalScalarWhereInput | MultisigApprovalScalarWhereInput[]
  }

  export type MultisigSafeUpdateOneRequiredWithoutTxsNestedInput = {
    create?: XOR<MultisigSafeCreateWithoutTxsInput, MultisigSafeUncheckedCreateWithoutTxsInput>
    connectOrCreate?: MultisigSafeCreateOrConnectWithoutTxsInput
    upsert?: MultisigSafeUpsertWithoutTxsInput
    connect?: MultisigSafeWhereUniqueInput
    update?: XOR<XOR<MultisigSafeUpdateToOneWithWhereWithoutTxsInput, MultisigSafeUpdateWithoutTxsInput>, MultisigSafeUncheckedUpdateWithoutTxsInput>
  }

  export type MultisigApprovalUncheckedUpdateManyWithoutTxNestedInput = {
    create?: XOR<MultisigApprovalCreateWithoutTxInput, MultisigApprovalUncheckedCreateWithoutTxInput> | MultisigApprovalCreateWithoutTxInput[] | MultisigApprovalUncheckedCreateWithoutTxInput[]
    connectOrCreate?: MultisigApprovalCreateOrConnectWithoutTxInput | MultisigApprovalCreateOrConnectWithoutTxInput[]
    upsert?: MultisigApprovalUpsertWithWhereUniqueWithoutTxInput | MultisigApprovalUpsertWithWhereUniqueWithoutTxInput[]
    createMany?: MultisigApprovalCreateManyTxInputEnvelope
    set?: MultisigApprovalWhereUniqueInput | MultisigApprovalWhereUniqueInput[]
    disconnect?: MultisigApprovalWhereUniqueInput | MultisigApprovalWhereUniqueInput[]
    delete?: MultisigApprovalWhereUniqueInput | MultisigApprovalWhereUniqueInput[]
    connect?: MultisigApprovalWhereUniqueInput | MultisigApprovalWhereUniqueInput[]
    update?: MultisigApprovalUpdateWithWhereUniqueWithoutTxInput | MultisigApprovalUpdateWithWhereUniqueWithoutTxInput[]
    updateMany?: MultisigApprovalUpdateManyWithWhereWithoutTxInput | MultisigApprovalUpdateManyWithWhereWithoutTxInput[]
    deleteMany?: MultisigApprovalScalarWhereInput | MultisigApprovalScalarWhereInput[]
  }

  export type MultisigTxCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<MultisigTxCreateWithoutApprovalsInput, MultisigTxUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: MultisigTxCreateOrConnectWithoutApprovalsInput
    connect?: MultisigTxWhereUniqueInput
  }

  export type MultisigTxUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<MultisigTxCreateWithoutApprovalsInput, MultisigTxUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: MultisigTxCreateOrConnectWithoutApprovalsInput
    upsert?: MultisigTxUpsertWithoutApprovalsInput
    connect?: MultisigTxWhereUniqueInput
    update?: XOR<XOR<MultisigTxUpdateToOneWithWhereWithoutApprovalsInput, MultisigTxUpdateWithoutApprovalsInput>, MultisigTxUncheckedUpdateWithoutApprovalsInput>
  }

  export type EnumPendingChainActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.PendingChainActionType
  }

  export type EnumPendingStatusFieldUpdateOperationsInput = {
    set?: $Enums.PendingStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGatewayPrefFilter<$PrismaModel = never> = {
    equals?: $Enums.GatewayPref | EnumGatewayPrefFieldRefInput<$PrismaModel>
    in?: $Enums.GatewayPref[] | ListEnumGatewayPrefFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatewayPref[] | ListEnumGatewayPrefFieldRefInput<$PrismaModel>
    not?: NestedEnumGatewayPrefFilter<$PrismaModel> | $Enums.GatewayPref
  }

  export type NestedEnumIndexStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IndexStatus | EnumIndexStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IndexStatus[] | ListEnumIndexStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndexStatus[] | ListEnumIndexStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIndexStatusFilter<$PrismaModel> | $Enums.IndexStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGatewayPrefWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GatewayPref | EnumGatewayPrefFieldRefInput<$PrismaModel>
    in?: $Enums.GatewayPref[] | ListEnumGatewayPrefFieldRefInput<$PrismaModel>
    notIn?: $Enums.GatewayPref[] | ListEnumGatewayPrefFieldRefInput<$PrismaModel>
    not?: NestedEnumGatewayPrefWithAggregatesFilter<$PrismaModel> | $Enums.GatewayPref
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGatewayPrefFilter<$PrismaModel>
    _max?: NestedEnumGatewayPrefFilter<$PrismaModel>
  }

  export type NestedEnumIndexStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IndexStatus | EnumIndexStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IndexStatus[] | ListEnumIndexStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndexStatus[] | ListEnumIndexStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIndexStatusWithAggregatesFilter<$PrismaModel> | $Enums.IndexStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIndexStatusFilter<$PrismaModel>
    _max?: NestedEnumIndexStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumNftStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NftStatus | EnumNftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NftStatus[] | ListEnumNftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NftStatus[] | ListEnumNftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNftStatusFilter<$PrismaModel> | $Enums.NftStatus
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumNftStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NftStatus | EnumNftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NftStatus[] | ListEnumNftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NftStatus[] | ListEnumNftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNftStatusWithAggregatesFilter<$PrismaModel> | $Enums.NftStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNftStatusFilter<$PrismaModel>
    _max?: NestedEnumNftStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusFilter<$PrismaModel> | $Enums.ListingStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingStatusFilter<$PrismaModel>
    _max?: NestedEnumListingStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAuctionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AuctionStatus | EnumAuctionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuctionStatusFilter<$PrismaModel> | $Enums.AuctionStatus
  }

  export type NestedEnumAuctionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuctionStatus | EnumAuctionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuctionStatus[] | ListEnumAuctionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAuctionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AuctionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuctionStatusFilter<$PrismaModel>
    _max?: NestedEnumAuctionStatusFilter<$PrismaModel>
  }

  export type NestedEnumContractTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeFilter<$PrismaModel> | $Enums.ContractType
  }

  export type NestedEnumMetadataOptionFilter<$PrismaModel = never> = {
    equals?: $Enums.MetadataOption | EnumMetadataOptionFieldRefInput<$PrismaModel>
    in?: $Enums.MetadataOption[] | ListEnumMetadataOptionFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetadataOption[] | ListEnumMetadataOptionFieldRefInput<$PrismaModel>
    not?: NestedEnumMetadataOptionFilter<$PrismaModel> | $Enums.MetadataOption
  }

  export type NestedEnumContractTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContractTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContractType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContractTypeFilter<$PrismaModel>
    _max?: NestedEnumContractTypeFilter<$PrismaModel>
  }

  export type NestedEnumMetadataOptionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MetadataOption | EnumMetadataOptionFieldRefInput<$PrismaModel>
    in?: $Enums.MetadataOption[] | ListEnumMetadataOptionFieldRefInput<$PrismaModel>
    notIn?: $Enums.MetadataOption[] | ListEnumMetadataOptionFieldRefInput<$PrismaModel>
    not?: NestedEnumMetadataOptionWithAggregatesFilter<$PrismaModel> | $Enums.MetadataOption
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetadataOptionFilter<$PrismaModel>
    _max?: NestedEnumMetadataOptionFilter<$PrismaModel>
  }

  export type NestedEnumDraftStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DraftStatus | EnumDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DraftStatus[] | ListEnumDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DraftStatus[] | ListEnumDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDraftStatusFilter<$PrismaModel> | $Enums.DraftStatus
  }

  export type NestedEnumDraftStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DraftStatus | EnumDraftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DraftStatus[] | ListEnumDraftStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DraftStatus[] | ListEnumDraftStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDraftStatusWithAggregatesFilter<$PrismaModel> | $Enums.DraftStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDraftStatusFilter<$PrismaModel>
    _max?: NestedEnumDraftStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusFilter<$PrismaModel> | $Enums.SubmissionStatus
  }

  export type NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubmissionStatusFilter<$PrismaModel>
  }

  export type NestedEnumFeaturedCycleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FeaturedCycleStatus | EnumFeaturedCycleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeaturedCycleStatus[] | ListEnumFeaturedCycleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeaturedCycleStatus[] | ListEnumFeaturedCycleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeaturedCycleStatusFilter<$PrismaModel> | $Enums.FeaturedCycleStatus
  }

  export type NestedEnumFeaturedCycleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeaturedCycleStatus | EnumFeaturedCycleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FeaturedCycleStatus[] | ListEnumFeaturedCycleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeaturedCycleStatus[] | ListEnumFeaturedCycleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFeaturedCycleStatusWithAggregatesFilter<$PrismaModel> | $Enums.FeaturedCycleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeaturedCycleStatusFilter<$PrismaModel>
    _max?: NestedEnumFeaturedCycleStatusFilter<$PrismaModel>
  }

  export type NestedEnumCurrencyKindFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyKind | EnumCurrencyKindFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyKind[] | ListEnumCurrencyKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyKind[] | ListEnumCurrencyKindFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyKindFilter<$PrismaModel> | $Enums.CurrencyKind
  }

  export type NestedEnumCurrencyKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyKind | EnumCurrencyKindFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyKind[] | ListEnumCurrencyKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyKind[] | ListEnumCurrencyKindFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyKindWithAggregatesFilter<$PrismaModel> | $Enums.CurrencyKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyKindFilter<$PrismaModel>
    _max?: NestedEnumCurrencyKindFilter<$PrismaModel>
  }

  export type NestedEnumStolenStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StolenStatus | EnumStolenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StolenStatus[] | ListEnumStolenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StolenStatus[] | ListEnumStolenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStolenStatusFilter<$PrismaModel> | $Enums.StolenStatus
  }

  export type NestedEnumStolenSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.StolenSource | EnumStolenSourceFieldRefInput<$PrismaModel>
    in?: $Enums.StolenSource[] | ListEnumStolenSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.StolenSource[] | ListEnumStolenSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumStolenSourceFilter<$PrismaModel> | $Enums.StolenSource
  }

  export type NestedEnumStolenStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StolenStatus | EnumStolenStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StolenStatus[] | ListEnumStolenStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StolenStatus[] | ListEnumStolenStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStolenStatusWithAggregatesFilter<$PrismaModel> | $Enums.StolenStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStolenStatusFilter<$PrismaModel>
    _max?: NestedEnumStolenStatusFilter<$PrismaModel>
  }

  export type NestedEnumStolenSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StolenSource | EnumStolenSourceFieldRefInput<$PrismaModel>
    in?: $Enums.StolenSource[] | ListEnumStolenSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.StolenSource[] | ListEnumStolenSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumStolenSourceWithAggregatesFilter<$PrismaModel> | $Enums.StolenSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStolenSourceFilter<$PrismaModel>
    _max?: NestedEnumStolenSourceFilter<$PrismaModel>
  }

  export type NestedEnumMultisigTxStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MultisigTxStatus | EnumMultisigTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MultisigTxStatus[] | ListEnumMultisigTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MultisigTxStatus[] | ListEnumMultisigTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMultisigTxStatusFilter<$PrismaModel> | $Enums.MultisigTxStatus
  }

  export type NestedEnumMultisigTxStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MultisigTxStatus | EnumMultisigTxStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MultisigTxStatus[] | ListEnumMultisigTxStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MultisigTxStatus[] | ListEnumMultisigTxStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMultisigTxStatusWithAggregatesFilter<$PrismaModel> | $Enums.MultisigTxStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMultisigTxStatusFilter<$PrismaModel>
    _max?: NestedEnumMultisigTxStatusFilter<$PrismaModel>
  }

  export type NestedEnumPendingChainActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingChainActionType | EnumPendingChainActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PendingChainActionType[] | ListEnumPendingChainActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingChainActionType[] | ListEnumPendingChainActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingChainActionTypeFilter<$PrismaModel> | $Enums.PendingChainActionType
  }

  export type NestedEnumPendingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingStatus | EnumPendingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingStatusFilter<$PrismaModel> | $Enums.PendingStatus
  }

  export type NestedEnumPendingChainActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingChainActionType | EnumPendingChainActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PendingChainActionType[] | ListEnumPendingChainActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingChainActionType[] | ListEnumPendingChainActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingChainActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.PendingChainActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPendingChainActionTypeFilter<$PrismaModel>
    _max?: NestedEnumPendingChainActionTypeFilter<$PrismaModel>
  }

  export type NestedEnumPendingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingStatus | EnumPendingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingStatusWithAggregatesFilter<$PrismaModel> | $Enums.PendingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPendingStatusFilter<$PrismaModel>
    _max?: NestedEnumPendingStatusFilter<$PrismaModel>
  }

  export type CollectionCreateWithoutCreatorInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutCollectionInput
    deployment?: DeployedContractCreateNestedOneWithoutCollectionInput
    featuredBidEntries?: FeaturedBidCreateNestedManyWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleCreateNestedManyWithoutWinnerCollectionInput
    nfts?: NFTCreateNestedManyWithoutCollectionInput
    presale?: PresaleCreateNestedOneWithoutCollectionInput
    publicSale?: PublicSaleCreateNestedOneWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutCollectionInput
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutCollectionInput
    featuredBidEntries?: FeaturedBidUncheckedCreateNestedManyWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleUncheckedCreateNestedManyWithoutWinnerCollectionInput
    nfts?: NFTUncheckedCreateNestedManyWithoutCollectionInput
    presale?: PresaleUncheckedCreateNestedOneWithoutCollectionInput
    publicSale?: PublicSaleUncheckedCreateNestedOneWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutCreatorInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutCreatorInput, CollectionUncheckedCreateWithoutCreatorInput>
  }

  export type CollectionCreateManyCreatorInputEnvelope = {
    data: CollectionCreateManyCreatorInput | CollectionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CollectionSubmissionCreateWithoutSubmittedByInput = {
    id?: string
    contract: string
    ownerAddress?: string | null
    name?: string | null
    symbol?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    baseUri?: string | null
    supply?: number | null
    description?: string | null
    website?: string | null
    x?: string | null
    instagram?: string | null
    telegram?: string | null
    feeTxHash?: string | null
    feePaidWei?: Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: Date | string | null
    ownershipVerified?: boolean
    status?: $Enums.SubmissionStatus
    statusReason?: string | null
    reviewedByUserId?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionSubmissionUncheckedCreateWithoutSubmittedByInput = {
    id?: string
    contract: string
    ownerAddress?: string | null
    name?: string | null
    symbol?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    baseUri?: string | null
    supply?: number | null
    description?: string | null
    website?: string | null
    x?: string | null
    instagram?: string | null
    telegram?: string | null
    feeTxHash?: string | null
    feePaidWei?: Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: Date | string | null
    ownershipVerified?: boolean
    status?: $Enums.SubmissionStatus
    statusReason?: string | null
    reviewedByUserId?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionSubmissionCreateOrConnectWithoutSubmittedByInput = {
    where: CollectionSubmissionWhereUniqueInput
    create: XOR<CollectionSubmissionCreateWithoutSubmittedByInput, CollectionSubmissionUncheckedCreateWithoutSubmittedByInput>
  }

  export type CollectionSubmissionCreateManySubmittedByInputEnvelope = {
    data: CollectionSubmissionCreateManySubmittedByInput | CollectionSubmissionCreateManySubmittedByInput[]
    skipDuplicates?: boolean
  }

  export type FeaturedBidCreateWithoutBidderInput = {
    id?: string
    bidderAddress: string
    totalBidWei: Decimal | DecimalJsLike | number | string
    txCount?: number
    lastTxHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collection: CollectionCreateNestedOneWithoutFeaturedBidEntriesInput
    cycle: FeaturedCycleCreateNestedOneWithoutBidsInput
    winnerOf?: FeaturedCycleCreateNestedOneWithoutWinnerBidInput
  }

  export type FeaturedBidUncheckedCreateWithoutBidderInput = {
    id?: string
    cycleId: string
    bidderAddress: string
    collectionContract: string
    totalBidWei: Decimal | DecimalJsLike | number | string
    txCount?: number
    lastTxHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    winnerOf?: FeaturedCycleUncheckedCreateNestedOneWithoutWinnerBidInput
  }

  export type FeaturedBidCreateOrConnectWithoutBidderInput = {
    where: FeaturedBidWhereUniqueInput
    create: XOR<FeaturedBidCreateWithoutBidderInput, FeaturedBidUncheckedCreateWithoutBidderInput>
  }

  export type FeaturedBidCreateManyBidderInputEnvelope = {
    data: FeaturedBidCreateManyBidderInput | FeaturedBidCreateManyBidderInput[]
    skipDuplicates?: boolean
  }

  export type HolderRewardMultiCreateWithoutUserInput = {
    id?: string
    walletAddress: string
    lastAccPerToken?: Decimal | DecimalJsLike | number | string
    claimedAmount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    currency: CurrencyCreateNestedOneWithoutHolderRewardsInput
  }

  export type HolderRewardMultiUncheckedCreateWithoutUserInput = {
    id?: string
    walletAddress: string
    currencyId: string
    lastAccPerToken?: Decimal | DecimalJsLike | number | string
    claimedAmount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type HolderRewardMultiCreateOrConnectWithoutUserInput = {
    where: HolderRewardMultiWhereUniqueInput
    create: XOR<HolderRewardMultiCreateWithoutUserInput, HolderRewardMultiUncheckedCreateWithoutUserInput>
  }

  export type HolderRewardMultiCreateManyUserInputEnvelope = {
    data: HolderRewardMultiCreateManyUserInput | HolderRewardMultiCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NFTCreateWithoutOwnerInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionCreateNestedManyWithoutNftInput
    listingEntries?: MarketplaceListingCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleCreateNestedManyWithoutNftInput
    collection?: CollectionCreateNestedOneWithoutNftsInput
    single1155?: Single1155CreateNestedOneWithoutNftsInput
    single721?: Single721CreateNestedOneWithoutNftsInput
    activities?: NFTActivityCreateNestedManyWithoutNftInput
  }

  export type NFTUncheckedCreateWithoutOwnerInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    collectionId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedCreateNestedManyWithoutNftInput
    listingEntries?: MarketplaceListingUncheckedCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutNftInput
    activities?: NFTActivityUncheckedCreateNestedManyWithoutNftInput
  }

  export type NFTCreateOrConnectWithoutOwnerInput = {
    where: NFTWhereUniqueInput
    create: XOR<NFTCreateWithoutOwnerInput, NFTUncheckedCreateWithoutOwnerInput>
  }

  export type NFTCreateManyOwnerInputEnvelope = {
    data: NFTCreateManyOwnerInput | NFTCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type RewardClaimLogCreateWithoutUserInput = {
    id?: string
    walletAddress: string
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    timestamp?: Date | string
    currency: CurrencyCreateNestedOneWithoutClaimLogsInput
  }

  export type RewardClaimLogUncheckedCreateWithoutUserInput = {
    id?: string
    walletAddress: string
    currencyId: string
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    timestamp?: Date | string
  }

  export type RewardClaimLogCreateOrConnectWithoutUserInput = {
    where: RewardClaimLogWhereUniqueInput
    create: XOR<RewardClaimLogCreateWithoutUserInput, RewardClaimLogUncheckedCreateWithoutUserInput>
  }

  export type RewardClaimLogCreateManyUserInputEnvelope = {
    data: RewardClaimLogCreateManyUserInput | RewardClaimLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StolenItemCreateWithoutReporterInput = {
    id?: string
    contract: string
    tokenId: string
    status?: $Enums.StolenStatus
    source?: $Enums.StolenSource
    reporterAddress?: string | null
    evidenceUrl?: string | null
    notes?: string | null
    disputed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StolenItemUncheckedCreateWithoutReporterInput = {
    id?: string
    contract: string
    tokenId: string
    status?: $Enums.StolenStatus
    source?: $Enums.StolenSource
    reporterAddress?: string | null
    evidenceUrl?: string | null
    notes?: string | null
    disputed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StolenItemCreateOrConnectWithoutReporterInput = {
    where: StolenItemWhereUniqueInput
    create: XOR<StolenItemCreateWithoutReporterInput, StolenItemUncheckedCreateWithoutReporterInput>
  }

  export type StolenItemCreateManyReporterInputEnvelope = {
    data: StolenItemCreateManyReporterInput | StolenItemCreateManyReporterInput[]
    skipDuplicates?: boolean
  }

  export type CollectionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CollectionWhereUniqueInput
    update: XOR<CollectionUpdateWithoutCreatorInput, CollectionUncheckedUpdateWithoutCreatorInput>
    create: XOR<CollectionCreateWithoutCreatorInput, CollectionUncheckedCreateWithoutCreatorInput>
  }

  export type CollectionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CollectionWhereUniqueInput
    data: XOR<CollectionUpdateWithoutCreatorInput, CollectionUncheckedUpdateWithoutCreatorInput>
  }

  export type CollectionUpdateManyWithWhereWithoutCreatorInput = {
    where: CollectionScalarWhereInput
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CollectionScalarWhereInput = {
    AND?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
    OR?: CollectionScalarWhereInput[]
    NOT?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
    id?: StringFilter<"Collection"> | string
    name?: StringFilter<"Collection"> | string
    symbol?: StringFilter<"Collection"> | string
    contract?: StringFilter<"Collection"> | string
    description?: StringNullableFilter<"Collection"> | string | null
    logoUrl?: StringNullableFilter<"Collection"> | string | null
    coverUrl?: StringNullableFilter<"Collection"> | string | null
    standard?: StringFilter<"Collection"> | string
    supply?: IntNullableFilter<"Collection"> | number | null
    baseUri?: StringNullableFilter<"Collection"> | string | null
    gatewayPref?: EnumGatewayPrefFilter<"Collection"> | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFilter<"Collection"> | $Enums.IndexStatus
    x?: StringNullableFilter<"Collection"> | string | null
    instagram?: StringNullableFilter<"Collection"> | string | null
    website?: StringNullableFilter<"Collection"> | string | null
    discord?: StringNullableFilter<"Collection"> | string | null
    telegram?: StringNullableFilter<"Collection"> | string | null
    floorPrice?: FloatFilter<"Collection"> | number
    volume?: FloatFilter<"Collection"> | number
    itemsCount?: IntFilter<"Collection"> | number
    ownersCount?: IntFilter<"Collection"> | number
    change24h?: FloatFilter<"Collection"> | number
    creatorId?: StringFilter<"Collection"> | string
    ownerAddress?: StringFilter<"Collection"> | string
    isOrphan?: BoolFilter<"Collection"> | boolean
    createdAt?: DateTimeFilter<"Collection"> | Date | string
    updatedAt?: DateTimeFilter<"Collection"> | Date | string
  }

  export type CollectionSubmissionUpsertWithWhereUniqueWithoutSubmittedByInput = {
    where: CollectionSubmissionWhereUniqueInput
    update: XOR<CollectionSubmissionUpdateWithoutSubmittedByInput, CollectionSubmissionUncheckedUpdateWithoutSubmittedByInput>
    create: XOR<CollectionSubmissionCreateWithoutSubmittedByInput, CollectionSubmissionUncheckedCreateWithoutSubmittedByInput>
  }

  export type CollectionSubmissionUpdateWithWhereUniqueWithoutSubmittedByInput = {
    where: CollectionSubmissionWhereUniqueInput
    data: XOR<CollectionSubmissionUpdateWithoutSubmittedByInput, CollectionSubmissionUncheckedUpdateWithoutSubmittedByInput>
  }

  export type CollectionSubmissionUpdateManyWithWhereWithoutSubmittedByInput = {
    where: CollectionSubmissionScalarWhereInput
    data: XOR<CollectionSubmissionUpdateManyMutationInput, CollectionSubmissionUncheckedUpdateManyWithoutSubmittedByInput>
  }

  export type CollectionSubmissionScalarWhereInput = {
    AND?: CollectionSubmissionScalarWhereInput | CollectionSubmissionScalarWhereInput[]
    OR?: CollectionSubmissionScalarWhereInput[]
    NOT?: CollectionSubmissionScalarWhereInput | CollectionSubmissionScalarWhereInput[]
    id?: StringFilter<"CollectionSubmission"> | string
    submittedByUserId?: StringFilter<"CollectionSubmission"> | string
    contract?: StringFilter<"CollectionSubmission"> | string
    ownerAddress?: StringNullableFilter<"CollectionSubmission"> | string | null
    name?: StringNullableFilter<"CollectionSubmission"> | string | null
    symbol?: StringNullableFilter<"CollectionSubmission"> | string | null
    logoUrl?: StringNullableFilter<"CollectionSubmission"> | string | null
    coverUrl?: StringNullableFilter<"CollectionSubmission"> | string | null
    baseUri?: StringNullableFilter<"CollectionSubmission"> | string | null
    supply?: IntNullableFilter<"CollectionSubmission"> | number | null
    description?: StringNullableFilter<"CollectionSubmission"> | string | null
    website?: StringNullableFilter<"CollectionSubmission"> | string | null
    x?: StringNullableFilter<"CollectionSubmission"> | string | null
    instagram?: StringNullableFilter<"CollectionSubmission"> | string | null
    telegram?: StringNullableFilter<"CollectionSubmission"> | string | null
    feeTxHash?: StringNullableFilter<"CollectionSubmission"> | string | null
    feePaidWei?: DecimalNullableFilter<"CollectionSubmission"> | Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: DateTimeNullableFilter<"CollectionSubmission"> | Date | string | null
    ownershipVerified?: BoolFilter<"CollectionSubmission"> | boolean
    status?: EnumSubmissionStatusFilter<"CollectionSubmission"> | $Enums.SubmissionStatus
    statusReason?: StringNullableFilter<"CollectionSubmission"> | string | null
    reviewedByUserId?: StringNullableFilter<"CollectionSubmission"> | string | null
    reviewedAt?: DateTimeNullableFilter<"CollectionSubmission"> | Date | string | null
    createdAt?: DateTimeFilter<"CollectionSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"CollectionSubmission"> | Date | string
  }

  export type FeaturedBidUpsertWithWhereUniqueWithoutBidderInput = {
    where: FeaturedBidWhereUniqueInput
    update: XOR<FeaturedBidUpdateWithoutBidderInput, FeaturedBidUncheckedUpdateWithoutBidderInput>
    create: XOR<FeaturedBidCreateWithoutBidderInput, FeaturedBidUncheckedCreateWithoutBidderInput>
  }

  export type FeaturedBidUpdateWithWhereUniqueWithoutBidderInput = {
    where: FeaturedBidWhereUniqueInput
    data: XOR<FeaturedBidUpdateWithoutBidderInput, FeaturedBidUncheckedUpdateWithoutBidderInput>
  }

  export type FeaturedBidUpdateManyWithWhereWithoutBidderInput = {
    where: FeaturedBidScalarWhereInput
    data: XOR<FeaturedBidUpdateManyMutationInput, FeaturedBidUncheckedUpdateManyWithoutBidderInput>
  }

  export type FeaturedBidScalarWhereInput = {
    AND?: FeaturedBidScalarWhereInput | FeaturedBidScalarWhereInput[]
    OR?: FeaturedBidScalarWhereInput[]
    NOT?: FeaturedBidScalarWhereInput | FeaturedBidScalarWhereInput[]
    id?: StringFilter<"FeaturedBid"> | string
    cycleId?: StringFilter<"FeaturedBid"> | string
    bidderAddress?: StringFilter<"FeaturedBid"> | string
    bidderUserId?: StringNullableFilter<"FeaturedBid"> | string | null
    collectionContract?: StringFilter<"FeaturedBid"> | string
    totalBidWei?: DecimalFilter<"FeaturedBid"> | Decimal | DecimalJsLike | number | string
    txCount?: IntFilter<"FeaturedBid"> | number
    lastTxHash?: StringNullableFilter<"FeaturedBid"> | string | null
    createdAt?: DateTimeFilter<"FeaturedBid"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedBid"> | Date | string
  }

  export type HolderRewardMultiUpsertWithWhereUniqueWithoutUserInput = {
    where: HolderRewardMultiWhereUniqueInput
    update: XOR<HolderRewardMultiUpdateWithoutUserInput, HolderRewardMultiUncheckedUpdateWithoutUserInput>
    create: XOR<HolderRewardMultiCreateWithoutUserInput, HolderRewardMultiUncheckedCreateWithoutUserInput>
  }

  export type HolderRewardMultiUpdateWithWhereUniqueWithoutUserInput = {
    where: HolderRewardMultiWhereUniqueInput
    data: XOR<HolderRewardMultiUpdateWithoutUserInput, HolderRewardMultiUncheckedUpdateWithoutUserInput>
  }

  export type HolderRewardMultiUpdateManyWithWhereWithoutUserInput = {
    where: HolderRewardMultiScalarWhereInput
    data: XOR<HolderRewardMultiUpdateManyMutationInput, HolderRewardMultiUncheckedUpdateManyWithoutUserInput>
  }

  export type HolderRewardMultiScalarWhereInput = {
    AND?: HolderRewardMultiScalarWhereInput | HolderRewardMultiScalarWhereInput[]
    OR?: HolderRewardMultiScalarWhereInput[]
    NOT?: HolderRewardMultiScalarWhereInput | HolderRewardMultiScalarWhereInput[]
    id?: StringFilter<"HolderRewardMulti"> | string
    userId?: StringNullableFilter<"HolderRewardMulti"> | string | null
    walletAddress?: StringFilter<"HolderRewardMulti"> | string
    currencyId?: StringFilter<"HolderRewardMulti"> | string
    lastAccPerToken?: DecimalFilter<"HolderRewardMulti"> | Decimal | DecimalJsLike | number | string
    claimedAmount?: DecimalFilter<"HolderRewardMulti"> | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFilter<"HolderRewardMulti"> | Date | string
  }

  export type NFTUpsertWithWhereUniqueWithoutOwnerInput = {
    where: NFTWhereUniqueInput
    update: XOR<NFTUpdateWithoutOwnerInput, NFTUncheckedUpdateWithoutOwnerInput>
    create: XOR<NFTCreateWithoutOwnerInput, NFTUncheckedCreateWithoutOwnerInput>
  }

  export type NFTUpdateWithWhereUniqueWithoutOwnerInput = {
    where: NFTWhereUniqueInput
    data: XOR<NFTUpdateWithoutOwnerInput, NFTUncheckedUpdateWithoutOwnerInput>
  }

  export type NFTUpdateManyWithWhereWithoutOwnerInput = {
    where: NFTScalarWhereInput
    data: XOR<NFTUpdateManyMutationInput, NFTUncheckedUpdateManyWithoutOwnerInput>
  }

  export type NFTScalarWhereInput = {
    AND?: NFTScalarWhereInput | NFTScalarWhereInput[]
    OR?: NFTScalarWhereInput[]
    NOT?: NFTScalarWhereInput | NFTScalarWhereInput[]
    id?: StringFilter<"NFT"> | string
    tokenId?: StringFilter<"NFT"> | string
    name?: StringNullableFilter<"NFT"> | string | null
    imageUrl?: StringNullableFilter<"NFT"> | string | null
    description?: StringNullableFilter<"NFT"> | string | null
    traits?: JsonNullableFilter<"NFT">
    attributes?: JsonNullableFilter<"NFT">
    tokenUri?: StringNullableFilter<"NFT"> | string | null
    contract?: StringFilter<"NFT"> | string
    standard?: StringNullableFilter<"NFT"> | string | null
    rawMetadata?: JsonNullableFilter<"NFT">
    royaltyBps?: IntNullableFilter<"NFT"> | number | null
    royaltyRecipient?: StringNullableFilter<"NFT"> | string | null
    ownerId?: StringNullableFilter<"NFT"> | string | null
    collectionId?: StringNullableFilter<"NFT"> | string | null
    single721Id?: StringNullableFilter<"NFT"> | string | null
    single1155Id?: StringNullableFilter<"NFT"> | string | null
    status?: EnumNftStatusFilter<"NFT"> | $Enums.NftStatus
    retryCount?: IntFilter<"NFT"> | number
    createdAt?: DateTimeFilter<"NFT"> | Date | string
    updatedAt?: DateTimeFilter<"NFT"> | Date | string
    rarityScore?: DecimalNullableFilter<"NFT"> | Decimal | DecimalJsLike | number | string | null
  }

  export type RewardClaimLogUpsertWithWhereUniqueWithoutUserInput = {
    where: RewardClaimLogWhereUniqueInput
    update: XOR<RewardClaimLogUpdateWithoutUserInput, RewardClaimLogUncheckedUpdateWithoutUserInput>
    create: XOR<RewardClaimLogCreateWithoutUserInput, RewardClaimLogUncheckedCreateWithoutUserInput>
  }

  export type RewardClaimLogUpdateWithWhereUniqueWithoutUserInput = {
    where: RewardClaimLogWhereUniqueInput
    data: XOR<RewardClaimLogUpdateWithoutUserInput, RewardClaimLogUncheckedUpdateWithoutUserInput>
  }

  export type RewardClaimLogUpdateManyWithWhereWithoutUserInput = {
    where: RewardClaimLogScalarWhereInput
    data: XOR<RewardClaimLogUpdateManyMutationInput, RewardClaimLogUncheckedUpdateManyWithoutUserInput>
  }

  export type RewardClaimLogScalarWhereInput = {
    AND?: RewardClaimLogScalarWhereInput | RewardClaimLogScalarWhereInput[]
    OR?: RewardClaimLogScalarWhereInput[]
    NOT?: RewardClaimLogScalarWhereInput | RewardClaimLogScalarWhereInput[]
    id?: StringFilter<"RewardClaimLog"> | string
    walletAddress?: StringFilter<"RewardClaimLog"> | string
    userId?: StringNullableFilter<"RewardClaimLog"> | string | null
    currencyId?: StringFilter<"RewardClaimLog"> | string
    amount?: DecimalFilter<"RewardClaimLog"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableFilter<"RewardClaimLog"> | string | null
    timestamp?: DateTimeFilter<"RewardClaimLog"> | Date | string
  }

  export type StolenItemUpsertWithWhereUniqueWithoutReporterInput = {
    where: StolenItemWhereUniqueInput
    update: XOR<StolenItemUpdateWithoutReporterInput, StolenItemUncheckedUpdateWithoutReporterInput>
    create: XOR<StolenItemCreateWithoutReporterInput, StolenItemUncheckedCreateWithoutReporterInput>
  }

  export type StolenItemUpdateWithWhereUniqueWithoutReporterInput = {
    where: StolenItemWhereUniqueInput
    data: XOR<StolenItemUpdateWithoutReporterInput, StolenItemUncheckedUpdateWithoutReporterInput>
  }

  export type StolenItemUpdateManyWithWhereWithoutReporterInput = {
    where: StolenItemScalarWhereInput
    data: XOR<StolenItemUpdateManyMutationInput, StolenItemUncheckedUpdateManyWithoutReporterInput>
  }

  export type StolenItemScalarWhereInput = {
    AND?: StolenItemScalarWhereInput | StolenItemScalarWhereInput[]
    OR?: StolenItemScalarWhereInput[]
    NOT?: StolenItemScalarWhereInput | StolenItemScalarWhereInput[]
    id?: StringFilter<"StolenItem"> | string
    contract?: StringFilter<"StolenItem"> | string
    tokenId?: StringFilter<"StolenItem"> | string
    status?: EnumStolenStatusFilter<"StolenItem"> | $Enums.StolenStatus
    source?: EnumStolenSourceFilter<"StolenItem"> | $Enums.StolenSource
    reporterAddress?: StringNullableFilter<"StolenItem"> | string | null
    reporterUserId?: StringNullableFilter<"StolenItem"> | string | null
    evidenceUrl?: StringNullableFilter<"StolenItem"> | string | null
    notes?: StringNullableFilter<"StolenItem"> | string | null
    disputed?: BoolFilter<"StolenItem"> | boolean
    createdAt?: DateTimeFilter<"StolenItem"> | Date | string
    updatedAt?: DateTimeFilter<"StolenItem"> | Date | string
  }

  export type AssetUploadCreateWithoutCollectionInput = {
    id?: string
    uploaderUserId?: string | null
    provider?: string
    cid: string
    url?: string | null
    bytes?: number | null
    sha256?: string | null
    contentType?: string | null
    originalName?: string | null
    createdAt?: Date | string
    single1155?: Single1155CreateNestedOneWithoutAssetUploadsInput
    single721?: Single721CreateNestedOneWithoutAssetUploadsInput
  }

  export type AssetUploadUncheckedCreateWithoutCollectionInput = {
    id?: string
    uploaderUserId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
    provider?: string
    cid: string
    url?: string | null
    bytes?: number | null
    sha256?: string | null
    contentType?: string | null
    originalName?: string | null
    createdAt?: Date | string
  }

  export type AssetUploadCreateOrConnectWithoutCollectionInput = {
    where: AssetUploadWhereUniqueInput
    create: XOR<AssetUploadCreateWithoutCollectionInput, AssetUploadUncheckedCreateWithoutCollectionInput>
  }

  export type AssetUploadCreateManyCollectionInputEnvelope = {
    data: AssetUploadCreateManyCollectionInput | AssetUploadCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCollectionsInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: CollectionSubmissionCreateNestedManyWithoutSubmittedByInput
    featuredBids?: FeaturedBidCreateNestedManyWithoutBidderInput
    holderRewardsMulti?: HolderRewardMultiCreateNestedManyWithoutUserInput
    ownedNFTs?: NFTCreateNestedManyWithoutOwnerInput
    rewardClaimLogs?: RewardClaimLogCreateNestedManyWithoutUserInput
    stolenReports?: StolenItemCreateNestedManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutCollectionsInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: CollectionSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    featuredBids?: FeaturedBidUncheckedCreateNestedManyWithoutBidderInput
    holderRewardsMulti?: HolderRewardMultiUncheckedCreateNestedManyWithoutUserInput
    ownedNFTs?: NFTUncheckedCreateNestedManyWithoutOwnerInput
    rewardClaimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutUserInput
    stolenReports?: StolenItemUncheckedCreateNestedManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutCollectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCollectionsInput, UserUncheckedCreateWithoutCollectionsInput>
  }

  export type DeployedContractCreateWithoutCollectionInput = {
    id?: string
    contractType: $Enums.ContractType
    cloneAddress: string
    implementationAddr: string
    factoryAddress: string
    deployerAddress: string
    txHash: string
    blockNumber: number
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal | DecimalJsLike | number | string
    royaltyRecipient: string
    royaltyBps: number
    baseURI?: string | null
    maxSupply?: number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    single1155?: Single1155CreateNestedOneWithoutDeploymentInput
    single721?: Single721CreateNestedOneWithoutDeploymentInput
  }

  export type DeployedContractUncheckedCreateWithoutCollectionInput = {
    id?: string
    contractType: $Enums.ContractType
    cloneAddress: string
    implementationAddr: string
    factoryAddress: string
    deployerAddress: string
    txHash: string
    blockNumber: number
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal | DecimalJsLike | number | string
    royaltyRecipient: string
    royaltyBps: number
    baseURI?: string | null
    maxSupply?: number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    single721Id?: string | null
    single1155Id?: string | null
  }

  export type DeployedContractCreateOrConnectWithoutCollectionInput = {
    where: DeployedContractWhereUniqueInput
    create: XOR<DeployedContractCreateWithoutCollectionInput, DeployedContractUncheckedCreateWithoutCollectionInput>
  }

  export type FeaturedBidCreateWithoutCollectionInput = {
    id?: string
    bidderAddress: string
    totalBidWei: Decimal | DecimalJsLike | number | string
    txCount?: number
    lastTxHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidder?: UserCreateNestedOneWithoutFeaturedBidsInput
    cycle: FeaturedCycleCreateNestedOneWithoutBidsInput
    winnerOf?: FeaturedCycleCreateNestedOneWithoutWinnerBidInput
  }

  export type FeaturedBidUncheckedCreateWithoutCollectionInput = {
    id?: string
    cycleId: string
    bidderAddress: string
    bidderUserId?: string | null
    totalBidWei: Decimal | DecimalJsLike | number | string
    txCount?: number
    lastTxHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    winnerOf?: FeaturedCycleUncheckedCreateNestedOneWithoutWinnerBidInput
  }

  export type FeaturedBidCreateOrConnectWithoutCollectionInput = {
    where: FeaturedBidWhereUniqueInput
    create: XOR<FeaturedBidCreateWithoutCollectionInput, FeaturedBidUncheckedCreateWithoutCollectionInput>
  }

  export type FeaturedBidCreateManyCollectionInputEnvelope = {
    data: FeaturedBidCreateManyCollectionInput | FeaturedBidCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type FeaturedCycleCreateWithoutWinnerCollectionInput = {
    id?: string
    cycleId: string
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.FeaturedCycleStatus
    minBidWei: Decimal | DecimalJsLike | number | string
    winnerAmountWei?: Decimal | DecimalJsLike | number | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: FeaturedBidCreateNestedManyWithoutCycleInput
    winnerBid?: FeaturedBidCreateNestedOneWithoutWinnerOfInput
  }

  export type FeaturedCycleUncheckedCreateWithoutWinnerCollectionInput = {
    id?: string
    cycleId: string
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.FeaturedCycleStatus
    minBidWei: Decimal | DecimalJsLike | number | string
    winnerBidId?: string | null
    winnerAmountWei?: Decimal | DecimalJsLike | number | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: FeaturedBidUncheckedCreateNestedManyWithoutCycleInput
  }

  export type FeaturedCycleCreateOrConnectWithoutWinnerCollectionInput = {
    where: FeaturedCycleWhereUniqueInput
    create: XOR<FeaturedCycleCreateWithoutWinnerCollectionInput, FeaturedCycleUncheckedCreateWithoutWinnerCollectionInput>
  }

  export type FeaturedCycleCreateManyWinnerCollectionInputEnvelope = {
    data: FeaturedCycleCreateManyWinnerCollectionInput | FeaturedCycleCreateManyWinnerCollectionInput[]
    skipDuplicates?: boolean
  }

  export type NFTCreateWithoutCollectionInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionCreateNestedManyWithoutNftInput
    listingEntries?: MarketplaceListingCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleCreateNestedManyWithoutNftInput
    owner?: UserCreateNestedOneWithoutOwnedNFTsInput
    single1155?: Single1155CreateNestedOneWithoutNftsInput
    single721?: Single721CreateNestedOneWithoutNftsInput
    activities?: NFTActivityCreateNestedManyWithoutNftInput
  }

  export type NFTUncheckedCreateWithoutCollectionInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    ownerId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedCreateNestedManyWithoutNftInput
    listingEntries?: MarketplaceListingUncheckedCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutNftInput
    activities?: NFTActivityUncheckedCreateNestedManyWithoutNftInput
  }

  export type NFTCreateOrConnectWithoutCollectionInput = {
    where: NFTWhereUniqueInput
    create: XOR<NFTCreateWithoutCollectionInput, NFTUncheckedCreateWithoutCollectionInput>
  }

  export type NFTCreateManyCollectionInputEnvelope = {
    data: NFTCreateManyCollectionInput | NFTCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type PresaleCreateWithoutCollectionInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    priceEtnWei: Decimal | DecimalJsLike | number | string
    maxSupply: number
    merkleRoot: string
    whitelistCount?: number | null
    allowlistCommit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whitelist?: PresaleWhitelistAddressCreateNestedManyWithoutPresaleInput
  }

  export type PresaleUncheckedCreateWithoutCollectionInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    priceEtnWei: Decimal | DecimalJsLike | number | string
    maxSupply: number
    merkleRoot: string
    whitelistCount?: number | null
    allowlistCommit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    whitelist?: PresaleWhitelistAddressUncheckedCreateNestedManyWithoutPresaleInput
  }

  export type PresaleCreateOrConnectWithoutCollectionInput = {
    where: PresaleWhereUniqueInput
    create: XOR<PresaleCreateWithoutCollectionInput, PresaleUncheckedCreateWithoutCollectionInput>
  }

  export type PublicSaleCreateWithoutCollectionInput = {
    id?: string
    startTime: Date | string
    priceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    maxPerTx: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicSaleUncheckedCreateWithoutCollectionInput = {
    id?: string
    startTime: Date | string
    priceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    maxPerTx: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublicSaleCreateOrConnectWithoutCollectionInput = {
    where: PublicSaleWhereUniqueInput
    create: XOR<PublicSaleCreateWithoutCollectionInput, PublicSaleUncheckedCreateWithoutCollectionInput>
  }

  export type AssetUploadUpsertWithWhereUniqueWithoutCollectionInput = {
    where: AssetUploadWhereUniqueInput
    update: XOR<AssetUploadUpdateWithoutCollectionInput, AssetUploadUncheckedUpdateWithoutCollectionInput>
    create: XOR<AssetUploadCreateWithoutCollectionInput, AssetUploadUncheckedCreateWithoutCollectionInput>
  }

  export type AssetUploadUpdateWithWhereUniqueWithoutCollectionInput = {
    where: AssetUploadWhereUniqueInput
    data: XOR<AssetUploadUpdateWithoutCollectionInput, AssetUploadUncheckedUpdateWithoutCollectionInput>
  }

  export type AssetUploadUpdateManyWithWhereWithoutCollectionInput = {
    where: AssetUploadScalarWhereInput
    data: XOR<AssetUploadUpdateManyMutationInput, AssetUploadUncheckedUpdateManyWithoutCollectionInput>
  }

  export type AssetUploadScalarWhereInput = {
    AND?: AssetUploadScalarWhereInput | AssetUploadScalarWhereInput[]
    OR?: AssetUploadScalarWhereInput[]
    NOT?: AssetUploadScalarWhereInput | AssetUploadScalarWhereInput[]
    id?: StringFilter<"AssetUpload"> | string
    uploaderUserId?: StringNullableFilter<"AssetUpload"> | string | null
    collectionId?: StringNullableFilter<"AssetUpload"> | string | null
    single721Id?: StringNullableFilter<"AssetUpload"> | string | null
    single1155Id?: StringNullableFilter<"AssetUpload"> | string | null
    provider?: StringFilter<"AssetUpload"> | string
    cid?: StringFilter<"AssetUpload"> | string
    url?: StringNullableFilter<"AssetUpload"> | string | null
    bytes?: IntNullableFilter<"AssetUpload"> | number | null
    sha256?: StringNullableFilter<"AssetUpload"> | string | null
    contentType?: StringNullableFilter<"AssetUpload"> | string | null
    originalName?: StringNullableFilter<"AssetUpload"> | string | null
    createdAt?: DateTimeFilter<"AssetUpload"> | Date | string
  }

  export type UserUpsertWithoutCollectionsInput = {
    update: XOR<UserUpdateWithoutCollectionsInput, UserUncheckedUpdateWithoutCollectionsInput>
    create: XOR<UserCreateWithoutCollectionsInput, UserUncheckedCreateWithoutCollectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCollectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCollectionsInput, UserUncheckedUpdateWithoutCollectionsInput>
  }

  export type UserUpdateWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: CollectionSubmissionUpdateManyWithoutSubmittedByNestedInput
    featuredBids?: FeaturedBidUpdateManyWithoutBidderNestedInput
    holderRewardsMulti?: HolderRewardMultiUpdateManyWithoutUserNestedInput
    ownedNFTs?: NFTUpdateManyWithoutOwnerNestedInput
    rewardClaimLogs?: RewardClaimLogUpdateManyWithoutUserNestedInput
    stolenReports?: StolenItemUpdateManyWithoutReporterNestedInput
  }

  export type UserUncheckedUpdateWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: CollectionSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    featuredBids?: FeaturedBidUncheckedUpdateManyWithoutBidderNestedInput
    holderRewardsMulti?: HolderRewardMultiUncheckedUpdateManyWithoutUserNestedInput
    ownedNFTs?: NFTUncheckedUpdateManyWithoutOwnerNestedInput
    rewardClaimLogs?: RewardClaimLogUncheckedUpdateManyWithoutUserNestedInput
    stolenReports?: StolenItemUncheckedUpdateManyWithoutReporterNestedInput
  }

  export type DeployedContractUpsertWithoutCollectionInput = {
    update: XOR<DeployedContractUpdateWithoutCollectionInput, DeployedContractUncheckedUpdateWithoutCollectionInput>
    create: XOR<DeployedContractCreateWithoutCollectionInput, DeployedContractUncheckedCreateWithoutCollectionInput>
    where?: DeployedContractWhereInput
  }

  export type DeployedContractUpdateToOneWithWhereWithoutCollectionInput = {
    where?: DeployedContractWhereInput
    data: XOR<DeployedContractUpdateWithoutCollectionInput, DeployedContractUncheckedUpdateWithoutCollectionInput>
  }

  export type DeployedContractUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    cloneAddress?: StringFieldUpdateOperationsInput | string
    implementationAddr?: StringFieldUpdateOperationsInput | string
    factoryAddress?: StringFieldUpdateOperationsInput | string
    deployerAddress?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    baseURI?: NullableStringFieldUpdateOperationsInput | string | null
    maxSupply?: NullableIntFieldUpdateOperationsInput | number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    single1155?: Single1155UpdateOneWithoutDeploymentNestedInput
    single721?: Single721UpdateOneWithoutDeploymentNestedInput
  }

  export type DeployedContractUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    cloneAddress?: StringFieldUpdateOperationsInput | string
    implementationAddr?: StringFieldUpdateOperationsInput | string
    factoryAddress?: StringFieldUpdateOperationsInput | string
    deployerAddress?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    baseURI?: NullableStringFieldUpdateOperationsInput | string | null
    maxSupply?: NullableIntFieldUpdateOperationsInput | number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FeaturedBidUpsertWithWhereUniqueWithoutCollectionInput = {
    where: FeaturedBidWhereUniqueInput
    update: XOR<FeaturedBidUpdateWithoutCollectionInput, FeaturedBidUncheckedUpdateWithoutCollectionInput>
    create: XOR<FeaturedBidCreateWithoutCollectionInput, FeaturedBidUncheckedCreateWithoutCollectionInput>
  }

  export type FeaturedBidUpdateWithWhereUniqueWithoutCollectionInput = {
    where: FeaturedBidWhereUniqueInput
    data: XOR<FeaturedBidUpdateWithoutCollectionInput, FeaturedBidUncheckedUpdateWithoutCollectionInput>
  }

  export type FeaturedBidUpdateManyWithWhereWithoutCollectionInput = {
    where: FeaturedBidScalarWhereInput
    data: XOR<FeaturedBidUpdateManyMutationInput, FeaturedBidUncheckedUpdateManyWithoutCollectionInput>
  }

  export type FeaturedCycleUpsertWithWhereUniqueWithoutWinnerCollectionInput = {
    where: FeaturedCycleWhereUniqueInput
    update: XOR<FeaturedCycleUpdateWithoutWinnerCollectionInput, FeaturedCycleUncheckedUpdateWithoutWinnerCollectionInput>
    create: XOR<FeaturedCycleCreateWithoutWinnerCollectionInput, FeaturedCycleUncheckedCreateWithoutWinnerCollectionInput>
  }

  export type FeaturedCycleUpdateWithWhereUniqueWithoutWinnerCollectionInput = {
    where: FeaturedCycleWhereUniqueInput
    data: XOR<FeaturedCycleUpdateWithoutWinnerCollectionInput, FeaturedCycleUncheckedUpdateWithoutWinnerCollectionInput>
  }

  export type FeaturedCycleUpdateManyWithWhereWithoutWinnerCollectionInput = {
    where: FeaturedCycleScalarWhereInput
    data: XOR<FeaturedCycleUpdateManyMutationInput, FeaturedCycleUncheckedUpdateManyWithoutWinnerCollectionInput>
  }

  export type FeaturedCycleScalarWhereInput = {
    AND?: FeaturedCycleScalarWhereInput | FeaturedCycleScalarWhereInput[]
    OR?: FeaturedCycleScalarWhereInput[]
    NOT?: FeaturedCycleScalarWhereInput | FeaturedCycleScalarWhereInput[]
    id?: StringFilter<"FeaturedCycle"> | string
    cycleId?: StringFilter<"FeaturedCycle"> | string
    startAt?: DateTimeFilter<"FeaturedCycle"> | Date | string
    endAt?: DateTimeFilter<"FeaturedCycle"> | Date | string
    status?: EnumFeaturedCycleStatusFilter<"FeaturedCycle"> | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalFilter<"FeaturedCycle"> | Decimal | DecimalJsLike | number | string
    winnerBidId?: StringNullableFilter<"FeaturedCycle"> | string | null
    winnerCollectionContract?: StringNullableFilter<"FeaturedCycle"> | string | null
    winnerAmountWei?: DecimalNullableFilter<"FeaturedCycle"> | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: DateTimeNullableFilter<"FeaturedCycle"> | Date | string | null
    createdAt?: DateTimeFilter<"FeaturedCycle"> | Date | string
    updatedAt?: DateTimeFilter<"FeaturedCycle"> | Date | string
  }

  export type NFTUpsertWithWhereUniqueWithoutCollectionInput = {
    where: NFTWhereUniqueInput
    update: XOR<NFTUpdateWithoutCollectionInput, NFTUncheckedUpdateWithoutCollectionInput>
    create: XOR<NFTCreateWithoutCollectionInput, NFTUncheckedCreateWithoutCollectionInput>
  }

  export type NFTUpdateWithWhereUniqueWithoutCollectionInput = {
    where: NFTWhereUniqueInput
    data: XOR<NFTUpdateWithoutCollectionInput, NFTUncheckedUpdateWithoutCollectionInput>
  }

  export type NFTUpdateManyWithWhereWithoutCollectionInput = {
    where: NFTScalarWhereInput
    data: XOR<NFTUpdateManyMutationInput, NFTUncheckedUpdateManyWithoutCollectionInput>
  }

  export type PresaleUpsertWithoutCollectionInput = {
    update: XOR<PresaleUpdateWithoutCollectionInput, PresaleUncheckedUpdateWithoutCollectionInput>
    create: XOR<PresaleCreateWithoutCollectionInput, PresaleUncheckedCreateWithoutCollectionInput>
    where?: PresaleWhereInput
  }

  export type PresaleUpdateToOneWithWhereWithoutCollectionInput = {
    where?: PresaleWhereInput
    data: XOR<PresaleUpdateWithoutCollectionInput, PresaleUncheckedUpdateWithoutCollectionInput>
  }

  export type PresaleUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    merkleRoot?: StringFieldUpdateOperationsInput | string
    whitelistCount?: NullableIntFieldUpdateOperationsInput | number | null
    allowlistCommit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whitelist?: PresaleWhitelistAddressUpdateManyWithoutPresaleNestedInput
  }

  export type PresaleUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    merkleRoot?: StringFieldUpdateOperationsInput | string
    whitelistCount?: NullableIntFieldUpdateOperationsInput | number | null
    allowlistCommit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whitelist?: PresaleWhitelistAddressUncheckedUpdateManyWithoutPresaleNestedInput
  }

  export type PublicSaleUpsertWithoutCollectionInput = {
    update: XOR<PublicSaleUpdateWithoutCollectionInput, PublicSaleUncheckedUpdateWithoutCollectionInput>
    create: XOR<PublicSaleCreateWithoutCollectionInput, PublicSaleUncheckedCreateWithoutCollectionInput>
    where?: PublicSaleWhereInput
  }

  export type PublicSaleUpdateToOneWithWhereWithoutCollectionInput = {
    where?: PublicSaleWhereInput
    data: XOR<PublicSaleUpdateWithoutCollectionInput, PublicSaleUncheckedUpdateWithoutCollectionInput>
  }

  export type PublicSaleUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    maxPerTx?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicSaleUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    maxPerTx?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionCreateWithoutNftInput = {
    id?: string
    sellerAddress: string
    quantity?: number
    startPriceEtnWei: Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: Decimal | DecimalJsLike | number | string | null
    startPriceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime: Date | string
    status?: $Enums.AuctionStatus
    txHashCreated?: string | null
    txHashFinalized?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highestBidder?: string | null
    currency?: CurrencyCreateNestedOneWithoutAuctionsInput
    bids?: AuctionBidCreateNestedManyWithoutAuctionInput
  }

  export type AuctionUncheckedCreateWithoutNftInput = {
    id?: string
    sellerAddress: string
    quantity?: number
    startPriceEtnWei: Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: Decimal | DecimalJsLike | number | string | null
    currencyId?: string | null
    startPriceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime: Date | string
    status?: $Enums.AuctionStatus
    txHashCreated?: string | null
    txHashFinalized?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highestBidder?: string | null
    bids?: AuctionBidUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type AuctionCreateOrConnectWithoutNftInput = {
    where: AuctionWhereUniqueInput
    create: XOR<AuctionCreateWithoutNftInput, AuctionUncheckedCreateWithoutNftInput>
  }

  export type AuctionCreateManyNftInputEnvelope = {
    data: AuctionCreateManyNftInput | AuctionCreateManyNftInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceListingCreateWithoutNftInput = {
    id?: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ListingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    txHashCreated?: string | null
    txHashFilled?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency?: CurrencyCreateNestedOneWithoutListingsInput
  }

  export type MarketplaceListingUncheckedCreateWithoutNftInput = {
    id?: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    currencyId?: string | null
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ListingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    txHashCreated?: string | null
    txHashFilled?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceListingCreateOrConnectWithoutNftInput = {
    where: MarketplaceListingWhereUniqueInput
    create: XOR<MarketplaceListingCreateWithoutNftInput, MarketplaceListingUncheckedCreateWithoutNftInput>
  }

  export type MarketplaceListingCreateManyNftInputEnvelope = {
    data: MarketplaceListingCreateManyNftInput | MarketplaceListingCreateManyNftInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceSaleCreateWithoutNftInput = {
    id?: string
    buyerAddress: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: Decimal | DecimalJsLike | number | string | null
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: string | null
    marketplaceFeeRecipient?: string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
    currency?: CurrencyCreateNestedOneWithoutSalesInput
  }

  export type MarketplaceSaleUncheckedCreateWithoutNftInput = {
    id?: string
    buyerAddress: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: Decimal | DecimalJsLike | number | string | null
    currencyId?: string | null
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: string | null
    marketplaceFeeRecipient?: string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type MarketplaceSaleCreateOrConnectWithoutNftInput = {
    where: MarketplaceSaleWhereUniqueInput
    create: XOR<MarketplaceSaleCreateWithoutNftInput, MarketplaceSaleUncheckedCreateWithoutNftInput>
  }

  export type MarketplaceSaleCreateManyNftInputEnvelope = {
    data: MarketplaceSaleCreateManyNftInput | MarketplaceSaleCreateManyNftInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCreateWithoutNftsInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutCollectionInput
    creator: UserCreateNestedOneWithoutCollectionsInput
    deployment?: DeployedContractCreateNestedOneWithoutCollectionInput
    featuredBidEntries?: FeaturedBidCreateNestedManyWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleCreateNestedManyWithoutWinnerCollectionInput
    presale?: PresaleCreateNestedOneWithoutCollectionInput
    publicSale?: PublicSaleCreateNestedOneWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutNftsInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    creatorId: string
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutCollectionInput
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutCollectionInput
    featuredBidEntries?: FeaturedBidUncheckedCreateNestedManyWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleUncheckedCreateNestedManyWithoutWinnerCollectionInput
    presale?: PresaleUncheckedCreateNestedOneWithoutCollectionInput
    publicSale?: PublicSaleUncheckedCreateNestedOneWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutNftsInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutNftsInput, CollectionUncheckedCreateWithoutNftsInput>
  }

  export type UserCreateWithoutOwnedNFTsInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collections?: CollectionCreateNestedManyWithoutCreatorInput
    submissions?: CollectionSubmissionCreateNestedManyWithoutSubmittedByInput
    featuredBids?: FeaturedBidCreateNestedManyWithoutBidderInput
    holderRewardsMulti?: HolderRewardMultiCreateNestedManyWithoutUserInput
    rewardClaimLogs?: RewardClaimLogCreateNestedManyWithoutUserInput
    stolenReports?: StolenItemCreateNestedManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutOwnedNFTsInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collections?: CollectionUncheckedCreateNestedManyWithoutCreatorInput
    submissions?: CollectionSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    featuredBids?: FeaturedBidUncheckedCreateNestedManyWithoutBidderInput
    holderRewardsMulti?: HolderRewardMultiUncheckedCreateNestedManyWithoutUserInput
    rewardClaimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutUserInput
    stolenReports?: StolenItemUncheckedCreateNestedManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutOwnedNFTsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedNFTsInput, UserUncheckedCreateWithoutOwnedNFTsInput>
  }

  export type Single1155CreateWithoutNftsInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    baseUri: string
    maxSupply: number
    mintPriceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutSingle1155Input
    deployment?: DeployedContractCreateNestedOneWithoutSingle1155Input
    balances?: Erc1155BalanceCreateNestedManyWithoutSingle1155Input
  }

  export type Single1155UncheckedCreateWithoutNftsInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    baseUri: string
    maxSupply: number
    mintPriceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutSingle1155Input
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutSingle1155Input
    balances?: Erc1155BalanceUncheckedCreateNestedManyWithoutSingle1155Input
  }

  export type Single1155CreateOrConnectWithoutNftsInput = {
    where: Single1155WhereUniqueInput
    create: XOR<Single1155CreateWithoutNftsInput, Single1155UncheckedCreateWithoutNftsInput>
  }

  export type Single721CreateWithoutNftsInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    tokenUri: string
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutSingle721Input
    deployment?: DeployedContractCreateNestedOneWithoutSingle721Input
  }

  export type Single721UncheckedCreateWithoutNftsInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    tokenUri: string
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutSingle721Input
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutSingle721Input
  }

  export type Single721CreateOrConnectWithoutNftsInput = {
    where: Single721WhereUniqueInput
    create: XOR<Single721CreateWithoutNftsInput, Single721UncheckedCreateWithoutNftsInput>
  }

  export type NFTActivityCreateWithoutNftInput = {
    id?: string
    contract: string
    tokenId: string
    type: string
    fromAddress: string
    toAddress: string
    priceEtnWei?: Decimal | DecimalJsLike | number | string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    marketplace?: string | null
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NFTActivityUncheckedCreateWithoutNftInput = {
    id?: string
    contract: string
    tokenId: string
    type: string
    fromAddress: string
    toAddress: string
    priceEtnWei?: Decimal | DecimalJsLike | number | string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    marketplace?: string | null
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NFTActivityCreateOrConnectWithoutNftInput = {
    where: NFTActivityWhereUniqueInput
    create: XOR<NFTActivityCreateWithoutNftInput, NFTActivityUncheckedCreateWithoutNftInput>
  }

  export type NFTActivityCreateManyNftInputEnvelope = {
    data: NFTActivityCreateManyNftInput | NFTActivityCreateManyNftInput[]
    skipDuplicates?: boolean
  }

  export type AuctionUpsertWithWhereUniqueWithoutNftInput = {
    where: AuctionWhereUniqueInput
    update: XOR<AuctionUpdateWithoutNftInput, AuctionUncheckedUpdateWithoutNftInput>
    create: XOR<AuctionCreateWithoutNftInput, AuctionUncheckedCreateWithoutNftInput>
  }

  export type AuctionUpdateWithWhereUniqueWithoutNftInput = {
    where: AuctionWhereUniqueInput
    data: XOR<AuctionUpdateWithoutNftInput, AuctionUncheckedUpdateWithoutNftInput>
  }

  export type AuctionUpdateManyWithWhereWithoutNftInput = {
    where: AuctionScalarWhereInput
    data: XOR<AuctionUpdateManyMutationInput, AuctionUncheckedUpdateManyWithoutNftInput>
  }

  export type AuctionScalarWhereInput = {
    AND?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
    OR?: AuctionScalarWhereInput[]
    NOT?: AuctionScalarWhereInput | AuctionScalarWhereInput[]
    id?: StringFilter<"Auction"> | string
    nftId?: StringFilter<"Auction"> | string
    sellerAddress?: StringFilter<"Auction"> | string
    quantity?: IntFilter<"Auction"> | number
    startPriceEtnWei?: DecimalFilter<"Auction"> | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: StringNullableFilter<"Auction"> | string | null
    startPriceTokenAmount?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: DecimalNullableFilter<"Auction"> | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFilter<"Auction"> | Date | string
    endTime?: DateTimeFilter<"Auction"> | Date | string
    status?: EnumAuctionStatusFilter<"Auction"> | $Enums.AuctionStatus
    txHashCreated?: StringNullableFilter<"Auction"> | string | null
    txHashFinalized?: StringNullableFilter<"Auction"> | string | null
    txHashCancelled?: StringNullableFilter<"Auction"> | string | null
    createdAt?: DateTimeFilter<"Auction"> | Date | string
    updatedAt?: DateTimeFilter<"Auction"> | Date | string
    highestBidder?: StringNullableFilter<"Auction"> | string | null
  }

  export type MarketplaceListingUpsertWithWhereUniqueWithoutNftInput = {
    where: MarketplaceListingWhereUniqueInput
    update: XOR<MarketplaceListingUpdateWithoutNftInput, MarketplaceListingUncheckedUpdateWithoutNftInput>
    create: XOR<MarketplaceListingCreateWithoutNftInput, MarketplaceListingUncheckedCreateWithoutNftInput>
  }

  export type MarketplaceListingUpdateWithWhereUniqueWithoutNftInput = {
    where: MarketplaceListingWhereUniqueInput
    data: XOR<MarketplaceListingUpdateWithoutNftInput, MarketplaceListingUncheckedUpdateWithoutNftInput>
  }

  export type MarketplaceListingUpdateManyWithWhereWithoutNftInput = {
    where: MarketplaceListingScalarWhereInput
    data: XOR<MarketplaceListingUpdateManyMutationInput, MarketplaceListingUncheckedUpdateManyWithoutNftInput>
  }

  export type MarketplaceListingScalarWhereInput = {
    AND?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
    OR?: MarketplaceListingScalarWhereInput[]
    NOT?: MarketplaceListingScalarWhereInput | MarketplaceListingScalarWhereInput[]
    id?: StringFilter<"MarketplaceListing"> | string
    nftId?: StringFilter<"MarketplaceListing"> | string
    sellerAddress?: StringFilter<"MarketplaceListing"> | string
    quantity?: IntFilter<"MarketplaceListing"> | number
    priceEtnWei?: DecimalFilter<"MarketplaceListing"> | Decimal | DecimalJsLike | number | string
    currencyId?: StringNullableFilter<"MarketplaceListing"> | string | null
    priceTokenAmount?: DecimalNullableFilter<"MarketplaceListing"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumListingStatusFilter<"MarketplaceListing"> | $Enums.ListingStatus
    startTime?: DateTimeFilter<"MarketplaceListing"> | Date | string
    endTime?: DateTimeNullableFilter<"MarketplaceListing"> | Date | string | null
    txHashCreated?: StringNullableFilter<"MarketplaceListing"> | string | null
    txHashFilled?: StringNullableFilter<"MarketplaceListing"> | string | null
    txHashCancelled?: StringNullableFilter<"MarketplaceListing"> | string | null
    createdAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
    updatedAt?: DateTimeFilter<"MarketplaceListing"> | Date | string
  }

  export type MarketplaceSaleUpsertWithWhereUniqueWithoutNftInput = {
    where: MarketplaceSaleWhereUniqueInput
    update: XOR<MarketplaceSaleUpdateWithoutNftInput, MarketplaceSaleUncheckedUpdateWithoutNftInput>
    create: XOR<MarketplaceSaleCreateWithoutNftInput, MarketplaceSaleUncheckedCreateWithoutNftInput>
  }

  export type MarketplaceSaleUpdateWithWhereUniqueWithoutNftInput = {
    where: MarketplaceSaleWhereUniqueInput
    data: XOR<MarketplaceSaleUpdateWithoutNftInput, MarketplaceSaleUncheckedUpdateWithoutNftInput>
  }

  export type MarketplaceSaleUpdateManyWithWhereWithoutNftInput = {
    where: MarketplaceSaleScalarWhereInput
    data: XOR<MarketplaceSaleUpdateManyMutationInput, MarketplaceSaleUncheckedUpdateManyWithoutNftInput>
  }

  export type MarketplaceSaleScalarWhereInput = {
    AND?: MarketplaceSaleScalarWhereInput | MarketplaceSaleScalarWhereInput[]
    OR?: MarketplaceSaleScalarWhereInput[]
    NOT?: MarketplaceSaleScalarWhereInput | MarketplaceSaleScalarWhereInput[]
    id?: StringFilter<"MarketplaceSale"> | string
    nftId?: StringFilter<"MarketplaceSale"> | string
    buyerAddress?: StringFilter<"MarketplaceSale"> | string
    sellerAddress?: StringFilter<"MarketplaceSale"> | string
    quantity?: IntFilter<"MarketplaceSale"> | number
    priceEtnWei?: DecimalFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    currencyId?: StringNullableFilter<"MarketplaceSale"> | string | null
    priceTokenAmount?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: DecimalNullableFilter<"MarketplaceSale"> | Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: StringNullableFilter<"MarketplaceSale"> | string | null
    marketplaceFeeRecipient?: StringNullableFilter<"MarketplaceSale"> | string | null
    txHash?: StringFilter<"MarketplaceSale"> | string
    logIndex?: IntFilter<"MarketplaceSale"> | number
    blockNumber?: IntFilter<"MarketplaceSale"> | number
    timestamp?: DateTimeFilter<"MarketplaceSale"> | Date | string
    createdAt?: DateTimeFilter<"MarketplaceSale"> | Date | string
  }

  export type CollectionUpsertWithoutNftsInput = {
    update: XOR<CollectionUpdateWithoutNftsInput, CollectionUncheckedUpdateWithoutNftsInput>
    create: XOR<CollectionCreateWithoutNftsInput, CollectionUncheckedCreateWithoutNftsInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutNftsInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutNftsInput, CollectionUncheckedUpdateWithoutNftsInput>
  }

  export type CollectionUpdateWithoutNftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutCollectionNestedInput
    creator?: UserUpdateOneRequiredWithoutCollectionsNestedInput
    deployment?: DeployedContractUpdateOneWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUpdateManyWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUpdateManyWithoutWinnerCollectionNestedInput
    presale?: PresaleUpdateOneWithoutCollectionNestedInput
    publicSale?: PublicSaleUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutNftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutCollectionNestedInput
    deployment?: DeployedContractUncheckedUpdateOneWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUncheckedUpdateManyWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUncheckedUpdateManyWithoutWinnerCollectionNestedInput
    presale?: PresaleUncheckedUpdateOneWithoutCollectionNestedInput
    publicSale?: PublicSaleUncheckedUpdateOneWithoutCollectionNestedInput
  }

  export type UserUpsertWithoutOwnedNFTsInput = {
    update: XOR<UserUpdateWithoutOwnedNFTsInput, UserUncheckedUpdateWithoutOwnedNFTsInput>
    create: XOR<UserCreateWithoutOwnedNFTsInput, UserUncheckedCreateWithoutOwnedNFTsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedNFTsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedNFTsInput, UserUncheckedUpdateWithoutOwnedNFTsInput>
  }

  export type UserUpdateWithoutOwnedNFTsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUpdateManyWithoutCreatorNestedInput
    submissions?: CollectionSubmissionUpdateManyWithoutSubmittedByNestedInput
    featuredBids?: FeaturedBidUpdateManyWithoutBidderNestedInput
    holderRewardsMulti?: HolderRewardMultiUpdateManyWithoutUserNestedInput
    rewardClaimLogs?: RewardClaimLogUpdateManyWithoutUserNestedInput
    stolenReports?: StolenItemUpdateManyWithoutReporterNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedNFTsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUncheckedUpdateManyWithoutCreatorNestedInput
    submissions?: CollectionSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    featuredBids?: FeaturedBidUncheckedUpdateManyWithoutBidderNestedInput
    holderRewardsMulti?: HolderRewardMultiUncheckedUpdateManyWithoutUserNestedInput
    rewardClaimLogs?: RewardClaimLogUncheckedUpdateManyWithoutUserNestedInput
    stolenReports?: StolenItemUncheckedUpdateManyWithoutReporterNestedInput
  }

  export type Single1155UpsertWithoutNftsInput = {
    update: XOR<Single1155UpdateWithoutNftsInput, Single1155UncheckedUpdateWithoutNftsInput>
    create: XOR<Single1155CreateWithoutNftsInput, Single1155UncheckedCreateWithoutNftsInput>
    where?: Single1155WhereInput
  }

  export type Single1155UpdateToOneWithWhereWithoutNftsInput = {
    where?: Single1155WhereInput
    data: XOR<Single1155UpdateWithoutNftsInput, Single1155UncheckedUpdateWithoutNftsInput>
  }

  export type Single1155UpdateWithoutNftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    baseUri?: StringFieldUpdateOperationsInput | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    mintPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutSingle1155NestedInput
    deployment?: DeployedContractUpdateOneWithoutSingle1155NestedInput
    balances?: Erc1155BalanceUpdateManyWithoutSingle1155NestedInput
  }

  export type Single1155UncheckedUpdateWithoutNftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    baseUri?: StringFieldUpdateOperationsInput | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    mintPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutSingle1155NestedInput
    deployment?: DeployedContractUncheckedUpdateOneWithoutSingle1155NestedInput
    balances?: Erc1155BalanceUncheckedUpdateManyWithoutSingle1155NestedInput
  }

  export type Single721UpsertWithoutNftsInput = {
    update: XOR<Single721UpdateWithoutNftsInput, Single721UncheckedUpdateWithoutNftsInput>
    create: XOR<Single721CreateWithoutNftsInput, Single721UncheckedCreateWithoutNftsInput>
    where?: Single721WhereInput
  }

  export type Single721UpdateToOneWithWhereWithoutNftsInput = {
    where?: Single721WhereInput
    data: XOR<Single721UpdateWithoutNftsInput, Single721UncheckedUpdateWithoutNftsInput>
  }

  export type Single721UpdateWithoutNftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenUri?: StringFieldUpdateOperationsInput | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutSingle721NestedInput
    deployment?: DeployedContractUpdateOneWithoutSingle721NestedInput
  }

  export type Single721UncheckedUpdateWithoutNftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenUri?: StringFieldUpdateOperationsInput | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutSingle721NestedInput
    deployment?: DeployedContractUncheckedUpdateOneWithoutSingle721NestedInput
  }

  export type NFTActivityUpsertWithWhereUniqueWithoutNftInput = {
    where: NFTActivityWhereUniqueInput
    update: XOR<NFTActivityUpdateWithoutNftInput, NFTActivityUncheckedUpdateWithoutNftInput>
    create: XOR<NFTActivityCreateWithoutNftInput, NFTActivityUncheckedCreateWithoutNftInput>
  }

  export type NFTActivityUpdateWithWhereUniqueWithoutNftInput = {
    where: NFTActivityWhereUniqueInput
    data: XOR<NFTActivityUpdateWithoutNftInput, NFTActivityUncheckedUpdateWithoutNftInput>
  }

  export type NFTActivityUpdateManyWithWhereWithoutNftInput = {
    where: NFTActivityScalarWhereInput
    data: XOR<NFTActivityUpdateManyMutationInput, NFTActivityUncheckedUpdateManyWithoutNftInput>
  }

  export type NFTActivityScalarWhereInput = {
    AND?: NFTActivityScalarWhereInput | NFTActivityScalarWhereInput[]
    OR?: NFTActivityScalarWhereInput[]
    NOT?: NFTActivityScalarWhereInput | NFTActivityScalarWhereInput[]
    id?: StringFilter<"NFTActivity"> | string
    nftId?: StringFilter<"NFTActivity"> | string
    contract?: StringFilter<"NFTActivity"> | string
    tokenId?: StringFilter<"NFTActivity"> | string
    type?: StringFilter<"NFTActivity"> | string
    fromAddress?: StringFilter<"NFTActivity"> | string
    toAddress?: StringFilter<"NFTActivity"> | string
    priceEtnWei?: DecimalNullableFilter<"NFTActivity"> | Decimal | DecimalJsLike | number | string | null
    txHash?: StringFilter<"NFTActivity"> | string
    logIndex?: IntFilter<"NFTActivity"> | number
    blockNumber?: IntFilter<"NFTActivity"> | number
    timestamp?: DateTimeFilter<"NFTActivity"> | Date | string
    marketplace?: StringNullableFilter<"NFTActivity"> | string | null
    rawData?: JsonNullableFilter<"NFTActivity">
    createdAt?: DateTimeFilter<"NFTActivity"> | Date | string
  }

  export type NFTCreateWithoutActivitiesInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionCreateNestedManyWithoutNftInput
    listingEntries?: MarketplaceListingCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleCreateNestedManyWithoutNftInput
    collection?: CollectionCreateNestedOneWithoutNftsInput
    owner?: UserCreateNestedOneWithoutOwnedNFTsInput
    single1155?: Single1155CreateNestedOneWithoutNftsInput
    single721?: Single721CreateNestedOneWithoutNftsInput
  }

  export type NFTUncheckedCreateWithoutActivitiesInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    ownerId?: string | null
    collectionId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedCreateNestedManyWithoutNftInput
    listingEntries?: MarketplaceListingUncheckedCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutNftInput
  }

  export type NFTCreateOrConnectWithoutActivitiesInput = {
    where: NFTWhereUniqueInput
    create: XOR<NFTCreateWithoutActivitiesInput, NFTUncheckedCreateWithoutActivitiesInput>
  }

  export type NFTUpsertWithoutActivitiesInput = {
    update: XOR<NFTUpdateWithoutActivitiesInput, NFTUncheckedUpdateWithoutActivitiesInput>
    create: XOR<NFTCreateWithoutActivitiesInput, NFTUncheckedCreateWithoutActivitiesInput>
    where?: NFTWhereInput
  }

  export type NFTUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: NFTWhereInput
    data: XOR<NFTUpdateWithoutActivitiesInput, NFTUncheckedUpdateWithoutActivitiesInput>
  }

  export type NFTUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUpdateManyWithoutNftNestedInput
    listingEntries?: MarketplaceListingUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutNftNestedInput
    collection?: CollectionUpdateOneWithoutNftsNestedInput
    owner?: UserUpdateOneWithoutOwnedNFTsNestedInput
    single1155?: Single1155UpdateOneWithoutNftsNestedInput
    single721?: Single721UpdateOneWithoutNftsNestedInput
  }

  export type NFTUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedUpdateManyWithoutNftNestedInput
    listingEntries?: MarketplaceListingUncheckedUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutNftNestedInput
  }

  export type AssetUploadCreateWithoutSingle721Input = {
    id?: string
    uploaderUserId?: string | null
    provider?: string
    cid: string
    url?: string | null
    bytes?: number | null
    sha256?: string | null
    contentType?: string | null
    originalName?: string | null
    createdAt?: Date | string
    collection?: CollectionCreateNestedOneWithoutAssetUploadsInput
    single1155?: Single1155CreateNestedOneWithoutAssetUploadsInput
  }

  export type AssetUploadUncheckedCreateWithoutSingle721Input = {
    id?: string
    uploaderUserId?: string | null
    collectionId?: string | null
    single1155Id?: string | null
    provider?: string
    cid: string
    url?: string | null
    bytes?: number | null
    sha256?: string | null
    contentType?: string | null
    originalName?: string | null
    createdAt?: Date | string
  }

  export type AssetUploadCreateOrConnectWithoutSingle721Input = {
    where: AssetUploadWhereUniqueInput
    create: XOR<AssetUploadCreateWithoutSingle721Input, AssetUploadUncheckedCreateWithoutSingle721Input>
  }

  export type AssetUploadCreateManySingle721InputEnvelope = {
    data: AssetUploadCreateManySingle721Input | AssetUploadCreateManySingle721Input[]
    skipDuplicates?: boolean
  }

  export type DeployedContractCreateWithoutSingle721Input = {
    id?: string
    contractType: $Enums.ContractType
    cloneAddress: string
    implementationAddr: string
    factoryAddress: string
    deployerAddress: string
    txHash: string
    blockNumber: number
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal | DecimalJsLike | number | string
    royaltyRecipient: string
    royaltyBps: number
    baseURI?: string | null
    maxSupply?: number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    collection?: CollectionCreateNestedOneWithoutDeploymentInput
    single1155?: Single1155CreateNestedOneWithoutDeploymentInput
  }

  export type DeployedContractUncheckedCreateWithoutSingle721Input = {
    id?: string
    contractType: $Enums.ContractType
    cloneAddress: string
    implementationAddr: string
    factoryAddress: string
    deployerAddress: string
    txHash: string
    blockNumber: number
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal | DecimalJsLike | number | string
    royaltyRecipient: string
    royaltyBps: number
    baseURI?: string | null
    maxSupply?: number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    collectionId?: string | null
    single1155Id?: string | null
  }

  export type DeployedContractCreateOrConnectWithoutSingle721Input = {
    where: DeployedContractWhereUniqueInput
    create: XOR<DeployedContractCreateWithoutSingle721Input, DeployedContractUncheckedCreateWithoutSingle721Input>
  }

  export type NFTCreateWithoutSingle721Input = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionCreateNestedManyWithoutNftInput
    listingEntries?: MarketplaceListingCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleCreateNestedManyWithoutNftInput
    collection?: CollectionCreateNestedOneWithoutNftsInput
    owner?: UserCreateNestedOneWithoutOwnedNFTsInput
    single1155?: Single1155CreateNestedOneWithoutNftsInput
    activities?: NFTActivityCreateNestedManyWithoutNftInput
  }

  export type NFTUncheckedCreateWithoutSingle721Input = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    ownerId?: string | null
    collectionId?: string | null
    single1155Id?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedCreateNestedManyWithoutNftInput
    listingEntries?: MarketplaceListingUncheckedCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutNftInput
    activities?: NFTActivityUncheckedCreateNestedManyWithoutNftInput
  }

  export type NFTCreateOrConnectWithoutSingle721Input = {
    where: NFTWhereUniqueInput
    create: XOR<NFTCreateWithoutSingle721Input, NFTUncheckedCreateWithoutSingle721Input>
  }

  export type NFTCreateManySingle721InputEnvelope = {
    data: NFTCreateManySingle721Input | NFTCreateManySingle721Input[]
    skipDuplicates?: boolean
  }

  export type AssetUploadUpsertWithWhereUniqueWithoutSingle721Input = {
    where: AssetUploadWhereUniqueInput
    update: XOR<AssetUploadUpdateWithoutSingle721Input, AssetUploadUncheckedUpdateWithoutSingle721Input>
    create: XOR<AssetUploadCreateWithoutSingle721Input, AssetUploadUncheckedCreateWithoutSingle721Input>
  }

  export type AssetUploadUpdateWithWhereUniqueWithoutSingle721Input = {
    where: AssetUploadWhereUniqueInput
    data: XOR<AssetUploadUpdateWithoutSingle721Input, AssetUploadUncheckedUpdateWithoutSingle721Input>
  }

  export type AssetUploadUpdateManyWithWhereWithoutSingle721Input = {
    where: AssetUploadScalarWhereInput
    data: XOR<AssetUploadUpdateManyMutationInput, AssetUploadUncheckedUpdateManyWithoutSingle721Input>
  }

  export type DeployedContractUpsertWithoutSingle721Input = {
    update: XOR<DeployedContractUpdateWithoutSingle721Input, DeployedContractUncheckedUpdateWithoutSingle721Input>
    create: XOR<DeployedContractCreateWithoutSingle721Input, DeployedContractUncheckedCreateWithoutSingle721Input>
    where?: DeployedContractWhereInput
  }

  export type DeployedContractUpdateToOneWithWhereWithoutSingle721Input = {
    where?: DeployedContractWhereInput
    data: XOR<DeployedContractUpdateWithoutSingle721Input, DeployedContractUncheckedUpdateWithoutSingle721Input>
  }

  export type DeployedContractUpdateWithoutSingle721Input = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    cloneAddress?: StringFieldUpdateOperationsInput | string
    implementationAddr?: StringFieldUpdateOperationsInput | string
    factoryAddress?: StringFieldUpdateOperationsInput | string
    deployerAddress?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    baseURI?: NullableStringFieldUpdateOperationsInput | string | null
    maxSupply?: NullableIntFieldUpdateOperationsInput | number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: CollectionUpdateOneWithoutDeploymentNestedInput
    single1155?: Single1155UpdateOneWithoutDeploymentNestedInput
  }

  export type DeployedContractUncheckedUpdateWithoutSingle721Input = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    cloneAddress?: StringFieldUpdateOperationsInput | string
    implementationAddr?: StringFieldUpdateOperationsInput | string
    factoryAddress?: StringFieldUpdateOperationsInput | string
    deployerAddress?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    baseURI?: NullableStringFieldUpdateOperationsInput | string | null
    maxSupply?: NullableIntFieldUpdateOperationsInput | number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NFTUpsertWithWhereUniqueWithoutSingle721Input = {
    where: NFTWhereUniqueInput
    update: XOR<NFTUpdateWithoutSingle721Input, NFTUncheckedUpdateWithoutSingle721Input>
    create: XOR<NFTCreateWithoutSingle721Input, NFTUncheckedCreateWithoutSingle721Input>
  }

  export type NFTUpdateWithWhereUniqueWithoutSingle721Input = {
    where: NFTWhereUniqueInput
    data: XOR<NFTUpdateWithoutSingle721Input, NFTUncheckedUpdateWithoutSingle721Input>
  }

  export type NFTUpdateManyWithWhereWithoutSingle721Input = {
    where: NFTScalarWhereInput
    data: XOR<NFTUpdateManyMutationInput, NFTUncheckedUpdateManyWithoutSingle721Input>
  }

  export type AssetUploadCreateWithoutSingle1155Input = {
    id?: string
    uploaderUserId?: string | null
    provider?: string
    cid: string
    url?: string | null
    bytes?: number | null
    sha256?: string | null
    contentType?: string | null
    originalName?: string | null
    createdAt?: Date | string
    collection?: CollectionCreateNestedOneWithoutAssetUploadsInput
    single721?: Single721CreateNestedOneWithoutAssetUploadsInput
  }

  export type AssetUploadUncheckedCreateWithoutSingle1155Input = {
    id?: string
    uploaderUserId?: string | null
    collectionId?: string | null
    single721Id?: string | null
    provider?: string
    cid: string
    url?: string | null
    bytes?: number | null
    sha256?: string | null
    contentType?: string | null
    originalName?: string | null
    createdAt?: Date | string
  }

  export type AssetUploadCreateOrConnectWithoutSingle1155Input = {
    where: AssetUploadWhereUniqueInput
    create: XOR<AssetUploadCreateWithoutSingle1155Input, AssetUploadUncheckedCreateWithoutSingle1155Input>
  }

  export type AssetUploadCreateManySingle1155InputEnvelope = {
    data: AssetUploadCreateManySingle1155Input | AssetUploadCreateManySingle1155Input[]
    skipDuplicates?: boolean
  }

  export type DeployedContractCreateWithoutSingle1155Input = {
    id?: string
    contractType: $Enums.ContractType
    cloneAddress: string
    implementationAddr: string
    factoryAddress: string
    deployerAddress: string
    txHash: string
    blockNumber: number
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal | DecimalJsLike | number | string
    royaltyRecipient: string
    royaltyBps: number
    baseURI?: string | null
    maxSupply?: number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    collection?: CollectionCreateNestedOneWithoutDeploymentInput
    single721?: Single721CreateNestedOneWithoutDeploymentInput
  }

  export type DeployedContractUncheckedCreateWithoutSingle1155Input = {
    id?: string
    contractType: $Enums.ContractType
    cloneAddress: string
    implementationAddr: string
    factoryAddress: string
    deployerAddress: string
    txHash: string
    blockNumber: number
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal | DecimalJsLike | number | string
    royaltyRecipient: string
    royaltyBps: number
    baseURI?: string | null
    maxSupply?: number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    collectionId?: string | null
    single721Id?: string | null
  }

  export type DeployedContractCreateOrConnectWithoutSingle1155Input = {
    where: DeployedContractWhereUniqueInput
    create: XOR<DeployedContractCreateWithoutSingle1155Input, DeployedContractUncheckedCreateWithoutSingle1155Input>
  }

  export type Erc1155BalanceCreateWithoutSingle1155Input = {
    id?: string
    ownerAddress: string
    balance?: number
    updatedAt?: Date | string
  }

  export type Erc1155BalanceUncheckedCreateWithoutSingle1155Input = {
    id?: string
    ownerAddress: string
    balance?: number
    updatedAt?: Date | string
  }

  export type Erc1155BalanceCreateOrConnectWithoutSingle1155Input = {
    where: Erc1155BalanceWhereUniqueInput
    create: XOR<Erc1155BalanceCreateWithoutSingle1155Input, Erc1155BalanceUncheckedCreateWithoutSingle1155Input>
  }

  export type Erc1155BalanceCreateManySingle1155InputEnvelope = {
    data: Erc1155BalanceCreateManySingle1155Input | Erc1155BalanceCreateManySingle1155Input[]
    skipDuplicates?: boolean
  }

  export type NFTCreateWithoutSingle1155Input = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionCreateNestedManyWithoutNftInput
    listingEntries?: MarketplaceListingCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleCreateNestedManyWithoutNftInput
    collection?: CollectionCreateNestedOneWithoutNftsInput
    owner?: UserCreateNestedOneWithoutOwnedNFTsInput
    single721?: Single721CreateNestedOneWithoutNftsInput
    activities?: NFTActivityCreateNestedManyWithoutNftInput
  }

  export type NFTUncheckedCreateWithoutSingle1155Input = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    ownerId?: string | null
    collectionId?: string | null
    single721Id?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedCreateNestedManyWithoutNftInput
    listingEntries?: MarketplaceListingUncheckedCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutNftInput
    activities?: NFTActivityUncheckedCreateNestedManyWithoutNftInput
  }

  export type NFTCreateOrConnectWithoutSingle1155Input = {
    where: NFTWhereUniqueInput
    create: XOR<NFTCreateWithoutSingle1155Input, NFTUncheckedCreateWithoutSingle1155Input>
  }

  export type NFTCreateManySingle1155InputEnvelope = {
    data: NFTCreateManySingle1155Input | NFTCreateManySingle1155Input[]
    skipDuplicates?: boolean
  }

  export type AssetUploadUpsertWithWhereUniqueWithoutSingle1155Input = {
    where: AssetUploadWhereUniqueInput
    update: XOR<AssetUploadUpdateWithoutSingle1155Input, AssetUploadUncheckedUpdateWithoutSingle1155Input>
    create: XOR<AssetUploadCreateWithoutSingle1155Input, AssetUploadUncheckedCreateWithoutSingle1155Input>
  }

  export type AssetUploadUpdateWithWhereUniqueWithoutSingle1155Input = {
    where: AssetUploadWhereUniqueInput
    data: XOR<AssetUploadUpdateWithoutSingle1155Input, AssetUploadUncheckedUpdateWithoutSingle1155Input>
  }

  export type AssetUploadUpdateManyWithWhereWithoutSingle1155Input = {
    where: AssetUploadScalarWhereInput
    data: XOR<AssetUploadUpdateManyMutationInput, AssetUploadUncheckedUpdateManyWithoutSingle1155Input>
  }

  export type DeployedContractUpsertWithoutSingle1155Input = {
    update: XOR<DeployedContractUpdateWithoutSingle1155Input, DeployedContractUncheckedUpdateWithoutSingle1155Input>
    create: XOR<DeployedContractCreateWithoutSingle1155Input, DeployedContractUncheckedCreateWithoutSingle1155Input>
    where?: DeployedContractWhereInput
  }

  export type DeployedContractUpdateToOneWithWhereWithoutSingle1155Input = {
    where?: DeployedContractWhereInput
    data: XOR<DeployedContractUpdateWithoutSingle1155Input, DeployedContractUncheckedUpdateWithoutSingle1155Input>
  }

  export type DeployedContractUpdateWithoutSingle1155Input = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    cloneAddress?: StringFieldUpdateOperationsInput | string
    implementationAddr?: StringFieldUpdateOperationsInput | string
    factoryAddress?: StringFieldUpdateOperationsInput | string
    deployerAddress?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    baseURI?: NullableStringFieldUpdateOperationsInput | string | null
    maxSupply?: NullableIntFieldUpdateOperationsInput | number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: CollectionUpdateOneWithoutDeploymentNestedInput
    single721?: Single721UpdateOneWithoutDeploymentNestedInput
  }

  export type DeployedContractUncheckedUpdateWithoutSingle1155Input = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    cloneAddress?: StringFieldUpdateOperationsInput | string
    implementationAddr?: StringFieldUpdateOperationsInput | string
    factoryAddress?: StringFieldUpdateOperationsInput | string
    deployerAddress?: StringFieldUpdateOperationsInput | string
    txHash?: StringFieldUpdateOperationsInput | string
    blockNumber?: IntFieldUpdateOperationsInput | number
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    baseURI?: NullableStringFieldUpdateOperationsInput | string | null
    maxSupply?: NullableIntFieldUpdateOperationsInput | number | null
    rawInit?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Erc1155BalanceUpsertWithWhereUniqueWithoutSingle1155Input = {
    where: Erc1155BalanceWhereUniqueInput
    update: XOR<Erc1155BalanceUpdateWithoutSingle1155Input, Erc1155BalanceUncheckedUpdateWithoutSingle1155Input>
    create: XOR<Erc1155BalanceCreateWithoutSingle1155Input, Erc1155BalanceUncheckedCreateWithoutSingle1155Input>
  }

  export type Erc1155BalanceUpdateWithWhereUniqueWithoutSingle1155Input = {
    where: Erc1155BalanceWhereUniqueInput
    data: XOR<Erc1155BalanceUpdateWithoutSingle1155Input, Erc1155BalanceUncheckedUpdateWithoutSingle1155Input>
  }

  export type Erc1155BalanceUpdateManyWithWhereWithoutSingle1155Input = {
    where: Erc1155BalanceScalarWhereInput
    data: XOR<Erc1155BalanceUpdateManyMutationInput, Erc1155BalanceUncheckedUpdateManyWithoutSingle1155Input>
  }

  export type Erc1155BalanceScalarWhereInput = {
    AND?: Erc1155BalanceScalarWhereInput | Erc1155BalanceScalarWhereInput[]
    OR?: Erc1155BalanceScalarWhereInput[]
    NOT?: Erc1155BalanceScalarWhereInput | Erc1155BalanceScalarWhereInput[]
    id?: StringFilter<"Erc1155Balance"> | string
    single1155Id?: StringFilter<"Erc1155Balance"> | string
    ownerAddress?: StringFilter<"Erc1155Balance"> | string
    balance?: IntFilter<"Erc1155Balance"> | number
    updatedAt?: DateTimeFilter<"Erc1155Balance"> | Date | string
  }

  export type NFTUpsertWithWhereUniqueWithoutSingle1155Input = {
    where: NFTWhereUniqueInput
    update: XOR<NFTUpdateWithoutSingle1155Input, NFTUncheckedUpdateWithoutSingle1155Input>
    create: XOR<NFTCreateWithoutSingle1155Input, NFTUncheckedCreateWithoutSingle1155Input>
  }

  export type NFTUpdateWithWhereUniqueWithoutSingle1155Input = {
    where: NFTWhereUniqueInput
    data: XOR<NFTUpdateWithoutSingle1155Input, NFTUncheckedUpdateWithoutSingle1155Input>
  }

  export type NFTUpdateManyWithWhereWithoutSingle1155Input = {
    where: NFTScalarWhereInput
    data: XOR<NFTUpdateManyMutationInput, NFTUncheckedUpdateManyWithoutSingle1155Input>
  }

  export type Single1155CreateWithoutBalancesInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    baseUri: string
    maxSupply: number
    mintPriceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutSingle1155Input
    deployment?: DeployedContractCreateNestedOneWithoutSingle1155Input
    nfts?: NFTCreateNestedManyWithoutSingle1155Input
  }

  export type Single1155UncheckedCreateWithoutBalancesInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    baseUri: string
    maxSupply: number
    mintPriceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutSingle1155Input
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutSingle1155Input
    nfts?: NFTUncheckedCreateNestedManyWithoutSingle1155Input
  }

  export type Single1155CreateOrConnectWithoutBalancesInput = {
    where: Single1155WhereUniqueInput
    create: XOR<Single1155CreateWithoutBalancesInput, Single1155UncheckedCreateWithoutBalancesInput>
  }

  export type Single1155UpsertWithoutBalancesInput = {
    update: XOR<Single1155UpdateWithoutBalancesInput, Single1155UncheckedUpdateWithoutBalancesInput>
    create: XOR<Single1155CreateWithoutBalancesInput, Single1155UncheckedCreateWithoutBalancesInput>
    where?: Single1155WhereInput
  }

  export type Single1155UpdateToOneWithWhereWithoutBalancesInput = {
    where?: Single1155WhereInput
    data: XOR<Single1155UpdateWithoutBalancesInput, Single1155UncheckedUpdateWithoutBalancesInput>
  }

  export type Single1155UpdateWithoutBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    baseUri?: StringFieldUpdateOperationsInput | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    mintPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutSingle1155NestedInput
    deployment?: DeployedContractUpdateOneWithoutSingle1155NestedInput
    nfts?: NFTUpdateManyWithoutSingle1155NestedInput
  }

  export type Single1155UncheckedUpdateWithoutBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    baseUri?: StringFieldUpdateOperationsInput | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    mintPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutSingle1155NestedInput
    deployment?: DeployedContractUncheckedUpdateOneWithoutSingle1155NestedInput
    nfts?: NFTUncheckedUpdateManyWithoutSingle1155NestedInput
  }

  export type CurrencyCreateWithoutListingsInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionCreateNestedManyWithoutCurrencyInput
    bids?: AuctionBidCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiCreateNestedOneWithoutCurrencyInput
    claimLogs?: RewardClaimLogCreateNestedManyWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutListingsInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionUncheckedCreateNestedManyWithoutCurrencyInput
    bids?: AuctionBidUncheckedCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiUncheckedCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedCreateNestedOneWithoutCurrencyInput
    claimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutListingsInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutListingsInput, CurrencyUncheckedCreateWithoutListingsInput>
  }

  export type NFTCreateWithoutListingEntriesInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleCreateNestedManyWithoutNftInput
    collection?: CollectionCreateNestedOneWithoutNftsInput
    owner?: UserCreateNestedOneWithoutOwnedNFTsInput
    single1155?: Single1155CreateNestedOneWithoutNftsInput
    single721?: Single721CreateNestedOneWithoutNftsInput
    activities?: NFTActivityCreateNestedManyWithoutNftInput
  }

  export type NFTUncheckedCreateWithoutListingEntriesInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    ownerId?: string | null
    collectionId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutNftInput
    activities?: NFTActivityUncheckedCreateNestedManyWithoutNftInput
  }

  export type NFTCreateOrConnectWithoutListingEntriesInput = {
    where: NFTWhereUniqueInput
    create: XOR<NFTCreateWithoutListingEntriesInput, NFTUncheckedCreateWithoutListingEntriesInput>
  }

  export type CurrencyUpsertWithoutListingsInput = {
    update: XOR<CurrencyUpdateWithoutListingsInput, CurrencyUncheckedUpdateWithoutListingsInput>
    create: XOR<CurrencyCreateWithoutListingsInput, CurrencyUncheckedCreateWithoutListingsInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutListingsInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutListingsInput, CurrencyUncheckedUpdateWithoutListingsInput>
  }

  export type CurrencyUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUpdateManyWithoutCurrencyNestedInput
    bids?: AuctionBidUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUpdateOneWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUpdateManyWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUncheckedUpdateManyWithoutCurrencyNestedInput
    bids?: AuctionBidUncheckedUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUncheckedUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedUpdateOneWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUncheckedUpdateManyWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type NFTUpsertWithoutListingEntriesInput = {
    update: XOR<NFTUpdateWithoutListingEntriesInput, NFTUncheckedUpdateWithoutListingEntriesInput>
    create: XOR<NFTCreateWithoutListingEntriesInput, NFTUncheckedCreateWithoutListingEntriesInput>
    where?: NFTWhereInput
  }

  export type NFTUpdateToOneWithWhereWithoutListingEntriesInput = {
    where?: NFTWhereInput
    data: XOR<NFTUpdateWithoutListingEntriesInput, NFTUncheckedUpdateWithoutListingEntriesInput>
  }

  export type NFTUpdateWithoutListingEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutNftNestedInput
    collection?: CollectionUpdateOneWithoutNftsNestedInput
    owner?: UserUpdateOneWithoutOwnedNFTsNestedInput
    single1155?: Single1155UpdateOneWithoutNftsNestedInput
    single721?: Single721UpdateOneWithoutNftsNestedInput
    activities?: NFTActivityUpdateManyWithoutNftNestedInput
  }

  export type NFTUncheckedUpdateWithoutListingEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutNftNestedInput
    activities?: NFTActivityUncheckedUpdateManyWithoutNftNestedInput
  }

  export type CurrencyCreateWithoutAuctionsInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: AuctionBidCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiCreateNestedOneWithoutCurrencyInput
    claimLogs?: RewardClaimLogCreateNestedManyWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutAuctionsInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: AuctionBidUncheckedCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiUncheckedCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedCreateNestedOneWithoutCurrencyInput
    claimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutAuctionsInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutAuctionsInput, CurrencyUncheckedCreateWithoutAuctionsInput>
  }

  export type NFTCreateWithoutAuctionEntriesInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    listingEntries?: MarketplaceListingCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleCreateNestedManyWithoutNftInput
    collection?: CollectionCreateNestedOneWithoutNftsInput
    owner?: UserCreateNestedOneWithoutOwnedNFTsInput
    single1155?: Single1155CreateNestedOneWithoutNftsInput
    single721?: Single721CreateNestedOneWithoutNftsInput
    activities?: NFTActivityCreateNestedManyWithoutNftInput
  }

  export type NFTUncheckedCreateWithoutAuctionEntriesInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    ownerId?: string | null
    collectionId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    listingEntries?: MarketplaceListingUncheckedCreateNestedManyWithoutNftInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutNftInput
    activities?: NFTActivityUncheckedCreateNestedManyWithoutNftInput
  }

  export type NFTCreateOrConnectWithoutAuctionEntriesInput = {
    where: NFTWhereUniqueInput
    create: XOR<NFTCreateWithoutAuctionEntriesInput, NFTUncheckedCreateWithoutAuctionEntriesInput>
  }

  export type AuctionBidCreateWithoutAuctionInput = {
    id?: string
    bidderAddress: string
    amountWei: Decimal | DecimalJsLike | number | string
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
    currency?: CurrencyCreateNestedOneWithoutBidsInput
  }

  export type AuctionBidUncheckedCreateWithoutAuctionInput = {
    id?: string
    bidderAddress: string
    amountWei: Decimal | DecimalJsLike | number | string
    currencyId?: string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type AuctionBidCreateOrConnectWithoutAuctionInput = {
    where: AuctionBidWhereUniqueInput
    create: XOR<AuctionBidCreateWithoutAuctionInput, AuctionBidUncheckedCreateWithoutAuctionInput>
  }

  export type AuctionBidCreateManyAuctionInputEnvelope = {
    data: AuctionBidCreateManyAuctionInput | AuctionBidCreateManyAuctionInput[]
    skipDuplicates?: boolean
  }

  export type CurrencyUpsertWithoutAuctionsInput = {
    update: XOR<CurrencyUpdateWithoutAuctionsInput, CurrencyUncheckedUpdateWithoutAuctionsInput>
    create: XOR<CurrencyCreateWithoutAuctionsInput, CurrencyUncheckedCreateWithoutAuctionsInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutAuctionsInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutAuctionsInput, CurrencyUncheckedUpdateWithoutAuctionsInput>
  }

  export type CurrencyUpdateWithoutAuctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: AuctionBidUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUpdateOneWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUpdateManyWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutAuctionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: AuctionBidUncheckedUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUncheckedUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedUpdateOneWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUncheckedUpdateManyWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type NFTUpsertWithoutAuctionEntriesInput = {
    update: XOR<NFTUpdateWithoutAuctionEntriesInput, NFTUncheckedUpdateWithoutAuctionEntriesInput>
    create: XOR<NFTCreateWithoutAuctionEntriesInput, NFTUncheckedCreateWithoutAuctionEntriesInput>
    where?: NFTWhereInput
  }

  export type NFTUpdateToOneWithWhereWithoutAuctionEntriesInput = {
    where?: NFTWhereInput
    data: XOR<NFTUpdateWithoutAuctionEntriesInput, NFTUncheckedUpdateWithoutAuctionEntriesInput>
  }

  export type NFTUpdateWithoutAuctionEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    listingEntries?: MarketplaceListingUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutNftNestedInput
    collection?: CollectionUpdateOneWithoutNftsNestedInput
    owner?: UserUpdateOneWithoutOwnedNFTsNestedInput
    single1155?: Single1155UpdateOneWithoutNftsNestedInput
    single721?: Single721UpdateOneWithoutNftsNestedInput
    activities?: NFTActivityUpdateManyWithoutNftNestedInput
  }

  export type NFTUncheckedUpdateWithoutAuctionEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    listingEntries?: MarketplaceListingUncheckedUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutNftNestedInput
    activities?: NFTActivityUncheckedUpdateManyWithoutNftNestedInput
  }

  export type AuctionBidUpsertWithWhereUniqueWithoutAuctionInput = {
    where: AuctionBidWhereUniqueInput
    update: XOR<AuctionBidUpdateWithoutAuctionInput, AuctionBidUncheckedUpdateWithoutAuctionInput>
    create: XOR<AuctionBidCreateWithoutAuctionInput, AuctionBidUncheckedCreateWithoutAuctionInput>
  }

  export type AuctionBidUpdateWithWhereUniqueWithoutAuctionInput = {
    where: AuctionBidWhereUniqueInput
    data: XOR<AuctionBidUpdateWithoutAuctionInput, AuctionBidUncheckedUpdateWithoutAuctionInput>
  }

  export type AuctionBidUpdateManyWithWhereWithoutAuctionInput = {
    where: AuctionBidScalarWhereInput
    data: XOR<AuctionBidUpdateManyMutationInput, AuctionBidUncheckedUpdateManyWithoutAuctionInput>
  }

  export type AuctionBidScalarWhereInput = {
    AND?: AuctionBidScalarWhereInput | AuctionBidScalarWhereInput[]
    OR?: AuctionBidScalarWhereInput[]
    NOT?: AuctionBidScalarWhereInput | AuctionBidScalarWhereInput[]
    id?: StringFilter<"AuctionBid"> | string
    auctionId?: StringFilter<"AuctionBid"> | string
    bidderAddress?: StringFilter<"AuctionBid"> | string
    amountWei?: DecimalFilter<"AuctionBid"> | Decimal | DecimalJsLike | number | string
    currencyId?: StringNullableFilter<"AuctionBid"> | string | null
    txHash?: StringFilter<"AuctionBid"> | string
    logIndex?: IntFilter<"AuctionBid"> | number
    blockNumber?: IntFilter<"AuctionBid"> | number
    timestamp?: DateTimeFilter<"AuctionBid"> | Date | string
    createdAt?: DateTimeFilter<"AuctionBid"> | Date | string
  }

  export type AuctionCreateWithoutBidsInput = {
    id?: string
    sellerAddress: string
    quantity?: number
    startPriceEtnWei: Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: Decimal | DecimalJsLike | number | string | null
    startPriceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime: Date | string
    status?: $Enums.AuctionStatus
    txHashCreated?: string | null
    txHashFinalized?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highestBidder?: string | null
    currency?: CurrencyCreateNestedOneWithoutAuctionsInput
    nft: NFTCreateNestedOneWithoutAuctionEntriesInput
  }

  export type AuctionUncheckedCreateWithoutBidsInput = {
    id?: string
    nftId: string
    sellerAddress: string
    quantity?: number
    startPriceEtnWei: Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: Decimal | DecimalJsLike | number | string | null
    currencyId?: string | null
    startPriceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime: Date | string
    status?: $Enums.AuctionStatus
    txHashCreated?: string | null
    txHashFinalized?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highestBidder?: string | null
  }

  export type AuctionCreateOrConnectWithoutBidsInput = {
    where: AuctionWhereUniqueInput
    create: XOR<AuctionCreateWithoutBidsInput, AuctionUncheckedCreateWithoutBidsInput>
  }

  export type CurrencyCreateWithoutBidsInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiCreateNestedOneWithoutCurrencyInput
    claimLogs?: RewardClaimLogCreateNestedManyWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutBidsInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionUncheckedCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiUncheckedCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedCreateNestedOneWithoutCurrencyInput
    claimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutBidsInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutBidsInput, CurrencyUncheckedCreateWithoutBidsInput>
  }

  export type AuctionUpsertWithoutBidsInput = {
    update: XOR<AuctionUpdateWithoutBidsInput, AuctionUncheckedUpdateWithoutBidsInput>
    create: XOR<AuctionCreateWithoutBidsInput, AuctionUncheckedCreateWithoutBidsInput>
    where?: AuctionWhereInput
  }

  export type AuctionUpdateToOneWithWhereWithoutBidsInput = {
    where?: AuctionWhereInput
    data: XOR<AuctionUpdateWithoutBidsInput, AuctionUncheckedUpdateWithoutBidsInput>
  }

  export type AuctionUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startPriceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFinalized?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highestBidder?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: CurrencyUpdateOneWithoutAuctionsNestedInput
    nft?: NFTUpdateOneRequiredWithoutAuctionEntriesNestedInput
  }

  export type AuctionUncheckedUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    startPriceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFinalized?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highestBidder?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CurrencyUpsertWithoutBidsInput = {
    update: XOR<CurrencyUpdateWithoutBidsInput, CurrencyUncheckedUpdateWithoutBidsInput>
    create: XOR<CurrencyCreateWithoutBidsInput, CurrencyUncheckedCreateWithoutBidsInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutBidsInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutBidsInput, CurrencyUncheckedUpdateWithoutBidsInput>
  }

  export type CurrencyUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUpdateOneWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUpdateManyWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUncheckedUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUncheckedUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedUpdateOneWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUncheckedUpdateManyWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type CollectionCreateWithoutDeploymentInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutCollectionInput
    creator: UserCreateNestedOneWithoutCollectionsInput
    featuredBidEntries?: FeaturedBidCreateNestedManyWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleCreateNestedManyWithoutWinnerCollectionInput
    nfts?: NFTCreateNestedManyWithoutCollectionInput
    presale?: PresaleCreateNestedOneWithoutCollectionInput
    publicSale?: PublicSaleCreateNestedOneWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutDeploymentInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    creatorId: string
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutCollectionInput
    featuredBidEntries?: FeaturedBidUncheckedCreateNestedManyWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleUncheckedCreateNestedManyWithoutWinnerCollectionInput
    nfts?: NFTUncheckedCreateNestedManyWithoutCollectionInput
    presale?: PresaleUncheckedCreateNestedOneWithoutCollectionInput
    publicSale?: PublicSaleUncheckedCreateNestedOneWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutDeploymentInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutDeploymentInput, CollectionUncheckedCreateWithoutDeploymentInput>
  }

  export type Single1155CreateWithoutDeploymentInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    baseUri: string
    maxSupply: number
    mintPriceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutSingle1155Input
    balances?: Erc1155BalanceCreateNestedManyWithoutSingle1155Input
    nfts?: NFTCreateNestedManyWithoutSingle1155Input
  }

  export type Single1155UncheckedCreateWithoutDeploymentInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    baseUri: string
    maxSupply: number
    mintPriceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutSingle1155Input
    balances?: Erc1155BalanceUncheckedCreateNestedManyWithoutSingle1155Input
    nfts?: NFTUncheckedCreateNestedManyWithoutSingle1155Input
  }

  export type Single1155CreateOrConnectWithoutDeploymentInput = {
    where: Single1155WhereUniqueInput
    create: XOR<Single1155CreateWithoutDeploymentInput, Single1155UncheckedCreateWithoutDeploymentInput>
  }

  export type Single721CreateWithoutDeploymentInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    tokenUri: string
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutSingle721Input
    nfts?: NFTCreateNestedManyWithoutSingle721Input
  }

  export type Single721UncheckedCreateWithoutDeploymentInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    tokenUri: string
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutSingle721Input
    nfts?: NFTUncheckedCreateNestedManyWithoutSingle721Input
  }

  export type Single721CreateOrConnectWithoutDeploymentInput = {
    where: Single721WhereUniqueInput
    create: XOR<Single721CreateWithoutDeploymentInput, Single721UncheckedCreateWithoutDeploymentInput>
  }

  export type CollectionUpsertWithoutDeploymentInput = {
    update: XOR<CollectionUpdateWithoutDeploymentInput, CollectionUncheckedUpdateWithoutDeploymentInput>
    create: XOR<CollectionCreateWithoutDeploymentInput, CollectionUncheckedCreateWithoutDeploymentInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutDeploymentInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutDeploymentInput, CollectionUncheckedUpdateWithoutDeploymentInput>
  }

  export type CollectionUpdateWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutCollectionNestedInput
    creator?: UserUpdateOneRequiredWithoutCollectionsNestedInput
    featuredBidEntries?: FeaturedBidUpdateManyWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUpdateManyWithoutWinnerCollectionNestedInput
    nfts?: NFTUpdateManyWithoutCollectionNestedInput
    presale?: PresaleUpdateOneWithoutCollectionNestedInput
    publicSale?: PublicSaleUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUncheckedUpdateManyWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUncheckedUpdateManyWithoutWinnerCollectionNestedInput
    nfts?: NFTUncheckedUpdateManyWithoutCollectionNestedInput
    presale?: PresaleUncheckedUpdateOneWithoutCollectionNestedInput
    publicSale?: PublicSaleUncheckedUpdateOneWithoutCollectionNestedInput
  }

  export type Single1155UpsertWithoutDeploymentInput = {
    update: XOR<Single1155UpdateWithoutDeploymentInput, Single1155UncheckedUpdateWithoutDeploymentInput>
    create: XOR<Single1155CreateWithoutDeploymentInput, Single1155UncheckedCreateWithoutDeploymentInput>
    where?: Single1155WhereInput
  }

  export type Single1155UpdateToOneWithWhereWithoutDeploymentInput = {
    where?: Single1155WhereInput
    data: XOR<Single1155UpdateWithoutDeploymentInput, Single1155UncheckedUpdateWithoutDeploymentInput>
  }

  export type Single1155UpdateWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    baseUri?: StringFieldUpdateOperationsInput | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    mintPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutSingle1155NestedInput
    balances?: Erc1155BalanceUpdateManyWithoutSingle1155NestedInput
    nfts?: NFTUpdateManyWithoutSingle1155NestedInput
  }

  export type Single1155UncheckedUpdateWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    baseUri?: StringFieldUpdateOperationsInput | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    mintPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutSingle1155NestedInput
    balances?: Erc1155BalanceUncheckedUpdateManyWithoutSingle1155NestedInput
    nfts?: NFTUncheckedUpdateManyWithoutSingle1155NestedInput
  }

  export type Single721UpsertWithoutDeploymentInput = {
    update: XOR<Single721UpdateWithoutDeploymentInput, Single721UncheckedUpdateWithoutDeploymentInput>
    create: XOR<Single721CreateWithoutDeploymentInput, Single721UncheckedCreateWithoutDeploymentInput>
    where?: Single721WhereInput
  }

  export type Single721UpdateToOneWithWhereWithoutDeploymentInput = {
    where?: Single721WhereInput
    data: XOR<Single721UpdateWithoutDeploymentInput, Single721UncheckedUpdateWithoutDeploymentInput>
  }

  export type Single721UpdateWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenUri?: StringFieldUpdateOperationsInput | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutSingle721NestedInput
    nfts?: NFTUpdateManyWithoutSingle721NestedInput
  }

  export type Single721UncheckedUpdateWithoutDeploymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenUri?: StringFieldUpdateOperationsInput | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutSingle721NestedInput
    nfts?: NFTUncheckedUpdateManyWithoutSingle721NestedInput
  }

  export type FeeConfigLogCreateWithoutFeeConfigInput = {
    id?: string
    previousRecipient?: string | null
    newRecipient?: string | null
    previousAmountEtnWei?: Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: Decimal | DecimalJsLike | number | string | null
    changedByUserId?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type FeeConfigLogUncheckedCreateWithoutFeeConfigInput = {
    id?: string
    previousRecipient?: string | null
    newRecipient?: string | null
    previousAmountEtnWei?: Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: Decimal | DecimalJsLike | number | string | null
    changedByUserId?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type FeeConfigLogCreateOrConnectWithoutFeeConfigInput = {
    where: FeeConfigLogWhereUniqueInput
    create: XOR<FeeConfigLogCreateWithoutFeeConfigInput, FeeConfigLogUncheckedCreateWithoutFeeConfigInput>
  }

  export type FeeConfigLogCreateManyFeeConfigInputEnvelope = {
    data: FeeConfigLogCreateManyFeeConfigInput | FeeConfigLogCreateManyFeeConfigInput[]
    skipDuplicates?: boolean
  }

  export type FeeConfigLogUpsertWithWhereUniqueWithoutFeeConfigInput = {
    where: FeeConfigLogWhereUniqueInput
    update: XOR<FeeConfigLogUpdateWithoutFeeConfigInput, FeeConfigLogUncheckedUpdateWithoutFeeConfigInput>
    create: XOR<FeeConfigLogCreateWithoutFeeConfigInput, FeeConfigLogUncheckedCreateWithoutFeeConfigInput>
  }

  export type FeeConfigLogUpdateWithWhereUniqueWithoutFeeConfigInput = {
    where: FeeConfigLogWhereUniqueInput
    data: XOR<FeeConfigLogUpdateWithoutFeeConfigInput, FeeConfigLogUncheckedUpdateWithoutFeeConfigInput>
  }

  export type FeeConfigLogUpdateManyWithWhereWithoutFeeConfigInput = {
    where: FeeConfigLogScalarWhereInput
    data: XOR<FeeConfigLogUpdateManyMutationInput, FeeConfigLogUncheckedUpdateManyWithoutFeeConfigInput>
  }

  export type FeeConfigLogScalarWhereInput = {
    AND?: FeeConfigLogScalarWhereInput | FeeConfigLogScalarWhereInput[]
    OR?: FeeConfigLogScalarWhereInput[]
    NOT?: FeeConfigLogScalarWhereInput | FeeConfigLogScalarWhereInput[]
    id?: StringFilter<"FeeConfigLog"> | string
    feeConfigId?: StringFilter<"FeeConfigLog"> | string
    previousRecipient?: StringNullableFilter<"FeeConfigLog"> | string | null
    newRecipient?: StringNullableFilter<"FeeConfigLog"> | string | null
    previousAmountEtnWei?: DecimalNullableFilter<"FeeConfigLog"> | Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: DecimalNullableFilter<"FeeConfigLog"> | Decimal | DecimalJsLike | number | string | null
    changedByUserId?: StringNullableFilter<"FeeConfigLog"> | string | null
    reason?: StringNullableFilter<"FeeConfigLog"> | string | null
    createdAt?: DateTimeFilter<"FeeConfigLog"> | Date | string
  }

  export type FeeConfigCreateWithoutLogsInput = {
    id?: string
    contractType: $Enums.ContractType
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedByUserId?: string | null
    targetUsdCents?: number | null
    pricingSource?: string
    pricingPair?: string
    lastPriceUsd?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
  }

  export type FeeConfigUncheckedCreateWithoutLogsInput = {
    id?: string
    contractType: $Enums.ContractType
    metadataOption: $Enums.MetadataOption
    feeRecipient: string
    feeAmountEtnWei: Decimal | DecimalJsLike | number | string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedByUserId?: string | null
    targetUsdCents?: number | null
    pricingSource?: string
    pricingPair?: string
    lastPriceUsd?: Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: Date | string | null
  }

  export type FeeConfigCreateOrConnectWithoutLogsInput = {
    where: FeeConfigWhereUniqueInput
    create: XOR<FeeConfigCreateWithoutLogsInput, FeeConfigUncheckedCreateWithoutLogsInput>
  }

  export type FeeConfigUpsertWithoutLogsInput = {
    update: XOR<FeeConfigUpdateWithoutLogsInput, FeeConfigUncheckedUpdateWithoutLogsInput>
    create: XOR<FeeConfigCreateWithoutLogsInput, FeeConfigUncheckedCreateWithoutLogsInput>
    where?: FeeConfigWhereInput
  }

  export type FeeConfigUpdateToOneWithWhereWithoutLogsInput = {
    where?: FeeConfigWhereInput
    data: XOR<FeeConfigUpdateWithoutLogsInput, FeeConfigUncheckedUpdateWithoutLogsInput>
  }

  export type FeeConfigUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    targetUsdCents?: NullableIntFieldUpdateOperationsInput | number | null
    pricingSource?: StringFieldUpdateOperationsInput | string
    pricingPair?: StringFieldUpdateOperationsInput | string
    lastPriceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeeConfigUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractType?: EnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType
    metadataOption?: EnumMetadataOptionFieldUpdateOperationsInput | $Enums.MetadataOption
    feeRecipient?: StringFieldUpdateOperationsInput | string
    feeAmountEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    targetUsdCents?: NullableIntFieldUpdateOperationsInput | number | null
    pricingSource?: StringFieldUpdateOperationsInput | string
    pricingPair?: StringFieldUpdateOperationsInput | string
    lastPriceUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lastPriceAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CollectionCreateWithoutPublicSaleInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutCollectionInput
    creator: UserCreateNestedOneWithoutCollectionsInput
    deployment?: DeployedContractCreateNestedOneWithoutCollectionInput
    featuredBidEntries?: FeaturedBidCreateNestedManyWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleCreateNestedManyWithoutWinnerCollectionInput
    nfts?: NFTCreateNestedManyWithoutCollectionInput
    presale?: PresaleCreateNestedOneWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutPublicSaleInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    creatorId: string
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutCollectionInput
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutCollectionInput
    featuredBidEntries?: FeaturedBidUncheckedCreateNestedManyWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleUncheckedCreateNestedManyWithoutWinnerCollectionInput
    nfts?: NFTUncheckedCreateNestedManyWithoutCollectionInput
    presale?: PresaleUncheckedCreateNestedOneWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutPublicSaleInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutPublicSaleInput, CollectionUncheckedCreateWithoutPublicSaleInput>
  }

  export type CollectionUpsertWithoutPublicSaleInput = {
    update: XOR<CollectionUpdateWithoutPublicSaleInput, CollectionUncheckedUpdateWithoutPublicSaleInput>
    create: XOR<CollectionCreateWithoutPublicSaleInput, CollectionUncheckedCreateWithoutPublicSaleInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutPublicSaleInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutPublicSaleInput, CollectionUncheckedUpdateWithoutPublicSaleInput>
  }

  export type CollectionUpdateWithoutPublicSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutCollectionNestedInput
    creator?: UserUpdateOneRequiredWithoutCollectionsNestedInput
    deployment?: DeployedContractUpdateOneWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUpdateManyWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUpdateManyWithoutWinnerCollectionNestedInput
    nfts?: NFTUpdateManyWithoutCollectionNestedInput
    presale?: PresaleUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutPublicSaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutCollectionNestedInput
    deployment?: DeployedContractUncheckedUpdateOneWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUncheckedUpdateManyWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUncheckedUpdateManyWithoutWinnerCollectionNestedInput
    nfts?: NFTUncheckedUpdateManyWithoutCollectionNestedInput
    presale?: PresaleUncheckedUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionCreateWithoutPresaleInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutCollectionInput
    creator: UserCreateNestedOneWithoutCollectionsInput
    deployment?: DeployedContractCreateNestedOneWithoutCollectionInput
    featuredBidEntries?: FeaturedBidCreateNestedManyWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleCreateNestedManyWithoutWinnerCollectionInput
    nfts?: NFTCreateNestedManyWithoutCollectionInput
    publicSale?: PublicSaleCreateNestedOneWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutPresaleInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    creatorId: string
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutCollectionInput
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutCollectionInput
    featuredBidEntries?: FeaturedBidUncheckedCreateNestedManyWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleUncheckedCreateNestedManyWithoutWinnerCollectionInput
    nfts?: NFTUncheckedCreateNestedManyWithoutCollectionInput
    publicSale?: PublicSaleUncheckedCreateNestedOneWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutPresaleInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutPresaleInput, CollectionUncheckedCreateWithoutPresaleInput>
  }

  export type PresaleWhitelistAddressCreateWithoutPresaleInput = {
    id?: string
    address: string
    maxAllocation?: number | null
  }

  export type PresaleWhitelistAddressUncheckedCreateWithoutPresaleInput = {
    id?: string
    address: string
    maxAllocation?: number | null
  }

  export type PresaleWhitelistAddressCreateOrConnectWithoutPresaleInput = {
    where: PresaleWhitelistAddressWhereUniqueInput
    create: XOR<PresaleWhitelistAddressCreateWithoutPresaleInput, PresaleWhitelistAddressUncheckedCreateWithoutPresaleInput>
  }

  export type PresaleWhitelistAddressCreateManyPresaleInputEnvelope = {
    data: PresaleWhitelistAddressCreateManyPresaleInput | PresaleWhitelistAddressCreateManyPresaleInput[]
    skipDuplicates?: boolean
  }

  export type CollectionUpsertWithoutPresaleInput = {
    update: XOR<CollectionUpdateWithoutPresaleInput, CollectionUncheckedUpdateWithoutPresaleInput>
    create: XOR<CollectionCreateWithoutPresaleInput, CollectionUncheckedCreateWithoutPresaleInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutPresaleInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutPresaleInput, CollectionUncheckedUpdateWithoutPresaleInput>
  }

  export type CollectionUpdateWithoutPresaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutCollectionNestedInput
    creator?: UserUpdateOneRequiredWithoutCollectionsNestedInput
    deployment?: DeployedContractUpdateOneWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUpdateManyWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUpdateManyWithoutWinnerCollectionNestedInput
    nfts?: NFTUpdateManyWithoutCollectionNestedInput
    publicSale?: PublicSaleUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutPresaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutCollectionNestedInput
    deployment?: DeployedContractUncheckedUpdateOneWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUncheckedUpdateManyWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUncheckedUpdateManyWithoutWinnerCollectionNestedInput
    nfts?: NFTUncheckedUpdateManyWithoutCollectionNestedInput
    publicSale?: PublicSaleUncheckedUpdateOneWithoutCollectionNestedInput
  }

  export type PresaleWhitelistAddressUpsertWithWhereUniqueWithoutPresaleInput = {
    where: PresaleWhitelistAddressWhereUniqueInput
    update: XOR<PresaleWhitelistAddressUpdateWithoutPresaleInput, PresaleWhitelistAddressUncheckedUpdateWithoutPresaleInput>
    create: XOR<PresaleWhitelistAddressCreateWithoutPresaleInput, PresaleWhitelistAddressUncheckedCreateWithoutPresaleInput>
  }

  export type PresaleWhitelistAddressUpdateWithWhereUniqueWithoutPresaleInput = {
    where: PresaleWhitelistAddressWhereUniqueInput
    data: XOR<PresaleWhitelistAddressUpdateWithoutPresaleInput, PresaleWhitelistAddressUncheckedUpdateWithoutPresaleInput>
  }

  export type PresaleWhitelistAddressUpdateManyWithWhereWithoutPresaleInput = {
    where: PresaleWhitelistAddressScalarWhereInput
    data: XOR<PresaleWhitelistAddressUpdateManyMutationInput, PresaleWhitelistAddressUncheckedUpdateManyWithoutPresaleInput>
  }

  export type PresaleWhitelistAddressScalarWhereInput = {
    AND?: PresaleWhitelistAddressScalarWhereInput | PresaleWhitelistAddressScalarWhereInput[]
    OR?: PresaleWhitelistAddressScalarWhereInput[]
    NOT?: PresaleWhitelistAddressScalarWhereInput | PresaleWhitelistAddressScalarWhereInput[]
    id?: StringFilter<"PresaleWhitelistAddress"> | string
    presaleId?: StringFilter<"PresaleWhitelistAddress"> | string
    address?: StringFilter<"PresaleWhitelistAddress"> | string
    maxAllocation?: IntNullableFilter<"PresaleWhitelistAddress"> | number | null
  }

  export type PresaleCreateWithoutWhitelistInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    priceEtnWei: Decimal | DecimalJsLike | number | string
    maxSupply: number
    merkleRoot: string
    whitelistCount?: number | null
    allowlistCommit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collection: CollectionCreateNestedOneWithoutPresaleInput
  }

  export type PresaleUncheckedCreateWithoutWhitelistInput = {
    id?: string
    collectionId: string
    startTime: Date | string
    endTime: Date | string
    priceEtnWei: Decimal | DecimalJsLike | number | string
    maxSupply: number
    merkleRoot: string
    whitelistCount?: number | null
    allowlistCommit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PresaleCreateOrConnectWithoutWhitelistInput = {
    where: PresaleWhereUniqueInput
    create: XOR<PresaleCreateWithoutWhitelistInput, PresaleUncheckedCreateWithoutWhitelistInput>
  }

  export type PresaleUpsertWithoutWhitelistInput = {
    update: XOR<PresaleUpdateWithoutWhitelistInput, PresaleUncheckedUpdateWithoutWhitelistInput>
    create: XOR<PresaleCreateWithoutWhitelistInput, PresaleUncheckedCreateWithoutWhitelistInput>
    where?: PresaleWhereInput
  }

  export type PresaleUpdateToOneWithWhereWithoutWhitelistInput = {
    where?: PresaleWhereInput
    data: XOR<PresaleUpdateWithoutWhitelistInput, PresaleUncheckedUpdateWithoutWhitelistInput>
  }

  export type PresaleUpdateWithoutWhitelistInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    merkleRoot?: StringFieldUpdateOperationsInput | string
    whitelistCount?: NullableIntFieldUpdateOperationsInput | number | null
    allowlistCommit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: CollectionUpdateOneRequiredWithoutPresaleNestedInput
  }

  export type PresaleUncheckedUpdateWithoutWhitelistInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    merkleRoot?: StringFieldUpdateOperationsInput | string
    whitelistCount?: NullableIntFieldUpdateOperationsInput | number | null
    allowlistCommit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCreateWithoutAssetUploadsInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCollectionsInput
    deployment?: DeployedContractCreateNestedOneWithoutCollectionInput
    featuredBidEntries?: FeaturedBidCreateNestedManyWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleCreateNestedManyWithoutWinnerCollectionInput
    nfts?: NFTCreateNestedManyWithoutCollectionInput
    presale?: PresaleCreateNestedOneWithoutCollectionInput
    publicSale?: PublicSaleCreateNestedOneWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutAssetUploadsInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    creatorId: string
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutCollectionInput
    featuredBidEntries?: FeaturedBidUncheckedCreateNestedManyWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleUncheckedCreateNestedManyWithoutWinnerCollectionInput
    nfts?: NFTUncheckedCreateNestedManyWithoutCollectionInput
    presale?: PresaleUncheckedCreateNestedOneWithoutCollectionInput
    publicSale?: PublicSaleUncheckedCreateNestedOneWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutAssetUploadsInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutAssetUploadsInput, CollectionUncheckedCreateWithoutAssetUploadsInput>
  }

  export type Single1155CreateWithoutAssetUploadsInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    baseUri: string
    maxSupply: number
    mintPriceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deployment?: DeployedContractCreateNestedOneWithoutSingle1155Input
    balances?: Erc1155BalanceCreateNestedManyWithoutSingle1155Input
    nfts?: NFTCreateNestedManyWithoutSingle1155Input
  }

  export type Single1155UncheckedCreateWithoutAssetUploadsInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    baseUri: string
    maxSupply: number
    mintPriceEtnWei: Decimal | DecimalJsLike | number | string
    maxPerWallet: number
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutSingle1155Input
    balances?: Erc1155BalanceUncheckedCreateNestedManyWithoutSingle1155Input
    nfts?: NFTUncheckedCreateNestedManyWithoutSingle1155Input
  }

  export type Single1155CreateOrConnectWithoutAssetUploadsInput = {
    where: Single1155WhereUniqueInput
    create: XOR<Single1155CreateWithoutAssetUploadsInput, Single1155UncheckedCreateWithoutAssetUploadsInput>
  }

  export type Single721CreateWithoutAssetUploadsInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    tokenUri: string
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deployment?: DeployedContractCreateNestedOneWithoutSingle721Input
    nfts?: NFTCreateNestedManyWithoutSingle721Input
  }

  export type Single721UncheckedCreateWithoutAssetUploadsInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    tokenUri: string
    royaltyRecipient: string
    royaltyBps: number
    creatorId: string
    ownerAddress: string
    description?: string | null
    imageUrl?: string | null
    indexStatus?: $Enums.IndexStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutSingle721Input
    nfts?: NFTUncheckedCreateNestedManyWithoutSingle721Input
  }

  export type Single721CreateOrConnectWithoutAssetUploadsInput = {
    where: Single721WhereUniqueInput
    create: XOR<Single721CreateWithoutAssetUploadsInput, Single721UncheckedCreateWithoutAssetUploadsInput>
  }

  export type CollectionUpsertWithoutAssetUploadsInput = {
    update: XOR<CollectionUpdateWithoutAssetUploadsInput, CollectionUncheckedUpdateWithoutAssetUploadsInput>
    create: XOR<CollectionCreateWithoutAssetUploadsInput, CollectionUncheckedCreateWithoutAssetUploadsInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutAssetUploadsInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutAssetUploadsInput, CollectionUncheckedUpdateWithoutAssetUploadsInput>
  }

  export type CollectionUpdateWithoutAssetUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCollectionsNestedInput
    deployment?: DeployedContractUpdateOneWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUpdateManyWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUpdateManyWithoutWinnerCollectionNestedInput
    nfts?: NFTUpdateManyWithoutCollectionNestedInput
    presale?: PresaleUpdateOneWithoutCollectionNestedInput
    publicSale?: PublicSaleUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutAssetUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deployment?: DeployedContractUncheckedUpdateOneWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUncheckedUpdateManyWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUncheckedUpdateManyWithoutWinnerCollectionNestedInput
    nfts?: NFTUncheckedUpdateManyWithoutCollectionNestedInput
    presale?: PresaleUncheckedUpdateOneWithoutCollectionNestedInput
    publicSale?: PublicSaleUncheckedUpdateOneWithoutCollectionNestedInput
  }

  export type Single1155UpsertWithoutAssetUploadsInput = {
    update: XOR<Single1155UpdateWithoutAssetUploadsInput, Single1155UncheckedUpdateWithoutAssetUploadsInput>
    create: XOR<Single1155CreateWithoutAssetUploadsInput, Single1155UncheckedCreateWithoutAssetUploadsInput>
    where?: Single1155WhereInput
  }

  export type Single1155UpdateToOneWithWhereWithoutAssetUploadsInput = {
    where?: Single1155WhereInput
    data: XOR<Single1155UpdateWithoutAssetUploadsInput, Single1155UncheckedUpdateWithoutAssetUploadsInput>
  }

  export type Single1155UpdateWithoutAssetUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    baseUri?: StringFieldUpdateOperationsInput | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    mintPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deployment?: DeployedContractUpdateOneWithoutSingle1155NestedInput
    balances?: Erc1155BalanceUpdateManyWithoutSingle1155NestedInput
    nfts?: NFTUpdateManyWithoutSingle1155NestedInput
  }

  export type Single1155UncheckedUpdateWithoutAssetUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    baseUri?: StringFieldUpdateOperationsInput | string
    maxSupply?: IntFieldUpdateOperationsInput | number
    mintPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxPerWallet?: IntFieldUpdateOperationsInput | number
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deployment?: DeployedContractUncheckedUpdateOneWithoutSingle1155NestedInput
    balances?: Erc1155BalanceUncheckedUpdateManyWithoutSingle1155NestedInput
    nfts?: NFTUncheckedUpdateManyWithoutSingle1155NestedInput
  }

  export type Single721UpsertWithoutAssetUploadsInput = {
    update: XOR<Single721UpdateWithoutAssetUploadsInput, Single721UncheckedUpdateWithoutAssetUploadsInput>
    create: XOR<Single721CreateWithoutAssetUploadsInput, Single721UncheckedCreateWithoutAssetUploadsInput>
    where?: Single721WhereInput
  }

  export type Single721UpdateToOneWithWhereWithoutAssetUploadsInput = {
    where?: Single721WhereInput
    data: XOR<Single721UpdateWithoutAssetUploadsInput, Single721UncheckedUpdateWithoutAssetUploadsInput>
  }

  export type Single721UpdateWithoutAssetUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenUri?: StringFieldUpdateOperationsInput | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deployment?: DeployedContractUpdateOneWithoutSingle721NestedInput
    nfts?: NFTUpdateManyWithoutSingle721NestedInput
  }

  export type Single721UncheckedUpdateWithoutAssetUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenUri?: StringFieldUpdateOperationsInput | string
    royaltyRecipient?: StringFieldUpdateOperationsInput | string
    royaltyBps?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deployment?: DeployedContractUncheckedUpdateOneWithoutSingle721NestedInput
    nfts?: NFTUncheckedUpdateManyWithoutSingle721NestedInput
  }

  export type UserCreateWithoutSubmissionsInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collections?: CollectionCreateNestedManyWithoutCreatorInput
    featuredBids?: FeaturedBidCreateNestedManyWithoutBidderInput
    holderRewardsMulti?: HolderRewardMultiCreateNestedManyWithoutUserInput
    ownedNFTs?: NFTCreateNestedManyWithoutOwnerInput
    rewardClaimLogs?: RewardClaimLogCreateNestedManyWithoutUserInput
    stolenReports?: StolenItemCreateNestedManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collections?: CollectionUncheckedCreateNestedManyWithoutCreatorInput
    featuredBids?: FeaturedBidUncheckedCreateNestedManyWithoutBidderInput
    holderRewardsMulti?: HolderRewardMultiUncheckedCreateNestedManyWithoutUserInput
    ownedNFTs?: NFTUncheckedCreateNestedManyWithoutOwnerInput
    rewardClaimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutUserInput
    stolenReports?: StolenItemUncheckedCreateNestedManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutSubmissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
  }

  export type UserUpsertWithoutSubmissionsInput = {
    update: XOR<UserUpdateWithoutSubmissionsInput, UserUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubmissionsInput, UserUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UserUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUpdateManyWithoutCreatorNestedInput
    featuredBids?: FeaturedBidUpdateManyWithoutBidderNestedInput
    holderRewardsMulti?: HolderRewardMultiUpdateManyWithoutUserNestedInput
    ownedNFTs?: NFTUpdateManyWithoutOwnerNestedInput
    rewardClaimLogs?: RewardClaimLogUpdateManyWithoutUserNestedInput
    stolenReports?: StolenItemUpdateManyWithoutReporterNestedInput
  }

  export type UserUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUncheckedUpdateManyWithoutCreatorNestedInput
    featuredBids?: FeaturedBidUncheckedUpdateManyWithoutBidderNestedInput
    holderRewardsMulti?: HolderRewardMultiUncheckedUpdateManyWithoutUserNestedInput
    ownedNFTs?: NFTUncheckedUpdateManyWithoutOwnerNestedInput
    rewardClaimLogs?: RewardClaimLogUncheckedUpdateManyWithoutUserNestedInput
    stolenReports?: StolenItemUncheckedUpdateManyWithoutReporterNestedInput
  }

  export type FeaturedBidCreateWithoutCycleInput = {
    id?: string
    bidderAddress: string
    totalBidWei: Decimal | DecimalJsLike | number | string
    txCount?: number
    lastTxHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidder?: UserCreateNestedOneWithoutFeaturedBidsInput
    collection: CollectionCreateNestedOneWithoutFeaturedBidEntriesInput
    winnerOf?: FeaturedCycleCreateNestedOneWithoutWinnerBidInput
  }

  export type FeaturedBidUncheckedCreateWithoutCycleInput = {
    id?: string
    bidderAddress: string
    bidderUserId?: string | null
    collectionContract: string
    totalBidWei: Decimal | DecimalJsLike | number | string
    txCount?: number
    lastTxHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    winnerOf?: FeaturedCycleUncheckedCreateNestedOneWithoutWinnerBidInput
  }

  export type FeaturedBidCreateOrConnectWithoutCycleInput = {
    where: FeaturedBidWhereUniqueInput
    create: XOR<FeaturedBidCreateWithoutCycleInput, FeaturedBidUncheckedCreateWithoutCycleInput>
  }

  export type FeaturedBidCreateManyCycleInputEnvelope = {
    data: FeaturedBidCreateManyCycleInput | FeaturedBidCreateManyCycleInput[]
    skipDuplicates?: boolean
  }

  export type FeaturedBidCreateWithoutWinnerOfInput = {
    id?: string
    bidderAddress: string
    totalBidWei: Decimal | DecimalJsLike | number | string
    txCount?: number
    lastTxHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bidder?: UserCreateNestedOneWithoutFeaturedBidsInput
    collection: CollectionCreateNestedOneWithoutFeaturedBidEntriesInput
    cycle: FeaturedCycleCreateNestedOneWithoutBidsInput
  }

  export type FeaturedBidUncheckedCreateWithoutWinnerOfInput = {
    id?: string
    cycleId: string
    bidderAddress: string
    bidderUserId?: string | null
    collectionContract: string
    totalBidWei: Decimal | DecimalJsLike | number | string
    txCount?: number
    lastTxHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedBidCreateOrConnectWithoutWinnerOfInput = {
    where: FeaturedBidWhereUniqueInput
    create: XOR<FeaturedBidCreateWithoutWinnerOfInput, FeaturedBidUncheckedCreateWithoutWinnerOfInput>
  }

  export type CollectionCreateWithoutFeaturedAsWinnerInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutCollectionInput
    creator: UserCreateNestedOneWithoutCollectionsInput
    deployment?: DeployedContractCreateNestedOneWithoutCollectionInput
    featuredBidEntries?: FeaturedBidCreateNestedManyWithoutCollectionInput
    nfts?: NFTCreateNestedManyWithoutCollectionInput
    presale?: PresaleCreateNestedOneWithoutCollectionInput
    publicSale?: PublicSaleCreateNestedOneWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutFeaturedAsWinnerInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    creatorId: string
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutCollectionInput
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutCollectionInput
    featuredBidEntries?: FeaturedBidUncheckedCreateNestedManyWithoutCollectionInput
    nfts?: NFTUncheckedCreateNestedManyWithoutCollectionInput
    presale?: PresaleUncheckedCreateNestedOneWithoutCollectionInput
    publicSale?: PublicSaleUncheckedCreateNestedOneWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutFeaturedAsWinnerInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutFeaturedAsWinnerInput, CollectionUncheckedCreateWithoutFeaturedAsWinnerInput>
  }

  export type FeaturedBidUpsertWithWhereUniqueWithoutCycleInput = {
    where: FeaturedBidWhereUniqueInput
    update: XOR<FeaturedBidUpdateWithoutCycleInput, FeaturedBidUncheckedUpdateWithoutCycleInput>
    create: XOR<FeaturedBidCreateWithoutCycleInput, FeaturedBidUncheckedCreateWithoutCycleInput>
  }

  export type FeaturedBidUpdateWithWhereUniqueWithoutCycleInput = {
    where: FeaturedBidWhereUniqueInput
    data: XOR<FeaturedBidUpdateWithoutCycleInput, FeaturedBidUncheckedUpdateWithoutCycleInput>
  }

  export type FeaturedBidUpdateManyWithWhereWithoutCycleInput = {
    where: FeaturedBidScalarWhereInput
    data: XOR<FeaturedBidUpdateManyMutationInput, FeaturedBidUncheckedUpdateManyWithoutCycleInput>
  }

  export type FeaturedBidUpsertWithoutWinnerOfInput = {
    update: XOR<FeaturedBidUpdateWithoutWinnerOfInput, FeaturedBidUncheckedUpdateWithoutWinnerOfInput>
    create: XOR<FeaturedBidCreateWithoutWinnerOfInput, FeaturedBidUncheckedCreateWithoutWinnerOfInput>
    where?: FeaturedBidWhereInput
  }

  export type FeaturedBidUpdateToOneWithWhereWithoutWinnerOfInput = {
    where?: FeaturedBidWhereInput
    data: XOR<FeaturedBidUpdateWithoutWinnerOfInput, FeaturedBidUncheckedUpdateWithoutWinnerOfInput>
  }

  export type FeaturedBidUpdateWithoutWinnerOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidder?: UserUpdateOneWithoutFeaturedBidsNestedInput
    collection?: CollectionUpdateOneRequiredWithoutFeaturedBidEntriesNestedInput
    cycle?: FeaturedCycleUpdateOneRequiredWithoutBidsNestedInput
  }

  export type FeaturedBidUncheckedUpdateWithoutWinnerOfInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    bidderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionContract?: StringFieldUpdateOperationsInput | string
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionUpsertWithoutFeaturedAsWinnerInput = {
    update: XOR<CollectionUpdateWithoutFeaturedAsWinnerInput, CollectionUncheckedUpdateWithoutFeaturedAsWinnerInput>
    create: XOR<CollectionCreateWithoutFeaturedAsWinnerInput, CollectionUncheckedCreateWithoutFeaturedAsWinnerInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutFeaturedAsWinnerInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutFeaturedAsWinnerInput, CollectionUncheckedUpdateWithoutFeaturedAsWinnerInput>
  }

  export type CollectionUpdateWithoutFeaturedAsWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutCollectionNestedInput
    creator?: UserUpdateOneRequiredWithoutCollectionsNestedInput
    deployment?: DeployedContractUpdateOneWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUpdateManyWithoutCollectionNestedInput
    nfts?: NFTUpdateManyWithoutCollectionNestedInput
    presale?: PresaleUpdateOneWithoutCollectionNestedInput
    publicSale?: PublicSaleUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutFeaturedAsWinnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutCollectionNestedInput
    deployment?: DeployedContractUncheckedUpdateOneWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUncheckedUpdateManyWithoutCollectionNestedInput
    nfts?: NFTUncheckedUpdateManyWithoutCollectionNestedInput
    presale?: PresaleUncheckedUpdateOneWithoutCollectionNestedInput
    publicSale?: PublicSaleUncheckedUpdateOneWithoutCollectionNestedInput
  }

  export type UserCreateWithoutFeaturedBidsInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collections?: CollectionCreateNestedManyWithoutCreatorInput
    submissions?: CollectionSubmissionCreateNestedManyWithoutSubmittedByInput
    holderRewardsMulti?: HolderRewardMultiCreateNestedManyWithoutUserInput
    ownedNFTs?: NFTCreateNestedManyWithoutOwnerInput
    rewardClaimLogs?: RewardClaimLogCreateNestedManyWithoutUserInput
    stolenReports?: StolenItemCreateNestedManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutFeaturedBidsInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collections?: CollectionUncheckedCreateNestedManyWithoutCreatorInput
    submissions?: CollectionSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    holderRewardsMulti?: HolderRewardMultiUncheckedCreateNestedManyWithoutUserInput
    ownedNFTs?: NFTUncheckedCreateNestedManyWithoutOwnerInput
    rewardClaimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutUserInput
    stolenReports?: StolenItemUncheckedCreateNestedManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutFeaturedBidsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeaturedBidsInput, UserUncheckedCreateWithoutFeaturedBidsInput>
  }

  export type CollectionCreateWithoutFeaturedBidEntriesInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadCreateNestedManyWithoutCollectionInput
    creator: UserCreateNestedOneWithoutCollectionsInput
    deployment?: DeployedContractCreateNestedOneWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleCreateNestedManyWithoutWinnerCollectionInput
    nfts?: NFTCreateNestedManyWithoutCollectionInput
    presale?: PresaleCreateNestedOneWithoutCollectionInput
    publicSale?: PublicSaleCreateNestedOneWithoutCollectionInput
  }

  export type CollectionUncheckedCreateWithoutFeaturedBidEntriesInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    creatorId: string
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assetUploads?: AssetUploadUncheckedCreateNestedManyWithoutCollectionInput
    deployment?: DeployedContractUncheckedCreateNestedOneWithoutCollectionInput
    featuredAsWinner?: FeaturedCycleUncheckedCreateNestedManyWithoutWinnerCollectionInput
    nfts?: NFTUncheckedCreateNestedManyWithoutCollectionInput
    presale?: PresaleUncheckedCreateNestedOneWithoutCollectionInput
    publicSale?: PublicSaleUncheckedCreateNestedOneWithoutCollectionInput
  }

  export type CollectionCreateOrConnectWithoutFeaturedBidEntriesInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutFeaturedBidEntriesInput, CollectionUncheckedCreateWithoutFeaturedBidEntriesInput>
  }

  export type FeaturedCycleCreateWithoutBidsInput = {
    id?: string
    cycleId: string
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.FeaturedCycleStatus
    minBidWei: Decimal | DecimalJsLike | number | string
    winnerAmountWei?: Decimal | DecimalJsLike | number | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    winnerBid?: FeaturedBidCreateNestedOneWithoutWinnerOfInput
    winnerCollection?: CollectionCreateNestedOneWithoutFeaturedAsWinnerInput
  }

  export type FeaturedCycleUncheckedCreateWithoutBidsInput = {
    id?: string
    cycleId: string
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.FeaturedCycleStatus
    minBidWei: Decimal | DecimalJsLike | number | string
    winnerBidId?: string | null
    winnerCollectionContract?: string | null
    winnerAmountWei?: Decimal | DecimalJsLike | number | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedCycleCreateOrConnectWithoutBidsInput = {
    where: FeaturedCycleWhereUniqueInput
    create: XOR<FeaturedCycleCreateWithoutBidsInput, FeaturedCycleUncheckedCreateWithoutBidsInput>
  }

  export type FeaturedCycleCreateWithoutWinnerBidInput = {
    id?: string
    cycleId: string
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.FeaturedCycleStatus
    minBidWei: Decimal | DecimalJsLike | number | string
    winnerAmountWei?: Decimal | DecimalJsLike | number | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: FeaturedBidCreateNestedManyWithoutCycleInput
    winnerCollection?: CollectionCreateNestedOneWithoutFeaturedAsWinnerInput
  }

  export type FeaturedCycleUncheckedCreateWithoutWinnerBidInput = {
    id?: string
    cycleId: string
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.FeaturedCycleStatus
    minBidWei: Decimal | DecimalJsLike | number | string
    winnerCollectionContract?: string | null
    winnerAmountWei?: Decimal | DecimalJsLike | number | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bids?: FeaturedBidUncheckedCreateNestedManyWithoutCycleInput
  }

  export type FeaturedCycleCreateOrConnectWithoutWinnerBidInput = {
    where: FeaturedCycleWhereUniqueInput
    create: XOR<FeaturedCycleCreateWithoutWinnerBidInput, FeaturedCycleUncheckedCreateWithoutWinnerBidInput>
  }

  export type UserUpsertWithoutFeaturedBidsInput = {
    update: XOR<UserUpdateWithoutFeaturedBidsInput, UserUncheckedUpdateWithoutFeaturedBidsInput>
    create: XOR<UserCreateWithoutFeaturedBidsInput, UserUncheckedCreateWithoutFeaturedBidsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeaturedBidsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeaturedBidsInput, UserUncheckedUpdateWithoutFeaturedBidsInput>
  }

  export type UserUpdateWithoutFeaturedBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUpdateManyWithoutCreatorNestedInput
    submissions?: CollectionSubmissionUpdateManyWithoutSubmittedByNestedInput
    holderRewardsMulti?: HolderRewardMultiUpdateManyWithoutUserNestedInput
    ownedNFTs?: NFTUpdateManyWithoutOwnerNestedInput
    rewardClaimLogs?: RewardClaimLogUpdateManyWithoutUserNestedInput
    stolenReports?: StolenItemUpdateManyWithoutReporterNestedInput
  }

  export type UserUncheckedUpdateWithoutFeaturedBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUncheckedUpdateManyWithoutCreatorNestedInput
    submissions?: CollectionSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    holderRewardsMulti?: HolderRewardMultiUncheckedUpdateManyWithoutUserNestedInput
    ownedNFTs?: NFTUncheckedUpdateManyWithoutOwnerNestedInput
    rewardClaimLogs?: RewardClaimLogUncheckedUpdateManyWithoutUserNestedInput
    stolenReports?: StolenItemUncheckedUpdateManyWithoutReporterNestedInput
  }

  export type CollectionUpsertWithoutFeaturedBidEntriesInput = {
    update: XOR<CollectionUpdateWithoutFeaturedBidEntriesInput, CollectionUncheckedUpdateWithoutFeaturedBidEntriesInput>
    create: XOR<CollectionCreateWithoutFeaturedBidEntriesInput, CollectionUncheckedCreateWithoutFeaturedBidEntriesInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutFeaturedBidEntriesInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutFeaturedBidEntriesInput, CollectionUncheckedUpdateWithoutFeaturedBidEntriesInput>
  }

  export type CollectionUpdateWithoutFeaturedBidEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutCollectionNestedInput
    creator?: UserUpdateOneRequiredWithoutCollectionsNestedInput
    deployment?: DeployedContractUpdateOneWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUpdateManyWithoutWinnerCollectionNestedInput
    nfts?: NFTUpdateManyWithoutCollectionNestedInput
    presale?: PresaleUpdateOneWithoutCollectionNestedInput
    publicSale?: PublicSaleUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutFeaturedBidEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutCollectionNestedInput
    deployment?: DeployedContractUncheckedUpdateOneWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUncheckedUpdateManyWithoutWinnerCollectionNestedInput
    nfts?: NFTUncheckedUpdateManyWithoutCollectionNestedInput
    presale?: PresaleUncheckedUpdateOneWithoutCollectionNestedInput
    publicSale?: PublicSaleUncheckedUpdateOneWithoutCollectionNestedInput
  }

  export type FeaturedCycleUpsertWithoutBidsInput = {
    update: XOR<FeaturedCycleUpdateWithoutBidsInput, FeaturedCycleUncheckedUpdateWithoutBidsInput>
    create: XOR<FeaturedCycleCreateWithoutBidsInput, FeaturedCycleUncheckedCreateWithoutBidsInput>
    where?: FeaturedCycleWhereInput
  }

  export type FeaturedCycleUpdateToOneWithWhereWithoutBidsInput = {
    where?: FeaturedCycleWhereInput
    data: XOR<FeaturedCycleUpdateWithoutBidsInput, FeaturedCycleUncheckedUpdateWithoutBidsInput>
  }

  export type FeaturedCycleUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeaturedCycleStatusFieldUpdateOperationsInput | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winnerAmountWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    winnerBid?: FeaturedBidUpdateOneWithoutWinnerOfNestedInput
    winnerCollection?: CollectionUpdateOneWithoutFeaturedAsWinnerNestedInput
  }

  export type FeaturedCycleUncheckedUpdateWithoutBidsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeaturedCycleStatusFieldUpdateOperationsInput | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winnerBidId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerCollectionContract?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAmountWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedCycleUpsertWithoutWinnerBidInput = {
    update: XOR<FeaturedCycleUpdateWithoutWinnerBidInput, FeaturedCycleUncheckedUpdateWithoutWinnerBidInput>
    create: XOR<FeaturedCycleCreateWithoutWinnerBidInput, FeaturedCycleUncheckedCreateWithoutWinnerBidInput>
    where?: FeaturedCycleWhereInput
  }

  export type FeaturedCycleUpdateToOneWithWhereWithoutWinnerBidInput = {
    where?: FeaturedCycleWhereInput
    data: XOR<FeaturedCycleUpdateWithoutWinnerBidInput, FeaturedCycleUncheckedUpdateWithoutWinnerBidInput>
  }

  export type FeaturedCycleUpdateWithoutWinnerBidInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeaturedCycleStatusFieldUpdateOperationsInput | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winnerAmountWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: FeaturedBidUpdateManyWithoutCycleNestedInput
    winnerCollection?: CollectionUpdateOneWithoutFeaturedAsWinnerNestedInput
  }

  export type FeaturedCycleUncheckedUpdateWithoutWinnerBidInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeaturedCycleStatusFieldUpdateOperationsInput | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winnerCollectionContract?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAmountWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: FeaturedBidUncheckedUpdateManyWithoutCycleNestedInput
  }

  export type AuctionCreateWithoutCurrencyInput = {
    id?: string
    sellerAddress: string
    quantity?: number
    startPriceEtnWei: Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: Decimal | DecimalJsLike | number | string | null
    startPriceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime: Date | string
    status?: $Enums.AuctionStatus
    txHashCreated?: string | null
    txHashFinalized?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highestBidder?: string | null
    nft: NFTCreateNestedOneWithoutAuctionEntriesInput
    bids?: AuctionBidCreateNestedManyWithoutAuctionInput
  }

  export type AuctionUncheckedCreateWithoutCurrencyInput = {
    id?: string
    nftId: string
    sellerAddress: string
    quantity?: number
    startPriceEtnWei: Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: Decimal | DecimalJsLike | number | string | null
    startPriceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime: Date | string
    status?: $Enums.AuctionStatus
    txHashCreated?: string | null
    txHashFinalized?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highestBidder?: string | null
    bids?: AuctionBidUncheckedCreateNestedManyWithoutAuctionInput
  }

  export type AuctionCreateOrConnectWithoutCurrencyInput = {
    where: AuctionWhereUniqueInput
    create: XOR<AuctionCreateWithoutCurrencyInput, AuctionUncheckedCreateWithoutCurrencyInput>
  }

  export type AuctionCreateManyCurrencyInputEnvelope = {
    data: AuctionCreateManyCurrencyInput | AuctionCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type AuctionBidCreateWithoutCurrencyInput = {
    id?: string
    bidderAddress: string
    amountWei: Decimal | DecimalJsLike | number | string
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
    auction: AuctionCreateNestedOneWithoutBidsInput
  }

  export type AuctionBidUncheckedCreateWithoutCurrencyInput = {
    id?: string
    auctionId: string
    bidderAddress: string
    amountWei: Decimal | DecimalJsLike | number | string
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type AuctionBidCreateOrConnectWithoutCurrencyInput = {
    where: AuctionBidWhereUniqueInput
    create: XOR<AuctionBidCreateWithoutCurrencyInput, AuctionBidUncheckedCreateWithoutCurrencyInput>
  }

  export type AuctionBidCreateManyCurrencyInputEnvelope = {
    data: AuctionBidCreateManyCurrencyInput | AuctionBidCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type HolderRewardMultiCreateWithoutCurrencyInput = {
    id?: string
    walletAddress: string
    lastAccPerToken?: Decimal | DecimalJsLike | number | string
    claimedAmount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutHolderRewardsMultiInput
  }

  export type HolderRewardMultiUncheckedCreateWithoutCurrencyInput = {
    id?: string
    userId?: string | null
    walletAddress: string
    lastAccPerToken?: Decimal | DecimalJsLike | number | string
    claimedAmount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type HolderRewardMultiCreateOrConnectWithoutCurrencyInput = {
    where: HolderRewardMultiWhereUniqueInput
    create: XOR<HolderRewardMultiCreateWithoutCurrencyInput, HolderRewardMultiUncheckedCreateWithoutCurrencyInput>
  }

  export type HolderRewardMultiCreateManyCurrencyInputEnvelope = {
    data: HolderRewardMultiCreateManyCurrencyInput | HolderRewardMultiCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceListingCreateWithoutCurrencyInput = {
    id?: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ListingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    txHashCreated?: string | null
    txHashFilled?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nft: NFTCreateNestedOneWithoutListingEntriesInput
  }

  export type MarketplaceListingUncheckedCreateWithoutCurrencyInput = {
    id?: string
    nftId: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ListingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    txHashCreated?: string | null
    txHashFilled?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceListingCreateOrConnectWithoutCurrencyInput = {
    where: MarketplaceListingWhereUniqueInput
    create: XOR<MarketplaceListingCreateWithoutCurrencyInput, MarketplaceListingUncheckedCreateWithoutCurrencyInput>
  }

  export type MarketplaceListingCreateManyCurrencyInputEnvelope = {
    data: MarketplaceListingCreateManyCurrencyInput | MarketplaceListingCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceSaleCreateWithoutCurrencyInput = {
    id?: string
    buyerAddress: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: Decimal | DecimalJsLike | number | string | null
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: string | null
    marketplaceFeeRecipient?: string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
    nft: NFTCreateNestedOneWithoutSalesInput
  }

  export type MarketplaceSaleUncheckedCreateWithoutCurrencyInput = {
    id?: string
    nftId: string
    buyerAddress: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: Decimal | DecimalJsLike | number | string | null
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: string | null
    marketplaceFeeRecipient?: string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type MarketplaceSaleCreateOrConnectWithoutCurrencyInput = {
    where: MarketplaceSaleWhereUniqueInput
    create: XOR<MarketplaceSaleCreateWithoutCurrencyInput, MarketplaceSaleUncheckedCreateWithoutCurrencyInput>
  }

  export type MarketplaceSaleCreateManyCurrencyInputEnvelope = {
    data: MarketplaceSaleCreateManyCurrencyInput | MarketplaceSaleCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type RewardAccumulatorMultiCreateWithoutCurrencyInput = {
    id?: string
    accPerToken?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type RewardAccumulatorMultiUncheckedCreateWithoutCurrencyInput = {
    id?: string
    accPerToken?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type RewardAccumulatorMultiCreateOrConnectWithoutCurrencyInput = {
    where: RewardAccumulatorMultiWhereUniqueInput
    create: XOR<RewardAccumulatorMultiCreateWithoutCurrencyInput, RewardAccumulatorMultiUncheckedCreateWithoutCurrencyInput>
  }

  export type RewardClaimLogCreateWithoutCurrencyInput = {
    id?: string
    walletAddress: string
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutRewardClaimLogsInput
  }

  export type RewardClaimLogUncheckedCreateWithoutCurrencyInput = {
    id?: string
    walletAddress: string
    userId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    timestamp?: Date | string
  }

  export type RewardClaimLogCreateOrConnectWithoutCurrencyInput = {
    where: RewardClaimLogWhereUniqueInput
    create: XOR<RewardClaimLogCreateWithoutCurrencyInput, RewardClaimLogUncheckedCreateWithoutCurrencyInput>
  }

  export type RewardClaimLogCreateManyCurrencyInputEnvelope = {
    data: RewardClaimLogCreateManyCurrencyInput | RewardClaimLogCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type RewardDistributionLogCreateWithoutCurrencyInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    blockNumber?: number | null
    timestamp?: Date | string
    note?: string | null
  }

  export type RewardDistributionLogUncheckedCreateWithoutCurrencyInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    blockNumber?: number | null
    timestamp?: Date | string
    note?: string | null
  }

  export type RewardDistributionLogCreateOrConnectWithoutCurrencyInput = {
    where: RewardDistributionLogWhereUniqueInput
    create: XOR<RewardDistributionLogCreateWithoutCurrencyInput, RewardDistributionLogUncheckedCreateWithoutCurrencyInput>
  }

  export type RewardDistributionLogCreateManyCurrencyInputEnvelope = {
    data: RewardDistributionLogCreateManyCurrencyInput | RewardDistributionLogCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type AuctionUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: AuctionWhereUniqueInput
    update: XOR<AuctionUpdateWithoutCurrencyInput, AuctionUncheckedUpdateWithoutCurrencyInput>
    create: XOR<AuctionCreateWithoutCurrencyInput, AuctionUncheckedCreateWithoutCurrencyInput>
  }

  export type AuctionUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: AuctionWhereUniqueInput
    data: XOR<AuctionUpdateWithoutCurrencyInput, AuctionUncheckedUpdateWithoutCurrencyInput>
  }

  export type AuctionUpdateManyWithWhereWithoutCurrencyInput = {
    where: AuctionScalarWhereInput
    data: XOR<AuctionUpdateManyMutationInput, AuctionUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type AuctionBidUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: AuctionBidWhereUniqueInput
    update: XOR<AuctionBidUpdateWithoutCurrencyInput, AuctionBidUncheckedUpdateWithoutCurrencyInput>
    create: XOR<AuctionBidCreateWithoutCurrencyInput, AuctionBidUncheckedCreateWithoutCurrencyInput>
  }

  export type AuctionBidUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: AuctionBidWhereUniqueInput
    data: XOR<AuctionBidUpdateWithoutCurrencyInput, AuctionBidUncheckedUpdateWithoutCurrencyInput>
  }

  export type AuctionBidUpdateManyWithWhereWithoutCurrencyInput = {
    where: AuctionBidScalarWhereInput
    data: XOR<AuctionBidUpdateManyMutationInput, AuctionBidUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type HolderRewardMultiUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: HolderRewardMultiWhereUniqueInput
    update: XOR<HolderRewardMultiUpdateWithoutCurrencyInput, HolderRewardMultiUncheckedUpdateWithoutCurrencyInput>
    create: XOR<HolderRewardMultiCreateWithoutCurrencyInput, HolderRewardMultiUncheckedCreateWithoutCurrencyInput>
  }

  export type HolderRewardMultiUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: HolderRewardMultiWhereUniqueInput
    data: XOR<HolderRewardMultiUpdateWithoutCurrencyInput, HolderRewardMultiUncheckedUpdateWithoutCurrencyInput>
  }

  export type HolderRewardMultiUpdateManyWithWhereWithoutCurrencyInput = {
    where: HolderRewardMultiScalarWhereInput
    data: XOR<HolderRewardMultiUpdateManyMutationInput, HolderRewardMultiUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type MarketplaceListingUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: MarketplaceListingWhereUniqueInput
    update: XOR<MarketplaceListingUpdateWithoutCurrencyInput, MarketplaceListingUncheckedUpdateWithoutCurrencyInput>
    create: XOR<MarketplaceListingCreateWithoutCurrencyInput, MarketplaceListingUncheckedCreateWithoutCurrencyInput>
  }

  export type MarketplaceListingUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: MarketplaceListingWhereUniqueInput
    data: XOR<MarketplaceListingUpdateWithoutCurrencyInput, MarketplaceListingUncheckedUpdateWithoutCurrencyInput>
  }

  export type MarketplaceListingUpdateManyWithWhereWithoutCurrencyInput = {
    where: MarketplaceListingScalarWhereInput
    data: XOR<MarketplaceListingUpdateManyMutationInput, MarketplaceListingUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type MarketplaceSaleUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: MarketplaceSaleWhereUniqueInput
    update: XOR<MarketplaceSaleUpdateWithoutCurrencyInput, MarketplaceSaleUncheckedUpdateWithoutCurrencyInput>
    create: XOR<MarketplaceSaleCreateWithoutCurrencyInput, MarketplaceSaleUncheckedCreateWithoutCurrencyInput>
  }

  export type MarketplaceSaleUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: MarketplaceSaleWhereUniqueInput
    data: XOR<MarketplaceSaleUpdateWithoutCurrencyInput, MarketplaceSaleUncheckedUpdateWithoutCurrencyInput>
  }

  export type MarketplaceSaleUpdateManyWithWhereWithoutCurrencyInput = {
    where: MarketplaceSaleScalarWhereInput
    data: XOR<MarketplaceSaleUpdateManyMutationInput, MarketplaceSaleUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type RewardAccumulatorMultiUpsertWithoutCurrencyInput = {
    update: XOR<RewardAccumulatorMultiUpdateWithoutCurrencyInput, RewardAccumulatorMultiUncheckedUpdateWithoutCurrencyInput>
    create: XOR<RewardAccumulatorMultiCreateWithoutCurrencyInput, RewardAccumulatorMultiUncheckedCreateWithoutCurrencyInput>
    where?: RewardAccumulatorMultiWhereInput
  }

  export type RewardAccumulatorMultiUpdateToOneWithWhereWithoutCurrencyInput = {
    where?: RewardAccumulatorMultiWhereInput
    data: XOR<RewardAccumulatorMultiUpdateWithoutCurrencyInput, RewardAccumulatorMultiUncheckedUpdateWithoutCurrencyInput>
  }

  export type RewardAccumulatorMultiUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardAccumulatorMultiUncheckedUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardClaimLogUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: RewardClaimLogWhereUniqueInput
    update: XOR<RewardClaimLogUpdateWithoutCurrencyInput, RewardClaimLogUncheckedUpdateWithoutCurrencyInput>
    create: XOR<RewardClaimLogCreateWithoutCurrencyInput, RewardClaimLogUncheckedCreateWithoutCurrencyInput>
  }

  export type RewardClaimLogUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: RewardClaimLogWhereUniqueInput
    data: XOR<RewardClaimLogUpdateWithoutCurrencyInput, RewardClaimLogUncheckedUpdateWithoutCurrencyInput>
  }

  export type RewardClaimLogUpdateManyWithWhereWithoutCurrencyInput = {
    where: RewardClaimLogScalarWhereInput
    data: XOR<RewardClaimLogUpdateManyMutationInput, RewardClaimLogUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type RewardDistributionLogUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: RewardDistributionLogWhereUniqueInput
    update: XOR<RewardDistributionLogUpdateWithoutCurrencyInput, RewardDistributionLogUncheckedUpdateWithoutCurrencyInput>
    create: XOR<RewardDistributionLogCreateWithoutCurrencyInput, RewardDistributionLogUncheckedCreateWithoutCurrencyInput>
  }

  export type RewardDistributionLogUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: RewardDistributionLogWhereUniqueInput
    data: XOR<RewardDistributionLogUpdateWithoutCurrencyInput, RewardDistributionLogUncheckedUpdateWithoutCurrencyInput>
  }

  export type RewardDistributionLogUpdateManyWithWhereWithoutCurrencyInput = {
    where: RewardDistributionLogScalarWhereInput
    data: XOR<RewardDistributionLogUpdateManyMutationInput, RewardDistributionLogUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type RewardDistributionLogScalarWhereInput = {
    AND?: RewardDistributionLogScalarWhereInput | RewardDistributionLogScalarWhereInput[]
    OR?: RewardDistributionLogScalarWhereInput[]
    NOT?: RewardDistributionLogScalarWhereInput | RewardDistributionLogScalarWhereInput[]
    id?: StringFilter<"RewardDistributionLog"> | string
    currencyId?: StringFilter<"RewardDistributionLog"> | string
    amount?: DecimalFilter<"RewardDistributionLog"> | Decimal | DecimalJsLike | number | string
    txHash?: StringNullableFilter<"RewardDistributionLog"> | string | null
    blockNumber?: IntNullableFilter<"RewardDistributionLog"> | number | null
    timestamp?: DateTimeFilter<"RewardDistributionLog"> | Date | string
    note?: StringNullableFilter<"RewardDistributionLog"> | string | null
  }

  export type CurrencyCreateWithoutSalesInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionCreateNestedManyWithoutCurrencyInput
    bids?: AuctionBidCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiCreateNestedOneWithoutCurrencyInput
    claimLogs?: RewardClaimLogCreateNestedManyWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutSalesInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionUncheckedCreateNestedManyWithoutCurrencyInput
    bids?: AuctionBidUncheckedCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiUncheckedCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedCreateNestedOneWithoutCurrencyInput
    claimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutSalesInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutSalesInput, CurrencyUncheckedCreateWithoutSalesInput>
  }

  export type NFTCreateWithoutSalesInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionCreateNestedManyWithoutNftInput
    listingEntries?: MarketplaceListingCreateNestedManyWithoutNftInput
    collection?: CollectionCreateNestedOneWithoutNftsInput
    owner?: UserCreateNestedOneWithoutOwnedNFTsInput
    single1155?: Single1155CreateNestedOneWithoutNftsInput
    single721?: Single721CreateNestedOneWithoutNftsInput
    activities?: NFTActivityCreateNestedManyWithoutNftInput
  }

  export type NFTUncheckedCreateWithoutSalesInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    ownerId?: string | null
    collectionId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedCreateNestedManyWithoutNftInput
    listingEntries?: MarketplaceListingUncheckedCreateNestedManyWithoutNftInput
    activities?: NFTActivityUncheckedCreateNestedManyWithoutNftInput
  }

  export type NFTCreateOrConnectWithoutSalesInput = {
    where: NFTWhereUniqueInput
    create: XOR<NFTCreateWithoutSalesInput, NFTUncheckedCreateWithoutSalesInput>
  }

  export type CurrencyUpsertWithoutSalesInput = {
    update: XOR<CurrencyUpdateWithoutSalesInput, CurrencyUncheckedUpdateWithoutSalesInput>
    create: XOR<CurrencyCreateWithoutSalesInput, CurrencyUncheckedCreateWithoutSalesInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutSalesInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutSalesInput, CurrencyUncheckedUpdateWithoutSalesInput>
  }

  export type CurrencyUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUpdateManyWithoutCurrencyNestedInput
    bids?: AuctionBidUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUpdateOneWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUpdateManyWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUncheckedUpdateManyWithoutCurrencyNestedInput
    bids?: AuctionBidUncheckedUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUncheckedUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedUpdateOneWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUncheckedUpdateManyWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type NFTUpsertWithoutSalesInput = {
    update: XOR<NFTUpdateWithoutSalesInput, NFTUncheckedUpdateWithoutSalesInput>
    create: XOR<NFTCreateWithoutSalesInput, NFTUncheckedCreateWithoutSalesInput>
    where?: NFTWhereInput
  }

  export type NFTUpdateToOneWithWhereWithoutSalesInput = {
    where?: NFTWhereInput
    data: XOR<NFTUpdateWithoutSalesInput, NFTUncheckedUpdateWithoutSalesInput>
  }

  export type NFTUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUpdateManyWithoutNftNestedInput
    listingEntries?: MarketplaceListingUpdateManyWithoutNftNestedInput
    collection?: CollectionUpdateOneWithoutNftsNestedInput
    owner?: UserUpdateOneWithoutOwnedNFTsNestedInput
    single1155?: Single1155UpdateOneWithoutNftsNestedInput
    single721?: Single721UpdateOneWithoutNftsNestedInput
    activities?: NFTActivityUpdateManyWithoutNftNestedInput
  }

  export type NFTUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedUpdateManyWithoutNftNestedInput
    listingEntries?: MarketplaceListingUncheckedUpdateManyWithoutNftNestedInput
    activities?: NFTActivityUncheckedUpdateManyWithoutNftNestedInput
  }

  export type CurrencyCreateWithoutRewardAccumulatorsInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionCreateNestedManyWithoutCurrencyInput
    bids?: AuctionBidCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleCreateNestedManyWithoutCurrencyInput
    claimLogs?: RewardClaimLogCreateNestedManyWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutRewardAccumulatorsInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionUncheckedCreateNestedManyWithoutCurrencyInput
    bids?: AuctionBidUncheckedCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiUncheckedCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutCurrencyInput
    claimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutRewardAccumulatorsInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutRewardAccumulatorsInput, CurrencyUncheckedCreateWithoutRewardAccumulatorsInput>
  }

  export type CurrencyUpsertWithoutRewardAccumulatorsInput = {
    update: XOR<CurrencyUpdateWithoutRewardAccumulatorsInput, CurrencyUncheckedUpdateWithoutRewardAccumulatorsInput>
    create: XOR<CurrencyCreateWithoutRewardAccumulatorsInput, CurrencyUncheckedCreateWithoutRewardAccumulatorsInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutRewardAccumulatorsInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutRewardAccumulatorsInput, CurrencyUncheckedUpdateWithoutRewardAccumulatorsInput>
  }

  export type CurrencyUpdateWithoutRewardAccumulatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUpdateManyWithoutCurrencyNestedInput
    bids?: AuctionBidUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUpdateManyWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutRewardAccumulatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUncheckedUpdateManyWithoutCurrencyNestedInput
    bids?: AuctionBidUncheckedUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUncheckedUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUncheckedUpdateManyWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyCreateWithoutHolderRewardsInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionCreateNestedManyWithoutCurrencyInput
    bids?: AuctionBidCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiCreateNestedOneWithoutCurrencyInput
    claimLogs?: RewardClaimLogCreateNestedManyWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutHolderRewardsInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionUncheckedCreateNestedManyWithoutCurrencyInput
    bids?: AuctionBidUncheckedCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedCreateNestedOneWithoutCurrencyInput
    claimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutHolderRewardsInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutHolderRewardsInput, CurrencyUncheckedCreateWithoutHolderRewardsInput>
  }

  export type UserCreateWithoutHolderRewardsMultiInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collections?: CollectionCreateNestedManyWithoutCreatorInput
    submissions?: CollectionSubmissionCreateNestedManyWithoutSubmittedByInput
    featuredBids?: FeaturedBidCreateNestedManyWithoutBidderInput
    ownedNFTs?: NFTCreateNestedManyWithoutOwnerInput
    rewardClaimLogs?: RewardClaimLogCreateNestedManyWithoutUserInput
    stolenReports?: StolenItemCreateNestedManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutHolderRewardsMultiInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collections?: CollectionUncheckedCreateNestedManyWithoutCreatorInput
    submissions?: CollectionSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    featuredBids?: FeaturedBidUncheckedCreateNestedManyWithoutBidderInput
    ownedNFTs?: NFTUncheckedCreateNestedManyWithoutOwnerInput
    rewardClaimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutUserInput
    stolenReports?: StolenItemUncheckedCreateNestedManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutHolderRewardsMultiInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHolderRewardsMultiInput, UserUncheckedCreateWithoutHolderRewardsMultiInput>
  }

  export type CurrencyUpsertWithoutHolderRewardsInput = {
    update: XOR<CurrencyUpdateWithoutHolderRewardsInput, CurrencyUncheckedUpdateWithoutHolderRewardsInput>
    create: XOR<CurrencyCreateWithoutHolderRewardsInput, CurrencyUncheckedCreateWithoutHolderRewardsInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutHolderRewardsInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutHolderRewardsInput, CurrencyUncheckedUpdateWithoutHolderRewardsInput>
  }

  export type CurrencyUpdateWithoutHolderRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUpdateManyWithoutCurrencyNestedInput
    bids?: AuctionBidUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUpdateOneWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUpdateManyWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutHolderRewardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUncheckedUpdateManyWithoutCurrencyNestedInput
    bids?: AuctionBidUncheckedUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedUpdateOneWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUncheckedUpdateManyWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type UserUpsertWithoutHolderRewardsMultiInput = {
    update: XOR<UserUpdateWithoutHolderRewardsMultiInput, UserUncheckedUpdateWithoutHolderRewardsMultiInput>
    create: XOR<UserCreateWithoutHolderRewardsMultiInput, UserUncheckedCreateWithoutHolderRewardsMultiInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHolderRewardsMultiInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHolderRewardsMultiInput, UserUncheckedUpdateWithoutHolderRewardsMultiInput>
  }

  export type UserUpdateWithoutHolderRewardsMultiInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUpdateManyWithoutCreatorNestedInput
    submissions?: CollectionSubmissionUpdateManyWithoutSubmittedByNestedInput
    featuredBids?: FeaturedBidUpdateManyWithoutBidderNestedInput
    ownedNFTs?: NFTUpdateManyWithoutOwnerNestedInput
    rewardClaimLogs?: RewardClaimLogUpdateManyWithoutUserNestedInput
    stolenReports?: StolenItemUpdateManyWithoutReporterNestedInput
  }

  export type UserUncheckedUpdateWithoutHolderRewardsMultiInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUncheckedUpdateManyWithoutCreatorNestedInput
    submissions?: CollectionSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    featuredBids?: FeaturedBidUncheckedUpdateManyWithoutBidderNestedInput
    ownedNFTs?: NFTUncheckedUpdateManyWithoutOwnerNestedInput
    rewardClaimLogs?: RewardClaimLogUncheckedUpdateManyWithoutUserNestedInput
    stolenReports?: StolenItemUncheckedUpdateManyWithoutReporterNestedInput
  }

  export type CurrencyCreateWithoutDistributionLogsInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionCreateNestedManyWithoutCurrencyInput
    bids?: AuctionBidCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiCreateNestedOneWithoutCurrencyInput
    claimLogs?: RewardClaimLogCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutDistributionLogsInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionUncheckedCreateNestedManyWithoutCurrencyInput
    bids?: AuctionBidUncheckedCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiUncheckedCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedCreateNestedOneWithoutCurrencyInput
    claimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutDistributionLogsInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutDistributionLogsInput, CurrencyUncheckedCreateWithoutDistributionLogsInput>
  }

  export type CurrencyUpsertWithoutDistributionLogsInput = {
    update: XOR<CurrencyUpdateWithoutDistributionLogsInput, CurrencyUncheckedUpdateWithoutDistributionLogsInput>
    create: XOR<CurrencyCreateWithoutDistributionLogsInput, CurrencyUncheckedCreateWithoutDistributionLogsInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutDistributionLogsInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutDistributionLogsInput, CurrencyUncheckedUpdateWithoutDistributionLogsInput>
  }

  export type CurrencyUpdateWithoutDistributionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUpdateManyWithoutCurrencyNestedInput
    bids?: AuctionBidUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUpdateOneWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutDistributionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUncheckedUpdateManyWithoutCurrencyNestedInput
    bids?: AuctionBidUncheckedUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUncheckedUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedUpdateOneWithoutCurrencyNestedInput
    claimLogs?: RewardClaimLogUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyCreateWithoutClaimLogsInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionCreateNestedManyWithoutCurrencyInput
    bids?: AuctionBidCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiCreateNestedOneWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyUncheckedCreateWithoutClaimLogsInput = {
    id?: string
    symbol: string
    decimals?: number
    kind?: $Enums.CurrencyKind
    tokenAddress?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    auctions?: AuctionUncheckedCreateNestedManyWithoutCurrencyInput
    bids?: AuctionBidUncheckedCreateNestedManyWithoutCurrencyInput
    holderRewards?: HolderRewardMultiUncheckedCreateNestedManyWithoutCurrencyInput
    listings?: MarketplaceListingUncheckedCreateNestedManyWithoutCurrencyInput
    sales?: MarketplaceSaleUncheckedCreateNestedManyWithoutCurrencyInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedCreateNestedOneWithoutCurrencyInput
    distributionLogs?: RewardDistributionLogUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type CurrencyCreateOrConnectWithoutClaimLogsInput = {
    where: CurrencyWhereUniqueInput
    create: XOR<CurrencyCreateWithoutClaimLogsInput, CurrencyUncheckedCreateWithoutClaimLogsInput>
  }

  export type UserCreateWithoutRewardClaimLogsInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collections?: CollectionCreateNestedManyWithoutCreatorInput
    submissions?: CollectionSubmissionCreateNestedManyWithoutSubmittedByInput
    featuredBids?: FeaturedBidCreateNestedManyWithoutBidderInput
    holderRewardsMulti?: HolderRewardMultiCreateNestedManyWithoutUserInput
    ownedNFTs?: NFTCreateNestedManyWithoutOwnerInput
    stolenReports?: StolenItemCreateNestedManyWithoutReporterInput
  }

  export type UserUncheckedCreateWithoutRewardClaimLogsInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collections?: CollectionUncheckedCreateNestedManyWithoutCreatorInput
    submissions?: CollectionSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    featuredBids?: FeaturedBidUncheckedCreateNestedManyWithoutBidderInput
    holderRewardsMulti?: HolderRewardMultiUncheckedCreateNestedManyWithoutUserInput
    ownedNFTs?: NFTUncheckedCreateNestedManyWithoutOwnerInput
    stolenReports?: StolenItemUncheckedCreateNestedManyWithoutReporterInput
  }

  export type UserCreateOrConnectWithoutRewardClaimLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRewardClaimLogsInput, UserUncheckedCreateWithoutRewardClaimLogsInput>
  }

  export type CurrencyUpsertWithoutClaimLogsInput = {
    update: XOR<CurrencyUpdateWithoutClaimLogsInput, CurrencyUncheckedUpdateWithoutClaimLogsInput>
    create: XOR<CurrencyCreateWithoutClaimLogsInput, CurrencyUncheckedCreateWithoutClaimLogsInput>
    where?: CurrencyWhereInput
  }

  export type CurrencyUpdateToOneWithWhereWithoutClaimLogsInput = {
    where?: CurrencyWhereInput
    data: XOR<CurrencyUpdateWithoutClaimLogsInput, CurrencyUncheckedUpdateWithoutClaimLogsInput>
  }

  export type CurrencyUpdateWithoutClaimLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUpdateManyWithoutCurrencyNestedInput
    bids?: AuctionBidUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUpdateOneWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUpdateManyWithoutCurrencyNestedInput
  }

  export type CurrencyUncheckedUpdateWithoutClaimLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    kind?: EnumCurrencyKindFieldUpdateOperationsInput | $Enums.CurrencyKind
    tokenAddress?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auctions?: AuctionUncheckedUpdateManyWithoutCurrencyNestedInput
    bids?: AuctionBidUncheckedUpdateManyWithoutCurrencyNestedInput
    holderRewards?: HolderRewardMultiUncheckedUpdateManyWithoutCurrencyNestedInput
    listings?: MarketplaceListingUncheckedUpdateManyWithoutCurrencyNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutCurrencyNestedInput
    rewardAccumulators?: RewardAccumulatorMultiUncheckedUpdateOneWithoutCurrencyNestedInput
    distributionLogs?: RewardDistributionLogUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type UserUpsertWithoutRewardClaimLogsInput = {
    update: XOR<UserUpdateWithoutRewardClaimLogsInput, UserUncheckedUpdateWithoutRewardClaimLogsInput>
    create: XOR<UserCreateWithoutRewardClaimLogsInput, UserUncheckedCreateWithoutRewardClaimLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRewardClaimLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRewardClaimLogsInput, UserUncheckedUpdateWithoutRewardClaimLogsInput>
  }

  export type UserUpdateWithoutRewardClaimLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUpdateManyWithoutCreatorNestedInput
    submissions?: CollectionSubmissionUpdateManyWithoutSubmittedByNestedInput
    featuredBids?: FeaturedBidUpdateManyWithoutBidderNestedInput
    holderRewardsMulti?: HolderRewardMultiUpdateManyWithoutUserNestedInput
    ownedNFTs?: NFTUpdateManyWithoutOwnerNestedInput
    stolenReports?: StolenItemUpdateManyWithoutReporterNestedInput
  }

  export type UserUncheckedUpdateWithoutRewardClaimLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUncheckedUpdateManyWithoutCreatorNestedInput
    submissions?: CollectionSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    featuredBids?: FeaturedBidUncheckedUpdateManyWithoutBidderNestedInput
    holderRewardsMulti?: HolderRewardMultiUncheckedUpdateManyWithoutUserNestedInput
    ownedNFTs?: NFTUncheckedUpdateManyWithoutOwnerNestedInput
    stolenReports?: StolenItemUncheckedUpdateManyWithoutReporterNestedInput
  }

  export type UserCreateWithoutStolenReportsInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collections?: CollectionCreateNestedManyWithoutCreatorInput
    submissions?: CollectionSubmissionCreateNestedManyWithoutSubmittedByInput
    featuredBids?: FeaturedBidCreateNestedManyWithoutBidderInput
    holderRewardsMulti?: HolderRewardMultiCreateNestedManyWithoutUserInput
    ownedNFTs?: NFTCreateNestedManyWithoutOwnerInput
    rewardClaimLogs?: RewardClaimLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStolenReportsInput = {
    id?: string
    walletAddress: string
    username: string
    bio?: string | null
    profileBanner?: string | null
    profileAvatar: string
    x?: string | null
    instagram?: string | null
    website?: string | null
    telegram?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    collections?: CollectionUncheckedCreateNestedManyWithoutCreatorInput
    submissions?: CollectionSubmissionUncheckedCreateNestedManyWithoutSubmittedByInput
    featuredBids?: FeaturedBidUncheckedCreateNestedManyWithoutBidderInput
    holderRewardsMulti?: HolderRewardMultiUncheckedCreateNestedManyWithoutUserInput
    ownedNFTs?: NFTUncheckedCreateNestedManyWithoutOwnerInput
    rewardClaimLogs?: RewardClaimLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStolenReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStolenReportsInput, UserUncheckedCreateWithoutStolenReportsInput>
  }

  export type UserUpsertWithoutStolenReportsInput = {
    update: XOR<UserUpdateWithoutStolenReportsInput, UserUncheckedUpdateWithoutStolenReportsInput>
    create: XOR<UserCreateWithoutStolenReportsInput, UserUncheckedCreateWithoutStolenReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStolenReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStolenReportsInput, UserUncheckedUpdateWithoutStolenReportsInput>
  }

  export type UserUpdateWithoutStolenReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUpdateManyWithoutCreatorNestedInput
    submissions?: CollectionSubmissionUpdateManyWithoutSubmittedByNestedInput
    featuredBids?: FeaturedBidUpdateManyWithoutBidderNestedInput
    holderRewardsMulti?: HolderRewardMultiUpdateManyWithoutUserNestedInput
    ownedNFTs?: NFTUpdateManyWithoutOwnerNestedInput
    rewardClaimLogs?: RewardClaimLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStolenReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profileBanner?: NullableStringFieldUpdateOperationsInput | string | null
    profileAvatar?: StringFieldUpdateOperationsInput | string
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUncheckedUpdateManyWithoutCreatorNestedInput
    submissions?: CollectionSubmissionUncheckedUpdateManyWithoutSubmittedByNestedInput
    featuredBids?: FeaturedBidUncheckedUpdateManyWithoutBidderNestedInput
    holderRewardsMulti?: HolderRewardMultiUncheckedUpdateManyWithoutUserNestedInput
    ownedNFTs?: NFTUncheckedUpdateManyWithoutOwnerNestedInput
    rewardClaimLogs?: RewardClaimLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MultisigOwnerCreateWithoutSafeInput = {
    id?: string
    ownerAddress: string
    addedAt?: Date | string
    removedAt?: Date | string | null
  }

  export type MultisigOwnerUncheckedCreateWithoutSafeInput = {
    id?: string
    ownerAddress: string
    addedAt?: Date | string
    removedAt?: Date | string | null
  }

  export type MultisigOwnerCreateOrConnectWithoutSafeInput = {
    where: MultisigOwnerWhereUniqueInput
    create: XOR<MultisigOwnerCreateWithoutSafeInput, MultisigOwnerUncheckedCreateWithoutSafeInput>
  }

  export type MultisigOwnerCreateManySafeInputEnvelope = {
    data: MultisigOwnerCreateManySafeInput | MultisigOwnerCreateManySafeInput[]
    skipDuplicates?: boolean
  }

  export type MultisigTxCreateWithoutSafeInput = {
    id?: string
    nonce: number
    to: string
    valueWei?: Decimal | DecimalJsLike | number | string
    dataHex?: string | null
    operation?: number | null
    submittedBy?: string | null
    status?: $Enums.MultisigTxStatus
    executedTxHash?: string | null
    createdAt?: Date | string
    executedAt?: Date | string | null
    approvals?: MultisigApprovalCreateNestedManyWithoutTxInput
  }

  export type MultisigTxUncheckedCreateWithoutSafeInput = {
    id?: string
    nonce: number
    to: string
    valueWei?: Decimal | DecimalJsLike | number | string
    dataHex?: string | null
    operation?: number | null
    submittedBy?: string | null
    status?: $Enums.MultisigTxStatus
    executedTxHash?: string | null
    createdAt?: Date | string
    executedAt?: Date | string | null
    approvals?: MultisigApprovalUncheckedCreateNestedManyWithoutTxInput
  }

  export type MultisigTxCreateOrConnectWithoutSafeInput = {
    where: MultisigTxWhereUniqueInput
    create: XOR<MultisigTxCreateWithoutSafeInput, MultisigTxUncheckedCreateWithoutSafeInput>
  }

  export type MultisigTxCreateManySafeInputEnvelope = {
    data: MultisigTxCreateManySafeInput | MultisigTxCreateManySafeInput[]
    skipDuplicates?: boolean
  }

  export type MultisigOwnerUpsertWithWhereUniqueWithoutSafeInput = {
    where: MultisigOwnerWhereUniqueInput
    update: XOR<MultisigOwnerUpdateWithoutSafeInput, MultisigOwnerUncheckedUpdateWithoutSafeInput>
    create: XOR<MultisigOwnerCreateWithoutSafeInput, MultisigOwnerUncheckedCreateWithoutSafeInput>
  }

  export type MultisigOwnerUpdateWithWhereUniqueWithoutSafeInput = {
    where: MultisigOwnerWhereUniqueInput
    data: XOR<MultisigOwnerUpdateWithoutSafeInput, MultisigOwnerUncheckedUpdateWithoutSafeInput>
  }

  export type MultisigOwnerUpdateManyWithWhereWithoutSafeInput = {
    where: MultisigOwnerScalarWhereInput
    data: XOR<MultisigOwnerUpdateManyMutationInput, MultisigOwnerUncheckedUpdateManyWithoutSafeInput>
  }

  export type MultisigOwnerScalarWhereInput = {
    AND?: MultisigOwnerScalarWhereInput | MultisigOwnerScalarWhereInput[]
    OR?: MultisigOwnerScalarWhereInput[]
    NOT?: MultisigOwnerScalarWhereInput | MultisigOwnerScalarWhereInput[]
    id?: StringFilter<"MultisigOwner"> | string
    safeId?: StringFilter<"MultisigOwner"> | string
    ownerAddress?: StringFilter<"MultisigOwner"> | string
    addedAt?: DateTimeFilter<"MultisigOwner"> | Date | string
    removedAt?: DateTimeNullableFilter<"MultisigOwner"> | Date | string | null
  }

  export type MultisigTxUpsertWithWhereUniqueWithoutSafeInput = {
    where: MultisigTxWhereUniqueInput
    update: XOR<MultisigTxUpdateWithoutSafeInput, MultisigTxUncheckedUpdateWithoutSafeInput>
    create: XOR<MultisigTxCreateWithoutSafeInput, MultisigTxUncheckedCreateWithoutSafeInput>
  }

  export type MultisigTxUpdateWithWhereUniqueWithoutSafeInput = {
    where: MultisigTxWhereUniqueInput
    data: XOR<MultisigTxUpdateWithoutSafeInput, MultisigTxUncheckedUpdateWithoutSafeInput>
  }

  export type MultisigTxUpdateManyWithWhereWithoutSafeInput = {
    where: MultisigTxScalarWhereInput
    data: XOR<MultisigTxUpdateManyMutationInput, MultisigTxUncheckedUpdateManyWithoutSafeInput>
  }

  export type MultisigTxScalarWhereInput = {
    AND?: MultisigTxScalarWhereInput | MultisigTxScalarWhereInput[]
    OR?: MultisigTxScalarWhereInput[]
    NOT?: MultisigTxScalarWhereInput | MultisigTxScalarWhereInput[]
    id?: StringFilter<"MultisigTx"> | string
    safeId?: StringFilter<"MultisigTx"> | string
    nonce?: IntFilter<"MultisigTx"> | number
    to?: StringFilter<"MultisigTx"> | string
    valueWei?: DecimalFilter<"MultisigTx"> | Decimal | DecimalJsLike | number | string
    dataHex?: StringNullableFilter<"MultisigTx"> | string | null
    operation?: IntNullableFilter<"MultisigTx"> | number | null
    submittedBy?: StringNullableFilter<"MultisigTx"> | string | null
    status?: EnumMultisigTxStatusFilter<"MultisigTx"> | $Enums.MultisigTxStatus
    executedTxHash?: StringNullableFilter<"MultisigTx"> | string | null
    createdAt?: DateTimeFilter<"MultisigTx"> | Date | string
    executedAt?: DateTimeNullableFilter<"MultisigTx"> | Date | string | null
  }

  export type MultisigSafeCreateWithoutOwnersInput = {
    id?: string
    contract: string
    name?: string | null
    threshold: number
    createdAt?: Date | string
    updatedAt?: Date | string
    txs?: MultisigTxCreateNestedManyWithoutSafeInput
  }

  export type MultisigSafeUncheckedCreateWithoutOwnersInput = {
    id?: string
    contract: string
    name?: string | null
    threshold: number
    createdAt?: Date | string
    updatedAt?: Date | string
    txs?: MultisigTxUncheckedCreateNestedManyWithoutSafeInput
  }

  export type MultisigSafeCreateOrConnectWithoutOwnersInput = {
    where: MultisigSafeWhereUniqueInput
    create: XOR<MultisigSafeCreateWithoutOwnersInput, MultisigSafeUncheckedCreateWithoutOwnersInput>
  }

  export type MultisigSafeUpsertWithoutOwnersInput = {
    update: XOR<MultisigSafeUpdateWithoutOwnersInput, MultisigSafeUncheckedUpdateWithoutOwnersInput>
    create: XOR<MultisigSafeCreateWithoutOwnersInput, MultisigSafeUncheckedCreateWithoutOwnersInput>
    where?: MultisigSafeWhereInput
  }

  export type MultisigSafeUpdateToOneWithWhereWithoutOwnersInput = {
    where?: MultisigSafeWhereInput
    data: XOR<MultisigSafeUpdateWithoutOwnersInput, MultisigSafeUncheckedUpdateWithoutOwnersInput>
  }

  export type MultisigSafeUpdateWithoutOwnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    txs?: MultisigTxUpdateManyWithoutSafeNestedInput
  }

  export type MultisigSafeUncheckedUpdateWithoutOwnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    txs?: MultisigTxUncheckedUpdateManyWithoutSafeNestedInput
  }

  export type MultisigApprovalCreateWithoutTxInput = {
    id?: string
    ownerAddress: string
    signature?: string | null
    createdAt?: Date | string
  }

  export type MultisigApprovalUncheckedCreateWithoutTxInput = {
    id?: string
    ownerAddress: string
    signature?: string | null
    createdAt?: Date | string
  }

  export type MultisigApprovalCreateOrConnectWithoutTxInput = {
    where: MultisigApprovalWhereUniqueInput
    create: XOR<MultisigApprovalCreateWithoutTxInput, MultisigApprovalUncheckedCreateWithoutTxInput>
  }

  export type MultisigApprovalCreateManyTxInputEnvelope = {
    data: MultisigApprovalCreateManyTxInput | MultisigApprovalCreateManyTxInput[]
    skipDuplicates?: boolean
  }

  export type MultisigSafeCreateWithoutTxsInput = {
    id?: string
    contract: string
    name?: string | null
    threshold: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owners?: MultisigOwnerCreateNestedManyWithoutSafeInput
  }

  export type MultisigSafeUncheckedCreateWithoutTxsInput = {
    id?: string
    contract: string
    name?: string | null
    threshold: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owners?: MultisigOwnerUncheckedCreateNestedManyWithoutSafeInput
  }

  export type MultisigSafeCreateOrConnectWithoutTxsInput = {
    where: MultisigSafeWhereUniqueInput
    create: XOR<MultisigSafeCreateWithoutTxsInput, MultisigSafeUncheckedCreateWithoutTxsInput>
  }

  export type MultisigApprovalUpsertWithWhereUniqueWithoutTxInput = {
    where: MultisigApprovalWhereUniqueInput
    update: XOR<MultisigApprovalUpdateWithoutTxInput, MultisigApprovalUncheckedUpdateWithoutTxInput>
    create: XOR<MultisigApprovalCreateWithoutTxInput, MultisigApprovalUncheckedCreateWithoutTxInput>
  }

  export type MultisigApprovalUpdateWithWhereUniqueWithoutTxInput = {
    where: MultisigApprovalWhereUniqueInput
    data: XOR<MultisigApprovalUpdateWithoutTxInput, MultisigApprovalUncheckedUpdateWithoutTxInput>
  }

  export type MultisigApprovalUpdateManyWithWhereWithoutTxInput = {
    where: MultisigApprovalScalarWhereInput
    data: XOR<MultisigApprovalUpdateManyMutationInput, MultisigApprovalUncheckedUpdateManyWithoutTxInput>
  }

  export type MultisigApprovalScalarWhereInput = {
    AND?: MultisigApprovalScalarWhereInput | MultisigApprovalScalarWhereInput[]
    OR?: MultisigApprovalScalarWhereInput[]
    NOT?: MultisigApprovalScalarWhereInput | MultisigApprovalScalarWhereInput[]
    id?: StringFilter<"MultisigApproval"> | string
    txId?: StringFilter<"MultisigApproval"> | string
    ownerAddress?: StringFilter<"MultisigApproval"> | string
    signature?: StringNullableFilter<"MultisigApproval"> | string | null
    createdAt?: DateTimeFilter<"MultisigApproval"> | Date | string
  }

  export type MultisigSafeUpsertWithoutTxsInput = {
    update: XOR<MultisigSafeUpdateWithoutTxsInput, MultisigSafeUncheckedUpdateWithoutTxsInput>
    create: XOR<MultisigSafeCreateWithoutTxsInput, MultisigSafeUncheckedCreateWithoutTxsInput>
    where?: MultisigSafeWhereInput
  }

  export type MultisigSafeUpdateToOneWithWhereWithoutTxsInput = {
    where?: MultisigSafeWhereInput
    data: XOR<MultisigSafeUpdateWithoutTxsInput, MultisigSafeUncheckedUpdateWithoutTxsInput>
  }

  export type MultisigSafeUpdateWithoutTxsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners?: MultisigOwnerUpdateManyWithoutSafeNestedInput
  }

  export type MultisigSafeUncheckedUpdateWithoutTxsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    threshold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owners?: MultisigOwnerUncheckedUpdateManyWithoutSafeNestedInput
  }

  export type MultisigTxCreateWithoutApprovalsInput = {
    id?: string
    nonce: number
    to: string
    valueWei?: Decimal | DecimalJsLike | number | string
    dataHex?: string | null
    operation?: number | null
    submittedBy?: string | null
    status?: $Enums.MultisigTxStatus
    executedTxHash?: string | null
    createdAt?: Date | string
    executedAt?: Date | string | null
    safe: MultisigSafeCreateNestedOneWithoutTxsInput
  }

  export type MultisigTxUncheckedCreateWithoutApprovalsInput = {
    id?: string
    safeId: string
    nonce: number
    to: string
    valueWei?: Decimal | DecimalJsLike | number | string
    dataHex?: string | null
    operation?: number | null
    submittedBy?: string | null
    status?: $Enums.MultisigTxStatus
    executedTxHash?: string | null
    createdAt?: Date | string
    executedAt?: Date | string | null
  }

  export type MultisigTxCreateOrConnectWithoutApprovalsInput = {
    where: MultisigTxWhereUniqueInput
    create: XOR<MultisigTxCreateWithoutApprovalsInput, MultisigTxUncheckedCreateWithoutApprovalsInput>
  }

  export type MultisigTxUpsertWithoutApprovalsInput = {
    update: XOR<MultisigTxUpdateWithoutApprovalsInput, MultisigTxUncheckedUpdateWithoutApprovalsInput>
    create: XOR<MultisigTxCreateWithoutApprovalsInput, MultisigTxUncheckedCreateWithoutApprovalsInput>
    where?: MultisigTxWhereInput
  }

  export type MultisigTxUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: MultisigTxWhereInput
    data: XOR<MultisigTxUpdateWithoutApprovalsInput, MultisigTxUncheckedUpdateWithoutApprovalsInput>
  }

  export type MultisigTxUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    to?: StringFieldUpdateOperationsInput | string
    valueWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataHex?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableIntFieldUpdateOperationsInput | number | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMultisigTxStatusFieldUpdateOperationsInput | $Enums.MultisigTxStatus
    executedTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    safe?: MultisigSafeUpdateOneRequiredWithoutTxsNestedInput
  }

  export type MultisigTxUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    safeId?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    to?: StringFieldUpdateOperationsInput | string
    valueWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataHex?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableIntFieldUpdateOperationsInput | number | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMultisigTxStatusFieldUpdateOperationsInput | $Enums.MultisigTxStatus
    executedTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CollectionCreateManyCreatorInput = {
    id?: string
    name: string
    symbol: string
    contract: string
    description?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    standard?: string
    supply?: number | null
    baseUri?: string | null
    gatewayPref?: $Enums.GatewayPref
    indexStatus?: $Enums.IndexStatus
    x?: string | null
    instagram?: string | null
    website?: string | null
    discord?: string | null
    telegram?: string | null
    floorPrice?: number
    volume?: number
    itemsCount?: number
    ownersCount?: number
    change24h?: number
    ownerAddress: string
    isOrphan?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionSubmissionCreateManySubmittedByInput = {
    id?: string
    contract: string
    ownerAddress?: string | null
    name?: string | null
    symbol?: string | null
    logoUrl?: string | null
    coverUrl?: string | null
    baseUri?: string | null
    supply?: number | null
    description?: string | null
    website?: string | null
    x?: string | null
    instagram?: string | null
    telegram?: string | null
    feeTxHash?: string | null
    feePaidWei?: Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: Date | string | null
    ownershipVerified?: boolean
    status?: $Enums.SubmissionStatus
    statusReason?: string | null
    reviewedByUserId?: string | null
    reviewedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedBidCreateManyBidderInput = {
    id?: string
    cycleId: string
    bidderAddress: string
    collectionContract: string
    totalBidWei: Decimal | DecimalJsLike | number | string
    txCount?: number
    lastTxHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HolderRewardMultiCreateManyUserInput = {
    id?: string
    walletAddress: string
    currencyId: string
    lastAccPerToken?: Decimal | DecimalJsLike | number | string
    claimedAmount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type NFTCreateManyOwnerInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    collectionId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
  }

  export type RewardClaimLogCreateManyUserInput = {
    id?: string
    walletAddress: string
    currencyId: string
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    timestamp?: Date | string
  }

  export type StolenItemCreateManyReporterInput = {
    id?: string
    contract: string
    tokenId: string
    status?: $Enums.StolenStatus
    source?: $Enums.StolenSource
    reporterAddress?: string | null
    evidenceUrl?: string | null
    notes?: string | null
    disputed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CollectionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUpdateManyWithoutCollectionNestedInput
    deployment?: DeployedContractUpdateOneWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUpdateManyWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUpdateManyWithoutWinnerCollectionNestedInput
    nfts?: NFTUpdateManyWithoutCollectionNestedInput
    presale?: PresaleUpdateOneWithoutCollectionNestedInput
    publicSale?: PublicSaleUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assetUploads?: AssetUploadUncheckedUpdateManyWithoutCollectionNestedInput
    deployment?: DeployedContractUncheckedUpdateOneWithoutCollectionNestedInput
    featuredBidEntries?: FeaturedBidUncheckedUpdateManyWithoutCollectionNestedInput
    featuredAsWinner?: FeaturedCycleUncheckedUpdateManyWithoutWinnerCollectionNestedInput
    nfts?: NFTUncheckedUpdateManyWithoutCollectionNestedInput
    presale?: PresaleUncheckedUpdateOneWithoutCollectionNestedInput
    publicSale?: PublicSaleUncheckedUpdateOneWithoutCollectionNestedInput
  }

  export type CollectionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    standard?: StringFieldUpdateOperationsInput | string
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayPref?: EnumGatewayPrefFieldUpdateOperationsInput | $Enums.GatewayPref
    indexStatus?: EnumIndexStatusFieldUpdateOperationsInput | $Enums.IndexStatus
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    discord?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    floorPrice?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
    itemsCount?: IntFieldUpdateOperationsInput | number
    ownersCount?: IntFieldUpdateOperationsInput | number
    change24h?: FloatFieldUpdateOperationsInput | number
    ownerAddress?: StringFieldUpdateOperationsInput | string
    isOrphan?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionSubmissionUpdateWithoutSubmittedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    feeTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    feePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionSubmissionUncheckedUpdateWithoutSubmittedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    feeTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    feePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionSubmissionUncheckedUpdateManyWithoutSubmittedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    ownerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    symbol?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    baseUri?: NullableStringFieldUpdateOperationsInput | string | null
    supply?: NullableIntFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    telegram?: NullableStringFieldUpdateOperationsInput | string | null
    feeTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    feePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feeVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ownershipVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    statusReason?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedBidUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: CollectionUpdateOneRequiredWithoutFeaturedBidEntriesNestedInput
    cycle?: FeaturedCycleUpdateOneRequiredWithoutBidsNestedInput
    winnerOf?: FeaturedCycleUpdateOneWithoutWinnerBidNestedInput
  }

  export type FeaturedBidUncheckedUpdateWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    collectionContract?: StringFieldUpdateOperationsInput | string
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    winnerOf?: FeaturedCycleUncheckedUpdateOneWithoutWinnerBidNestedInput
  }

  export type FeaturedBidUncheckedUpdateManyWithoutBidderInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    collectionContract?: StringFieldUpdateOperationsInput | string
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolderRewardMultiUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    lastAccPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    claimedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: CurrencyUpdateOneRequiredWithoutHolderRewardsNestedInput
  }

  export type HolderRewardMultiUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    lastAccPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    claimedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolderRewardMultiUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    lastAccPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    claimedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUpdateManyWithoutNftNestedInput
    listingEntries?: MarketplaceListingUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutNftNestedInput
    collection?: CollectionUpdateOneWithoutNftsNestedInput
    single1155?: Single1155UpdateOneWithoutNftsNestedInput
    single721?: Single721UpdateOneWithoutNftsNestedInput
    activities?: NFTActivityUpdateManyWithoutNftNestedInput
  }

  export type NFTUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedUpdateManyWithoutNftNestedInput
    listingEntries?: MarketplaceListingUncheckedUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutNftNestedInput
    activities?: NFTActivityUncheckedUpdateManyWithoutNftNestedInput
  }

  export type NFTUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type RewardClaimLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: CurrencyUpdateOneRequiredWithoutClaimLogsNestedInput
  }

  export type RewardClaimLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardClaimLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    currencyId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StolenItemUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    status?: EnumStolenStatusFieldUpdateOperationsInput | $Enums.StolenStatus
    source?: EnumStolenSourceFieldUpdateOperationsInput | $Enums.StolenSource
    reporterAddress?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    disputed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StolenItemUncheckedUpdateWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    status?: EnumStolenStatusFieldUpdateOperationsInput | $Enums.StolenStatus
    source?: EnumStolenSourceFieldUpdateOperationsInput | $Enums.StolenSource
    reporterAddress?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    disputed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StolenItemUncheckedUpdateManyWithoutReporterInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    status?: EnumStolenStatusFieldUpdateOperationsInput | $Enums.StolenStatus
    source?: EnumStolenSourceFieldUpdateOperationsInput | $Enums.StolenSource
    reporterAddress?: NullableStringFieldUpdateOperationsInput | string | null
    evidenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    disputed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUploadCreateManyCollectionInput = {
    id?: string
    uploaderUserId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
    provider?: string
    cid: string
    url?: string | null
    bytes?: number | null
    sha256?: string | null
    contentType?: string | null
    originalName?: string | null
    createdAt?: Date | string
  }

  export type FeaturedBidCreateManyCollectionInput = {
    id?: string
    cycleId: string
    bidderAddress: string
    bidderUserId?: string | null
    totalBidWei: Decimal | DecimalJsLike | number | string
    txCount?: number
    lastTxHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedCycleCreateManyWinnerCollectionInput = {
    id?: string
    cycleId: string
    startAt: Date | string
    endAt: Date | string
    status?: $Enums.FeaturedCycleStatus
    minBidWei: Decimal | DecimalJsLike | number | string
    winnerBidId?: string | null
    winnerAmountWei?: Decimal | DecimalJsLike | number | string | null
    finalizedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NFTCreateManyCollectionInput = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    ownerId?: string | null
    single721Id?: string | null
    single1155Id?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
  }

  export type AssetUploadUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    bytes?: NullableIntFieldUpdateOperationsInput | number | null
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    single1155?: Single1155UpdateOneWithoutAssetUploadsNestedInput
    single721?: Single721UpdateOneWithoutAssetUploadsNestedInput
  }

  export type AssetUploadUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    bytes?: NullableIntFieldUpdateOperationsInput | number | null
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUploadUncheckedUpdateManyWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    bytes?: NullableIntFieldUpdateOperationsInput | number | null
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedBidUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidder?: UserUpdateOneWithoutFeaturedBidsNestedInput
    cycle?: FeaturedCycleUpdateOneRequiredWithoutBidsNestedInput
    winnerOf?: FeaturedCycleUpdateOneWithoutWinnerBidNestedInput
  }

  export type FeaturedBidUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    bidderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    winnerOf?: FeaturedCycleUncheckedUpdateOneWithoutWinnerBidNestedInput
  }

  export type FeaturedBidUncheckedUpdateManyWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    bidderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeaturedCycleUpdateWithoutWinnerCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeaturedCycleStatusFieldUpdateOperationsInput | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winnerAmountWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: FeaturedBidUpdateManyWithoutCycleNestedInput
    winnerBid?: FeaturedBidUpdateOneWithoutWinnerOfNestedInput
  }

  export type FeaturedCycleUncheckedUpdateWithoutWinnerCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeaturedCycleStatusFieldUpdateOperationsInput | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winnerBidId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAmountWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bids?: FeaturedBidUncheckedUpdateManyWithoutCycleNestedInput
  }

  export type FeaturedCycleUncheckedUpdateManyWithoutWinnerCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cycleId?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFeaturedCycleStatusFieldUpdateOperationsInput | $Enums.FeaturedCycleStatus
    minBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    winnerBidId?: NullableStringFieldUpdateOperationsInput | string | null
    winnerAmountWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    finalizedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUpdateManyWithoutNftNestedInput
    listingEntries?: MarketplaceListingUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutNftNestedInput
    owner?: UserUpdateOneWithoutOwnedNFTsNestedInput
    single1155?: Single1155UpdateOneWithoutNftsNestedInput
    single721?: Single721UpdateOneWithoutNftsNestedInput
    activities?: NFTActivityUpdateManyWithoutNftNestedInput
  }

  export type NFTUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedUpdateManyWithoutNftNestedInput
    listingEntries?: MarketplaceListingUncheckedUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutNftNestedInput
    activities?: NFTActivityUncheckedUpdateManyWithoutNftNestedInput
  }

  export type NFTUncheckedUpdateManyWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type AuctionCreateManyNftInput = {
    id?: string
    sellerAddress: string
    quantity?: number
    startPriceEtnWei: Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: Decimal | DecimalJsLike | number | string | null
    currencyId?: string | null
    startPriceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime: Date | string
    status?: $Enums.AuctionStatus
    txHashCreated?: string | null
    txHashFinalized?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highestBidder?: string | null
  }

  export type MarketplaceListingCreateManyNftInput = {
    id?: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    currencyId?: string | null
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ListingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    txHashCreated?: string | null
    txHashFilled?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceSaleCreateManyNftInput = {
    id?: string
    buyerAddress: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: Decimal | DecimalJsLike | number | string | null
    currencyId?: string | null
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: string | null
    marketplaceFeeRecipient?: string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type NFTActivityCreateManyNftInput = {
    id?: string
    contract: string
    tokenId: string
    type: string
    fromAddress: string
    toAddress: string
    priceEtnWei?: Decimal | DecimalJsLike | number | string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    marketplace?: string | null
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuctionUpdateWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startPriceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFinalized?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highestBidder?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: CurrencyUpdateOneWithoutAuctionsNestedInput
    bids?: AuctionBidUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionUncheckedUpdateWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    startPriceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFinalized?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highestBidder?: NullableStringFieldUpdateOperationsInput | string | null
    bids?: AuctionBidUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionUncheckedUpdateManyWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    startPriceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFinalized?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highestBidder?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MarketplaceListingUpdateWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFilled?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: CurrencyUpdateOneWithoutListingsNestedInput
  }

  export type MarketplaceListingUncheckedUpdateWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFilled?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceListingUncheckedUpdateManyWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFilled?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceSaleUpdateWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerAddress?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    marketplaceFeeRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: CurrencyUpdateOneWithoutSalesNestedInput
  }

  export type MarketplaceSaleUncheckedUpdateWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerAddress?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    marketplaceFeeRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceSaleUncheckedUpdateManyWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerAddress?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    marketplaceFeeRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTActivityUpdateWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    priceEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTActivityUncheckedUpdateWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    priceEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTActivityUncheckedUpdateManyWithoutNftInput = {
    id?: StringFieldUpdateOperationsInput | string
    contract?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    fromAddress?: StringFieldUpdateOperationsInput | string
    toAddress?: StringFieldUpdateOperationsInput | string
    priceEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    rawData?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUploadCreateManySingle721Input = {
    id?: string
    uploaderUserId?: string | null
    collectionId?: string | null
    single1155Id?: string | null
    provider?: string
    cid: string
    url?: string | null
    bytes?: number | null
    sha256?: string | null
    contentType?: string | null
    originalName?: string | null
    createdAt?: Date | string
  }

  export type NFTCreateManySingle721Input = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    ownerId?: string | null
    collectionId?: string | null
    single1155Id?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
  }

  export type AssetUploadUpdateWithoutSingle721Input = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    bytes?: NullableIntFieldUpdateOperationsInput | number | null
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: CollectionUpdateOneWithoutAssetUploadsNestedInput
    single1155?: Single1155UpdateOneWithoutAssetUploadsNestedInput
  }

  export type AssetUploadUncheckedUpdateWithoutSingle721Input = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    bytes?: NullableIntFieldUpdateOperationsInput | number | null
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUploadUncheckedUpdateManyWithoutSingle721Input = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    bytes?: NullableIntFieldUpdateOperationsInput | number | null
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTUpdateWithoutSingle721Input = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUpdateManyWithoutNftNestedInput
    listingEntries?: MarketplaceListingUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutNftNestedInput
    collection?: CollectionUpdateOneWithoutNftsNestedInput
    owner?: UserUpdateOneWithoutOwnedNFTsNestedInput
    single1155?: Single1155UpdateOneWithoutNftsNestedInput
    activities?: NFTActivityUpdateManyWithoutNftNestedInput
  }

  export type NFTUncheckedUpdateWithoutSingle721Input = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedUpdateManyWithoutNftNestedInput
    listingEntries?: MarketplaceListingUncheckedUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutNftNestedInput
    activities?: NFTActivityUncheckedUpdateManyWithoutNftNestedInput
  }

  export type NFTUncheckedUpdateManyWithoutSingle721Input = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single1155Id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type AssetUploadCreateManySingle1155Input = {
    id?: string
    uploaderUserId?: string | null
    collectionId?: string | null
    single721Id?: string | null
    provider?: string
    cid: string
    url?: string | null
    bytes?: number | null
    sha256?: string | null
    contentType?: string | null
    originalName?: string | null
    createdAt?: Date | string
  }

  export type Erc1155BalanceCreateManySingle1155Input = {
    id?: string
    ownerAddress: string
    balance?: number
    updatedAt?: Date | string
  }

  export type NFTCreateManySingle1155Input = {
    id?: string
    tokenId: string
    name?: string | null
    imageUrl?: string | null
    description?: string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: string | null
    contract: string
    standard?: string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: number | null
    royaltyRecipient?: string | null
    ownerId?: string | null
    collectionId?: string | null
    single721Id?: string | null
    status?: $Enums.NftStatus
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rarityScore?: Decimal | DecimalJsLike | number | string | null
  }

  export type AssetUploadUpdateWithoutSingle1155Input = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    bytes?: NullableIntFieldUpdateOperationsInput | number | null
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: CollectionUpdateOneWithoutAssetUploadsNestedInput
    single721?: Single721UpdateOneWithoutAssetUploadsNestedInput
  }

  export type AssetUploadUncheckedUpdateWithoutSingle1155Input = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    bytes?: NullableIntFieldUpdateOperationsInput | number | null
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssetUploadUncheckedUpdateManyWithoutSingle1155Input = {
    id?: StringFieldUpdateOperationsInput | string
    uploaderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    cid?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    bytes?: NullableIntFieldUpdateOperationsInput | number | null
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Erc1155BalanceUpdateWithoutSingle1155Input = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Erc1155BalanceUncheckedUpdateWithoutSingle1155Input = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Erc1155BalanceUncheckedUpdateManyWithoutSingle1155Input = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NFTUpdateWithoutSingle1155Input = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUpdateManyWithoutNftNestedInput
    listingEntries?: MarketplaceListingUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUpdateManyWithoutNftNestedInput
    collection?: CollectionUpdateOneWithoutNftsNestedInput
    owner?: UserUpdateOneWithoutOwnedNFTsNestedInput
    single721?: Single721UpdateOneWithoutNftsNestedInput
    activities?: NFTActivityUpdateManyWithoutNftNestedInput
  }

  export type NFTUncheckedUpdateWithoutSingle1155Input = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    auctionEntries?: AuctionUncheckedUpdateManyWithoutNftNestedInput
    listingEntries?: MarketplaceListingUncheckedUpdateManyWithoutNftNestedInput
    sales?: MarketplaceSaleUncheckedUpdateManyWithoutNftNestedInput
    activities?: NFTActivityUncheckedUpdateManyWithoutNftNestedInput
  }

  export type NFTUncheckedUpdateManyWithoutSingle1155Input = {
    id?: StringFieldUpdateOperationsInput | string
    tokenId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    traits?: NullableJsonNullValueInput | InputJsonValue
    attributes?: NullableJsonNullValueInput | InputJsonValue
    tokenUri?: NullableStringFieldUpdateOperationsInput | string | null
    contract?: StringFieldUpdateOperationsInput | string
    standard?: NullableStringFieldUpdateOperationsInput | string | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    royaltyBps?: NullableIntFieldUpdateOperationsInput | number | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    single721Id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNftStatusFieldUpdateOperationsInput | $Enums.NftStatus
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rarityScore?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type AuctionBidCreateManyAuctionInput = {
    id?: string
    bidderAddress: string
    amountWei: Decimal | DecimalJsLike | number | string
    currencyId?: string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type AuctionBidUpdateWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    amountWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: CurrencyUpdateOneWithoutBidsNestedInput
  }

  export type AuctionBidUncheckedUpdateWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    amountWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionBidUncheckedUpdateManyWithoutAuctionInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    amountWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currencyId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeConfigLogCreateManyFeeConfigInput = {
    id?: string
    previousRecipient?: string | null
    newRecipient?: string | null
    previousAmountEtnWei?: Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: Decimal | DecimalJsLike | number | string | null
    changedByUserId?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type FeeConfigLogUpdateWithoutFeeConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    newRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    previousAmountEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeConfigLogUncheckedUpdateWithoutFeeConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    newRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    previousAmountEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeConfigLogUncheckedUpdateManyWithoutFeeConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    previousRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    newRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    previousAmountEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    newAmountEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    changedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PresaleWhitelistAddressCreateManyPresaleInput = {
    id?: string
    address: string
    maxAllocation?: number | null
  }

  export type PresaleWhitelistAddressUpdateWithoutPresaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    maxAllocation?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PresaleWhitelistAddressUncheckedUpdateWithoutPresaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    maxAllocation?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PresaleWhitelistAddressUncheckedUpdateManyWithoutPresaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    maxAllocation?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FeaturedBidCreateManyCycleInput = {
    id?: string
    bidderAddress: string
    bidderUserId?: string | null
    collectionContract: string
    totalBidWei: Decimal | DecimalJsLike | number | string
    txCount?: number
    lastTxHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeaturedBidUpdateWithoutCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bidder?: UserUpdateOneWithoutFeaturedBidsNestedInput
    collection?: CollectionUpdateOneRequiredWithoutFeaturedBidEntriesNestedInput
    winnerOf?: FeaturedCycleUpdateOneWithoutWinnerBidNestedInput
  }

  export type FeaturedBidUncheckedUpdateWithoutCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    bidderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionContract?: StringFieldUpdateOperationsInput | string
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    winnerOf?: FeaturedCycleUncheckedUpdateOneWithoutWinnerBidNestedInput
  }

  export type FeaturedBidUncheckedUpdateManyWithoutCycleInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    bidderUserId?: NullableStringFieldUpdateOperationsInput | string | null
    collectionContract?: StringFieldUpdateOperationsInput | string
    totalBidWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txCount?: IntFieldUpdateOperationsInput | number
    lastTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionCreateManyCurrencyInput = {
    id?: string
    nftId: string
    sellerAddress: string
    quantity?: number
    startPriceEtnWei: Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: Decimal | DecimalJsLike | number | string | null
    startPriceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: Decimal | DecimalJsLike | number | string | null
    startTime?: Date | string
    endTime: Date | string
    status?: $Enums.AuctionStatus
    txHashCreated?: string | null
    txHashFinalized?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    highestBidder?: string | null
  }

  export type AuctionBidCreateManyCurrencyInput = {
    id?: string
    auctionId: string
    bidderAddress: string
    amountWei: Decimal | DecimalJsLike | number | string
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type HolderRewardMultiCreateManyCurrencyInput = {
    id?: string
    userId?: string | null
    walletAddress: string
    lastAccPerToken?: Decimal | DecimalJsLike | number | string
    claimedAmount?: Decimal | DecimalJsLike | number | string
    updatedAt?: Date | string
  }

  export type MarketplaceListingCreateManyCurrencyInput = {
    id?: string
    nftId: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ListingStatus
    startTime?: Date | string
    endTime?: Date | string | null
    txHashCreated?: string | null
    txHashFilled?: string | null
    txHashCancelled?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketplaceSaleCreateManyCurrencyInput = {
    id?: string
    nftId: string
    buyerAddress: string
    sellerAddress: string
    quantity?: number
    priceEtnWei: Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: Decimal | DecimalJsLike | number | string | null
    priceTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: string | null
    marketplaceFeeRecipient?: string | null
    txHash: string
    logIndex?: number
    blockNumber: number
    timestamp: Date | string
    createdAt?: Date | string
  }

  export type RewardClaimLogCreateManyCurrencyInput = {
    id?: string
    walletAddress: string
    userId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    timestamp?: Date | string
  }

  export type RewardDistributionLogCreateManyCurrencyInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    txHash?: string | null
    blockNumber?: number | null
    timestamp?: Date | string
    note?: string | null
  }

  export type AuctionUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startPriceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFinalized?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highestBidder?: NullableStringFieldUpdateOperationsInput | string | null
    nft?: NFTUpdateOneRequiredWithoutAuctionEntriesNestedInput
    bids?: AuctionBidUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionUncheckedUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startPriceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFinalized?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highestBidder?: NullableStringFieldUpdateOperationsInput | string | null
    bids?: AuctionBidUncheckedUpdateManyWithoutAuctionNestedInput
  }

  export type AuctionUncheckedUpdateManyWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    startPriceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    highestBidEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementEtnWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startPriceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    highestBidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    minIncrementTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAuctionStatusFieldUpdateOperationsInput | $Enums.AuctionStatus
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFinalized?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    highestBidder?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuctionBidUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    amountWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auction?: AuctionUpdateOneRequiredWithoutBidsNestedInput
  }

  export type AuctionBidUncheckedUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    amountWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuctionBidUncheckedUpdateManyWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auctionId?: StringFieldUpdateOperationsInput | string
    bidderAddress?: StringFieldUpdateOperationsInput | string
    amountWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolderRewardMultiUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    lastAccPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    claimedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutHolderRewardsMultiNestedInput
  }

  export type HolderRewardMultiUncheckedUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: StringFieldUpdateOperationsInput | string
    lastAccPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    claimedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolderRewardMultiUncheckedUpdateManyWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    walletAddress?: StringFieldUpdateOperationsInput | string
    lastAccPerToken?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    claimedAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceListingUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFilled?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nft?: NFTUpdateOneRequiredWithoutListingEntriesNestedInput
  }

  export type MarketplaceListingUncheckedUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFilled?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceListingUncheckedUpdateManyWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    txHashCreated?: NullableStringFieldUpdateOperationsInput | string | null
    txHashFilled?: NullableStringFieldUpdateOperationsInput | string | null
    txHashCancelled?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceSaleUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    buyerAddress?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    marketplaceFeeRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nft?: NFTUpdateOneRequiredWithoutSalesNestedInput
  }

  export type MarketplaceSaleUncheckedUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    buyerAddress?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    marketplaceFeeRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceSaleUncheckedUpdateManyWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nftId?: StringFieldUpdateOperationsInput | string
    buyerAddress?: StringFieldUpdateOperationsInput | string
    sellerAddress?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    priceEtnWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    royaltyPaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    marketplaceFeePaidWei?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priceTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyPaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    feePaidTokenAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    royaltyRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    marketplaceFeeRecipient?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: StringFieldUpdateOperationsInput | string
    logIndex?: IntFieldUpdateOperationsInput | number
    blockNumber?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardClaimLogUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutRewardClaimLogsNestedInput
  }

  export type RewardClaimLogUncheckedUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardClaimLogUncheckedUpdateManyWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RewardDistributionLogUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardDistributionLogUncheckedUpdateWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RewardDistributionLogUncheckedUpdateManyWithoutCurrencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    blockNumber?: NullableIntFieldUpdateOperationsInput | number | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MultisigOwnerCreateManySafeInput = {
    id?: string
    ownerAddress: string
    addedAt?: Date | string
    removedAt?: Date | string | null
  }

  export type MultisigTxCreateManySafeInput = {
    id?: string
    nonce: number
    to: string
    valueWei?: Decimal | DecimalJsLike | number | string
    dataHex?: string | null
    operation?: number | null
    submittedBy?: string | null
    status?: $Enums.MultisigTxStatus
    executedTxHash?: string | null
    createdAt?: Date | string
    executedAt?: Date | string | null
  }

  export type MultisigOwnerUpdateWithoutSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultisigOwnerUncheckedUpdateWithoutSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultisigOwnerUncheckedUpdateManyWithoutSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    removedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultisigTxUpdateWithoutSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    to?: StringFieldUpdateOperationsInput | string
    valueWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataHex?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableIntFieldUpdateOperationsInput | number | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMultisigTxStatusFieldUpdateOperationsInput | $Enums.MultisigTxStatus
    executedTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvals?: MultisigApprovalUpdateManyWithoutTxNestedInput
  }

  export type MultisigTxUncheckedUpdateWithoutSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    to?: StringFieldUpdateOperationsInput | string
    valueWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataHex?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableIntFieldUpdateOperationsInput | number | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMultisigTxStatusFieldUpdateOperationsInput | $Enums.MultisigTxStatus
    executedTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvals?: MultisigApprovalUncheckedUpdateManyWithoutTxNestedInput
  }

  export type MultisigTxUncheckedUpdateManyWithoutSafeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nonce?: IntFieldUpdateOperationsInput | number
    to?: StringFieldUpdateOperationsInput | string
    valueWei?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dataHex?: NullableStringFieldUpdateOperationsInput | string | null
    operation?: NullableIntFieldUpdateOperationsInput | number | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMultisigTxStatusFieldUpdateOperationsInput | $Enums.MultisigTxStatus
    executedTxHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MultisigApprovalCreateManyTxInput = {
    id?: string
    ownerAddress: string
    signature?: string | null
    createdAt?: Date | string
  }

  export type MultisigApprovalUpdateWithoutTxInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultisigApprovalUncheckedUpdateWithoutTxInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MultisigApprovalUncheckedUpdateManyWithoutTxInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerAddress?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}